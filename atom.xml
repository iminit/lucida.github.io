<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Lucida]]></title>
  <link href="http://zh.lucida.me/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2015-01-01T00:18:57-08:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序员英语学习指引]]></title>
    <link href="http://zh.lucida.me/blog/english-for-programmers/"/>
    <updated>2015-01-01T00:04:51-08:00</updated>
    <id>http://zh.lucida.me/blog/english-for-programmers</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/english-for-programmers/">http://zh.lucida.me/blog/english-for-programmers/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>概要</h2>

<p>这篇文章面向程序员，简要的介绍了一些学习计算机专业英语的步骤和经验。</p>

<h2>关于</h2>

<p>之前不少人曾站内我如何学习英语，我也曾试图写一篇如何学习英语的博文，但我现在的实力着实无法写出令人信服的文章：</p>

<ol>
<li>尽管阅读、写作和听力还可以，但口语很差——我指的是日常用语，即便出国一年，现在我和同事交流时仍然磕磕巴巴，不知道用什么词的情况经常出现；</li>
<li>尽管读过大量外文资料，但它们绝大多是计算机专业书籍和论文，并不适用于通用的英语学习，也不适用于其它专业。</li>
</ol>


<p>所以这篇文章并不是一篇英语学习教程——而是一篇面向国内开发者的计算机专业（为了简便，接下来的“专业”均指“计算机专业”）英语学习指引，本文集中于如下问题：</p>

<ul>
<li><a href="#why_english">为什么要学习英语？</a></li>
<li><a href="#how_to_read_from_scratch">如何从零开始阅读专业英文书籍？</a></li>
<li><a href="#how_to_improve_reading_skills">如何提升专业英语阅读能力？</a></li>
<li><a href="#how_to_improve_writing_skills">如何提升专业英语写作能力？</a></li>
<li><a href="#how_to_improve_listening_skills">如何提升英语听力？</a></li>
</ul>


<p>此外，我把简短的问答放在<a href="#miscellaneous">杂项</a>之中，以便阅读。</p>

<!-- more -->


<h2><a name="why_english">为什么要学习英语？</a></h2>

<p>这个问题很多人问过，也有很多人回答过，此外如果你在阅读这篇文章那么你应该已经意识到了学习英语的重要性。所以我不打算花太多篇幅在它上面，这里简略的总结下学习英语的好处：</p>

<ol>
<li>更多的高质量学习资源：首先，绝大多数高质量的计算机学习资源（书籍、论文、博文和视频等）都是英文；其次，高质量的中文计算机学习资源几乎为零；</li>
<li>无需忍受翻译带来的问题：

<ol>
<li>信息损耗：任何知识从一种语言翻译到另一种语言一定会有信息损耗，更何况是英文和中文这两种差别巨大的语言；</li>
<li>时效损耗：翻译需要时间，如果你读的是翻译版那么你已经至少落后了半年；</li>
<li>翻译损耗：国内的计算机书籍翻译水平参差不齐，你需要拼人品；</li>
</ol>
</li>
<li>编写更好的代码：良好的英语水平是编写可读（Readable）代码的前提；</li>
<li>翻墙：相对于其它专业，计算机专业出国工作要容易很多，但前提是你的英语要说的过去。</li>
</ol>


<h2><a name="how_to_read_from_scratch">如何从零开始阅读专业英文书籍？</a></h2>

<p>注意这里的零基础指的是专业英文书籍阅读零基础——而不是英语零基础，英语零基础就没啥好说的了 &ndash;_&ndash;#</p>

<p>刚开始阅读专业英文书籍时要记住一点：你的目标是<strong>提升计算机专业词汇量</strong>，而不是学习计算机专业知识。所以你要阅读的是计算机“通俗”读物或“科普”读物，我的计算机英文入门书籍是<a href="http://book.douban.com/subject/1880471/">计算机文化</a>（<a href="http://book.douban.com/subject/2376634/">New Perspectives on Computer Concepts</a>），这本书每年一版，现在已经出到<a href="http://www.amazon.com/Perspectives-Computer-Concepts-2014-Comprehensive/dp/1285096924/">第16版</a>：</p>

<p><img src="http://i.imgur.com/Uhke7OQ.jpg" alt="New Perspectives on Computer Concepts" /></p>

<p>这本书的好处在于它极其浅显易懂，并且包含大量计算机专业领域名词，所以读者可以专注于提升计算机专业词汇量，而不是一边查单词一边学新技术——同时搞两件事是很困难的。</p>

<p>顺便提一下那篇<a href="http://blog.jobbole.com/45296/">老码农教你学英语</a>和那个老码农推荐的<a href="http://blog.jobbole.com/45795/">书目</a>，姑且不论他把Mythical Man-month拼写成Man Month Myth，我非常惊讶他居然称人月神话原版为白话书并且推荐初学者阅读，直到看到这里：</p>

<p><img src="http://i.imgur.com/Scg0Egm.jpg" alt="WTF" /></p>

<p>这句<em>“另外两本也很不错，我很久以前看的翻译版，一直也想找原版的来看看，可惜总是没空，这次你们就算替我看了吧”</em>着实让我很无语，没看过的书也可以随便推荐么 &ndash;_&ndash;# 难怪那么多人推荐计算机程序设计艺术呢。</p>

<p>我在读研时从头至尾阅读了<a href="http://en.wikipedia.org/wiki/Fred_Brooks">Frederick Brooks</a>的<a href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">Mythical Man Month</a>以及他的几篇论文（No Silver Bullets和the Computer Scientist as Toolsmith），所以对Brooks的文风有一定了解——Brooks绝对是一位多才多艺的计算机科学大师——他的文字不仅涉及到计算机，还涉及到管理、人文、艺术、建筑和神学等学科。读他的书和文章，我查单词直接查到手抽，推荐初学者读这种书，你是要玩死初学者么 &ndash;_&ndash;#</p>

<h2><a name="how_to_improve_reading_skills">如何提升专业英语阅读能力？</a></h2>

<p>阅读<a href="http://www.amazon.com/Perspectives-Computer-Concepts-2014-Comprehensive/dp/1285096924/">New Perspectives on Computer Concepts</a>之后，你应该掌握了大量的计算机专业英文词汇，这时你可以尝试阅读一些语言浅显但主题相对深入的计算机科学基础书籍，个人力荐<a href="http://www.cs.princeton.edu/~bwk/">Brian W Kernighan</a>和<a href="http://www.cs.vu.nl/~ast/">Andrew S Tanenbaum</a>的作品，他们的著作不但本本经典，而且语言朴实：</p>

<ul>
<li><a href="http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628/">The C Programming Language 2th</a>：不但是C语言的神作，而且为编程语言书籍的编写树立了新的标杆；</li>
<li><a href="http://www.amazon.com/gp/product/013937681X/">The Unix Programming Environment</a>：覆盖了Unix的设计思想，简洁易懂的Unix入门手册；</li>
<li><a href="http://www.amazon.com/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X/">The Practice of Programming</a>：两位Unix大师（<a href="http://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>和<a href="http://www.cs.princeton.edu/~bwk/">Brian Kernighan</a>）近三十年的编程经验尽在此书之中；</li>
<li><a href="http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/">Algorithms 4th</a>：数据结构与算法入门；</li>
<li><a href="http://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X/">Modern Operating Systems 4th</a>：全面的操作系统概论；</li>
<li><a href="http://www.amazon.com/Computer-Networks-5th-Andrew-Tanenbaum/dp/0132126958/">Computer Networks 5th</a>：全面的计算机网络概论。</li>
</ul>


<p>这些书读完之后，你应该可以做到脱离字典阅读绝大多数的计算机书籍——是的，可能还会有一些生词，但不会影响阅读。</p>

<p>除了读书，阅读专业博客也是非常好的提升专业英语水平的途径。个人推荐下面几个网站：</p>

<ul>
<li><a href="https://news.ycombinator.com">Hacker News</a>：大量的技术资讯和博文；</li>
<li><a href="http://www.reddit.com">Reddit</a>：非常的聚合站点，我一般去下面几个频道（subreddit）

<ul>
<li><a href="http://www.reddit.com/r/programming/">/programming</a>：聚合了大量的优秀程序设计博文（其实不少国内技术站点就是搬运它的内容）；</li>
<li><a href="http://www.reddit.com/r/java/">/java</a>：大量的Java技术博文，质量不如<a href="http://www.reddit.com/r/programming/">/programming</a>，但也还说的过去；</li>
<li><a href="http://www.reddit.com/r/shittyprogramming/">/shittyprogramming</a>：悠闲时的去处，不少段子来自这里；</li>
</ul>
</li>
<li><a href="https://medium.com">Medium</a>：大量的高质量文章；</li>
<li><a href="http://www.quora.com">Quora</a>：大量的高质量问答，有不少中国人在上面练习英语；</li>
</ul>


<h2><a name="how_to_improve_writing_skills">如何提升英语写作能力？</a></h2>

<p>程序员学习英语不是为了写小说——而主要是如下场景：</p>

<ol>
<li>编写设计文档（Design Document）；</li>
<li>收发邮件，进行交流；</li>
<li>开发程序中的命名、注释等描述性内容。</li>
</ol>


<p>1和2需要Nonfiction Writing——言简意赅，层次分明。这方面的写作书籍我推荐：</p>

<p><img src="http://i.imgur.com/9EjJ7Cx.jpg" alt="the Elements Of Style" /></p>

<p><a href="http://www.amazon.com/Elements-Style-Fourth-William-Strunk/dp/020530902X/">the Elements Of Style</a>（这本书我应该推荐了无数次 &ndash;_&ndash;#</p>

<p><img src="http://i.imgur.com/B8Qwfur.jpg" alt="On Writing Well" /></p>

<p><a href="http://www.amazon.com/Writing-Well-30th-Anniversary-Nonfiction/dp/0060891548/">On Writing Well</a></p>

<p><img src="http://i.imgur.com/uO9p3nw.jpg" alt="中式英语之鉴" /></p>

<p>此外少不了<a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a>，中式英语说说还成，写到纸面上就丢大发了。</p>

<p>关于3的书籍很多，我个人推荐<a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/">Code Complete</a>中关于命名（Naming）的一章，章名好像是the Power of Variable Names；以及<a href="http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/">Effective Java 2nd</a>的Item44——如何编写代码注释及文档。</p>

<h2><a name="how_to_improve_listening_skills">如何提升听力？</a></h2>

<p>阅读量达到一定程度听力也不会差，个人推荐<a href="http://channel9.msdn.com/">Channel 9</a>、<a href="https://www.youtube.com/user/GoogleTechTalks">Google Tech Talk</a>和<a href="https://www.coursera.org/">Coursera</a>，多看多听，此外务必不要中文字幕。</p>

<h2><a name="miscellaneous">杂项</a></h2>

<p>这里包含一些简短的问题，如果你有疑问也可以留言，我会把答案添加到这里。</p>

<h3>是否一定需要阅读原版？</h3>

<p>除非你阅读原版书籍和中文书籍一样顺畅，或者翻译书籍信息损失量太大，否则不需要刻意阅读原版。</p>

<h3>开发者需要多少单词量？</h3>

<p>没有标准答案。作为开发者，大词汇量不是必需，但一定要<strong>把词用对</strong>——尤其是动词。</p>

<p>以方法/函数名中经常出现的<code>get</code>为例：我们需要知道何时应该使用<code>get</code>，以及何时使用<code>fetch</code>、<code>build</code>、<code>retrieve</code>、<code>compute</code>、<code>calculate</code>和<code>receive</code>这些<code>get</code>的同类词汇。</p>

<h3>有没有好用的词典？</h3>

<p>目前我还没有发现一个好用的词典应用，所以依然在使用6年前的CASIO V2800H电子辞典。（略土 &ndash;_&ndash;#</p>

<p>以上。</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/english-for-programmers/">http://zh.lucida.me/blog/english-for-programmers/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回顾2014——还算不错的开端]]></title>
    <link href="http://zh.lucida.me/blog/2014-summary/"/>
    <updated>2014-12-26T14:51:50-08:00</updated>
    <id>http://zh.lucida.me/blog/2014-summary</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/2014-summary/">http://zh.lucida.me/blog/2014-summary/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<hr />

<h2>摘要</h2>

<p>这篇文章记录了我对2014年的回顾，包含一些感触，也有一些吐槽——这篇文章不会像之前的文章那么严谨——意识流——想到哪里——说到哪里。</p>

<ul>
<li><a href="#working">工作</a></li>
<li><a href="#travelling">出国</a></li>
<li><a href="#reading">读书</a></li>
<li><a href="#gaming">游戏</a></li>
<li><a href="#buying">败物</a></li>
<li><a href="#blogging">博客</a></li>
<li><a href="#planning">展望</a></li>
</ul>


<h2><a name="working">工作</a></h2>

<p>2014是我正式工作的第一年——工作对我既熟悉又陌生——在正式工作之前，我在大连<a href="http://www.avepoint.com.cn/">AvePoint</a>和<a href="http://www.microsoft.com/zh-cn/ard/default.aspx">微软亚洲工程院</a>分别有一年和两年的实习经历，大大小小的应用也写过不少；但我并未参与过正式的开发流程，实习时写的东西规模都很小（不超过1w行），技术含量也不高（没有教科书以外的算法），也没有一个资深的开发者手把手教我（基本都是自学瞎鼓捣）。简而言之——我属于<a href="http://www.mydrivingseat.com/the-blog/dabbler-obsessive-hacker-or-master/">Dabbler</a>——聊聊技术名词写几个小程序还可以，搞点正经东西就抓瞎。</p>

<p>所以2014年是我从<a href="http://www.mydrivingseat.com/the-blog/dabbler-obsessive-hacker-or-master/">Dabbler</a>走向<a href="https://pragprog.com/book/tpp/the-pragmatic-programmer">Journeyman</a>的第一年，这一年我接触了很多真正的专业开发者（Professional Developer），也学到了很多书本中学不到的东西。</p>

<!-- more -->


<h3>专业开发者</h3>

<p>我提到我接触了很多真正的专业开发者，这里举一个例子：</p>

<p>刚刚开始工作时，我说的最多的一个短语就是&#8221;I think&#8221;——&#8221;我觉得XXX应该是YYY&#8221;</p>

<p>这时我就会被同事无情的打断——&#8221;You shouldn&rsquo;t think, you should be certain&#8221;</p>

<p>然后我就会羞愧苦逼的回去翻看文档，询问同事，直到彻底搞清楚问题为止——没有任何&#8221;I think&#8221;。</p>

<p>后来我读到<a href="http://www.amazon.com/The-Clean-Coder-Professional-Programmers/dp/0137081073">Clean Coder</a>这本书，发现里面很多观点和我身边的同事的所作所为不谋而合——专业开发者——就应该是这样。</p>

<h3>代码审查</h3>

<p>Google内部提交代码必需要经过<a href="http://www.amazon.com/Google-Tests-Software-James-Whittaker/dp/0321803027">代码审查</a>——如果你要在某个目录下提交代码，你必须要获得来自代码审查者的两个Approval（准许）：Owner Approval（目录所有者的准许）和Readablity Approval（代码可读性准许），具体细节可以看这个Quora问答：<a href="http://www.quora.com/What-is-Googles-internal-code-review-policy-process">http://www.quora.com/What-is-Googles-internal-code-review-policy-process</a>。</p>

<p>在2014这一年，我的绝大多数开发知识/经验都来自代码审查——从刚开始写代码被别人“黑”的惨不忍睹，到之后慢慢可以越来越顺利的通过代码审查，再到之后获得Java Readablity（参考<a href="http://www.zhihu.com/question/19794858">C++ Readablity</a>），到现在天天审查别人的代码，这个过程我学到的开发经验比我在学校7年学到的都多。我相信在接下来的两三年我的开发经验也会来自代码审查。</p>

<p>代码审查有一个副作用——它会提升你的代码品位，使得你再也无法忍受糟糕的代码——就我个人的感受，国内技术社区90%以上的代码都是翔，5%以上的代码翔都不如——所以现在我很少看国内的技术文章。</p>

<h3>从编程到开发</h3>

<p>作为开发者，走出学校进入工作岗位最大的转变是从编程（<a href="http://en.wikipedia.org/wiki/Computer_programming">Programming</a>）转向开发（<a href="http://en.wikipedia.org/wiki/Software_development">Development</a>）——专注的不再是算法、数据结构或操作系统这些编程概念，而是产品质量、持续集成和领域知识等开发概念。</p>

<p>我并非否认计算机基础的重要性——这些基础知识是底线（Bottom line），这些东西都不会还写毛程序？作为开发者应该具备良好的编程基础，然后不断提升自己的开发技能，而不是不断的折腾算法和数据结构这些理应在学校掌握的东西。</p>

<h2><a name="travelling">出国</a></h2>

<p>之前从未想到过我会出国，然而误打误撞，2014年我先后在英国伦敦和美国加州湾区工作，见识了万恶的资本主义发源地，也见识了万恶的资本主义社会：</p>

<h2>伦敦</h2>

<p><img src="http://i.imgur.com/MiSMFrz.jpg" alt="伦敦鸟瞰" /></p>

<ol>
<li>英腔逼格很高，我努力学了一点，很受用；</li>
<li>美女很少，一般美女都来自东欧；</li>
<li>留学生很多，白富美富二代也很多；</li>
<li>常年阴雨连绵，但雨并不大；</li>
<li>英国人很绅士，坐地铁或公交时能明显体会到，不像国内那般争先恐后不守规矩；</li>
<li>贝克街221B是一个不存在的地址，我还特地去验证了一把；</li>
<li>东西很贵，貌似今年刚成为全球最贵城市；</li>
<li>是的，搞基很多，我曾在Green Park见过两名壮汉拍婚纱照；</li>
<li>只翻修不拆迁，所以伦敦街上的建筑大多都有三百年多历史，为什么不是四百年？因为当时<a href="http://en.wikipedia.org/wiki/Great_Fire_of_London">那把火</a>；</li>
<li>顺便推荐一条步行线路：London Eye俯瞰全景 &ndash;> Westminister Cathedral体验Big Ben &ndash;> Buckingham Palace观看&#8221;红卫兵&#8221; &ndash;> Picadilly Circus观看接头表演 &ndash;> Covent Garden购买手工艺品 &ndash;> Leicester Square吃中餐/日餐。</li>
</ol>


<h2>湾区</h2>

<p><img src="http://i.imgur.com/kkTeNns.jpg" alt="阳光屯小吃一条街" /></p>

<ol>
<li>美音很屌丝，也很容易懂；</li>
<li>美女很多，来历不明；</li>
<li>留学生没有码农多；</li>
<li>一年四季，阳光普照；</li>
<li>大多还不错，但不如英国人那般讲究；</li>
<li>是的，加州没有加州牛肉面；</li>
<li>物价尚可，房价涨的一逼；</li>
<li>搞基没有伦敦那么张扬；</li>
<li>大片土地闲置，既不拆迁也不翻修更不新建，大多屎黄色建筑，土的一逼；</li>
<li>还不熟悉，打算明年自驾游一把。</li>
</ol>


<h2><a name="reading">读书</a></h2>

<p>工作之后专门的阅读时间就少了很多，有时连每周10小时的阅读时间都不能保证——所以我打算在15年提高阅读时长和质量。</p>

<h3>专业类</h3>

<p>大多都是比较浅的书，所以收获一般。打算在15年读一些深入的专业书籍。</p>

<ul>
<li><a href="http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/">Effective Java</a>：Java圣经级著作，我的第一本Java书，其本身属于超越语言的作品；</li>
<li><a href="http://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/">Java Concurrency in Practice</a>：系统的介绍了Java并发编程，以及如何绕过并发里的种种坑；</li>
<li><a href="http://www.amazon.com/Java-Puzzlers-Traps-Pitfalls-Corner/dp/032133678X/">Java Puzzlers</a>：分门别类的讲述了Java语言的坑，部分例子过于Artificial，但总的来说不错；</li>
<li><a href="http://www.amazon.com/Well-Grounded-Java-Developer-techniques-programming/dp/1617290068/">The Well-Grounded Java Developer</a>：一本与时俱进的Java书籍——覆盖了Java 7之后的的语言特性及JVM特性；</li>
<li><a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>：系统的介绍了Java 8中的Lambda表达式，但不如Brian Goetz的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/">Lambda Articles</a>深入；</li>
<li><a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机</a>：很优秀的国产JVM书籍，让我对国产技术书籍重拾信心；</li>
<li><a href="http://book.douban.com/subject/7059903/">编写高质量代码 改善Java程序的151个建议</a>：极其低劣的书籍，再度让我对国产技术书籍失去信心；</li>
<li><a href="http://www.amazon.com/Linux-Command-Line-Complete-Introduction/dp/1593273894/">The Linux Command Line</a>：非常不错的Linux Shell入门书籍，不深入，但很实用（尽管我还是觉得Shell语言就是一坨代谢聚合物）；</li>
<li><a href="http://www.amazon.com/Getting-started-Community-Experience-Distilled-ebook/dp/B00EJIZRG6/">Getting Started with Google Guava</a>：很一般的<a href="http://code.google.com/p/guava-libraries/">Google Guava</a>入门书，还不如阅读Guava的Wiki和源码来的实在；</li>
<li><a href="http://www.amazon.com/Google-Guice-Lightweight-Dependency-FirstPress/dp/1590599977/">Google Guice: Agile Lightweight Dependency Injection Framework</a>：Google最常用的IoC框架，书还可以就是有点过时，不如Guice的<a href="https://github.com/google/guice/wiki">文档</a>；</li>
<li><a href="http://www.amazon.com/Practical-Unit-Testing-JUnit-Mockito/dp/8393489393/">Practical Unit Testing with JUnit and Mockito</a>：非常好的Java单元测试书籍，每个Java开发者都应阅读此书；</li>
<li><a href="http://www.amazon.com/Bad-Tests-Good-Tomek-Kaczanowski-ebook/dp/B00IDFKRY8/">Bad Tests, Good Tests</a>：上面那本的补充；</li>
<li><a href="http://www.amazon.com/Clean-Coder-Conduct-Professional-Programmers/dp/0137081073/">The Clean Coder: A Code of Conduct for Professional Programmers</a>：成为专业开发者的必读书目，但里面有些原则在国内可能不适用——尤其是对某些996的公司；</li>
<li><a href="http://www.amazon.com/Mastering-Sublime-Text-Dan-Peleg/dp/1849698422/">Mastering Sublime Text</a>：很一般的Sublime Text教程，甚至还不如我写的<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">教程</a>；</li>
<li><a href="http://www.amazon.com/Architecture-Open-Source-Applications/dp/1257638017/">The Architecture Of Open Source Applications</a>：我学习软件架构的入门书籍；</li>
<li><a href="http://www.amazon.com/Performance-Open-Source-Applications/dp/1304488780/">The Performance of Open Source Applications</a>：我学习提升软件性能的入门书籍；</li>
<li><a href="http://www.amazon.com/Understanding-Computation-Machines-Impossible-Programs/dp/1449329276/">Understanding Computation: From Simple Machines to Impossible Programs</a>：一本很另类的介绍计算理论（Computation Theory）的书籍，我认为如果不用Ruby这么花哨的语言效果会更好；</li>
<li><a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively with Legacy Code</a>：专业软件开发者必读；</li>
<li><a href="http://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/">The Mythical Man-Month: Essays on Software Engineering</a>：经典重读；</li>
<li><a href="http://www.amazon.com/Design-Essays-Computer-Scientist/dp/0201362988/">The Design of Design: Essays from a Computer Scientist</a>：很玄妙的书籍，因为我着实记不起来内容是什么了——也许需要再读一遍；</li>
<li><a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>：少见的专门介绍调试的书籍，其中的原则不仅仅适用于软件开发；</li>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/">JavaScript: The Good Parts</a>：写Chrome插件时用来入门JavaScript的书籍；</li>
<li><a href="http://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691/">Professional JavaScript for Web Developers</a>：另一本JavaScript的书籍，废话超多，远不如上一本，不知道为什么这本书被很多人称为圣经；</li>
<li><a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Michael/dp/0123745144/">Programming Language Pragmatics</a>：超一流编程语言理论书籍，这本书会大大提升学习编程语言的速度和理解程度；</li>
<li><a href="http://www.amazon.com/Quick-Python-Book-Second/dp/193518220X/">The Quick Python Book</a>：用作Python入门，书本身很一般；</li>
<li><a href="http://www.amazon.com/Literate-Programming-Center-Language-Information/dp/0937073806/">Literate Programming</a>：重点阅读了编程错误分析的那一部分，这也是<a href="http://zh.lucida.me/blog/on-programming-errors-1/">关于编程错误的思考</a>系列的出处；</li>
<li><a href="http://www.amazon.com/Science-Programming-Monographs-Computer/dp/0387964800/">The Science of Programming</a>：经典重读；</li>
<li><a href="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871/">Structure and Interpretation of Computer Programs</a>：本来计划是完成前四章习题结果拖延症犯了看到第二章就搞别的去了，来年再战；</li>
<li><a href="http://www.amazon.com/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>：为了能读懂C++，所以读了这本入门小书，简练使用；</li>
</ul>


<h3>非专业类</h3>

<p>很杂很混乱，收获尚可。</p>

<ul>
<li><a href="http://www.amazon.com/Steve-Jobs-Walter-Isaacson/dp/1451648537/">Steve Jobs</a>：每次坐飞机时都会重读教主自传，每次读到教主怒骂Android那一段时就会感叹“只恨Steve当年剿匪不力”；</li>
<li><a href="http://www.amazon.com/Universal-Principles-Design-Revised-Updated/dp/1592535879/">Universal Principles of Design</a>：简洁的设计入门书籍；</li>
<li><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a>：绝好的英语语法+用法书籍；</li>
<li><a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a>：系统的指出了中式英语常犯的错误，除了例子有些政治化，其它都不错；</li>
<li><a href="http://www.amazon.com/Designing-One-Color-Two-Colors/dp/0062004611/">Designing with One Color and Two Colors</a>：学习配色时看的书，属于Cookbook；</li>
<li><a href="http://book.douban.com/subject/1970428/">激荡三十年</a>：了解中国的经济史；</li>
<li><a href="http://book.douban.com/subject/4010186/">跌荡一百年</a>：同上；</li>
<li><a href="http://book.douban.com/subject/6980818/">浩荡两千年</a>：同上，btw，中国商人太惨了；</li>
<li><a href="http://book.douban.com/subject/25783654/">如何高效学习</a>：建立知识网络，打通各个学科，大概就是这样；</li>
<li><a href="http://book.douban.com/subject/20507212/">习惯的力量</a>：找到产生消极习惯的循环，引入积极的元素，产生积极习惯；</li>
<li><a href="http://book.douban.com/subject/6892579/">美国种族简史</a>：去US时前读的书籍，对Jewish、Irish、Italian、Chinese、Japanese、Mexican等种族有了大概的认识，但这本书实在太旧，我不认为它符合现状；</li>
<li><a href="http://book.douban.com/subject/24383461/">网络素养</a>：所有“网友”都应该阅读此书；</li>
<li><a href="http://book.douban.com/subject/1823751/">中国近代史</a>：非常简练的中国近代史导论——此外大赞这本书的成书时间，正好错过了所有的TG的敏感区，不然它就甭想出版；</li>
<li><a href="http://book.douban.com/subject/1467022/">上帝掷色子吗</a>：通俗的物理学演义，但我一点没觉的通俗，看了一半就困的不行；</li>
<li><a href="http://book.douban.com/subject/4113090/">我们台湾这些年</a>：普通人眼里的台湾近30年历史，很鸡肋的一书，估计是因为受限于内容审查所以很多东西不能写；</li>
<li><a href="http://book.douban.com/subject/10586741/">关键对话</a>：非常好的如何进行理性对话的书籍；</li>
<li><a href="http://www.amazon.com/Dumbbell-Training-Allen-Hedrick/dp/145044458X/">Dumbbell Training</a>：系统的哑铃训练书籍；</li>
<li><a href="http://book.douban.com/subject/1924903/">老子</a>：老祖宗的有些东西现在读起来还是挺有意思的；</li>
<li><a href="http://www.amazon.com/Mastery-Keys-Success-Long-Term-Fulfillment/dp/0452267560/">Mastery: The Keys to Success and Long-Term Fulfillment</a>：很有禅意的超一流书籍——如何在领域内做到登峰造极；</li>
</ul>


<h2><a name="gaming">游戏</a></h2>

<p>2014年的另一个变化就是从PC转向Console——事实证明Console比PC爽太多——尤其对我这种ARPG爱好者。</p>

<p>为了“抄底”，我购入了XBox 360：</p>

<ul>
<li>XBox One刚出一年游戏并不多，而 XBox360上拥有大量游戏而且价格很便宜；</li>
<li>购买一台游戏PC的价格（大致1500$）足以购买一台XBox360+50个经典游戏；</li>
<li>很多经典游戏根本看不上PC这种盗版遍地的low逼平台——例如GTA V，例如God of War；</li>
<li>Kinect。</li>
</ul>


<p>下面是我打通的游戏：</p>

<ul>
<li><a href="http://www.metacritic.com/game/xbox-360/grand-theft-auto-v">GTA V</a>：史上最强神作，为了GTA V买一个主机都是值得的；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/grand-theft-auto-iv-the-complete-edition">GTA VI The Complete Edition</a>：GTA V之前的神作，之前在PC上low逼的打过盗版，所以现在特意买了正版重新打一遍；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/batman-arkham-asylum">Batman Arkham Asylum</a>：非常酷的动作解谜游戏，之前在PC上low逼的打过盗版，所以现在特意买了正版重新打一遍；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/batman-arkham-city">Batman Arkham City</a>：大大超越前作，可惜游戏时长太短；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/asuras-wrath">Asura&rsquo;s Wrath</a>：因为<a href="http://v.youku.com/v_show/id_XNTE0ODA2NDAw_rss.html">西游降魔篇抄袭</a>所以入了这款游戏——游戏本身很糟糕，基本就是QTE完形填空——整个游戏打下来跟看一遍日漫差不多；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/prototype-2">Prototype 2</a>：砍砍砍，跑跑跑，杀杀杀，然后通关，很无聊；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/fable-ii">Fable 2</a>：节奏很慢，但风格不错，喜欢里面的英音；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/red-dead-redemption">Red Dead Redemption</a>：GTA的西部版——GTA V里的很多元素都来自这里，僵尸DLC非常酷；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/darksiders-ii">Darksiders 2</a>：除了没有第一部紧凑，其它还可以；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/diablo-iii-ultimate-evil-edition">Diablo 3 Ultimate Evil</a>：没有想到Diablo这种ARPG在主机上的效果和手感居然能超越PC；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/borderlands">Borderlands</a>：很另类的FPS，这款游戏里我学到的更多的是如何有手柄控制准星 &ndash;_&ndash;#；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/nike+-kinect-training">Nike+Sports</a>：非常专业的Kinect运动游戏，现在每天都会练习30分钟；</li>
<li><a href="http://www.metacritic.com/game/xbox-360/ufc-personal-trainer-the-ultimate-fitness-system">UFC Training</a>：不那么专业的UFC运动训练，偶尔会玩一玩。</li>
</ul>


<p>附上游戏全家福：</p>

<p><img src="http://i.imgur.com/Td2xphs.jpg" alt="XBox 360 Games" /></p>

<h2><a name="buying">败物</a></h2>

<h3><a href="http://www.bose.com/controller?url=/shop_online/speakers/computer_speakers/companion_20/index.jsp">Bose C20</a></h3>

<p><img src="http://i.imgur.com/sFNWZ3s.jpg" alt="Bose C20" /></p>

<p>第一次用Bose产品，很惊讶这么小的体积居然可以发出如此大的声音，看电影尤其爽。</p>

<h3><a href="http://www.amazon.com/Xbox-360-500GB-Call-Duty-Bundle/dp/B00NNU07RU/">XBox 360 + Kinect</a></h3>

<p><img src="http://i.imgur.com/8cxU0iU.png" alt="XBox 360 + Kinect" /></p>

<p>除非你是RTS重度玩家，否则主机要比PC爽太多——既没有年年升级的烦恼，也没有low逼盗版的负罪感。</p>

<h3><a href="http://www.amazon.com/Parrot-Wireless-Cancelling-Headphones-Control/dp/B0081TH24O/">Parrot Zik</a></h3>

<p><img src="http://i.imgur.com/vpihZqi.jpg" alt="Parrot Zik" /></p>

<p>造型很奇特，但戴上去却格外舒适——内置降噪以及音效调节，触控操作非常人性化，唯一的不足就是不能记忆音量——每次都需要重新调节音量。</p>

<h3><a href="http://www.urbanears.com/headphones/plattan/plattan-black/">Urbanears Plattan</a></h3>

<p><img src="http://i.imgur.com/iynkuSI.jpg" alt="Urbanears Plattan" /></p>

<p>源自北欧，伦敦使用率最高的出街耳机，逼格秒杀一票<a href="http://cn.beatsbydre.com/">2B</a>。</p>

<h3><a href="http://bowflex.com/bowflex-home-gyms-us/accessories/freeweights/prdcd~100131/Bowflex+SelectTech+552+Dumbbells.jsp">Bowflex 552</a></h3>

<p><img src="http://i.imgur.com/PSy2aRz.jpg" alt="Bowflex 552" /></p>

<p>到US之后购入，非常好用的家用哑铃，从此再也不用在换铃片上费时间。</p>

<h3><a href="http://www.amazon.com/Microsoft-Sculpt-Ergonomic-Desktop-L5V-00001/dp/B00CYX54C0/">Microsoft Sculpt Ergonomic Desktop</a></h3>

<p><img src="http://i.imgur.com/x0Mycth.jpg" alt="Microsoft Sculpt Ergonomic Desktop" /></p>

<p>造型炫酷，使用舒适，开发者必备。</p>

<h3><a href="http://www.amazon.com/Microsoft-Surface-Pro-Intel-Core/dp/B00KHQWRZS/">Surface Pro 3</a></h3>

<p><img src="http://i.imgur.com/TvD2Rbg.jpg" alt="Surface Pro 3" /></p>

<p>非常炫酷的高性能平板，看文献秒杀iPad，写代码干翻超级本——唯一不足是<a href="http://answers.microsoft.com/en-us/surface/forum/surfpro3-surfusingpro/excessively-loud-fan-constant-overheating-during/1efa253a-f7f2-486b-a891-5633738b8532">散热极差</a>，购买前要小心。</p>

<h3><a href="http://www.microsoftstore.com/store/msusa/en_US/pdp/productID.307449200">Lumia 1520</a></h3>

<p><img src="http://i.imgur.com/Gio4QFq.jpg" alt="Lumia 1520" /></p>

<p>买来之后一直当相机用。</p>

<h3><a href="http://www.thatcompanycalledif.com/">The Company Called If</a></h3>

<p><img src="http://i.imgur.com/9GwlLfx.jpg" alt="Waterstones" /></p>

<p>在伦敦时我经常在<a href="http://www.waterstones.com/waterstonesweb/">Waterstones</a>蹭书，所以接触了<a href="http://www.thatcompanycalledif.com/">The Company Called If</a>这个专产阅读周边的英国本土品牌。</p>

<h4><a href="http://www.thatcompanycalledif.com/17/book-holders/little-book-holder">Little Book Holder</a></h4>

<p><img src="http://i.imgur.com/8CJQFPP.jpg" alt="Little Book Holder" /></p>

<p>非常可爱的书夹，美观性大于实用性，适合看书慢或边看书边笔记的同学。</p>

<h4><a href="http://www.thatcompanycalledif.com/64/reference-bookmarks/multi-reference-bookmarks">Multi-Reference Bookmarks</a></h4>

<p><img src="http://i.imgur.com/GAWIVQZ.jpg" alt="Multi-Reference Bookmarks" /></p>

<p>美观性和实用性兼具的多功能书签，不但能指明页数，还可以指明行数。</p>

<h4><a href="http://www.thatcompanycalledif.com/183/book-holders/the-brilliant-reading-rest">The Brilliant Reading Rest</a></h4>

<p><img src="http://i.imgur.com/JV3gQ7a.jpg" alt="The Brilliant Reading Rest" /></p>

<p>敦实的书架，阅读大部头书时非常好用。</p>

<h4><a href="http://www.thatcompanycalledif.com/20/book-holders/fold-away-book-rest">Fold-Away Book Rest</a></h4>

<p><img src="http://i.imgur.com/emKItSL.jpg" alt="Fold-Away Book Rest" /></p>

<p>很方便的折叠书架，适合中型书籍。</p>

<h3><a href="http://www.fiftythree.com/pencil">Pencil</a></h3>

<p><img src="http://i.imgur.com/Ew7nydU.jpg" alt="Pencil" /></p>

<p><a href="http://www.fiftythree.com/paper">Paper</a>是iPad上的超一流应用，加上<a href="http://www.fiftythree.com/pencil">Pencil</a>更是如虎添翼，木质<a href="http://www.fiftythree.com/pencil">Pencil</a>更是逼格爆表。</p>

<h2><a name="blogging">博客</a></h2>

<p>从2014年我开始写独立博客（<a href="http://zh.lucida.me/">http://zh.lucida.me/</a> ）——一共<a href="http://zh.lucida.me/blog/archives/">27篇</a>，我的<a href="http://zh.lucida.me/blog/my-first-article/">第一篇博文</a>说明了我写独立博客的原因。</p>

<p>刘未鹏的一篇关于<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">为什么要写博客</a>的文章对我影响很大——所以我决定写价值博客——而且是超一流的原创价值博客。</p>

<h3>历程</h3>

<p>由于很长时间没有写作，所以我前期的博文往往篇幅较短，而且叙事混乱，比如<a href="http://zh.lucida.me/blog/memoirs-on-my-postgraduate-life/">从挣钱的角度回忆下自己的研究生三年</a>和<a href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/">网络上瘾及其解决方法</a>，都属于相当糟糕的文章。</p>

<p>从<a href="http://zh.lucida.me/blog/on-reading-books/">如何阅读书籍</a>开始，我开始使用统一的模式编写博客——提出问题——分析问题——解决问题。在此篇博文之后的技术博文走的都是这个套路：例如<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">90分钟实现一门编程语言——极简解释器教程</a>和<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">学习&amp;使用技术的四种层次</a>。</p>

<p>尽管我非常费力的去写博文，然而访问量却一直不理想——大致一天二三十十的访问，其中两三成还来自我自己。（-_-）</p>

<p>转折点来自<a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>，这篇半经历半吐槽的文章被各种转发推荐，不但让我的博客日访问量上了三位数，还给我带来了四位数的微博关注和豆瓣关注。但我自己很疑惑——这篇文章无论在严谨程度还是技术含量上都不如前面的几篇，但它的阅读量反而却远超前几篇博文的总和。如果你在Google上搜<a href="https://www.google.com.hk/#safe=strict&amp;q=%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0">“算法学习”</a>、<a href="https://www.google.com.hk/#safe=strict&amp;q=%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95">“学习算法”</a>或<a href="https://www.google.com.hk/#safe=strict&amp;q=%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95">“如何学习算法”</a>，<a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>都排在第一位。</p>

<p>我甚至猜测是不是这种诙谐的文章很有市场，于是搞了一篇<a href="http://zh.lucida.me/blog/stories-of-masturbations/">打飞机故事集</a>然后满怀希望的等待访问量再创新高。</p>

<p>结果连个P都没有——看来我的猜测是错的，至少没人会为单纯的诙谐买账。</p>

<p>于是我尝试用另一种方式提高访问量——热门话题。于是就有了<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">关于锤子手机和锤子手机发布会</a>和<a href="http://zh.lucida.me/blog/an-introduction-to-swift/">来自苹果的编程语言——Swift简介</a>这两篇文章，效果很不错。</p>

<p>访问量稳定之后，我开始尝试一些连载文章，比如<a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">设计中的设计</a>和<a href="http://zh.lucida.me/blog/on-programming-errors-0/">关于编程错误的思考</a>这两个系列，尽管这系列文章的访问量不高，但我在其中学到了很多东西。（是的，这两个系列我还没写完，来年再填）</p>

<p>为了学习<a href="http://www.sublimetext.com/">Sublime Text</a>，我写了<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">Sublime Text 全程指南</a>这篇教程，现在它已经是最热门的Sublime Text中文教程——在Google上搜索<a href="https://www.google.com.hk/#safe=strict&amp;q=sublime+text+%E6%95%99%E7%A8%8B">“Sublime Text 教程”</a>或<a href="https://www.google.com.hk/#safe=strict&amp;q=sublime+text+%E6%8C%87%E5%8D%97">“Sublime Text 教程”</a>它都排在第一位，而<a href="https://www.google.com.hk/#safe=strict&amp;q=sublime+text">Google搜索“Sublime Text”</a>这篇教程则紧随Sublime Text官网之后。</p>

<p>再之后，我翻译了Brian Goetz的<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">Lambda Articles</a>，并回顾了我以前写的<a href="http://zh.lucida.me/blog/top-code-offline-browser/">Top Coder浏览器</a>和<a href="http://zh.lucida.me/blog/lucida-pinyin-converter/">Lucida拼音库</a>。</p>

<p>总之，2014年是一个不错的开端。从2015年开始，维持<a href="http://zh.lucida.me/">中文博客</a>的同时，我会开始编写<a href="http://en.lucida.me/">英文博客</a>——相信在明年会有我的英文博文被“翻译”回中文，到时一定会很有趣。</p>

<h2><a name="planning">展望</a></h2>

<p>2015年有很多事情要做，但主要目标（Primary Objectives）很简单——3件事，按优先级排序：</p>

<ol>
<li><strong>减重</strong>——工作之后体重稳步增长到160斤（身高173cm），我实在不想成为一个胖逼（胖子是没有前途的！！），所以15年的目标是把体重控制回135斤以内；（实际上已经锻炼了1个多月，减掉了4斤）；</li>
<li><strong>升职</strong>——是时候尝试下了 :&ndash;) ；</li>
<li><strong>写书</strong>——早在一年半之前<a href="http://www.phei.com.cn/">电子工业出版社</a>就曾经联系过我写一本关于程序员求职的书，原计划是去年8月出版（瀑布汗，实在对不住<a href="http://www.weibo.com/208686914">@永恒的侠少</a>），结果一直拖到现在（一方面是懒，另一方面是觉得实力不足）。工作一年多写了一年博客之后，经验和写作能力都提升不小，是时候把这个坑填上了。</li>
</ol>


<p>次要目标（Secondary Objectives）包括但不限于：</p>

<ol>
<li>撰写英文博客——至少做到三篇进入<a href="http://www.reddit.com/r/programming">Reddit Programming</a> Top 5；</li>
<li>完成SICP前四章习题；</li>
<li>完成Merriam Webster Vocabulary Builder里的单词；</li>
<li>至少做3次Tech Talk；</li>
<li>阅读5本以上的软件开发领域的经典书籍；</li>
<li>搞定Python Readability；</li>
<li>重新精读<a href="http://www.amazon.com/Programming-Language-Pragmatics-Third-Edition/dp/0123745144">Programming Language Pragmatics</a>，构建自己的程序设计语言知识框架；</li>
<li>……</li>
</ol>


<p>以上。</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/2014-summary/">http://zh.lucida.me/blog/2014-summary/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/"/>
    <updated>2014-12-12T22:23:36-08:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<p>本文是深入理解Java 8 Lambda系列的第二篇，主要介绍Java 8针对新增语言特性而新增的类库（例如Streams API、Collectors和并行）。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of the Lambda: Libraries Edition</a>一文的翻译。</p>

<h2><a name="about">关于</a></h2>

<p>Java SE 8增加了新的语言特性（例如lambda表达式和默认方法），为此Java SE 8的类库也进行了很多改进，本文简要介绍了这些改进。在阅读本文前，你应该先阅读<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">深入浅出Java 8 Lambda（语言篇）</a>，以便对Java SE 8的新增特性有一个全面了解。</p>

<h2><a name="background">背景（Background）</a></h2>

<p>自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而<a href="https://jcp.org/en/jsr/detail?id=355">JSR 355</a>（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API：</p>

<!-- more -->


<ul>
<li>为现有的接口（例如<code>Collection</code>，<code>List</code>和<code>Stream</code>）增加扩展方法；</li>
<li>在类库中增加新的<em>流</em>（stream，即<code>java.util.stream.Stream</code>）抽象以便进行聚集（aggregation）操作；</li>
<li>改造现有的类型使之可以提供流视图（stream view）；</li>
<li>改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如<code>ArrayList</code>和<code>HashMap</code>（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。</li>
</ul>


<p>除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。除此之外，我们还需要在将并行变的<em>容易</em>（easier）和将并行变的<em>不可见</em>（invisible）之间做出抉择，我们选择了一个折中的路线：提供<em>显式</em>（explicit）但<em>非侵入</em>（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题）</p>

<h2><a name="interal_vs_external_iteration">内部迭代和外部迭代（Internal  vs external iteration）</a></h2>

<p>集合类库主要依赖于<em>外部迭代</em>（external iteration）。<code>Collection</code>实现<code>Iterable</code>接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Shape</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">shapes</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">shape</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子演示了外部迭代：for-each循环调用<code>shapes</code>的<code>iterator()</code>方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：</p>

<ul>
<li>Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。</li>
</ul>


<p>尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。</p>

<p>我们可以使用<em>内部迭代</em>（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。</p>

<p>下面是前例的内部迭代代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">shapes</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>

<p>外部迭代同时承担了<em>做什么</em>（把形状设为红色）和<em>怎么做</em>（得到<code>Iterator</code>实例然后依次遍历）两项职责，而内部迭代只负责<em>做什么</em>，而把<em>怎么做</em>留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。</p>

<h2><a name="stream">流（Stream）</a></h2>

<p><em>流</em>是Java SE 8类库中新增的关键抽象，它被定义于<code>java.util.stream</code>（这个包里有若干流类型：<code>Stream&lt;T&gt;</code>代表对象引用流，此外还有一系列特化（specialization）流，比如<code>IntStream</code>代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。</p>

<p>流的操作可以被组合成<em>流水线</em>（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>      <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>      <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流视图（stream view），接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>

<p>如果我们想把蓝色的形状提取到新的<code>List</code>里，则可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                         <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>collect()</code>操作会把其接收的元素聚集（aggregate）到一起（这里是<code>List</code>），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到<code>List</code>中。（如需更多<code>collect()</code>方法的细节，请阅读<a href="#collectors">Collectors</a>一节）</p>

<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="n">hasBlueShape</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getContainingBox</span><span class="o">())</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>

<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。</p>

<h2><a name="stream_vs_collection">流和集合（Streams vs Collections）</a></h2>

<p>集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同：</p>

<ul>
<li>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到；</li>
<li>天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改；</li>
<li>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；</li>
<li>无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举<a href="http://en.wikipedia.org/wiki/Perfect_number">完美数</a>这个操作可以被表达为在所有整数上进行过滤）。集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）；</li>
</ul>


<p>从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（<code>Collection</code>拥有<code>stream()</code>和<code>parallelStream()</code>方法），也可以通过流产生一个集合（使用前例的<code>collect()</code>方法）。<code>Collection</code>以外的类型也可以作为<code>stream</code>的数据源，比如JDK中的<code>BufferedReader</code>、<code>Random</code>和<code>BitSet</code>已经被改造可以用做流的数据源，<code>Arrays.stream()</code>则产生给定数组的流视图。事实上，任何可以用<code>Iterator</code>描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。</p>

<h3><a name="laziness">惰性（Laziness）</a></h3>

<p>过滤和映射这样的操作既可以被<em>急性求值</em>（以<code>filter</code>为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被<em>惰性求值</em>（用<code>Stream</code>代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</p>

<p>对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像<code>sum()</code>这样生成值的操作和<code>forEach()</code>这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。</p>

<p>以下面的流水线为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的过滤操作和映射操作是惰性的，这意味着在调用<code>sum()</code>之前，我们不会从数据源提取任何元素。在<code>sum</code>操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。</p>

<p>大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（<code>forEach</code>，<code>toArray</code>和<code>collect</code>等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让<code>filter</code>和<code>map</code>返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如<code>forEach()</code>）都是急性操作。绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。</p>

<p>在使用这种<em>数据源—惰性操作—惰性操作—急性操作</em>流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。</p>

<p>对于<code>anyMatch(Predicate)</code>和<code>findFirst()</code>这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">firstBlue</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                                  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                                  <span class="o">.</span><span class="na">findFirst</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于过滤这一步是惰性的，<code>findFirst</code>在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。<code>findFirst()</code>方法返回<code>Optional</code>对象，因为集合中有可能不存在满足条件的元素。<code>Optional</code>是一种用于描述可缺失值的类型。</p>

<p>在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。</p>

<h3><a name="parallelism">并行（Parallelism）</a></h3>

<p>流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过<code>parallel()</code>方法被转化为并行流）</p>

<p>尽管并行是显式的，但它并不需要成为侵入式的。利用<code>parallelStream()</code>，我们可以轻松的把之前重量求和的代码并行化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span> <span class="o">=</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。</p>

<p>因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出<code>ConcurrentModificationException</code>）我们把这个条件称为无干扰性（non-interference）。</p>

<p>我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义：</p>

<ol>
<li>不要干扰数据源；</li>
<li>不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。</li>
</ol>


<p>只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如<code>ArrayList</code>）也是一样。</p>

<h2><a name="examples">实例（Examples）</a></h2>

<p>下面的代码源自JDK中的<code>Class</code>类型（<code>getEnclosingMethod</code>方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getEnclosingClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Class</span><span class="o">&lt;</span> <span class="o">?</span> <span class="o">&gt;[]</span> <span class="n">candidateParamClasses</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">candidateParamClasses</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">parameterClasses</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">boolean</span> <span class="n">matches</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidateParamClasses</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">candidateParamClasses</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">parameterClasses</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">matches</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>          <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">matches</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// finally, check return type</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">returnType</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">method</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">throw</span> <span class="k">new</span> <span class="nf">InternalError</span><span class="o">(</span><span class="s">&quot;Enclosing method not found&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用<code>Arrays.stream</code>将它转化为<code>Stream</code>，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用<code>findFirst</code>得到<code>Optional&lt;Method&gt;</code>，最后利用<code>orElseThrow</code>返回目标值或者抛出异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getEnclosingClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">())</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">(),</span> <span class="n">parameterClasses</span><span class="o">))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">(),</span> <span class="n">returnType</span><span class="o">))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
</span><span class='line'>             <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="s">&quot;Enclosing method not found&quot;</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。</p>

<p>流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。</p>

<p>假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;</span> <span class="n">favs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Album</span> <span class="n">album</span> <span class="o">:</span> <span class="n">albums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="n">hasFavorite</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Track</span> <span class="n">track</span> <span class="o">:</span> <span class="n">album</span><span class="o">.</span><span class="na">tracks</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">track</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">hasFavorite</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">hasFavorite</span><span class="o">)</span>
</span><span class='line'>    <span class="n">favs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">album</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">favs</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Album</span> <span class="n">a1</span><span class="o">,</span> <span class="n">Album</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用<code>anyMatch</code>）；按名字排序；以及把满足条件的专辑放在一个<code>List</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;</span> <span class="n">sortedFavs</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">albums</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">tracks</span><span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">name</span><span class="o">))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Compartor.comparing</code>方法接收一个函数（该函数返回一个实现了<code>Comparable</code>接口的排序键值），然后返回一个利用该键值进行排序的<code>Comparator</code>（请参考下面的<a href="#comparator_factories">比较器工厂</a>一节）。</p>

<h3><a name="collectors">收集器（Collectors）</a></h3>

<p>在之前的例子中，我们利用<code>collect()</code>方法把流中的元素聚合到<code>List</code>或<code>Set</code>中。<code>collect()</code>接收一个类型为<code>Collector</code>的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。<code>Collectors</code>类包含了大量常用收集器的工厂方法，<code>toList()</code>和<code>toSet()</code>就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。</p>

<p><code>Collector</code>的类型由其输入类型和输出类型决定。以<code>toList()</code>收集器为例，它的输入类型为<code>T</code>，输出类型为<code>List&lt;T&gt;</code>，<code>toMap</code>是另外一个较为复杂的<code>Collector</code>，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。<code>toMap</code>的输入类型是<code>T</code>，输出类型是<code>Map&lt;K, V&gt;</code>，其中<code>K</code>和<code>V</code>分别是前面两个函数所生成的键类型和值类型。（复杂版本的<code>toMap</code>收集器则允许你指定目标<code>Map</code>的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Album</span><span class="o">&gt;</span> <span class="n">albumsByCatalogNumber</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">albums</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">getCatalogNumber</span><span class="o">(),</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>groupingBy</code>是一个与<code>toMap</code>相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的<code>Collector</code>：它以<code>Track</code>作为输入，以<code>Map&lt;Artist, List&lt;Track&gt;&gt;</code>作为输出。<code>groupingBy</code>收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成<code>Map</code>，该<code>Map</code>的键是分类函数的返回结果，值是该分类下的元素列表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;</span> <span class="n">favsByArtist</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的<code>groupingBy</code>收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用<em>其它</em>收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的<code>groupingBy</code>使用<code>toList()</code>作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到<code>Set</code>而非<code>List</code>中，我们可以使用<code>toSet</code>收集器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;</span> <span class="n">favsByArtist</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">,</span>
</span><span class='line'>                                         <span class="n">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级<code>Map</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;&gt;</span> <span class="n">byArtistAndRating</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span><span class="o">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用<code>Stream.flatMap()</code>得到一个歌曲流，然后用<code>Pattern.splitAsStream</code>把每首歌曲的标题打散成词流；接下来我们用<code>groupingBy</code>和<code>String.toUpperCase</code>对这些词进行不区分大小写的分组，最后使用<code>counting()</code>收集器计算每个词出现的次数（从而无需创建中间集合）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&quot;\\s+&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordFreq</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">splitAsStream</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">))</span> <span class="c1">// Stream&lt;String&gt;</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">(),</span>
</span><span class='line'>                              <span class="n">counting</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>flatMap</code>接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的<code>flatMap</code>会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。</p>

<p><code>Collectors</code>类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义<code>Collector</code>。</p>

<h2><a name="parallelism_under_the_hood">并行的实质（Parallelism under the hood）</a></h2>

<p>Java SE 7引入了<a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Fork/Join</a>模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。</p>

<p>为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步：</p>

<ul>
<li>把问题分解为子问题；</li>
<li>串行解决子问题从而得到部分结果（partial result）；</li>
<li>合并部分结果合为最终结果。</li>
</ul>


<p>这也是Fork/Join的实现原理。</p>

<p>为了能够并行化任意流上的所有操作，我们把流抽象为<code>Spliterator</code>，<code>Spliterator</code>是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像<code>Iterator</code>允许你跳过一个元素然后保留剩下的元素，<code>Spliterator</code>允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的<code>Spliterator</code>中，而剩下的数据则会被保存在原来的<code>Spliterator</code>里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。</p>

<p>上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。</p>

<p>大多数用户无需去实现<code>Spliterator</code>接口，因为集合上的<code>stream()</code>方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现<code>Spliterator</code>接口。<code>Spliterator</code>接口的API如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Element access</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Decomposition</span>
</span><span class='line'>  <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//Optional metadata</span>
</span><span class='line'>  <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
</span><span class='line'>  <span class="n">Comparator</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">getComparator</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>集合库中的基础接口<code>Collection</code>和<code>Iterable</code>都实现了正确但相对低效的<code>spliterator()</code>实现，但派生接口（例如<code>Set</code>）和具体实现类（例如<code>ArrayList</code>）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在<code>split()</code>方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。</p>

<h3><a name="encounter_order">出现顺序（Encounter order）</a></h3>

<p>多数数据结构（例如列表，数组和I/O通道）都拥有<em>自然出现顺序</em>（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如<code>HashSet</code>）则没有一个明确定义的出现顺序（这也是<code>HashSet</code>的<code>Iterator</code>实现中不保证元素出现顺序的原因）。</p>

<p>是否具有明确定义的出现顺序是<code>Spliterator</code>检查的特性之一（这个特性也被流使用）。除了少数例外（比如<code>Stream.forEach()</code>和<code>Stream.findAny()</code>），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
</span><span class='line'>                           <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
</span><span class='line'>                           <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码中名字出现的顺序必须要和流中的<code>Person</code>出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是<code>HashSet</code>，那么上面代码中名字就可以以任意顺序出现。</p>

<h2><a name="streams_lambdas_in_jdk">JDK中的流和lambda（Streams and lambdas in JDK）</a></h2>

<p><code>Stream</code>在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用<code>Stream</code>。我们为<code>Collection</code>提供了<code>stream()</code>和<code>parallelStream()</code>，以便把集合转化为流；此外数组可以通过<code>Arrays.stream()</code>被转化为流。</p>

<p>除此之外，<code>Stream</code>中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如<code>Stream.of()</code>，<code>Stream.generate</code>以及<code>IntStream.range</code>。其它的常用类型也提供了流相关的方法，例如<code>String.chars</code>，<code>BufferedReader.lines</code>，<code>Pattern.splitAsStream</code>，<code>Random.ints</code>和<code>BitSet.stream</code>。</p>

<p>最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现<code>Stream</code>至少需要一个<code>Iterator</code>，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过<code>Spliterator</code>提供一个更加高效的实现（就像JDK中所有的集合一样）。</p>

<h3><a name="comparator_factories">比较器工厂（Comparator factories）</a></h3>

<p>我们在<code>Comparator</code>接口中新增了若干用于生成比较器的实用方法：</p>

<p>静态方法<code>Comparator.comparing()</code>接收一个函数（该函数返回一个实现<code>Comparable</code>接口的比较键值），返回一个<code>Comparator</code>，它的实现十分简洁：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">U</span><span class="o">&gt;&gt;</span> <span class="n">Compartor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">comparing</span><span class="o">(</span>
</span><span class='line'>    <span class="n">Function</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c1</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c2</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把这种方法称为<em>高阶函数</em>——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码比“过去的代码”（一般要定义一个实现<code>Comparator</code>接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，<code>Comparator</code>拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()).</span><span class="na">reversed</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>与之类似，默认方法<code>thenComparing</code>允许你去改进一个已有的<code>Comparator</code>：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">())</span>
</span><span class='line'>                                 <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">());</span>
</span><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a name="mutative_collection_operation">可变的集合操作（Mutative  collection operation）</a></h3>

<p>集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如<code>Collection</code>，<code>List</code>和<code>Map</code>）提供了一些新的方法，比如<code>Iterable.forEach(Consumer)</code>，<code>Collection.removeAll(Predicate)</code>，<code>List.replaceAll(UnaryOperator)</code>，<code>List.sort(Comparator)</code>和<code>Map.computeIfAbsent()</code>。除此之外，<code>ConcurrentMap</code>中的一些非原子方法（例如<code>replace</code>和<code>putIfAbsent</code>）被提升到<code>Map</code>之中。</p>

<h2><a name="summary">小结（Summary）</a></h2>

<p>引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。<code>Stream</code>抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从2000毫秒到10毫秒——Lucida拼音库的设计与实现]]></title>
    <link href="http://zh.lucida.me/blog/lucida-pinyin-converter/"/>
    <updated>2014-12-07T00:27:17-08:00</updated>
    <id>http://zh.lucida.me/blog/lucida-pinyin-converter</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lucida-pinyin-converter">从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>本文介绍了Lucida拼音库的设计、实现以及优化过程。Lucida拼音库以微软拼音库为基础，能够快速的把汉字转化为对应的拼音，它比微软拼音库快200多倍，同时占用内存不到微软拼音库的八分之一。</p>

<h2>背景</h2>

<p>Lucida拼音库是我三年前编写<a href="http://www.windowsphone.com/zh-cn/store/app/%E4%B8%AD%E6%96%87%E6%8B%A8%E5%8F%B7%E5%8A%A9%E6%89%8B/3e4f73b2-c70e-40dd-b3b8-1d2135e9af56">拨号助手</a>时自行设计并实现的一个工具类（Utility Class）。它可以把中文转化成汉语拼音，并可以在Windows Phone 7上使用。</p>

<p>我曾经在<a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>里面提到过我为什么需要这个工具类（用户期望根据拼音给出智能提示），以及为什么需要自己动手编写，而不是使用现成的代码（<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=15251">微软拼音库</a>）。有兴趣的同学可以阅读<a href="http://zh.lucida.me/blog/on-learning-algorithms/">那篇文章</a>了解背景。</p>

<p>我个人习惯使用自上而下（Top-Down）的方式设计类，Lucida拼音库也不例外：</p>

<ol>
<li>API设计；</li>
<li>具体实现；</li>
<li>测试；</li>
<li>度量->优化->度量->优化&hellip;</li>
</ol>


<p>接下来我将按照这个步骤一一介绍Lucida拼音库从设计到实现的过程。</p>

<!-- more -->


<h2>API设计（API Design）</h2>

<p>API设计<a href="http://www.newt.com/java/GoodApiDesign-JoshBloch.pdf">至关重要</a>——结合<a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Framework Design Guidelines</a>和<a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Joshua Bloch</a>关于如何设计API的<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">演讲</a>，我在设计API时会遵循以下步骤：</p>

<ol>
<li>确认功能需求；</li>
<li>确认至少三个不同的使用场景；</li>
<li>确认API。</li>
</ol>


<h3>功能需求</h3>

<p>Lucida拼音库将汉字转化为拼音——但为了编码，我们需要更加细化的需求：</p>

<ol>
<li>能够得到给定汉字的拼音；（<code>'中' -&gt; "ZHONG"</code>）</li>
<li>能够得到给定多音汉字的所有拼音；（<code>'曾' -&gt; ["CENG", "ZENG"]</code>）</li>
<li>能够判断一个给定字符是否是汉字；（<code>'中' -&gt; true; 'A' -&gt; false</code>）</li>
<li><strong>只</strong>需要拼音，<strong>不</strong>需要音调。</li>
</ol>


<h3>使用场景</h3>

<p>结合实际需求，我写下了如下使用场景：</p>

<figure class='code'><figcaption><span>得到汉字的拼音</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">String</span><span class="p">[]</span> <span class="n">pinyins</span> <span class="p">=</span> <span class="sc">&#39;曾&#39;</span><span class="p">.</span><span class="n">GetPinyins</span><span class="p">();</span>
</span><span class='line'><span class="c1">// pinyins == [&quot;CENG&quot;, &quot;ZENG&quot;]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>得到中文词汇的拼音</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">String</span> <span class="k">value</span> <span class="p">=</span> <span class="s">&quot;中华人民&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">String</span><span class="p">[]</span> <span class="n">pinyinOfValue</span> <span class="p">=</span> <span class="k">value</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">GetPinyins</span><span class="p">()[</span><span class="m">0</span><span class="p">]).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'><span class="c1">// pinyinOfValue == [&quot;ZHONG&quot;, &quot;HUA&quot;, &quot;REN&quot;, &quot;MIN&quot;]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>得到得到混合词汇的首字母缩写</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">String</span> <span class="n">mixed</span> <span class="p">=</span> <span class="s">&quot;IBM中国有限公司&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">String</span> <span class="n">initialOfMixed</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">mixed</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">ToUpper</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">IsChinese</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">GetPinyins</span><span class="p">()[</span><span class="m">0</span><span class="p">][</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}));</span>
</span><span class='line'><span class="c1">// initialOfMixed == [&quot;IBMZGYXGS&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难看出<code>GetPinyins</code>和<code>IsChinese</code>是Lucida拼音库的关键操作。</p>

<h3>API设计</h3>

<p>根据前面的使用场景，不难得到下面的API：</p>

<figure class='code'><figcaption><span>Lucida拼音库API</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ChineseCharExtensions</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">/// &lt;summary&gt;</span>
</span><span class='line'>  <span class="c1">/// Gets an array of Pinyin from the given character.</span>
</span><span class='line'>  <span class="c1">/// &lt;/summary&gt;</span>
</span><span class='line'>  <span class="c1">/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;Throws when the given character is not a Chinese character.&lt;/exception&gt;</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">GetPinyins</span><span class="p">(</span><span class="k">this</span> <span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">/// &lt;summary&gt;</span>
</span><span class='line'>  <span class="c1">/// Indicates whether the given character is a Chinese character.</span>
</span><span class='line'>  <span class="c1">/// &lt;/summary&gt;</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">static</span> <span class="n">Boolean</span> <span class="nf">IsChinese</span><span class="p">(</span><span class="k">this</span> <span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>ChineseCharExtensions</code>是一个扩展类，它为<code>Char</code>提供<code>GetPinyins</code>和<code>IsChinese</code>这两个<a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">扩展方法</a>，从而允许我们直接在<code>Char</code>类型上调用这两个方法，非常方便。</p>

<p>可能有人会问为什么不引入<code>GetFirstPinyin</code>或<code>GetInitial</code>这样的辅助方法。我的答案是：<strong>一个类应该提供少量正交的（Orthogonal）高性能方法，调用者根据需求进行进一步抽象。</strong></p>

<h2>实现（Implementation）</h2>

<blockquote><p>问：把大象放进冰箱需要几步？
答：三步：1. 打开冰箱门；2. 把大象放进去；3. 关上冰箱。</p></blockquote>

<p>API设计告诉我们做什么（What to do），接下来我们需要确定怎么做（How to do），也就是代码实现。</p>

<p>Windows Phone 7不支持大容量<code>Dictionary</code>（这也是微软拼音库无法在Windows Phone 7上正常运行的原因），所以我们不能直接使用.Net自带的字典数据结构。但拼音转换需要一个字典结构——对于给定的字符返回其拼音——也就是说我们要<strong>自己实现</strong>一个类似<code>Dictionary&lt;Char, String[]&gt;</code>的数据结构，但又不能直接使用<code>Dictionary</code>。从性能方面考虑，这个数据结构应该尽可能使用<code>Int32</code>、<code>String</code>和<code>String[]</code>这些低开销基本类型，而<strong>不</strong>使用<code>List&lt;String&gt;</code>或<code>Dictionary&lt;Char, String[]&gt;</code>这些高开销类型。</p>

<p>为了实现<code>汉字 -&gt; 拼音</code>这个字典结构，我们需要解决下面这两个问题：</p>

<ol>
<li>如何在不使用<code>Dictionary</code>的前提下查找汉字？</li>
<li>如何尽可能紧凑的表示拼音？我们可以为每个汉字用<code>String</code>数组表示拼音，但两万多个<code>String</code>数组无疑是不小的开销。</li>
</ol>


<h3>如何查找汉字</h3>

<p>这个问题并不难解决，我们可以把两万多个汉字拼接成一个字符串，然后对这个字符串进行排序，接下来用二分搜索查找汉字。我们可以把这个大号字符串（两万多个汉字）放在代码里，从而省去排序时间：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Char</span><span class="p">[]</span> <span class="n">ChineseCharacters</span> <span class="p">=</span> <span class="s">&quot;〇一丁丂七丄丅...&quot;</span><span class="p">.</span><span class="n">ToArray</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来我们可以用二分搜索查找汉字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Int32</span> <span class="nf">FindCharacter</span><span class="p">(</span><span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">Array</span><span class="p">.</span><span class="n">BinarySearch</span><span class="p">(</span><span class="n">ChineseCharacters</span><span class="p">,</span> <span class="n">chr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是转念一想，为什么要二分搜索呢？就像C标准库里的<code>isupper</code>和<code>islower</code>一样，我可以使用一个位图（Bit-map）来查找汉字，从而把速度从o(logN)降到o(1)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">/// &lt;summary&gt;</span>
</span><span class='line'><span class="c1">/// The minimum integer value of a valid Chinese character.</span>
</span><span class='line'><span class="c1">/// &lt;/summary&gt;</span>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Int32</span> <span class="n">MinValue</span> <span class="p">=</span> <span class="m">12295</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// &lt;summary&gt;</span>
</span><span class='line'><span class="c1">/// The maximum integer value of a valid Chinese character.</span>
</span><span class='line'><span class="c1">/// &lt;/summary&gt;</span>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Int32</span> <span class="n">MaxValue</span> <span class="p">=</span> <span class="m">59491</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Boolean</span><span class="p">[]</span> <span class="n">ChineseCharactersTruthTable</span> <span class="p">=</span> <span class="p">{</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了<code>ChineseCharactersTruthTable</code>，我们可以很容易的实现<code>IsChinese</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">Boolean</span> <span class="nf">IsChinese</span><span class="p">(</span><span class="k">this</span> <span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">MinValue</span> <span class="p">&lt;=</span> <span class="n">chr</span> <span class="p">&amp;&amp;</span> <span class="n">chr</span> <span class="p">&lt;=</span> <span class="n">MaxValue</span> <span class="p">&amp;&amp;</span> <span class="n">ChineseCharactersTruthTable</span><span class="p">[</span><span class="n">chr</span> <span class="p">-</span> <span class="n">MinValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>如何表示拼音</h3>

<p>最直接的表示拼音的方式是使用<code>String[][]</code>，它按照<code>ChineseCharacters</code>中的汉字顺序保存着每个汉字的拼音：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">String</span><span class="p">[][]</span> <span class="n">PinyinsTable</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="n">String</span><span class="p">[]</span> <span class="p">{</span><span class="s">&quot;LING&quot;</span><span class="p">},</span> <span class="k">new</span> <span class="n">String</span><span class="p">[]</span> <span class="p">{</span><span class="s">&quot;YI&quot;</span><span class="p">},</span> <span class="p">...</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后利用它和<code>FindCharacter</code>实现<code>GetPinyins</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">GetPinyins</span><span class="p">(</span><span class="k">this</span> <span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Int32</span> <span class="n">index</span> <span class="p">=</span> <span class="n">FindCharacter</span><span class="p">(</span><span class="n">chr</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="p">!=</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">PinyinsTable</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="s">&quot;chr&quot;</span><span class="p">,</span> <span class="n">chr</span><span class="p">,</span> <span class="s">&quot;Expect a Chinese character.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但用多维数组表示<code>PinyinTable</code>存在很多问题：</p>

<ol>
<li><code>PinyinTable</code>是一个由两万多个数组组成的多维数组——构造它可是不小的开销；</li>
<li><code>GetPinyins</code>会直接返回<code>PinyinTable</code>里的子数组引用，如果用户修改了子数组那么原始数组<code>PinyinTable</code>也会遭到修改。（是的，我们可以返回一个拷贝，然而这又造成了性能开销）</li>
</ol>


<p>出于这两个原因，我们不会使用<code>String[][]</code>。我们应该使用一种紧凑的方式表达拼音，这时我的第一反应就是用<code>Int64</code>表示拼音，我的理由如下：</p>

<ol>
<li>尽管汉字有多音字，但我估计每个多音字的发音不会超过8种；</li>
<li>我估计汉字的拼音应该不会超过500种，也就是说可以用9位（Bit）表示一个拼音；</li>
<li>所以<code>Int64</code>可以容纳7个拼音（64 > 7 * 9），我认为这足够了。</li>
</ol>


<p>为了验证我的猜想，我编写了一段代码用来计算汉字的拼音数量：</p>

<figure class='code'><figcaption><span>计算汉字拼音有多少种</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">ChineseCharacters</span>
</span><span class='line'>    <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ChineseChar</span><span class="p">(</span><span class="n">c</span><span class="p">).</span><span class="n">Pinyins</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">Aggregate</span><span class="p">(</span><span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(),</span> <span class="p">(</span><span class="n">hashSet</span><span class="p">,</span> <span class="n">pinyins</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">foreach</span> <span class="p">(</span><span class="n">String</span> <span class="n">pinyin</span> <span class="k">in</span> <span class="n">pinyins</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">!=</span> <span class="k">null</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">hashSet</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">pinyin</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">pinyin</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">));</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">hashSet</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}).</span><span class="n">Count</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// -&gt; 403</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以汉字拼音一共有<strong>403</strong>种——然后我用一段代码来算一个汉字最多能有多少拼音：</p>

<figure class='code'><figcaption><span>计算一个汉字最多能有几种拼音</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">chr</span> <span class="p">=</span> <span class="n">Pinyin</span><span class="p">.</span><span class="n">HanziArray</span>
</span><span class='line'>    <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">Value</span> <span class="p">=</span> <span class="n">c</span><span class="p">,</span>
</span><span class='line'>      <span class="n">Pinyins</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ChineseChar</span><span class="p">(</span><span class="n">c</span><span class="p">).</span><span class="n">Pinyins</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">!=</span> <span class="k">null</span><span class="p">).</span><span class="n">ToArray</span><span class="p">()</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>    <span class="p">.</span><span class="n">Aggregate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">.</span><span class="n">Length</span> <span class="p">?</span> <span class="n">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">chr</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="s">&quot;: &quot;</span> <span class="p">+</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="n">chr</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// -&gt; 差: CHA1, CHA4, CHA5, CHAI1, CHAI4, CHAI5, CI1, CI5</span>
</span></code></pre></td></tr></table></div></figure>


<p>好吧<em>差</em>有8种拼音，不过由于我们不考虑音调，所以再算一遍：</p>

<figure class='code'><figcaption><span>计算一个汉字最多能有几种拼音（不考虑音调）</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">chr</span> <span class="p">=</span> <span class="n">Pinyin</span><span class="p">.</span><span class="n">HanziArray</span>
</span><span class='line'>  <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Value</span> <span class="p">=</span> <span class="n">c</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Pinyins</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span>
</span><span class='line'>        <span class="k">new</span> <span class="nf">ChineseChar</span><span class="p">(</span><span class="n">c</span><span class="p">).</span><span class="n">Pinyins</span>
</span><span class='line'>          <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>          <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">)))</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'>  <span class="p">.</span><span class="n">Aggregate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">.</span><span class="n">Count</span> <span class="p">?</span> <span class="n">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">chr</span><span class="p">.</span><span class="n">Value</span> <span class="p">+</span> <span class="s">&quot;: &quot;</span> <span class="p">+</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="n">chr</span><span class="p">.</span><span class="n">Pinyins</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// -&gt; 轧: GA, YA, YAI, ZHA</span>
</span></code></pre></td></tr></table></div></figure>


<p>这证明了我的猜想：一个汉字最多有4种拼音（不考虑音调），拼音一共有403种。所以我们可以用9位（Bit）表示一个拼音，从而最多使用36位。也就是说<code>Int64</code>可以被用来表示一个汉字的拼音，以<code>差</code>为例，它有CHA、CHAI和CI三种发音：</p>

<p><img src="http://i.imgur.com/1IKzPu2.png" alt="图解差的拼音表示" /></p>

<p>所以，我们可以用<code>Int64[]</code>来代替前面的<code>String[][]</code>，每一个<code>Int64</code>代表一个汉字的拼音：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Int64</span><span class="p">[]</span> <span class="n">PinyinCodes</span> <span class="p">=</span> <span class="p">{</span> <span class="m">175</span><span class="p">,</span> <span class="m">357</span><span class="p">,</span> <span class="m">196677</span><span class="p">,</span> <span class="m">186002</span><span class="p">,</span> <span class="m">246</span><span class="p">,</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>PinyinCodes</code>的引入使得<code>ChineseCharactersTruthTable</code>变的多余，因为现在可以通过检查<code>PinyinCodes</code>的值来判断一个字符是否为汉字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">Boolean</span> <span class="nf">IsChinese</span><span class="p">(</span><span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">MinValue</span> <span class="p">&lt;=</span> <span class="n">chr</span> <span class="p">&amp;&amp;</span> <span class="n">chr</span> <span class="p">&lt;=</span> <span class="n">MaxValue</span> <span class="p">&amp;&amp;</span> <span class="n">PinyinCodes</span><span class="p">[</span><span class="n">chr</span> <span class="p">-</span> <span class="n">MinValue</span><span class="p">]</span> <span class="p">!=</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外我们需要编写额外一个方法用来把<code>Int64</code>解码（Decode）为对应的拼音，并增加一个类型为<code>String[]</code>的<code>PinyinTable</code>保存汉字中所有的拼音：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="n">PinyinTable</span> <span class="p">=</span> <span class="p">{</span> <span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="s">&quot;AI&quot;</span><span class="p">,</span> <span class="s">&quot;AN&quot;</span><span class="p">,</span> <span class="s">&quot;ANG&quot;</span><span class="p">,</span> <span class="s">&quot;AO&quot;</span><span class="p">,</span> <span class="s">&quot;BA&quot;</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">DecodePinyins</span><span class="p">(</span><span class="n">Int64</span> <span class="n">pinyinCode</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Int16</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">Int64</span> <span class="n">tmp</span> <span class="p">=</span> <span class="n">pinyinCode</span><span class="p">;</span> <span class="n">tmp</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">count</span> <span class="p">+=</span> <span class="m">1</span><span class="p">,</span> <span class="n">tmp</span> <span class="p">&gt;&gt;=</span> <span class="m">9</span><span class="p">)</span> <span class="p">;</span>
</span><span class='line'>  <span class="n">String</span><span class="p">[]</span> <span class="n">pinyins</span> <span class="p">=</span> <span class="k">new</span> <span class="n">String</span><span class="p">[</span><span class="n">count</span><span class="p">];</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">Int16</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">pinyinCode</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">+=</span> <span class="m">1</span><span class="p">,</span> <span class="n">pinyinCode</span> <span class="p">&gt;&gt;=</span> <span class="m">9</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">pinyins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">PinyinTable</span><span class="p">[(</span><span class="n">pinyinCode</span> <span class="p">&amp;</span> <span class="m">511</span><span class="p">)</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">pinyins</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后利用它们来实现<code>GetPinyins</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">GetPinyins</span><span class="p">(</span><span class="k">this</span> <span class="n">Char</span> <span class="n">chr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">IsChinese</span><span class="p">(</span><span class="n">chr</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">DecodePinyins</span><span class="p">(</span><span class="n">PinyinCodes</span><span class="p">[</span><span class="n">chr</span> <span class="p">-</span> <span class="n">MinValue</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">(</span><span class="s">&quot;chr&quot;</span><span class="p">,</span> <span class="n">chr</span><span class="p">,</span> <span class="s">&quot;Expect a Chinese character.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现了<code>IsChinese</code>和<code>GetPinyins</code>，Lucida拼音库的实现就基本完成了，接下来是测试。</p>

<h2>测试（Test）</h2>

<p>我的测试思路很简单：我假设微软拼音库是正确的，如果Lucida拼音库和微软拼音库具有一致的行为（Behavior），那么Lucida拼音库就是正确的。</p>

<p>测试代码非常简单直接：遍历所有的字符（<code>Char</code>），检查Lucida拼音库是否和微软拼音库具有一致的行为。</p>

<figure class='code'><figcaption><span>等价性测试</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="na">[TestClass]</span>
</span><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">ChineseCharExtensionsTest</span> <span class="p">{</span>
</span><span class='line'><span class="na">  [TestMethod]</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">void</span> <span class="nf">TestIsChinese</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">invalidCases</span> <span class="p">=</span> <span class="n">AllChars</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">IsChinese</span><span class="p">()</span> <span class="p">!=</span> <span class="n">ChineseChar</span><span class="p">.</span><span class="n">IsValidChar</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">Value</span> <span class="p">=</span> <span class="n">c</span><span class="p">,</span>
</span><span class='line'>          <span class="n">Expected</span> <span class="p">=</span> <span class="n">ChineseChar</span><span class="p">.</span><span class="n">IsValidChar</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
</span><span class='line'>          <span class="n">Actual</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">IsChinese</span><span class="p">()</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Empty</span><span class="p">,</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;\n&quot;</span><span class="p">,</span> <span class="n">invalidCases</span><span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="na">  [TestMethod]</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">void</span> <span class="nf">TestGetPinyins</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">invalidCases</span> <span class="p">=</span> <span class="n">AllChars</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="n">ChineseChar</span><span class="p">.</span><span class="n">IsValidChar</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">c</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">Value</span> <span class="p">=</span> <span class="n">c</span><span class="p">,</span>
</span><span class='line'>          <span class="n">Expected</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span>
</span><span class='line'>              <span class="k">new</span> <span class="nf">ChineseChar</span><span class="p">(</span><span class="n">c</span><span class="p">).</span><span class="n">Pinyins</span>
</span><span class='line'>                  <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                  <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="m">1</span><span class="p">))),</span>
</span><span class='line'>          <span class="n">Actual</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span><span class="n">c</span><span class="p">.</span><span class="n">GetPinyins</span><span class="p">())</span>
</span><span class='line'>        <span class="p">})</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">o</span><span class="p">.</span><span class="n">Expected</span><span class="p">.</span><span class="n">SetEquals</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">Actual</span><span class="p">))</span>
</span><span class='line'>        <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">Value</span> <span class="p">=</span> <span class="n">o</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
</span><span class='line'>          <span class="n">Expected</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">Expected</span><span class="p">),</span>
</span><span class='line'>          <span class="n">Actual</span> <span class="p">=</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">Actual</span><span class="p">)</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="n">Assert</span><span class="p">.</span><span class="n">AreEqual</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Empty</span><span class="p">,</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot;\n&quot;</span><span class="p">,</span> <span class="n">invalidCases</span><span class="p">));</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">private</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Char</span><span class="p">&gt;</span> <span class="n">AllChars</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">Char</span> <span class="k">value</span> <span class="p">=</span> <span class="n">Char</span><span class="p">.</span><span class="n">MinValue</span><span class="p">;</span> <span class="k">value</span> <span class="p">!=</span> <span class="n">Char</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span> <span class="k">value</span> <span class="p">+=</span> <span class="p">(</span><span class="n">Char</span><span class="p">)</span><span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">yield</span> <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后测试就通过了 &ndash;_&ndash;# 我甚至手动改了下代码让测试失败再改回来让测试通过以确定测试是有效的。</p>

<h2>度量（Profiling）</h2>

<p>理论上来说我的拼音库要比微软拼音库速度快，而且占用空间小。但是理论归理论，我们需要度量（Profile）程序来验证它。我在这里使用Visual Studio 2013自带的性能分析工具（Performance and Diagnostics）进行时间度量和内存度量。</p>

<p>度量程序如下。我使用一短（30个字符）一长（22047个字符）两个字符串作为测试数据，然后使用<code>ByMsLibrary</code>和<code>ByLucLibrary</code>分别用微软拼音库和我的拼音查询库将这两个字符串转化成对应的拼音：</p>

<figure class='code'><figcaption><span>度量用例</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Char</span><span class="p">[]</span> <span class="n">shortText</span> <span class="p">=</span> <span class="s">&quot;前面三辆囚车中分别监禁的是三个男子，都作书生打扮，一个是白发&quot;</span><span class="p">.</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">var</span> <span class="n">longText</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllText</span><span class="p">(</span><span class="s">@&quot;sample_text.txt&quot;</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">Char</span><span class="p">[]</span> <span class="n">longText</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="n">ReadAllText</span><span class="p">(</span><span class="s">@&quot;sample_text.txt&quot;</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">String</span> <span class="nf">ByMsLibrary</span><span class="p">(</span><span class="n">Char</span><span class="p">[]</span> <span class="n">chrArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="n">chrArray</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ch</span> <span class="p">=&gt;</span> <span class="n">ChineseChar</span><span class="p">.</span><span class="n">IsValidChar</span><span class="p">(</span><span class="n">ch</span><span class="p">)).</span><span class="n">Select</span><span class="p">(</span><span class="n">ch</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ChineseChar</span><span class="p">(</span><span class="n">ch</span><span class="p">).</span><span class="n">Pinyins</span><span class="p">[</span><span class="m">0</span><span class="p">]));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">static</span> <span class="n">String</span> <span class="nf">ByLucLibrary</span><span class="p">(</span><span class="n">Char</span><span class="p">[]</span> <span class="n">chrArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="n">chrArray</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">ch</span> <span class="p">=&gt;</span> <span class="n">ch</span><span class="p">.</span><span class="n">IsChinese</span><span class="p">()).</span><span class="n">Select</span><span class="p">(</span><span class="n">ch</span> <span class="p">=&gt;</span> <span class="n">ch</span><span class="p">.</span><span class="n">GetPinyins</span><span class="p">()[</span><span class="m">0</span><span class="p">]));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>时间度量（Timing Profiling）</h3>

<h4>短字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="n">value1</span> <span class="p">=</span> <span class="n">ByMsLibrary</span><span class="p">(</span><span class="n">shortText</span><span class="p">);</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">value2</span> <span class="p">=</span> <span class="n">ByLucLibrary</span><span class="p">(</span><span class="n">shortText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/IPHln3j.png" alt="短字符串时间度量" /></p>

<p>对于短字符串（30个字符），Lucida拼音库的性能优势并不明显（3毫秒对48毫秒，尽管也快了16倍），值得一提的是，微软拼音库花了30毫秒用于初始化，而我的拼音查询库只用了不到2毫秒。</p>

<h4>长字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="n">value1</span> <span class="p">=</span> <span class="n">ByMsLibrary</span><span class="p">(</span><span class="n">longText</span><span class="p">);</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">value2</span> <span class="p">=</span> <span class="n">ByLucLibrary</span><span class="p">(</span><span class="n">longText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/AfU1pCX.png" alt="长字符串时间度量" /></p>

<p>对于长字符串（22047个字符），我的拼音查询库的性能优势得到了展现：微软拼音库用了1603毫秒，而我的拼音查询库只用了7毫秒——比微软拼音库快200多倍。</p>

<h3>内存度量（Memory Profiling）</h3>

<h4>微软拼音库 + 短字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="k">value</span> <span class="p">=</span> <span class="n">ByMsLibrary</span><span class="p">(</span><span class="n">shortText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/fvohazD.png" alt="微软拼音库 + 短字符串" /></p>

<p>微软拼音库使用了1633KB内存：内存大量被花费在反序列化拼音信息（<code>CharUnit.Deserialize</code>）、读取资源（<code>ResourceReader.GetResourceData</code>）和初始化列表（<code>List.Add</code>）上。</p>

<h4>Lucida拼音库 + 短字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="k">value</span> <span class="p">=</span> <span class="n">ByLucLibrary</span><span class="p">(</span><span class="n">shortText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/RFOzRJ8.png" alt="Lucida拼音库 + 短字符串" /></p>

<p>Lucida拼音库使用了392KB内存——大约是微软拼音库的四分之一，几乎所有的内存都被花费在初始化拼音编码数组上。</p>

<h4>微软拼音库 + 长字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="k">value</span> <span class="p">=</span> <span class="n">ByMsLibrary</span><span class="p">(</span><span class="n">longText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/fpcDFbt.png" alt="微软拼音库 + 长字符串" /></p>

<p>微软拼音库使用了6229KB内存，这时<code>CharUnit</code>对象的获取和初始化成为了内存占用的主力。</p>

<h4>Lucida拼音库 + 长字符串</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>  <span class="n">String</span> <span class="k">value</span> <span class="p">=</span> <span class="n">ByLucLibrary</span><span class="p">(</span><span class="n">longText</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/tH0KIiR.png" alt="Lucida拼音库 + 长字符串" /></p>

<p>Lucida拼音库使用了1354KB内存——依然不到微软拼音库的四分之一，初始化拼音编码数组仍占据了接近三成，可以注意到获取拼音时生成的字符串数组（<code>String[]</code>）占据了大量的内存。</p>

<h2>优化（Optimization）</h2>

<p>上面的代码是我三年前写下的，尽管它已经足够快足够紧凑——速度比微软拼音库快200多倍，初始化时间不到微软拼音库的三十分之一，占用内存不到微软拼音库的四分之一，但我认为它可以被继续优化——毕竟我当时在实现它时为了赶进度没有进行进一步的优化。</p>

<p>由于汉字查询的时间复杂度已是o(1)，而且内存度量显示Lucida拼音库在初始化时消耗了相当内存——所以接下来的优化主要从空间复杂度着手：</p>

<h3>稀疏数组（Sparse Array）</h3>

<p>汉字的最小编码是<code>12295</code>，最大编码是<code>59491</code>，为了简便，我直接开了一个大小为<code>47197</code>（<code>59491 - 12295 + 1</code>）的<code>Int64</code>数组用来存储拼音编码。但汉字实际上是<code>20591</code>个，这意味着有一多半的空间都被浪费了。</p>

<p>我猜测汉字编码应该是连续的——就像英文字母的ASCII表示一样。于是我编写了一小段代码来观察汉字编码分布，实验证明：尽管汉字编码是不连续，但它们只集中在<code>[12295, 12295]</code>、<code>[19968, 40869]</code>和<code>[59418, 59491]</code>这三个区间，也就是说可以用大小总和不到<code>21000</code>的三个数组来存储拼音编码，从而节省了一多半空间。</p>

<p>于是我用三个数组代替了原来的<code>PinyinCodes</code>，代码变的有些复杂，但是有测试在我也不怕会搞出什么问题。修改完成之后，我重新进行了性能和内存度量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</span><span class='line'>短字符串         3毫秒            6毫秒             392KB             182KB
</span><span class='line'>长字符串         7毫秒            10毫秒           1354KB             857KB
</span></code></pre></td></tr></table></div></figure>


<p>和我的估计差不多：由于分支判断增多导致运行时间增加了3毫秒，但内存占用则少了很多。</p>

<h3>拼音编码（Pinyin Encoding）</h3>

<p>我之前的代码存在另外一个问题：汉字拼音有403种，一个汉字最多有4种拼音，于是我使用4个9位，也就是36位，来表示一个汉字的拼音。</p>

<p>这个方法看似合理，但存在一个问题：太多的空间被浪费掉了。</p>

<p>为什么我会这么说呢？是的，汉字是有很多多音字，但不会有那么多多音字。我的方案考虑了所有可能的拼音组合，也就是<code>403 + 403 * 402 + 403 * 402 * 401 + 403 * 402 * 401 * 400 = 26,050,889,215</code>种，而汉字只有20591个，所以我原来的方案至少浪费了99.9999%以上的空间。</p>

<p>我估计所有可能的拼音组合不到一万种，为了印证我的猜想，我编写了另外一段代码计算汉字拼音有多少种组合——答案是<code>2163</code>。也就是说，我完全可以使用<code>Int16</code>来编码汉字拼音。每个编码对应一种拼音组合（例如<code>'差'</code>对应<code>"CA;CHA;CI"</code>），然后使用<code>String#Split</code>得到拼音，这样连移位操作也可以省略。</p>

<p>完成修改之后，我再次进行了性能和内存度量，效果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</span><span class='line'>短字符串         6毫秒           12毫秒             182KB            127KB
</span><span class='line'>长字符串        10毫秒           15毫秒             857KB           1643KB
</span></code></pre></td></tr></table></div></figure>


<p>令我吃惊的是这个&#8221;优化&#8221;并没有得到预想的效果：改变编码后的拼音库仅仅在短字符输入时节省了60KB内存，而在处理长字符时内存占用反而增加了一倍，经过进一步度量我发现<code>GetPinyins</code>在调用<code>String#Split</code>时消耗了大量内存。</p>

<p>于是我使用了另一种方法——去除<code>String#Split</code>，但保留<code>Int16</code>编码，然后通过一个大小为2163的<code>Int64</code>数组来保存原来的<code>Int64</code>拼音编码。然后我再次进行了性能和内存度量，效果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</span><span class='line'>短字符串        12毫秒            3毫秒             127KB             74KB
</span><span class='line'>长字符串        15毫秒            7毫秒             857KB            776KB
</span></code></pre></td></tr></table></div></figure>


<p>度量结果显示速度得到了提升——恢复到了优化内存之前的水平，而内存占用被进一步缩小。</p>

<h2>总结（Summary）</h2>

<p>通过空间换时间（Time-Space Trade Off）、紧凑表示（Compact Representation）、减少抽象层级（Reduce Abstract Level）以及时间/内存度量（Timing/Memory Profiling）等优化策略。我在微软拼音库的基础上实现了更加短小迅速的Lucida拼音库：</p>

<ul>
<li>查询速度比微软拼音库快200倍以上；</li>
<li>占用内存不到微软拼音库的八分之一；</li>
<li>启动速度比微软拼音库快30倍以上；</li>
<li>库的大小不到微软拼音库的五分之一。</li>
</ul>


<p>这个比较并不公平——因为微软拼音库支持音调和笔画，而Lucida拼音库只支持汉字到拼音，但我认为这并不是产生性能差距的主要原因——如果让我设计一个和微软拼音库功能一模一样的拼音库，我相信我至少可以把速度提升50倍，并把内存占用降低至原来的三分之一。</p>

<h3>回顾（Review）</h3>

<p>下面是对整个优化过程的回顾：</p>

<p>以长字符串（22047个字符）作为基准</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>                           时间           内存占用
</span><span class='line'>0. 微软拼音库              1603毫秒          6229KB
</span><span class='line'>1. 去除字典                 21毫秒          1471KB
</span><span class='line'>2. 使用位图代替二分搜索         7毫秒          1354KB
</span><span class='line'>3. 使用稀疏数组              10毫秒           857KB
</span><span class='line'>4. 使用紧凑表示               7毫秒           776KB
</span></code></pre></td></tr></table></div></figure>


<p>以短字符串（30个字符）作为基准</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>                           时间          内存占用
</span><span class='line'>0. 微软拼音库                48毫秒          1633KB
</span><span class='line'>1. 去除字典                   7毫秒           536KB
</span><span class='line'>2. 使用位图代替二分搜索         3毫秒           392KB
</span><span class='line'>3. 使用稀疏数组               6毫秒           182KB
</span><span class='line'>4. 使用紧凑表示               3毫秒            74KB
</span></code></pre></td></tr></table></div></figure>


<h3>得到的经验（Lessons Learned）</h3>

<ol>
<li>转移所有不必要的运行时计算到代码时（Move all unnecessary runtime computations to coding-time）：Lucida拼音库大量使用了这个技巧，例如汉字拼音编码都是手动编码生成，从而避免运行时计算；</li>
<li>如果追求性能，尽可能使用基本类型构建数据结构：Lucida拼音库没有使用任何.Net自带的<code>List</code>或是<code>Dictionary</code>类型；</li>
<li>通过实验验证猜想：我在编写Lucida拼音库时进行了很多假设（例如汉字编码是连续的和汉字拼音的组合是有限的等等），这些假设需要通过实验证明；</li>
<li>时间和空间不一定是矛盾的：Lucida拼音库就是一个很好的例子——200倍以上的速度提升——八分之一以下的内存占用；</li>
<li>通过度量进行优化，而非猜测：我曾经认为<code>String#Split</code>不会造成太大的性能损耗，事实恰恰相反；</li>
<li>如果可能，使用o(1)的算法；</li>
<li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">Make it run, make it correct, make it fast</a>；</li>
<li>代码优化会牺牲可读性：我不认为会有人能直接读懂Lucida拼音库的代码：</li>
</ol>


<p><img src="http://i.imgur.com/lT8SHBY.png" alt="Lucida拼音库部分代码" /></p>

<p>事实上它的大部分都是我通过另外一个程序生成，而另外一个程序则是通过另外一个程序生成 &ndash;_&ndash;#</p>

<h2>引用（References）</h2>

<ol>
<li><a href="http://www.amazon.com/Writing-Efficient-Programs-Prentice-Hall-Software/dp/013970244X/">Writing Efficient Programs</a>;</li>
<li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">Make it run, make it correct, make it fast</a>;</li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms182398.aspx">Profiling in Visual Studio 2013</a>;</li>
<li><a href="http://java.bizhat.com/~cs134/Resources/Reading/Articles/Bentley/p1087-bentley.pdf">Perspective on Performance</a></li>
<li><a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Framework Design Guidelines</a>;</li>
<li><a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Joshua Bloch</a>关于如何设计API的<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">演讲</a>;</li>
<li><a href="http://research.microsoft.com/en-us/um/people/blampson/33-hints/webpage.html">Hints for Computer System Design</a>;</li>
<li><a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>.</li>
</ol>


<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lucida-pinyin-converter">从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精益技术简历之道——改善技术简历的47条原则]]></title>
    <link href="http://zh.lucida.me/blog/lean-technical-resume/"/>
    <updated>2014-11-01T21:08:43-07:00</updated>
    <id>http://zh.lucida.me/blog/lean-technical-resume</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>这篇文章围绕着技术简历这个话题，从版式、个人信息、技术能力、项目经历和教育背景等方面出发，给出了编写高质量技术简历所应遵循的47条原则。它们既有益于求职者编写高质量的简历，也有助于招聘者筛选合格的求职者。</p>

<h2>为什么要编写这篇文章？</h2>

<p>技术简历既是技术人员求职必不可少的一环，也是找工作的第一步，其重要性不言而喻。然而关于如何编写技术简历的靠谱教程却少之又少，以至于求职者无法编写出合格的简历，而招聘者无法从简历中看出求职者的真实水平。</p>

<p>一些人可能会反对：如何编写技术简历还不简单，网上到处都是嘛！找一个教程，套一个模板，简历不就出来了嘛！</p>

<ul>
<li><a href="http://jingyan.baidu.com/article/363872ecf0fa656e4ba16f80.html">求职简历怎么写</a>，</li>
<li><a href="http://bbs.yingjiesheng.com/thread-180175-1-1.html">资深HR告诉你到底怎么写一份好的简历</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4a388a6d01008cza.html">技术人员的简历编写技巧</a></li>
<li><a href="http://wenku.baidu.com/view/98f781d528ea81c758f57876.html">精美简历模板集合</a></li>
<li><a href="http://wenku.baidu.com/link?url=ocsWDBteInQGBzY562PWrz7_ZRZHF9BkzonuRAYmFCFGFCmMjXLPB3wSMxuQOFmbzx8FnuhJXogWHVmS8ViYt2nfkY_Xj3RT7ifLZH2WoZe">IT求职简历模板</a></li>
</ul>


<p>上面的教程和模板是我在谷歌和百度搜索“如何编写技术简历”和“技术简历模板”得到的结果，它们的共性是<strong>完全不适用于技术领域</strong>：这些教程和模板会指导你写出一篇<del>屁话连连空话连篇看似出彩但</del>毫无实质内容的嘴遁简历，是的，它们可能适用于一些国有企业，但对于追求实际的外企和民企完全不适用。</p>

<p>技术领域追求<strong>简练、客观、实际和成就</strong>，而不是<strong>冗余、主观、抽象和过程</strong>。如果求职者使用上面的教程或模板编写技术简历，那么结果注定会非常糟糕；如果招聘者使用上面的教程来甄别求职者，那么注定会招进一群光说不做的饭桶。我不是在开玩笑——尽管算上实习我只工作了三年，但我已经见证过很多优秀的童鞋因为简历被公司拒之门外，也见证过招聘者/HR因为不懂甄别简历，搞进来一群莫名其妙的家伙来面试，既浪费时间，又浪费资源。</p>

<p>所以我决定写一篇如何编写技术简历的文章，也就是<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>：</p>

<ol>
<li>为技术人员提供一个靠谱实用的技术简历编写教程</li>
<li>为招聘人员提供一个便捷高效的技术简历甄别教程</li>
</ol>


<p>结合国外书籍/文章和我自己的经验，我总结出47项编写高质量技术简历的原则，<strong>这些原则既可以作为求职者编写技术简历的准则，也可以作为招聘人员筛选技术简历的标准。</strong></p>

<p>此外，随着越来越多的人开始海外求职，我特别针对英文简历编写了9项原则，以帮助国人编写合格的英文技术简历。</p>

<p>注：本文标题中的的“精益”（Lean）源于精益创业（<a href="http://theleanstartup.com/">the Lean Startup</a>）。</p>

<h2>注意</h2>

<p>为了完成这篇文章，我从我的微博关注者中征集了一系列简历（感谢你们的信任！）。下文有可能会出现你们简历中的部分内容（当然我会进行改动以便保护你们的隐私），如果觉得不妥，请与我联系，我会将其删除。</p>

<p>下面进入正文。</p>

<!-- more -->


<hr />

<h2>精益技术简历原则</h2>

<h3>关于</h3>

<p>为了使本文更加严谨有序，我在组织简历原则时参考了编程书籍中著名的Effective系列（例如<a href="http://book.douban.com/subject/1842426/">Effective C++</a>和<a href="http://book.douban.com/subject/3360807/">Effective Java</a>）以及<a href="http://book.douban.com/subject/3267575/">Framework Design Guidelines</a>的行文风格：</p>

<ul>
<li>“使用……”、“对……进行……”、“按照……”这些原则属于必须遵循的原则</li>
<li>“不要使用……”、“不要……”、“避免……”这些原则属于必须避免的原则</li>
<li>“考虑……”、“不必……”、“谨慎……”这些原则属于我个人建议的原则，你可以去违反它们，但我个人不推荐这样做</li>
</ul>


<p>为了便于阅读和理解，我将这些原则按照进行了分类：</p>

<ul>
<li><strong>排版</strong>分类中的原则介绍了如何写出美观的简历</li>
<li>一般来说一封简历都会包含<strong>个人信息</strong>、<strong>技术能力</strong>、<strong>项目经验</strong>、<strong>教育背景</strong>和<strong>个人爱好</strong>，所以我将简历内容相关的原则按照这些分类进行了组织</li>
<li><strong>英文简历</strong>分类介绍了如何改善你的英文简历</li>
<li>未被分组的原则被归类到<strong>其他</strong></li>
</ul>


<h3><a name="sec1">版式</a></h3>

<p>版式（排版和样式）并不是简历内容的一部分，但却会对简历给人的第一印象造成很大影响——“字如其人”，简历版式可以反映其作者是否严谨是否认真。如果版式过于糟糕，那么简历很可能会被直接筛掉。</p>

<h4><a name="rule1">1. 使用对齐</a></h4>

<p>对齐（Alignment）是良好排版的第一要素——对齐不仅使简历层次分明，也会给人有力的感觉，例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="未对齐的简历" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="对齐的简历" /></p>

<h4><a name="rule2">2. 不必使用居中</a></h4>

<p>居中会破坏对齐，减弱整体的层次感，所以我不建议在简历中使用居中。例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="居中标题" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="非居中标题" /></p>

<p>是的，这条原则里使用的图片来自<a href="#rule1">原则 1. 使用对齐</a>，请牢记：<strong>左/右对齐优于居中对齐。</strong></p>

<h4><a name="rule3">3. 谨慎使用<strong>粗体</strong></a></h4>

<p>粗体是一个很强大的工具，它可以有效的去引导简历阅读者的视线，并突出重要的内容。但我在阅读简历的时候发现不少人对粗体使用不当——滥用，用错，甚至是全文使用粗体，这使得简历完全无法被正常阅读。</p>

<p>粗体适用于去突出<strong>成就</strong>（Achievements），例如：</p>

<ul>
<li>量化的成就：将页面加载速度提升<strong>50%</strong></li>
<li>良好的成绩：GPA <strong>4.0/4.0</strong></li>
<li>奖项：ICPC/ACM比赛中获得XX赛区<strong>一等奖</strong></li>
<li>他人的推荐语：<strong>“XX是我见过的最优秀的实习生”</strong></li>
</ul>


<p>在其它场景下，我不推荐使用粗体，此外注意不要过多使用粗体——<strong>粗体是为了突出成就，不是为了突出技术关键字</strong>，<strong>太多的粗体会导致什么也突出不出来。</strong></p>

<h4><a name="rule4">4. 避免不必要的折行</a></h4>

<p>折行（Wrap）指当一行内容过长时会自动进入下一行。我不是说不可以折行（那就成了古龙小说了 :&ndash;/），而是说不要使用不必要的折行，比如说：</p>

<p><img src="http://i.imgur.com/oWHWfnO.png" alt="不必要的折行" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/RHoQFdQ.png" alt="去掉折行" /></p>

<p>不必要的折行会降低简历的密度，破坏简历的层次感，而且会给人没话说有意占行数的感觉。请务必避免这样的折行。</p>

<h4><a name="rule5">5. 使用制表符辅助对齐</a></h4>

<p>为了进行对齐，我们往往需要添加一些空白符。在这里请使用制表符（tab）而非空格（space），因为：</p>

<ol>
<li>空格往往不会带来严格的对齐（因为简历字体往往不是等宽的）</li>
<li>制表符在打印版本下的表现更佳</li>
</ol>


<h3><a name="sec2">个人信息</a></h3>

<p>个人信息部分决定了简历阅读者对简历的第一印象，请务必在这部分内容多下功夫。</p>

<h4><a name="rule6">6. 不要使用不必要的条目名称</a></h4>

<p>条目名称（Column name）这个词很拗口，我举一个例子：“姓名：张大锤”和“电话：135-9112-7890”里的“姓名”和“电话”就是条目名称。</p>

<p>绝大多数的条目名称都是不必要的——“张大锤”一看就是一个名字，“135-9112-7890”一看就是一个手机号码。这种条目信息会让简历变得拖沓啰嗦，请务必删除它们。</p>

<p>此外，请牢记<strong>“个人简历”是简历上最大的废话</strong>——这当然是一封简历，不用你提醒。可笑的是很多所谓的“500强简历模板”还把“个人简历”作为简历抬头（Header）。</p>

<h4><a name="rule7">7. 使用分隔符增强电话号码的可读性</a></h4>

<p>请使用“-”和“()”格式化你的电话号码，例如：把<strong>8618601007070</strong> 改为 <strong>(+86) 186-0100-7070</strong>，以便简历阅读者能够正确便捷的拨打你的号码，此外这样的号码也显得更加专业。</p>

<h4><a name="rule8">8. 使用可以点击的链接</a></h4>

<ul>
<li>使用<a href="http://zh.lucida.me">http://zh.lucida.me</a>而非http<nolink>://zh.lucida.me</li>
<li>使用<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#x6d;&#x79;&#109;&#97;&#x69;&#x6c;&#64;&#103;&#103;&#x67;&#x2e;&#99;&#111;&#109;">&#109;&#x79;&#x6d;&#x61;&#x69;&#108;&#64;&#103;&#103;&#103;&#x2e;&#x63;&#111;&#x6d;</a>而非mymail<nolink>@ggg.com</li>
</ul>


<p>这样简历阅读者就可以直接点击，而不是费力的把链接复制粘贴到某个输入栏中。</p>

<h4><a name="rule9">9. 不要使用照片</a></h4>

<p>照片不会对你的简历产生任何正面价值，而且它会破坏简历的结构，请不要在简历中使用照片。</p>

<h4><a name="rule10">10. 不要写无关个人信息</a></h4>

<p>是的，你是在写技术简历，而不是在写入党申请或征婚启事之类的东西，所以请不要在简历中出现下面这些信息：</p>

<ul>
<li>性别</li>
<li>生日</li>
<li>星座</li>
<li>籍贯</li>
<li>通信地址</li>
<li>民族</li>
<li>政治面貌（WTF!!??）</li>
<li>身高/体重</li>
</ul>


<p>理想的个人信息应该包括姓名、联系方式（电邮地址和手机号码），如果你有不错的技术博客也可以把它放在上面。</p>

<h4><a name="rule11">11. 使用客观事实而非主观描述</a></h4>

<p>我经常在简历里面看到诸如“我是一个热爱编程的开发者”或是“我精力充沛，热爱学习，能够长时间从事编程工作”之类的个人评价，总之就是把雇主希望看到的性格特点堆在一起，有时感动的我都想哭。</p>

<p>但感动归感动，这些感人肺腑的个人评价我向来直接无视——<strong>我为什么要相信你呢？</strong>引用<a href="https://lkml.org/lkml/2000/8/25/132">Linus的话</a>，<strong>Talk is cheap, show me the code</strong>。如果要说明你是一个热爱编程的开发者，那么请出你的Github页面或优秀的个人作品；如果要说明你热爱学习，请给出你读过的书或写过的书评。总之，使用客观事实，而非主观描述。</p>

<h4><a name="rule12">12. 考虑提供他人的评价</a></h4>

<p>这条原则是上一条原则的扩充——找你的导师、老板或者同事为你写一个评语，相对于主观描述，他人的评价往往更加可信。如果你的评价者是业内权威，那么效果就会更好。</p>

<h4><a name="rule13">13. 不必写求职目标</a></h4>

<p>我读过的很多简历都有“Objective”（求职目标）这一栏，一般求职者会在这里写他所期待的职位。我个人非常不喜欢求职目标这一栏，因为求职目标给我一种海投简历的感觉。如果走的是内部推荐，或者使用目标公司的求职页面，请去掉求职目标，你应该已经了解投递职位，不需要在简历里面重复。</p>

<h3><a name="sec3">技术能力</a></h3>

<p>技术能力是技术简历里面重要的一环，一般来说简历阅读者会通过这部分内容了解你的技能集（Skill set），从而构成对你的第一技术印象。</p>

<h4><a name="rule14">14. 不要堆砌技术名词</a></h4>

<p>技术简历中一个常见误区是堆砌技术名词，一些求职者认为在简历上写的技术越多越好，于是把自己会的、用过的、见过的甚至没见过的技术都堆在一起，比如：</p>

<p>Technical Skills</p>

<ul>
<li>Programming Language: HTML, CSS, PHP, JavaScript, SQL, Haskell, Perl, Python, C, C++, Java, Ruby, Prolog, .NET, C#, Assembly, REXX, Verilog, R, Visual Basic, MATLAB, jQuery, Angular, SASS</li>
<li>Operating System: Unix/Linux, Mac, MS-DOS, Windows 7/8, Windows Server 2003/2008/2012, z/VM</li>
<li>Software: Adobe Creative Cloud Dreamweaver, Photoshop, InDesign, Audition. WordPress, OmniUpdate, Google Analytics, Eclipse, NetBeans, LaTex, Microsoft Office Suite, Microsoft Excel, Project, Visio, Visual Studio</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>是的，一个人可以同时掌握甚至精通多种编程语言，但一般来说这种可能性很小。当我看到这样的技术描述，我会迅速的跳转到简历的项目经验环节，如果我无法在项目经验里找到对应的技术，我会直接把这个简历筛掉。（我把它叫做“未声明引用”（Undeclared reference）：你说你精通C++，但你却没有C++的项目经验，你确定不是在逗我？）</p>

<p>所以，不要堆砌技术名词，技术简历并非多多益善，熟悉什么技术就写什么技术，然后在项目经验里面给出你熟悉该技术的证据（evidence），这样会使你的简历更有说服力。</p>

<h4><a name="rule15">15. 对技术进行分类</a></h4>

<p>技术能力部分的另一个常见问题是缺乏分类或者分类错误，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Visual Studio, Shell, Python, Eclipse, Java</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/PpAXta9.jpg" alt="分类不清" /></p>

<p>这样的简历也会被直接扔进废纸篓——连编程语言和编程环境都分不清，招你作甚。</p>

<p>正确分类后就清楚了很多：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Java, Python, Shell
</span><span class='line'>开发环境：Visual Studio, Eclipse</span></code></pre></td></tr></table></div></figure>


<h4><a name="rule16">16. 使用正确的技术名称</a></h4>

<p>这个原则非常简单（甚至有点弱智）——正确拼写技术名称，并使用正确的大小写。我在这里摘取了一些我见过的技术名词错误：</p>

<ul>
<li>Andoid &ndash;> Android</li>
<li>IOS, ios &ndash;> iOS</li>
<li>javascript &ndash;> JavaScript</li>
<li>coffescript &ndash;> CoffeeScript</li>
<li>intelij &ndash;> IntelliJ</li>
<li>Dikjstra &ndash;> Dijkstra</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="别字错误" /></p>

<p>请严格检查此类错误——这类错误会大大降低你的简历的专业性，并给人非常不好的印象</p>

<h4><a name="rule17">17. 不要写电脑能力</a></h4>

<p>技术简历需要展现你的技术能力（Technical Skills），而不是电脑能力（Computer Skills），这两个概念比较拗口，所以我在这里举几个例子：</p>

<ul>
<li>技术能力包括：编程（C++/Java/Python），开发环境（Visual Studio/IntelliJ/Eclipse），测试（JUnit/TestNG/mockito/truth），用户体验（Axure/Expression Blend）等等。</li>
<li>电脑能力包括：日常办公（Word/Excel/PowerPoint/Office），图形界面操作系统（Windows 7/8）的使用，浏览器（IE/Chrome/Safari）的使用等等。</li>
</ul>


<p>电脑能力不但会稀释你的简历含金量，还会给人极不专业的感觉。不要在技术简历里面出现任何电脑能力——据说某公司甚至定了一个规矩，<strong>只要在技术简历里面看到Office字样就直接滤掉</strong>（靠谱！）。</p>

<h4><a name="rule18">18. 按照熟悉程度对技术能力进行排序</a></h4>

<p>这个原则十分简单——使用合适的词汇描述你的技术能力，并按照熟悉程度排序，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Java, Python, JavaScript</span></code></pre></td></tr></table></div></figure>


<p>就不如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：熟悉C++、C#和Java，了解Python和JavaScript</span></code></pre></td></tr></table></div></figure>


<p>另一种方式是使用比较符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++ = C# &gt; Java &gt; Python = JavaScript</span></code></pre></td></tr></table></div></figure>


<p>注意：没有必要在技术能力后面加上使用时间，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>技术名称     熟练程度     使用时间
</span><span class='line'>C++           精通         8年
</span><span class='line'>Java          熟悉         5年</span></code></pre></td></tr></table></div></figure>


<p>时间没有意义——搞技术的都明白技术的使用时间和技术的熟练程度没有任何关系（谁知道这货是不是用了1个月C++然后在后面的95个月不断重复第一个月的东西？），只可惜有些HR永远都不懂这个道理，也不肯懂。</p>

<h4><a name="rule19">19. 不要写过于特定的技术</a></h4>

<p>什么叫做过于特定（Specific）的技术呢？举个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>熟悉单例（Singleton）模式</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="捂脸" /></p>

<p>且不说单例是不是一个好模式，单例模式有什么好熟悉的？这种东西也配写到简历上吗？至少在我看来，“熟悉单例模式”就跟“熟悉for循环”、“精通if语句”一般可笑。</p>

<h4><a name="rule20">20. 谨慎使用精通</a></h4>

<p>精通和Proficient是非常Strong的词汇，在简历上写精通类词汇也许会帮你得到面试机会，但你要面对难度更高的面试——招聘者会通过更高难度的问题来确认你真的是精通，而不是在嘴遁。</p>

<p>但如果你真的精通某项技术，那就自信的写上精通，然后用项目经历和面试中的表现说服招聘者，这样往往有助于你拿到Strong Offer。</p>

<h4><a name="rule21">21. 使用项目经验印证技术能力</a></h4>

<p>这条原则在<a href="#rule13">原则13 不要堆砌技术名词</a>也有提到——你的技术能力应该在你的项目经历中得到<strong>全部</strong>体现，技术能力展现你的技能集（Skills Set），而项目经验为其提供证据（Evidence）。打个比方，如果你提到你熟悉C++，那么你就需要在项目经验中提到C++，否则我认为你在说谎或者忘记把C++的项目经验写在简历上，说谎和健忘，两者都不是好事。</p>

<h3><a name="sec4">项目经历</a></h3>

<p>项目经历是简历阅读者进一步了解求职者技术能力的重要依据，良好的项目经历应当清晰，简洁，既印证前面提到的技术能力，也反映出求职者应对复杂度（Handle complexity）的能力。</p>

<h4><a name="rule22">22. 按照时间对项目经历排序</a></h4>

<p>一般来说，项目经历应该按照时间倒序排序——最新的项目经历放在最前。此外，考虑去掉过于久远（比如说，七八年前）的项目经历，因为你很有可能已经忘了七八年前做过的东西了。</p>

<p>另外一种排序方式是按照项目的重要程度排序——最重要的项目放在最前，但我个人不推荐这种方式，因为往往最重要的项目都在最近，如果你最重要的项目在很多年，那么很有可能你这些年毫无长进。</p>

<h4><a name="rule23">23. 不要列出过多的项目</a></h4>

<p>我经常看到非常长的简历：三四页纸，两三千字，十余个项目，恨不得把他/她做过的东西全都铺上去。而事实证明写出这样简历的人水平都不怎么样——至少就我的个人经验而言。</p>

<p>项目经历不是自传，不用把你全部的经历铺上去，也不要写过多的项目经历——三个项目是一个不错的选择，五个就有点多，十个就会没人看。要知道三个优秀的项目远胜十个一般的项目。</p>

<p>所以问题来了，什么是优秀的项目呢？就技术项目而言，我的评估标准是复杂度（Complexity）和影响力（Impact）：一个项目，如果复杂度和影响力都有那是最好，如果只有一个也不错，如果都没有那就呵呵。我会在<a href="#rule25">原则25 强调影响力和复杂度</a>中进一步说明。</p>

<h4><a name="rule24">24. 强调成果而非过程</a></h4>

<p>我在我之前的<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">关于锤子手机和锤子手机发布会</a>提到过：</p>

<blockquote><p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress。</p></blockquote>

<p>技术简历也是如此，不要在项目经历中过度强调你有多努力。“连续高强度工作三个月”和“在深夜重构了XX项目中的代码”并不是一个好的项目描述：如果你“连续高强度工作三个月”却无法说明你的工作成果，“在深夜重构了XX项目中的代码”却无法说明重构后代码改进了多少，那我认为你的“努力”毫无意义。</p>

<p>强调你的项目成果（Achievements）而非过程，“将网站访问量提升300%”、“将响应时间从1.5s减少到0.1s以内”都是不错的成果。</p>

<h4><a name="rule25">25. 使用量化结果而非抽象描述</a></h4>

<p>我经常在简历上看到“改善了代码的质量”、“提升了启动速度”和“大大增加了网站访问量”之类的描述，我的第一反应就是：</p>

<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p><strong>用个数字你会死啊！！！看新闻联播看多了吧亲！！！！</strong></p>

<p>接下来的反应是：</p>

<ul>
<li>“改善了代码的质量”——改善了多少？你是如何评估的？圈复杂度？测试覆盖度？Bug的数量？ ？？？</li>
<li>“提升了启动速度”——提升了多少？用户的反馈如何？是否在可接受的范围内？ ？？？</li>
<li>“大大增加了网站访问量”——“大大”是什么？访问量增加了多少？访问量原来是多少？ ？？？</li>
</ul>


<p>如果我找不到上面问题的答案，我会直接无视这些抽象描述——还是那句话，我为什么要相信你的一面之词？而且你连话都说不清。</p>

<h4><a name="rule26">26. 强调影响力和复杂度</a></h4>

<blockquote><p>&ldquo;Controlling complexity is the essence of computer programming.&rdquo;</p>

<p>Brian Kernighan</p></blockquote>

<p>控制复杂度使程序设计的根本（essense），所以绝大多数IT公司在招聘时都会把应对复杂度（Handle complexity）放在职位描述里面——你如果能把难题搞定，那么简单题也不在话下。如果你做过的项目足够复杂，那么就证明你能扛得住复杂度，是个好<del>备胎</del>备选（Candidate）。</p>

<p>那么什么样的项目经历称得上复杂呢？我在这里给出一个不严谨的分类，仅供参考：</p>

<ul>
<li>编程复杂度：操作系统，编译器/解释器，图形学编程，网络协议设计与实现等</li>
<li>算法复杂度：算法竞赛奖项等（不好意思我不熟悉算法所以给不出啥例子 &ndash;_-）</li>
<li>设计复杂度：大型网站，企业级应用，分布式应用等</li>
</ul>


<p>衡量项目的另一个重要依据是影响力（Impact），有的软件项目可能不那么复杂，但是它具有相当大的影响力，例如jQuery、RoR和JUnit：</p>

<blockquote><p>&ldquo;Never in the field of software development have so many owed so much to so few lines of code (JUnit).&rdquo;</p>

<p>Martin Fowler</p></blockquote>

<p>如果你的项目并不复杂，那么请强调它的影响力，用户量超过十万的手机应用和被广泛应用的类库都是很好的项目，尽管它们可能并不复杂。</p>

<p>如果一个项目既没有复杂度，也没有影响力，那么直接删掉它——不要犹豫，它不会为你的简历提供任何价值。</p>

<h3><a name="sec5">教育背景</a></h3>

<p>教育背景是简历的另一项重要内容，它对于应届生尤其重要——因为应届生往往没有太多的工作经历。</p>

<h4><a name="rule27">27. 不要写大学之前的教育经历</a></h4>

<p>我不明白为什么很多人把高中甚至初中都写在简历里——也许你的高中/初中很出色，不过那么多年前的事情就不用再提了吧 &ndash;_&ndash;||</p>

<h4><a name="rule28">28. 不要写课程列表</a></h4>

<p>我在简历的教育背景部分发现的另一个奇怪的现象是课程列表（Courseworks）：求职者把大学专业课程一水排开，放在简历里面，颇是壮观：</p>

<p>专业课程：</p>

<ul>
<li>计算机科学导论，C语言及程序设计，计算机组成原理，数据结构，算法设计，离散数学，操作系统原理，编译原理，计算机网络，数据库系统原理，面向对象编程，软件工程，图像处理技术，人工智能及其应用，网络工程</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>更加令人啼笑皆非的是把<strong>所有</strong>的大学课程放在一起：</p>

<p>大学课程：</p>

<ul>
<li>高等数学，线性代数，大学物理，概率与数理统计，毛泽东思想概论，思想道德修养，邓小平理论，马列政治经济学原理……</li>
</ul>


<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p>每当看到这样的简历我都在想我是该筛掉你呢还是筛掉你呢还是筛掉你呢？</p>

<p><strong>不要写课程列表</strong>，除非你有想特别强调的特殊专业课，而且你在该课上有突出表现（比如“编译原理（实现了带下标检查的扩展C编译器）”就不错）。</p>

<h4><a name="rule29">29. 考虑使用成绩或排名</a></h4>

<p>如果你的大学成绩或排名还不错，那么请把它放在教育背景中，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2009 ~ 2013    学士    大连理工大学    软件工程    GPA: 3.8/4.0，排名：3/153</span></code></pre></td></tr></table></div></figure>


<p>就不错。</p>

<p>但如果你的成绩一般（80%一下）或排名一般（前20%开外），那么就不要提它们（我就是这么做的，-_&ndash;#）</p>

<h4><a name="rule30">30. 考虑使用导师（老师）的评语</a></h4>

<p>这条原则和<a href="#rule12">原则12. 考虑提供他人的评价</a>相类似，与其说你在学校多么努力，不如让你的专业课老师（导师）给你一个评价。</p>

<p>注意：不要使用辅导员的评价，是的，辅导员在大学很重要，但辅导员对学生的评价往往没有<strong>专业</strong>参考价值。</p>

<h4><a name="rule31">31. 考虑使用学业相关的奖项</a></h4>

<p>请把在校期间的<strong>重要奖项</strong>放在教育背景中，比如“一等奖学金”，“数学建模大赛一等奖”就不错。</p>

<p>我在阅读简历时见到过很多学霸——学校里面获得的奖项接近一页纸之多。这是个好事，不过放太多奖无益于突出重点，所以请参考<a href="#rule23">原则 23. 不要列出过多的项目</a>：精选3到5个最有说服力的奖项，然后把它们放在教育背景中。</p>

<h3><a name="sec6">个人爱好</a></h3>

<p>个人爱好对技术简历往往毫无价值，所以这里的原则只有一条——</p>

<h4><a name="rule32">32. 避免写个人爱好</a></h4>

<p>除非你在个人爱好上取得了相当的成就，否则不要写个人爱好。每个人都喜欢音乐，都喜欢看书，也都喜欢技术，这种<del>屁话</del>套话还是留到入职邮件再说也不迟。</p>

<h3><a name="sec7">英文简历</a></h3>

<p>海外求职需要英文简历，而英文简历需要专业的英语——阅读你简历的人很有可能只懂英文，如果你的英文太糟糕那么他/她很可能会无视你的技术而直接把你筛掉。</p>

<h4><a name="rule33">33. 不要出现拼写错误</a></h4>

<p>请打开拼写检查——要知道简历里面的拼写错误是致命的。我在这里给出一些常见的拼写错误：</p>

<ul>
<li>explaination &ndash;> explanation</li>
<li>convenence &ndash;> convenience</li>
<li>seperate &ndash;> separate</li>
<li>Febuary &ndash;> February</li>
<li>embarass &ndash;> embarrass</li>
<li>consience &ndash;> conscience</li>
<li>mispell &ndash;> misspell</li>
<li>enginner &ndash;> engineer</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="金馆长" /></p>

<p>更多的拼写错误请参考<a href="http://grammar.yourdictionary.com/spelling-and-word-lists/misspelled.html">这里</a>。</p>

<h4><a name="rule34">34. 不要使用全角字符</a></h4>

<p>务必不要在英文简历中使用全角字符：</p>

<ol>
<li>全角字符会影响英文排版，使其变的很难看</li>
<li>对方的机器上可能没有对应的字库，因而无法显示全角字符</li>
</ol>


<p>我个人推荐在英文简历中只使用ASCII字符集里的字符。</p>

<h4><a name="rule35">35. 使用正确的词汇</a></h4>

<p><img src="http://i.imgur.com/SJF8N2m.jpg" alt="神翻译" /></p>

<p>国人英文简历的一大通病是用词不当，下面是我阅读英文技术简历时所发现的最常见的三个错误：</p>

<ol>
<li>“<strong>实现</strong>了xx功能”：使用<strong>Implement</strong>，而不是<strong>Achieve</strong></li>
<li>“软件工程师”：使用<strong>Software Developer</strong>或<strong>Software Engineer</strong>，而不是<strong>Software Programmer</strong></li>
<li>“我对xxx<strong>感兴趣</strong>”：使用<strong>I am interested in &hellip;</strong>，而不是<strong>I am interesting in</strong>，详见<a href="http://www.learnersdictionary.com/qa/what-is-the-difference-between-interested-and-interesting">这里</a></li>
</ol>


<p>用词不当会影响简历阅读者的理解，为其带来相当负面的印象。为了减少这类错误，你应该去阅读更多的专业英文著作，或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule36">36. 使用简洁的句子</a></h4>

<p>受中式思维的影响，我们的英文往往很冗余（Verbose），我举两个简单的例子</p>

<ul>
<li>“during the development period”应该是“during the development”：因为“development”本身已经包含“过程（period）”的意思。</li>
<li>“implemented xxx successfully”应当是“implemented xxx”：既然使用了过去式，那么你已经把它实现（implement）了，那自然就是“成功”实现。如果想要强调“成功”，那么可以用“accomplished xxx”。</li>
</ul>


<p>这里水一句：一般来说中国人对这种英语完全不敏感，反而很亲切（因为更接近中式思维），那为什么我对这种英语特别在意呢？因为我有几个伦敦同事特别在意英语的纯正性，初到伦敦时，无论是吃饭、聊天还是提交代码，他们都会无时无刻的纠正我的语法错误和发音错误（我想我已经被他们纠正几千多次了-_&ndash;#），所以我现在对此类中式英语异常敏感。</p>

<p>此外在简历里面我们有时可以忽略主语（Subject），例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Project A:
</span><span class='line'>    I implemented the communication module.
</span><span class='line'>    I wrote tests for the communication module.
</span><span class='line'>    I deployed the module into our system.</span></code></pre></td></tr></table></div></figure>


<p>可以这么写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Project A:
</span><span class='line'>    Implemented the communication module.
</span><span class='line'>    Wrote tests for the communication module.
</span><span class='line'>    Deployed the module into our system.</span></code></pre></td></tr></table></div></figure>


<p>这样不但更加简洁，而且用动词开头会让句子显得更加有力，给人以自信的感觉。</p>

<p>为了使简历中的英文句子更加简洁，你应该去阅读更多的英文写作书籍（例如<a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>和<a href="http://www.amazon.com/Writing-Well-30th-Anniversary-Edition/dp/0060891548/">On writing well</a>），或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule37">37. 避免中式英语</a></h4>

<p>这个原则实际上是<a href="#rule35">原则35. 使用正确的词汇</a>和<a href="#rule36">原则36. 使用简洁的句子</a>的扩展，因为这两个原则都属于中式英语的范畴。</p>

<p>中式英语的源头在于用中式思维将中文逐字转化成英语，尽管我们不会搞出这样的错误：</p>

<p><img src="http://i.imgur.com/PfkAXV7.jpg" alt="神翻译" /></p>

<p>但是小错是难免的，我已经不止三次的听到有人使用&#8221;red color&#8221;这个神奇的短语了。（red本身就是颜色，所以完全不需要后面的color）如果你打算根除中式英语，你有两种途径：</p>

<ol>
<li>找几个腹黑伦敦同事。-_&ndash;#</li>
<li>阅读<a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a></li>
</ol>


<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p>这是我读过最好的（貌似也是唯一的）讲中式英语的书籍。</p>

<p>当然，如果你只是把简历改的不那么中式，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule38">38. 使用一致的时态</a></h4>

<p>这个原则很简单——使用一致的时态：</p>

<ul>
<li>对于个人评价：使用现代式。</li>
<li>对于项目经历：使用过去式。</li>
</ul>


<p>之所以把这么简单的原则提出来，是因为我都过的英文简历几乎都违反了这个原则——它们或者在个人评价里“I was a passionate programmer”（嗯，你过去很激情那么现在呢？），或者在项目经历里“Implement xxx”（一直实现到现在不容易啊童鞋！）。</p>

<h4><a name="rule39">39. 考虑提供缩写词的解释</a></h4>

<p>不是所有人都了解你的工作或研究，所以对于<strong>不常用</strong>和<strong>有歧义</strong>的首字母缩写词（Acronym），请提供全称。</p>

<p>注意我说的是<strong>不常用</strong>和<strong>有歧义</strong>的缩写词，你无需告诉简历阅读者HTML的全称是HyperText Markup Language，也无需说明MVC是Model View Controller，但你可能需要说明AST是Abstract Syntax Tree，DSL是Domain Specific Language（而不是Digital Subscriber Line）。</p>

<h4><a name="rule40">40. 使用Bullets组织长段</a></h4>

<p>如果一段项目过长，请使用Bullets而不是“Firstly&hellip;, secondly&hellip;, finally&hellip;”，例如：</p>

<p>Firstly, I collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java. Secondly, I developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos. Finally, I improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</p>

<p>即便是一个English native speaker，看到这样的大长段也会发怵，这里可以利用Bullets改善可读性：</p>

<ol>
<li>Collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java.</li>
<li>Developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos.</li>
<li>Improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</li>
</ol>


<h4><a name="rule41">41. 打下良好的英文基础</a></h4>

<p>归根到底，写好英文简历需要良好的英文基础，所以我在这里推荐几本不错的英语基础书籍：</p>

<p><img src="http://img3.douban.com/lpic/s1446975.jpg" alt="Practical English Usage" /></p>

<p><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a>：简洁，精炼，学习英文语法和口语的必备书籍。</p>

<p><img src="http://img5.douban.com/lpic/s11442466.jpg" alt="Collins Pocket English Thesaurus" /></p>

<p><a href="http://www.amazon.com/Collins-Pocket-English-Thesaurus-Dictionaries/dp/0007450567/">Collins Pocket English Thesaurus</a>：个人无责任推荐——每天看一点，这本书不会提升你的词汇量（Total Vocabulary），但会提升你的有效词汇量（Effective Vocabulary）。</p>

<p><img src="http://img5.douban.com/lpic/s4228916.jpg" alt="Elements of Style" /></p>

<p><a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>：英语写作第一书。无论是写作，还是编程，都能从本书受益良多。</p>

<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a>：可能是目前唯一一本讲述中式英语的书籍，尽管书中的例子有点政治化，但不妨碍本书是一本好书。</p>

<p>这篇文章的主题并非英语学习，如果你对英语学习有兴趣可以去Google和<del>逼乎</del>知乎搜索更相关的答案。</p>

<p>当然，如果你只是想得到一个不错的英文简历，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h3><a name="sec8">其它</a></h3>

<p>剩下的是一些通用原则。</p>

<h4><a name="rule42">42. 考虑使用超链接</a></h4>

<p>这项原则是<em>原则8. 使用可以点击的链接</em>的扩充——超链接适用于简历全文，而不只适用于个人信息里的个人主页和邮箱地址：</p>

<ul>
<li>如果你的作品/项目有介绍链接，请提供它</li>
<li>如果你的作品/项目有在线演示，请提供它</li>
<li>如果你的作品/项目有用户反馈，请提供它</li>
</ul>


<p>使用超链接时要注意一点：使用隐式超链接而非显式超链接，例如使用<a href="http://www.google.com">Google</a>而非<a href="http://www.google.com">http://www.google.com</a>。因为显式超链接往往很长而且不可读，还会破坏打印版简历的效果。</p>

<h4><a name="rule43">43. 考虑提供一个“加强版”简历</a></h4>

<p>这项原则是<a href="#rule42">原则42. 考虑使用超链接</a>的补充，简历受限于篇幅（一般是一页）和格式（一般是PDF），无法提供更多丰富多彩的内容。但你可以用超链接关联一个外部“加强版”简历。</p>

<p>一个典型例子是<a href="http://iconmoon.com/about/">JJ Ying</a>的在线“简历”（使用Parallax效果），这种“加强版”简历往往会使简历阅读者眼前一亮，从而大大增加你的简历通过率。</p>

<h4><a name="rule44">44. 考虑提供开发社区账号</a></h4>

<p>如果你有非常活跃的开发社区（例如<a href="http://stackoverflow.com/">Stack Overflow</a>，<a href="https://github.com/">GitHub</a>和<a href="http://www.reddit.com/r/programming/">Reddit Programming</a>等开发社区）账号，那么请在简历中提供它们。</p>

<p>注意我说的开发社区账号，而不是社交网络账号：提供<a href="http://www.renren.com/">人人</a>、<a href="http://www.weibo.com/">微博</a>或<a href="https://www.facebook.com/">Facebook</a>账号不会对简历有任何帮助。</p>

<h4><a name="rule45">45. 持续更新简历</a></h4>

<p>优秀的简历应该是<del>与时俱进</del>持续更新的。从现在开始，定一个周期（一个月或三个月），然后以这个周期持续更新简历，这样你可以：</p>

<ol>
<li>随时拥有最新的简历，而不是在求职时挖空心思编写</li>
<li>形成一个成长记录，以便自我改善</li>
<li>时刻提醒自己持续学习，如果你发现这个周期的简历同上个周期变化不大，你就要好好反思下了</li>
</ol>


<p>以我自己为例，我维护着一个Markdown简历，每两个月一更新，通过更新记录/当前简历/下一步计划，我可以更有效的指导我的学习和工作。</p>

<h4><a name="rule46">46. 不断提升个人能力</a></h4>

<blockquote><p>“没有声音，再好的戏也出不来”
某广告语</p></blockquote>

<p>简历原则有助于展示（Demostrate）实力，而不是放大（Amplify）实力——打个比方，你的实力有100分，低劣的简历会让你看起来只有50分，而良好的简历则会展现出你100分，但不要指望简历会把你变成200分——我承认有些人可以通过说谎/造假/吹牛达到这个效果，但我不推荐这种透支信用的做法。</p>

<p>所以，优秀简历的根本是强大的实力，多学习，多做有影响力/复杂度（参考<a href="#rule26">原则26. 强调影响力和复杂度</a>）的项目，而不是在马上找工作的时候挖空心思编项目堆技能。没有声音，再好的戏也出不来。</p>

<h4><a name="rule47">47. 考虑征求他人意见</a></h4>

<blockquote><p>“当局者迷，旁观者清”</p></blockquote>

<p>在投递简历前，最好去征求他人意见——外人往往可以看出你简历的不足，指出低级错误，给出不错的建议。</p>

<p>当然你也可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h2>总结</h2>

<p>在这里我把精益技术简历的47条原则整理在一起，以便阅读整理：</p>

<h3><a href="#sec1">版式</a></h3>

<ol>
<li><a href="#rule1">原则1：使用对齐</a></li>
<li><a href="#rule2">原则2：不必使用居中</a></li>
<li><a href="#rule3">原则3：谨慎使用<strong>粗体</strong></a></li>
<li><a href="#rule4">原则4：避免不必要的折行</a></li>
<li><a href="#rule5">原则5：使用制表符辅助对齐</a></li>
</ol>


<h3><a href="#sec2">个人信息</a></h3>

<ol>
<li><a href="#rule6">原则6：不要使用不必要的条目名称</a></li>
<li><a href="#rule7">原则7：使用分隔符增强电话号码的可读性</a></li>
<li><a href="#rule8">原则8：使用可以点击的链接</a></li>
<li><a href="#rule9">原则9：不要使用照片</a></li>
<li><a href="#rule10">原则10：不要写无关个人信息</a></li>
<li><a href="#rule11">原则11：使用客观事实而非主观描述</a></li>
<li><a href="#rule12">原则12：考虑提供他人的评价</a></li>
<li><a href="#rule13">原则13：不必写求职目标</a></li>
</ol>


<h3><a href="#sec3">技术能力</a></h3>

<ol>
<li><a href="#rule14">原则14：不要堆砌技术名词</a></li>
<li><a href="#rule15">原则15：对技术进行分类</a></li>
<li><a href="#rule16">原则16：使用正确的技术名称</a></li>
<li><a href="#rule17">原则17：不要写电脑能力</a></li>
<li><a href="#rule18">原则18：按照熟悉程度对技术能力进行排序</a></li>
<li><a href="#rule19">原则19：不要写过于特定的技术</a></li>
<li><a href="#rule20">原则20：谨慎使用精通</a></li>
<li><a href="#rule21">原则21：使用项目经验印证技术能力</a></li>
</ol>


<h3><a href="#sec4">项目经历</a></h3>

<ol>
<li><a href="#rule22">原则22：按照时间对项目经历排序</a></li>
<li><a href="#rule23">原则23：不要列出过多的项目</a></li>
<li><a href="#rule24">原则24：强调成果而非过程</a></li>
<li><a href="#rule25">原则25：使用量化结果而非抽象描述</a></li>
<li><a href="#rule26">原则26：强调影响力和复杂度</a></li>
</ol>


<h3><a href="#sec5">教育背景</a></h3>

<ol>
<li><a href="#rule27">原则27：不要写大学之前的教育经历</a></li>
<li><a href="#rule28">原则28：不要写课程列表</a></li>
<li><a href="#rule29">原则29：考虑使用成绩或排名</a></li>
<li><a href="#rule30">原则30：考虑使用导师（老师）的评语</a></li>
<li><a href="#rule31">原则31：考虑使用学业相关的奖项</a></li>
</ol>


<h3><a href="#sec6">个人爱好</a></h3>

<ol>
<li><a href="#rule32">原则32：避免写个人爱好</a></li>
</ol>


<h3><a href="#sec7">英文简历</a></h3>

<ol>
<li><a href="#rule33">原则33：不要出现拼写错误</a></li>
<li><a href="#rule34">原则34：不要使用全角字符</a></li>
<li><a href="#rule35">原则35：使用正确的词汇</a></li>
<li><a href="#rule36">原则36：使用简洁的句子</a></li>
<li><a href="#rule37">原则37：避免中式英语</a></li>
<li><a href="#rule38">原则38：使用一致的时态</a></li>
<li><a href="#rule39">原则39：考虑提供缩写词的解释</a></li>
<li><a href="#rule40">原则40：使用Bullets组织长段</a></li>
<li><a href="#rule41">原则41：打下良好的英文基础</a></li>
</ol>


<h3><a href="#sec8">其它</a></h3>

<ol>
<li><a href="#rule42">原则42：考虑使用超链接</a></li>
<li><a href="#rule43">原则43：考虑提供一个“加强版”简历</a></li>
<li><a href="#rule44">原则44：考虑提供开发社区账号</a></li>
<li><a href="#rule45">原则45：持续更新简历</a></li>
<li><a href="#rule46">原则46：不断提升个人能力</a></li>
<li><a href="#rule47">原则47：考虑征求他人意见</a></li>
</ol>


<h2>参考</h2>

<p>书籍：</p>

<ol>
<li><a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X/">Cracking the Coding Interview: 150 Programming Questions and Solutions</a></li>
<li><a href="http://www.amazon.com/The-Google-Resume-Prepare-Microsoft/dp/0470927623/">The Google Resume: How to Prepare for a Career and Land a Job at Apple, Microsoft, Google, or any Top Tech Company</a></li>
<li><a href="http://www.amazon.com/Land-Tech-Love-Pragmatic-Life/dp/1934356263/">Land the Tech Job You Love</a></li>
<li><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a></li>
<li><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a></li>
</ol>


<p>链接：</p>

<ol>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></li>
<li><a href="http://www.weibo.com/p/1001603769729557894059">英文简历咨询服务</a>：再次谢谢关注者的简历！</li>
</ol>


<hr />

<p>以上。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/"/>
    <updated>2014-10-23T23:54:02-07:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li>深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<h2>关于</h2>

<p>本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>一文的翻译，那么问题来了：</p>

<h3>为什么要写（翻译）这个系列？</h3>

<!-- more -->


<ol>
<li>工作之后，我开始大量使用Java</li>
<li>公司将会在不久的未来使用Java 8</li>
<li>作为资质平庸的开发者，我需要打一点提前量，以免到时拙计</li>
<li>为了学习Java 8（主要是其中的lambda及相关库），我先后阅读了Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>，<a href="http://www.amazon.com/Cay-S.-Horstmann/e/B000AQ1QDY/">Cay Horstmann</a>（<a href="http://www.amazon.com/Core-Volume-I--Fundamentals-Edition-Series/dp/0137081898/">Core Java</a>的作者）的<a href="http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/">Java 8 for the Really Impatient</a>和Richard Warburton的<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a></li>
<li>但我感到并没有多大收获，Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>涉及了lambda表达式的每一个概念，但都是点到辄止；后两本书（尤其是<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>）花了大量篇幅介绍Java lambda及其类库，但实质内容不多，读完了还是没有对Java lambda产生一个清晰的认识</li>
<li>关键在于这些文章和书都没有解决我对Java lambda的困惑，比如：

<ul>
<li>Java 8中的lambda为什么要设计成这样？（为什么要一个lambda对应一个接口？而不是Structural Typing？）</li>
<li>lambda和匿名类型的关系是什么？lambda是匿名对象的语法糖吗？</li>
<li>Java 8是如何对lambda进行类型推导的？它的类型推导做到了什么程度？</li>
<li>Java 8为什么要引入默认方法？</li>
<li>Java编译器如何处理lambda？</li>
<li>等等……</li>
</ul>
</li>
<li>之后我在Google搜索这些问题，然后就找到<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的三篇关于Java lambda的文章（<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>，<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of Lambda libraries version</a>和<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">Translation of lambda</a>），读完之后上面的问题都得到了解决</li>
<li>为了加深理解，我决定翻译这一系列文章</li>
</ol>


<h3>警告（Caveats）</h3>

<p>如果你不知道什么是函数式编程，或者不了解<code>map</code>，<code>filter</code>，<code>reduce</code>这些常用的高阶函数，那么你不适合阅读本文，请先学习函数式编程基础（比如<a href="http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/">这本书</a>）。</p>

<hr />

<h1><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a> by <a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a></h1>

<blockquote><p>The high-level goal of Project Lambda is to enable programming patterns that require modeling code as data to be convenient and idiomatic in Java.</p></blockquote>

<h2>关于</h2>

<p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>

<ul>
<li>lambda表达式（又被成为“闭包”或“匿名方法”）</li>
<li>方法引用和构造方法引用</li>
<li>扩展的目标类型和类型推导</li>
<li>接口中的默认方法和静态方法</li>
</ul>


<h2>1. 背景</h2>

<p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>

<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ActionListener</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里并不需要专门定义一个类来实现<code>ActionListener</code>接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ActionListener</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>

<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的<a href="http://blogs.oracle.com/jrose/entry/better_closures">选择</a>，因为：</p>

<ol>
<li>语法过于冗余</li>
<li>匿名类中的<code>this</code>和变量名容易使人产生误解</li>
<li>类型载入和实例创建语义不够灵活</li>
<li>无法捕获非<code>final</code>的局部变量</li>
<li>无法对控制流进行抽象</li>
</ol>


<p>上面的多数问题均在Java SE 8中得以解决：</p>

<ul>
<li>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2</li>
<li>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3</li>
<li>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰</li>
</ul>


<p>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>

<h2>2. 函数式接口（Functional interfaces）</h2>

<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>

<ul>
<li>接口是Java类型系统的一部分</li>
<li>接口天然就拥有其运行时表示（Runtime representation）</li>
<li>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）</li>
</ul>


<p>上面提到的<code>ActionListener</code>接口只有一个方法，大多数回调接口都拥有这个特征：比如<code>Runnable</code>接口和<code>Comparator</code>接口。我们把这些只拥有一个方法的接口称为<em>函数式接口</em>。（之前它们被称为<em>SAM类型</em>，即<em>单抽象方法类型</em>（Single Abstract Method））</p>

<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个<code>Object</code>已经提供的方法，比如<code>toString()</code>，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过<code>@FunctionalInterface</code>注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>

<p>实现函数式类型的另一种方式是引入一个全新的<em>结构化</em>函数类型，我们也称其为“箭头”类型。例如，一个接收<code>String</code>和<code>Object</code>并返回<code>int</code>的函数类型可以被表示为<code>(String, Object) -&gt; int</code>。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>

<ul>
<li>它会为Java类型系统引入额外的复杂度，并带来<a href="http://en.wikipedia.org/wiki/Structural_type_system">结构类型（Structural Type）</a>和<a href="http://en.wikipedia.org/wiki/Nominal_type_system">指名类型（Nominal Type）</a>的混用。（Java几乎全部使用指名类型）</li>
<li>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型</li>
<li>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后</li>
<li>每个函数类型很难拥有其运行时表示，这意味着开发者会受到<a href="http://en.wikipedia.org/wiki/Type_erasure">类型擦除（erasure）</a>的困扰和局限。比如说，我们无法对方法<code>m(T-&gt;U)</code>和<code>m(X-&gt;Y)</code>进行重载（Overload）</li>
</ul>


<p>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：</p>

<ul>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html">java.security.PrivilegedAction</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html">java.util.Comparator</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html">java.io.FileFilter</a></li>
<li><a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html">java.beans.PropertyChangeListener</a></li>
</ul>


<p>除此之外，Java SE 8中增加了一个新的包：<code>java.util.function</code>，它里面包含了常用的函数式接口，例如：</p>

<ul>
<li><code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code></li>
<li><code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象，不返回值</li>
<li><code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象，返回<code>R</code>对象</li>
<li><code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂），不接收值</li>
<li><code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象，返回<code>T</code>对象</li>
<li><code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象，返回<code>T</code>对象</li>
</ul>


<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>。（我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如<code>BiFunction&lt;T, U, R&gt;</code>，它接收<code>T</code>对象和<code>U</code>对象，返回<code>R</code>对象。</p>

<h2>3. lambda表达式（lambda expressions）</h2>

<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作。</p>

<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>

<p>下面是一些lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'><span class="o">()</span> <span class="o">-&gt;</span> <span class="mi">42</span>
</span><span class='line'><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个lambda表达式接收<code>x</code>和<code>y</code>这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数&#8217;42&#8217;；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>

<p>lambda表达式的语法由参数列表、箭头符号<code>-&gt;</code>和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——

<ul>
<li><code>return</code>语句会把控制权交给匿名方法的调用者</li>
<li><code>break</code>和<code>continue</code>只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li>
</ul>
</li>
</ul>


<p>表达式函数体适合小型lambda表达式，它消除了<code>return</code>关键字，使得语法更加简洁。</p>

<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<p>下面是一些出现在语句中的lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">FileFilter</span> <span class="n">java</span> <span class="o">=</span> <span class="o">(</span><span class="n">File</span> <span class="n">f</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;*.java&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">String</span> <span class="n">user</span> <span class="o">=</span> <span class="n">doPrivileged</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;user.name&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">connectToService</span><span class="o">();</span>
</span><span class='line'>  <span class="n">sendNotification</span><span class="o">();</span>
</span><span class='line'><span class="o">}).</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 目标类型（Target typing）</h2>

<p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是<code>ActionListener</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ActionListener</span> <span class="n">l</span> <span class="o">=</span> <span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">&quot;done&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">&quot;done&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个lambda表达式<code>() -&gt; "done"</code>是<code>Callable</code>的实例，而第二个lambda表达式则是<code>PrivilegedAction</code>的实例。</p>

<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导，这个<strong>被期待的类型</strong>被称为<em>目标类型</em>。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>

<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型<code>T</code>：</p>

<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li>
<li>lambda表达式的返回值和<code>T</code>的方法返回值相兼容（Compatible）</li>
<li>lambda表达式内所抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li>
</ul>


<p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareToIgnoreCase</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子里，编译器可以推导出<code>s1</code>和<code>s2</code>的类型是<code>String</code>。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">FileFilter</span> <span class="n">java</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.java&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>

<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">li</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. 目标类型的上下文（Contexts for target typing）</h2>

<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>

<ul>
<li>变量声明</li>
<li>赋值</li>
<li>返回语句</li>
<li>数组初始化器</li>
<li>方法和构造方法的参数</li>
<li>lambda表达式函数体</li>
<li>条件表达式（<code>? :</code>）</li>
<li>转型（Cast）表达式</li>
</ul>


<p>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareToIgnoreCase</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="n">Runnable</span> <span class="nf">toDoLater</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;later&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">filterFiles</span><span class="o">(</span><span class="k">new</span> <span class="n">FileFilter</span><span class="o">[]</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">(),</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">canRead</span><span class="o">(),</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;q&quot;</span><span class="o">)</span>
</span><span class='line'>            <span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>

<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有<strong>显式类型</strong>（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有<strong>隐式类型</strong>（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>

<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，<code>ps</code>的类型是<code>List&lt;Person&gt;</code>，所以<code>ps.stream()</code>的返回类型是<code>Stream&lt;Person&gt;</code>。<code>map()</code>方法接收一个类型为<code>Function&lt;T, R&gt;</code>的函数式接口，这里<code>T</code>的类型即是<code>Stream</code>元素的类型，也就是<code>Person</code>，而<code>R</code>的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导<code>R</code>的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回<code>String</code>，因此<code>R</code>的类型是<code>String</code>，因而<code>map()</code>返回<code>Stream&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>

<ul>
<li>使用显式lambda表达式（为参数<code>p</code>提供显式类型）以提供额外的类型信息</li>
<li>把lambda表达式转型为<code>Function&lt;Person, String&gt;</code></li>
<li>为泛型参数<code>R</code>提供一个实际类型。（<code>.&lt;String&gt;map(p -&gt; p.getName())</code>）</li>
</ul>


<p>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">);</span> <span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">?</span> <span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">23</span><span class="o">)</span> <span class="o">:</span> <span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">42</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// Object o = () -&gt; { System.out.println(&quot;hi&quot;); }; 这段代码是非法的</span>
</span><span class='line'><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="o">(</span><span class="n">Runnable</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">);</span> <span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>

<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">checkedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">si</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">?</span> <span class="n">Collections</span><span class="o">.</span><span class="na">singleton</span><span class="o">(</span><span class="mi">23</span><span class="o">)</span> <span class="o">:</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptySet</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6. 词法作用域（Lexical scoping）</h2>

<p>在内部类中使用变量名（以及<code>this</code>）非常容易出错。内部类中通过继承得到的成员（包括来自<code>Object</code>的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的<code>this</code>引用会指向内部类自己而非外部类。</p>

<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，&#8217;this&#8217;关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>

<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把<code>"Hello, world!"</code>打印两遍：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'>  <span class="n">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">toString</span><span class="o">());</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>  <span class="k">return</span> <span class="s">&quot;Hello, world&quot;</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">Hello</span><span class="o">().</span><span class="na">r1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">Hello</span><span class="o">().</span><span class="na">r2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与之相类似的内部类实现则会打印出类似<code>Hello$1@5b89a773</code>和<code>Hello$2@537a7706</code>之类的字符串，这往往会使开发者大吃一惊。</p>

<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如<code>for</code>循环和<code>catch</code>从句）一致。</p>

<p><strong>个人补充</strong>：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//这里会出现编译错误，因为i已经在for循环外部声明过了</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>7. 变量捕获（Variable capture）</h2>

<p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合<em>有效只读</em>（Effectively final）的局部变量。</p>

<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上<code>final</code>后也不会导致编译错误的局部变量就是有效只读变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">helloCallable</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">hello</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段的引用和未限定方法的调用在本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其它情况下，lambda对象不会保留任何对<code>this</code>的引用。</p>

<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>

<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对<em>值</em>封闭，对<em>变量</em>开放。</p>

<p><strong>个人补充</strong>：lambda表达式对<em>值</em>封闭，对<em>变量</em>开放的原文是：lambda expressions close over <em>values</em>, not <em>variables</em>，我在这里增加一个例子以说明这个特性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">});</span> <span class="c1">// Illegal, close over values</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">aList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">aList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="o">});</span> <span class="c1">// Legal, open over variables</span>
</span></code></pre></td></tr></table></div></figure>


<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。<code>java.util.stream</code>包提供了各种通用的和专用的规约操作（例如<code>sum</code>、<code>min</code>和<code>max</code>），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替<code>forEach</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>              <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>              <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sum()</code>等价于下面的规约操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>              <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>              <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span> <span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="mi">0</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>

<h2>8. 方法引用（Method references）</h2>

<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在<em>已有的</em>方法上实现同样的特性。</p>

<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>

<p>以下面的代码为例，假设我们要按照<code>name</code>或<code>age</code>为<code>Person</code>数组进行排序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Person</span><span class="o">[]</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">byName</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'><span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">byName</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里我们可以用方法引用代替lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">byName</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>Person::getName</code>可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>

<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">b1</span> <span class="o">=</span> <span class="nl">System:</span><span class="o">:</span><span class="n">exit</span><span class="o">;</span>    <span class="c1">// void exit(int status)</span>
</span><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">[]&gt;</span> <span class="n">b2</span> <span class="o">=</span> <span class="nl">Arrays:</span><span class="n">sort</span><span class="o">;</span>    <span class="c1">// void sort(Object[] a)</span>
</span><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">b3</span> <span class="o">=</span> <span class="nl">MyProgram:</span><span class="o">:</span><span class="n">main</span><span class="o">;</span>  <span class="c1">// void main(String... args)</span>
</span><span class='line'><span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="nl">Myprogram:</span><span class="o">:</span><span class="n">mapToInt</span>        <span class="c1">// void main(String... args)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>9. 方法引用的种类（Kinds of method references）</h2>

<p>方法引用有很多种，它们的语法如下：</p>

<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>


<p>对于静态方法引用，我们需要在类名和方法名之间加入<code>::</code>分隔符，例如<code>Integer::sum</code>。</p>

<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">knownNames</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">isKnown</span> <span class="o">=</span> <span class="nl">knownNames:</span><span class="o">:</span><span class="n">contains</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的隐式lambda表达式（也就是实例方法引用）会从<code>knownNames</code>中捕获<code>String</code>对象，而它的方法体则会通过<code>Set.contains</code>使用该<code>String</code>对象。</p>

<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Privileged</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nl">c:</span><span class="o">:</span><span class="n">call</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">upperfier</span> <span class="o">=</span> <span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的隐式lambda表达式（即<code>String::toUpperCase</code>实例方法引用）有一个<code>String</code>参数，这个参数会被<code>toUpperCase</code>方法使用。</p>

<p>如果类型的实例方法是泛型的，那么我们就需要在<code>::</code>分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>

<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>

<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在<code>::</code>分隔符之前提供参数类型信息。</p>

<p>和静态方法引用类似，构造方法也可以通过<code>new</code>关键字被直接引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">SocketImplFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nl">MySocketImpl:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>

<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照&#8221;菱形&#8221;构造方法调用时的方式进行推导。</p>

<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收<code>int</code>参数的数组构造方法。参考下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">IntFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">arrayMaker</span> <span class="o">=</span> <span class="kt">int</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">arrayMaker</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> <span class="c1">// 创建数组 int[10]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>10. 默认方法和静态接口方法（Default and static interface methods）</h2>

<p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把<em>代码即数据</em>（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>

<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。<em>默认方法</em>（之前被称为<em>虚拟扩展方法</em>或<em>守护方法</em>）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>

<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如<code>removeAll</code>方法应该被泛化为接收一个函数式接口<code>Predicate</code>，但这个新的方法应该被放在哪里呢？我们无法直接在<code>Collection</code>接口上新增方法——不然就会破坏现有的<code>Collection</code>实现。我们倒是可以在<code>Collections</code>工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>

<p><em>默认方法</em>利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是<em>抽象的</em>或是<em>默认的</em>。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>

<p>下面的例子展示了如何向<code>Iterator</code>接口增加默认方法<code>skip</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
</span><span class='line'>  <span class="n">E</span> <span class="nf">next</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">remove</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">default</span> <span class="kt">void</span> <span class="nf">skip</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hasNext</span><span class="o">();</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">next</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据上面的<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会自动继承<code>skip</code>方法。在使用者的眼里，<code>skip</code>不过是接口新增的一个虚拟方法。在没有覆盖<code>skip</code>方法的<code>Iterator</code>子类实例上调用<code>skip</code>会执行<code>skip</code>的默认实现：调用<code>hasNext</code>和<code>next</code>若干次。子类可以通过覆盖<code>skip</code>来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>

<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>

<p>除了默认方法，Java SE 8还在允许在接口中定义<em>静态</em>方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如<code>Collections</code>）。比如，我们一般需要使用静态辅助方法生成实现<code>Comparator</code>的比较器，在Java SE 8中我们可以直接把该静态方法定义在<code>Comparator</code>接口中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">U</span><span class="o">&gt;&gt;</span>
</span><span class='line'>    <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c1</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c2</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>11. 继承默认方法（Inheritance of default methods）</h2>

<p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>

<ul>
<li>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。</li>
<li>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。</li>
</ul>


<p>为了演示第二条规则，我们假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法。在下面的<code>implement</code>从句中，<code>List</code>中的方法声明会优先于<code>Queue</code>中的方法声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Robot</span> <span class="kd">implements</span> <span class="n">Artist</span><span class="o">,</span> <span class="n">Gun</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">default</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span> <span class="n">Artist</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">draw</span><span class="o">();</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>super</code>前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>

<p>最后，接口在<code>inherits</code>和<code>extends</code>从句中的声明顺序和它们被实现的顺序无关。</p>

<h2>12. 融会贯通（Putting it together）</h2>

<p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>

<p>比如说下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Person</span> <span class="n">x</span><span class="o">,</span> <span class="n">Person</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>冗余代码实在太多了！</p>

<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Person</span> <span class="n">x</span><span class="o">,</span> <span class="n">Person</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助<code>Comparator</code>里的<code>comparing</code>方法实现比较操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">((</span><span class="n">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们注意到这里的lambda表达式实际上是<code>getLastName</code>的代理（forwarder），于是我们可以用方法引用代替它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，使用<code>Collections.sort</code>这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现<code>List</code>接口的数据结构提供特定（specialized）的高效实现，而且由于<code>Collections.sort</code>方法不属于<code>List</code>接口，用户在阅读<code>List</code>接口的文档时不会察觉在另外的<code>Collections</code>类中还有一个针对<code>List</code>接口的排序（<code>sort()</code>）方法。</p>

<p>默认方法可以有效的解决这个问题，我们为<code>List</code>增加默认方法<code>sort()</code>，然后就可以这样调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">));;</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外，如果我们为<code>Comparator</code>接口增加一个默认方法<code>reversed()</code>（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">).</span><span class="na">reversed</span><span class="o">());;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>13. 小结（Summary）</h2>

<p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>

<p>未完待续——</p>

<p>下篇：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Top Coder算法题目浏览器]]></title>
    <link href="http://zh.lucida.me/blog/top-code-offline-browser/"/>
    <updated>2014-10-14T23:37:29-07:00</updated>
    <id>http://zh.lucida.me/blog/top-code-offline-browser</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>

<h2>关于</h2>

<p><a href="http://weibo.com/haoel">左耳朵耗子</a>在最近发了一条关于leetcode的微博：</p>

<p><img src="http://i.imgur.com/alUuOmx.jpg" alt="微博截图" /></p>

<p>佩服之余，想起自己两年前找工作时随手写的一个小程序：Top Coder算法题目浏览器，硬盘里翻了翻没找到，于是找师弟要了一份copy，截了几张图放到微博上。</p>

<p><img src="http://i.imgur.com/bIiXNR4.jpg" alt="微博截图" /></p>

<p>没想到不少人表示很感兴趣，还有些同学留下邮箱索要这个算法题目浏览器——我是懒的一个个发邮箱，所以干脆放到博客上，顺便提高下访问量 :)</p>

<!-- more -->


<h2>介绍</h2>

<h3>TC Browser</h3>

<p><strong>TC Browser</strong>：全称<strong>Top Coder offline Browser</strong>，是我为了方便自己练习算法题目而花一下午制作的Windows小程序。</p>

<p><strong>TC Browser</strong>内置2933道算法题目，这些算法题目覆盖动态规划（Dynamic Programming）、递归（Recursion）、迭代（Iteration）、暴力（Brute Force）和图论（Graph Theory）等17个分类，并按照级别（Level）不同和难度（Success Rate）不同进行分类，以便从简单到复杂逐步练习。</p>

<h4>TC Browser可以</h4>

<ul>
<li>离线浏览算法题目 &ndash;_&ndash;</li>
<li>按照算法、级别和难度过滤题目，以便逐步提高水平。</li>
<li>随机出题 &ndash;_&ndash;</li>
</ul>


<h4>TC Browser不可以</h4>

<ul>
<li>评判（Judge）题目，如它的名字，TC Browser只是一个题目浏览器，而非一个完整的OJ（Online Judge）。不过好在TC题目的Sample Input/Output比较全。</li>
<li>提供答案（Answer），嗯，这些题目都没有答案，所以对于初学者可能不合适。</li>
</ul>


<h3>为什么选择<a href="http://www.topcoder.com/">Top Coder</a>？</h3>

<ol>
<li>大量的算法题目：<strong>TC Browser</strong>是我两年半前写的，当时有2933道题目，现在的题目只会更多。</li>
<li>题目具有良好的分类：Top Coder里的每道算法题目都有明确的分类：类型（Category）、级别（Level）、难度（Success Rate）。</li>
<li>良好的题目陈述（Problem Statement）：Top Coder的题目陈述非常清晰，并且都带有若干组示例输入/输出（Sample Input/Output）。</li>
<li>题目相对实际（Practical）：相对于一些OJ的纯算法题目，Top Coder里面的题目更加实际——更接近与实际的编程而非单纯的算法演练，对于非算法竞赛出身的我非常合适。</li>
<li>Top Coder在线不稳定：也许是我的网络原因，我经常登陆不进Top Coder，这也是我编写离线版TC的原因之一。</li>
</ol>


<h2>使用</h2>

<h3>Top Coder术语</h3>

<p>如果你玩过Top Coder，请跳过本节 :&ndash;)</p>

<p>Top Coder的题目分为两个区（Division，简称D），每个区又分为三个级别（Level，简称L），每道题目有其通过率（Success Rate）。D1难度小于D2，L1难度小于L2小于L3，通过率越高难度越低。</p>

<p>举例来说，一道D1L1SR50的题目适合初学者练习，一道D2L2SR30的题目就可能需要相当的算法水准才能搞定。</p>

<h3>我如何使用TC Browser</h3>

<p>在找工作初期，我的算法水平非常拙计，于是我所练习的题目大多都是D1L2和D1L3，SR>40的题目，同时根据往届师兄师姐的面试经验，我会重点练习动态规划、递归、字符串操作和搜索这几个类型的题目。</p>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="截图" /></p>

<p>到了中后期，随着经验的累计，我开始练习D1L3的题目，并尝试一些D2L1的题目。</p>

<p><img src="http://i.imgur.com/yHE02Qi.jpg" alt="截图" /></p>

<p>到了最后，就开始使用Random模式——从D2L1和D2L2中随机出一道题目然后思考解决思路，想出来之后再随机下一道。</p>

<p>为了练习方便，我为TC Browser加了一个做题模式——其实就是把题目选择区隐藏，这样就可以方便的双窗口操作。</p>

<h4>浏览模式：</h4>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="浏览模式" /></p>

<h4>做题模式：</h4>

<p><img src="http://i.imgur.com/gNn58vt.jpg" alt="做题模式" /></p>

<p>顺便提一句，TC Browser左上角的Config、Switch Mode和About三个按钮只有Switch Mode能用——一个按钮，三倍情怀。</p>

<h3>面试有多难？</h3>

<p>就我的面试经验来说，D2L1的题目已经相当够用了——绝大多数的编程题目都没有超过D1L3的难度，要知道面试只有45分钟，搞那些惊天地泣鬼神的算法题目面试官和面试者谁都受不了。</p>

<p>但也要注意，我没有算法竞赛背景，所以面试官不会问太难的题目，但对于那些算法竞赛选手就是另一种情况了——面试官需要用更难的题目来确认你是一个合格的算法选手，正所谓道高一尺，魔高一丈。</p>

<h2>下载地址</h2>

<p>所以下载地址在这里：<a href="http://pan.baidu.com/s/1fGX5c">网盘地址</a></p>

<p>解压密码是宇宙的终极答案（The ultimate anwser to the universe）。</p>

<p>谢谢试用，至于代码可以自行反编译阅读（写的翔一般还是不读为好），恕不赘述。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 全程指南]]></title>
    <link href="http://zh.lucida.me/blog/sublime-text-complete-guide/"/>
    <updated>2014-09-27T13:57:15-07:00</updated>
    <id>http://zh.lucida.me/blog/sublime-text-complete-guide</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>摘要（Abstract）</h2>

<p>本文系统全面的介绍了Sublime Text，旨在成为最优秀的Sublime Text中文教程。</p>

<h3>更新记录</h3>

<ol>
<li>2014/09/27：完成初稿</li>
<li>2014/09/28：

<ul>
<li>更正打开控制台的快捷键为<code>Ctrl + `</code></li>
<li>更正全局替换的快捷键为<code>Ctrl + Alt + Enter</code></li>
</ul>
</li>
</ol>


<h2>前言（Prologue）</h2>

<p>Sublime Text是一款跨平台代码编辑器（Code Editor），从最初的Sublime Text 1.0，到现在的Sublime Text 3.0，Sublime Text从一个不知名的编辑器演变到现在几乎是各平台首选的GUI编辑器。而这样优秀的编辑器却没有一个靠谱的中文教程，所以我试图通过本文弥补这个缺陷。</p>

<h3>编辑器的选择（Editor Choices）</h3>

<p>从初学编程到现在，我用过的编辑器有EditPlus、UltraEdit、Notepad++、Vim、TextMate和Sublime Text，如果让我从中推荐，我会毫不犹豫的推荐Vim和Sublime Text，原因有下面几点：</p>

<!-- more -->


<ol>
<li><strong>跨平台</strong>：Vim和Sublime Text均为跨平台编辑器（在Linux、OS X和Windows下均可使用）。作为一个程序员，切换系统是常有的事情，为了减少重复学习，使用一个跨平台的编辑器是很有必要的。</li>
<li><strong>可扩展</strong>：Vim和Sublime Text都是可扩展的（Extensible），并包含大量实用插件，我们可以通过安装自己领域的插件来成倍提高工作效率。</li>
<li><strong>互补</strong>：Vim和Sublime Text分别是命令行环境（CLI）和图形界面环境（GUI）下的最佳选择，同时使用两者会大大提高工作效率。</li>
</ol>


<h3>个人背景（Personal Background）</h3>

<p>我是一名非常典型的程序员：平时工作主要在Linux环境下使用Java和Python，偶尔会用HTML+CSS+JavaScript编写网页；业余时会在Windows环境编写一些C#程序（包括控制台程序（Console Application）和移动应用（Mobile App），也会玩一些非主流语言（比如Haskell，ML和Ruby等）以拓展见识。</p>

<p>所以这篇文章会我的个人工作内容为主要使用场景（Scenario），尽管无法覆盖到所有的使用场景，但我认为依然可以覆盖到绝大部分，如果您认为我遗漏了什么内容，请在文章下面回复，我会尽量更新。</p>

<h3>本文风格（Writing Style）</h3>

<p>受益于<a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R C</a>的写作风格，我倾向于以实际案例来讲解Sublime Text的功能，所以本文中的例子均源于我在实际开发时遇到的问题。</p>

<p>此外，把本文会使用大量动画（GIF）演示Sublime Text的编辑功能，因为我发现图片难以演示完整的编辑流程（Workflow），而视频又过于重量级。本文的GIF动画均使用<a href="http://screentogif.codeplex.com/">ScreenToGif</a>进行录制。</p>

<h3>编辑器（Editor） vs 集成开发环境（Integrated Development Environment，下文简称IDE）</h3>

<p>我经常看到一些程序员拿编辑器和IDE进行比较，诸如Vim比Eclipse强大或是Visual Studio太慢不如Notepad++好使之类的讨论比比皆是，个人认为这些讨论没有意义，因为编辑器和IDE根本是面向两种不同使用场景的工具：</p>

<ul>
<li>编辑器面向无语义的纯文本，不涉及领域逻辑，因此速度快体积小，适合编写单独的配置文件和动态语言脚本（Shell、Python和Ruby等）。</li>
<li>IDE面向有语义的代码，会涉及到大量领域逻辑，因此速度偏慢体积庞大，适合编写静态语言项目（Java、C++和C#等）。</li>
</ul>


<p>我认为应当使用正确的工具去做有价值的事情，并把效率最大化，所以我会用Eclipse编写Java项目，用Vim编写Shell，用Sublime Text编写JavaScript/HTML/Python，用Visual Studio编写C#。</p>

<p>前言到此结束，下面进入正题。</p>

<h2>安装（Installation）</h2>

<p>Sublime Text<a href="http://www.sublimetext.com/">官方网站</a>提供了Sublime Text各系统各版本的下载，目前Sublime Text的最新版本是<a href="http://www.sublimetext.com/3">Sublime Text 3</a>。这里以Windows版本的Sublime Text安装为例。</p>

<p>注意在安装时勾选<strong>Add to explorer context menu</strong>，这样在右键单击文件时就可以直接使用Sublime Text打开。</p>

<p><img src="http://i.imgur.com/zVtiXNP.jpg" alt="右键打开" /></p>

<h3>添加Sublime Text到环境变量</h3>

<p>使用<code>Win + R</code>运行<code>sysdm.cpl</code>打开“系统属性”。</p>

<p><img src="http://i.imgur.com/ysZe1BH.jpg" alt="sysdm.cpl" /></p>

<p>然后在“高级”选项卡里选择“环境变量”，编辑“Path”，增加Sublime Text的安装目录（例如<code>D:\Program Files\Sublime Text 3</code>）。</p>

<p><img src="http://i.imgur.com/dY5EaZX.jpg" alt="添加环境变量" /></p>

<p>接下来你就可以在命令行里面利用<code>subl</code>命令直接使用Sublime Text了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subl file    :: 使用Sublime Text打开file文件
</span><span class='line'>subl folder  :: 使用Sublime Text打开folder文件夹
</span><span class='line'>subl .       :: 使用Sublime Text当前文件夹</span></code></pre></td></tr></table></div></figure>


<h3>安装Package Control</h3>

<p>前文提到Sublime Text支持大量插件，如何找到并管理这些插件就成了一个问题，Package Control正是为了解决这个问题而出现的，利用它我们可以很方便的浏览、安装和卸载Sublime Text中的插件。</p>

<p>进入Package Control的<a href="https://sublime.wbond.net/">官网</a>，里面有详细的<a href="https://sublime.wbond.net/installation">安装教程</a>。Package Control支持Sublime Text 2和3，本文只给出3的安装流程：</p>

<ul>
<li>使用<code>Ctrl + `</code>打开Sublime Text控制台。</li>
<li>将下面的代码粘贴到控制台里：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>等待Package Control安装完成。之后使用<code>Ctrl + Shift + P</code>打开命令板，输入<code>PC</code>应出现Package Control：</li>
</ul>


<p><img src="http://i.imgur.com/fgnl2Qj.jpg" alt="Package Control安装成功" /></p>

<p>成功安装Package Control之后，我们就可以方便的安装使用Sublime Text的各种插件：</p>

<p><img src="http://i.imgur.com/pnuar4c.gif" alt="使用Package Control安装插件" /></p>

<h2>购买（Purchase）</h2>

<p>Sublime Text是一个收费闭源软件，这在一定程度上成为了我支持Sublime Text的理由（我心中的软件靠谱程度：免费开源 &lt;&lt; 免费闭源 &lt; 收费开源 &lt; 收费闭源）：在<a href="https://www.sublimetext.com/buy">这里</a>购买。</p>

<p>不过不购买Sublime Text也可以“正常”使用它，只是Sublime Text会时不时的弹出一个对话框提醒你购买，此外窗口处会有一个很屌丝很low逼的<strong>(UNREGISTERED)</strong>。（在高频操作下，一般20分钟提示一次，个人认为算是很厚道了）</p>

<p><img src="http://i.imgur.com/hPNqz66.jpg" alt="提示注册" /></p>

<p>也许不少人会觉着Sublime Text 70刀的价格太贵，但相比它的功能和带来的效率提升，70刀真的不值一提，如果你不方便使用Paypal付款可以邮件联系我，你支付宝给我打款然后我帮你付款，价格按当日汇率折算（450元左右）。</p>

<p><img src="http://i.imgur.com/gWt2eLA.jpg" alt="购买之后" /></p>

<h2>概览（Tour）</h2>

<h3>基本概念（Basic Concepts）</h3>

<p>Sublime Text的界面如下：</p>

<p><img src="http://i.imgur.com/XrUYmH8.jpg" alt="Sublime Text" /></p>

<ul>
<li>标签（Tab）：无需介绍。</li>
<li>编辑区（Editing Area）：无需介绍。</li>
<li>侧栏（Side Bar）：包含当前打开的文件以及文件夹视图。</li>
<li>缩略图（Minimap）：如其名。</li>
<li>命令板（Command Palette）：Sublime Text的操作中心，它使得我们基本可以脱离鼠标和菜单栏进行操作。</li>
<li>控制台（Console）：使用<code>Ctrl + `</code>调出，它既是一个标准的Python REPL，也可以直接对Sublime Text进行配置。</li>
<li>状态栏（Status Bar）：显示当前行号、当前语言和Tab格式等信息。</li>
</ul>


<h3>配置（Settings）</h3>

<p>与其他GUI环境下的编辑器不同，Sublime Text并没有一个专门的配置界面，与之相反，Sublime Text使用JSON配置文件，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "font_size": 12,
</span><span class='line'>  "highlight_line": true,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>会将默认字体大小调整为12，并高亮当前行。</p>

<p>JSON配置文件的引入简化了Sublime Text的界面，但也使得配置变的复杂，一般我会到<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/settings.html">这里</a>查看可用的Sublime Text配置。</p>

<h2>编辑（Editing）</h2>

<p>Sublime Text的编辑十分人性化——它不像Vim那样反人类（尽管我也用Vim但我还是要说Vim的快捷键设定绝壁连代谢产物都不如），少量的快捷键就可以完成绝大多数编辑任务。</p>

<h3>基本编辑（Basic Editing）</h3>

<p><code>↑↓←→</code>就是<code>↑↓←→</code>，不是<code>KJHL</code>，（没错我就是在吐槽Vim，尼玛设成<code>WSAD</code>也比这个强啊），粘贴剪切复制均和系统一致。</p>

<p><code>Ctrl + Enter</code>在当前行下面新增一行然后跳至该行；<code>Ctrl + Shift + Enter</code>在当前行上面增加一行并跳至该行。</p>

<p><img src="http://i.imgur.com/rvzS9Ok.gif" alt="演示新增行" /></p>

<p><code>Ctrl + ←/→</code>进行逐词移动，相应的，<code>Ctrl + Shift + ←/→</code>进行逐词选择。</p>

<p><img src="http://i.imgur.com/jFnTDl3.gif" alt="演示逐词移动及选择" /></p>

<p><code>Ctrl + ↑/↓</code>移动当前显示区域，<code>Ctrl + Shift + ↑/↓</code>移动当前行。</p>

<p><img src="http://i.imgur.com/v31pd3k.gif" alt="演示移动当前行" /></p>

<h3>选择（Selecting）</h3>

<p>Sublime Text的一大亮点是支持多重选择——同时选择多个区域，然后同时进行编辑。</p>

<p><code>Ctrl + D</code>选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑。</p>

<p>多重选词的一大应用场景就是重命名——从而使得代码更加整洁。尽管Sublime Text无法像IDE（例如Eclipse）那样进行自动重命名，但我们可以通过多重选词+多重编辑进行直观且便捷的重命名：</p>

<p><img src="http://i.imgur.com/IRVbUTJ.gif" alt="利用多重选词进行重命名" /></p>

<p>有时我们需要对一片区域的所有行进行同时编辑，<code>Ctrl + Shift + L</code>可以将当前选中区域打散，然后进行同时编辑：</p>

<p><img src="http://i.imgur.com/0NHpXFl.gif" alt="利用打散为列表套上引号" /></p>

<p>有打散自然就有合并，<code>Ctrl + J</code>可以把当前选中区域合并为一行：</p>

<p><img src="http://i.imgur.com/hfRAyiy.gif" alt="合并选中行" /></p>

<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<p>Sublime Text提供了强大的查找（和替换）功能，为了提供一个清晰的介绍，我将Sublime Text的查找功能分为<strong>快速查找</strong>、<strong>标准查找</strong>和<strong>多文件查找</strong>三种类型。</p>

<h4>快速查找&amp;替换</h4>

<p>多数情况下，我们需要查找文中某个关键字出现的其它位置，这时并不需要重新将该关键字重新输入一遍然后搜索，我们只需要使用<code>Shift + ←/→</code>或<code>Ctrl + D</code>选中关键字，然后<code>F3</code>跳到其下一个出现位置，<code>Shift + F3</code>跳到其上一个出现位置，此外还可以用<code>Alt + F3</code>选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p>

<p><img src="http://i.imgur.com/gcaHacI.gif" alt="使用快速替换" /></p>

<h4>标准查找&amp;替换</h4>

<p>另一种常见的使用场景是搜索某个已知但不在当前显示区域的关键字，这时可以使用<code>Ctrl + F</code>调出搜索框进行搜索：</p>

<p><img src="http://i.imgur.com/6AaBiRS.jpg" alt="Sublime Text的搜索框" /></p>

<p>以及使用<code>Ctrl + H</code>进行替换：</p>

<p><img src="http://i.imgur.com/4NnE9SN.jpg" alt="Sublime Text的替换框" /></p>

<h5>关键字查找&amp;替换</h5>

<p>对于普通用户来说，常规的关键字搜索就可以满足其需求：在搜索框输入关键字后<code>Enter</code>跳至关键字当前光标的下一个位置，<code>Shift + Enter</code>跳至上一个位置，<code>Alt + Enter</code>选中其出现的所有位置（同样的，接下来可以进行快速替换）。</p>

<p>Sublime Text的查找有不同的模式：<code>Alt + C</code>切换大小写敏感（Case-sensitive）模式，<code>Alt + W</code>切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"auto_find_in_selection": true</span></code></pre></td></tr></table></div></figure>


<p>这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：</p>

<p><img src="http://i.imgur.com/QRIsDra.gif" alt="使用范围搜索进行局部重命名" /></p>

<p>使用<code>Ctrl + H</code>进行标准替换，输入替换内容后，使用<code>Ctrl + Shift + H</code>替换当前关键字，<code>Ctrl + Alt + Enter</code>替换所有匹配关键字。</p>

<h5>正则表达式查找&amp;替换</h5>

<p><a href="http://en.wikipedia.org/wiki/Regular_expression">正则表达式</a>是非常强大的文本查找&amp;替换工具，Sublime Text中使用<code>Alt + R</code>切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html">Boost里的Perl正则表达式风格</a>。</p>

<p>出于篇幅原因，本文不会对正则表达式进行详细介绍，<a href="http://regex.info/">Mastering Regex</a>（中译本：<a href="http://book.douban.com/subject/2154713/">精通正则表达式</a>）对正则表达式的原理和各语言下的使用进行了详细介绍。此外网上有大量正则表达式的优秀教程（<a href="http://deerchao.net/tutorials/regex/regex.htm">“正则表达式30分钟入门教程”</a>和<a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90">MSDN正则表达式教程</a>.aspx)），以及在线测试工具（<a href="http://regexpal.com/">regexpal</a>和<a href="http://www.regexr.com/">regexer</a>）。</p>

<h4>多文件搜索&amp;替换</h4>

<p>使用<code>Ctrl + Shift + F</code>开启多文件搜索&amp;替换（注意此快捷键和搜狗输入法的简繁切换快捷键有冲突）：</p>

<p><img src="http://i.imgur.com/05Fchle.jpg" alt="多文件搜索界面" /></p>

<p>多文件搜索&amp;替换默认在当前打开的文件和文件夹进行搜索/替换，我们也可以指定文件/文件夹进行搜索/替换。</p>

<h3>跳转（Jumping）</h3>

<p>Sublime Text提供了强大的跳转功能使得我们可以在不同的文件/方法/函数中无缝切换。就我的使用经验而言，目前还没有哪一款编辑器可以在这个方面超越Sublime Text。</p>

<h4>跳转到文件</h4>

<p><code>Ctrl + P</code>会列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后<code>Enter</code>跳转至该文件。</p>

<p>需要注意的是，Sublime Text使用模糊字符串匹配（Fuzzy String Matching），这也就意味着你可以通过文件名的前缀、首字母或是某部分进行匹配：例如，<code>EIS</code>、<code>Eclip</code>和<code>Stupid</code>都可以匹配<code>EclipseIsStupid.java</code>。</p>

<p><img src="http://i.imgur.com/db15c5n.gif" alt="跳转到文件" /></p>

<h4>跳转到符号</h4>

<p>尽管是一个文本编辑器，Sublime Text能够对代码符号进行一定程度的索引。<code>Ctrl + R</code>会列出当前文件中的符号（例如类名和函数名，但无法深入到变量名），输入符号名称<code>Enter</code>即可以跳转到该处。此外，还可以使用<code>F12</code>快速跳转到当前光标所在符号的定义处（Jump to Definition）。</p>

<p><img src="http://i.imgur.com/D2rGDck.gif" alt="跳转到符号" /></p>

<p>比较有意思的是，对于Markdown，<code>Ctrl + R</code>会列出其大纲，非常实用。</p>

<p><img src="http://i.imgur.com/qDnjcNn.jpg" alt="Markdown大纲" /></p>

<h4>跳转到某行</h4>

<p><code>Ctrl + G</code>然后输入行号以跳转到指定行：</p>

<p><img src="http://i.imgur.com/F5BLsae.gif" alt="跳转到某行" /></p>

<h4>组合跳转</h4>

<p>在<code>Ctrl + P</code>匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p>

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>


<p><img src="http://i.imgur.com/3y9MG88.gif" alt="组合跳转演示" /></p>

<p>所以Sublime Text把<code>Ctrl + P</code>称之为<strong>“Go To Anything”</strong>，这个功能如此好用，以至于我认为没有其它编辑器能够超越它。</p>

<h3>中文输入法的问题</h3>

<p>从Sublime Text的初版（1.0）到现在（3.0 3065），中文输入法（包括日文输入法）都有一个问题：输入框不跟随。</p>

<p><img src="http://i.imgur.com/VQQ87Rr.jpg" alt="输入框不跟随" /></p>

<p>目前官方还没有修复这个bug，解决方法是安装<code>IMESupport</code>插件，之后重启Sublime Text问题就解决了。</p>

<p><img src="http://i.imgur.com/ErbK7wH.jpg" alt="修复之后输入框跟随" /></p>

<h3>文件夹（Folders）</h3>

<p>Sublime Text支持以文件夹做为单位进行编辑，这在编辑一个文件夹下的代码时尤其有用。在<code>File</code>下<code>Open Folder</code>：</p>

<p><img src="http://i.imgur.com/xS9Nriz.jpg" alt="文件夹视图" /></p>

<p>你会发现右边多了一个侧栏，这个侧栏列出了当前打开的文件和文件夹的文件，使用<code>Ctrl + K, Ctrl + B</code>显示或隐藏侧栏，使用<code>Ctrl + P</code>快速跳转到文件夹里的文件。</p>

<h2>窗口&amp;标签（Windows &amp; Tabs）</h2>

<p>Sublime Text是一个多窗口多标签编辑器：我们既可以开多个Sublime Text窗口，也可以在一个Sublime Text窗口内开多个标签。</p>

<h3>窗口（Window）</h3>

<p>使用<code>Ctrl + Shift + N</code>创建一个新窗口（该快捷键再次和搜狗输入法快捷键冲突，个人建议禁用所有搜狗输入法快捷键）。</p>

<p>当窗口内没有标签时，使用<code>Ctrl + W</code>关闭该窗口。</p>

<h3>标签（Tab）</h3>

<p>使用<code>Ctrl + N</code>在当前窗口创建一个新标签，<code>Ctrl + W</code>关闭当前标签，<code>Ctrl + Shift + T</code>恢复刚刚关闭的标签。</p>

<p>编辑代码时我们经常会开多个窗口，所以分屏很重要。<code>Alt + Shift + 2</code>进行左右分屏，<code>Alt + Shift + 8</code>进行上下分屏，<code>Alt + Shift + 5</code>进行上下左右分屏（即分为四屏）。</p>

<p><img src="http://i.imgur.com/lAvhuX6.gif" alt="各种分屏" /></p>

<p>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏。例如，<code>Ctrl + 1</code>会跳转到1屏，而<code>Ctrl + Shift + 2</code>会将当前屏移动到2屏。</p>

<h3>全屏（Full Screen）</h3>

<p>Sublime Text有两种全屏模式：普通全屏和无干扰全屏。</p>

<p>个人强烈建议在开启全屏前关闭菜单栏（Toggle Menu），否则全屏效果会大打折扣。</p>

<p><code>F11</code>切换普通全屏：</p>

<p><img src="http://i.imgur.com/Kdj9eEX.jpg" alt="普通全屏" /></p>

<p><code>Shift + F11</code>切换无干扰全屏：</p>

<p><img src="http://i.imgur.com/mnTIFQk.jpg" alt="无干扰全屏" /></p>

<h2>风格（Styles）</h2>

<p>风格对于任何软件都很重要，对编辑器也是如此，尤其是GUI环境下的编辑器。作为一个程序员，我希望我的编辑器足够简洁且足够个性。</p>

<p>Notepad++默认界面</p>

<p><img src="http://i.imgur.com/MZb7AsV.png" alt="Notepad++" /></p>

<p>Sublime Text默认界面</p>

<p><img src="http://i.imgur.com/ZzwQ0sI.png" alt="Sublime Text" /></p>

<p>所以在用过Sublime Text之后，我立刻就卸掉了Notepad++。</p>

<p>Sublime Text自带的风格是我喜欢的深色风格（也可以调成浅色），默认主题是<code>Monokai Bright</code>，这两者的搭配已经很不错了，不过我们还可以做得更好：接下来我将会展示如何通过设置偏好项和添加自定义风格/主题使得Sublime Text更加Stylish。</p>

<h3>一些设置（Miscellaneous Settings）</h3>

<p>下面是我个人使用的设置项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 设置Sans-serif（无衬线）等宽字体，以便阅读
</span><span class='line'>"font_face": "YaHei Consolas Hybrid",
</span><span class='line'>"font_size": 12,
</span><span class='line'>// 使光标闪动更加柔和
</span><span class='line'>"caret_style": "phase",
</span><span class='line'>// 高亮当前行
</span><span class='line'>"highlight_line": true,
</span><span class='line'>// 高亮有修改的标签
</span><span class='line'>"highlight_modified_tabs": true,</span></code></pre></td></tr></table></div></figure>


<p>设置之后的效果如下：</p>

<p><img src="http://i.imgur.com/MkyHff5.jpg" alt="设置效果" /></p>

<h3>主题（Themes）</h3>

<p>Sublime Text有大量第三方主题：[<a href="https://sublime.wbond.net/browse/labels/theme">https://sublime.wbond.net/browse/labels/theme</a>]，这里我给出几个个人感觉不错的主题：</p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Light</a></h4>

<p><img src="http://i.imgur.com/exxgbm1.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Dark</a></h4>

<p><img src="http://i.imgur.com/YsrCJMe.png" alt="深色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a></h4>

<p><img src="http://i.imgur.com/ECLGEWD.png" alt="Nexus" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland</a></h4>

<p><img src="http://i.imgur.com/LT0AyhR.png" alt="Flatland" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Light</a></h4>

<p><img src="http://i.imgur.com/j0hJqeV.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Dark</a></h4>

<p><img src="http://i.imgur.com/CJJhvTj.png" alt="深色版" /></p>

<h3>配色（Color）</h3>

<p><a href="http://colorsublime.com/">colorsublime</a>包含了大量Sublime Text配色方案，并支持在线预览，配色方案的安装教程在<a href="http://colorsublime.com/how-to-install-a-theme">这里</a>，恕不赘述。</p>

<p>我个人使用的是<a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a>主题和<a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland Dark</a>配色，配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"theme": "Nexus.sublime-theme",
</span><span class='line'>"color_scheme": "Packages/Theme - Flatland/Flatland Dark.tmTheme",</span></code></pre></td></tr></table></div></figure>


<p>效果如下：</p>

<p><img src="http://i.imgur.com/gCxTGii.jpg" alt="Nexus+Flatland" /></p>

<h2>编码（Coding）</h2>

<p>优秀的编辑器使编码变的更加容易，所以Sublime Text提供了一系列功能以提高开发效率。</p>

<h3>良好实践（Good Practices）</h3>

<p>良好的代码应该是规范的，所以Google为每一门主流语言都设置了其代码规范（Code Style Guideline）。我自己通过下面的设置使以规范化自己的代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 设置tab的大小为2
</span><span class='line'>"tab_size": 2,
</span><span class='line'>// 使用空格代替tab
</span><span class='line'>"translate_tabs_to_spaces": true,
</span><span class='line'>// 添加行宽标尺
</span><span class='line'>"rulers": [80, 100],
</span><span class='line'>// 显示空白字符
</span><span class='line'>"draw_white_space": "all",
</span><span class='line'>// 保存时自动去除行末空白
</span><span class='line'>"trim_trailing_white_space_on_save": true,
</span><span class='line'>// 保存时自动增加文件末尾换行
</span><span class='line'>"ensure_newline_at_eof_on_save": true,</span></code></pre></td></tr></table></div></figure>


<h3>代码段（Code Snippets）</h3>

<p>Sublime Text支持代码段（Code Snippet），输入代码段名称后<code>Tab</code>即可生成代码段。</p>

<p><img src="http://i.imgur.com/EQc1zNX.gif" alt="代码段效果" /></p>

<p>你可以通过Package Control安装第三方代码段，也可以自己创建代码段，参考<a href="http://www.hongkiat.com/blog/sublime-code-snippets/">这里</a>。</p>

<h3>格式化（Formatting）</h3>

<p>Sublime Text基本的手动格式化操作包括：<code>Ctrl + [</code>向左缩进，<code>Ctrl + ]</code>向右缩进，此外<code>Ctrl + Shift + V</code>可以以当前缩进粘贴代码（非常实用）。</p>

<p>除了手动格式化，我们也可以通过安装插件实现自动缩进和智能对齐：</p>

<ul>
<li><a href="https://sublime.wbond.net/packages/HTMLBeautify">HTMLBeautify</a>：格式化HTML。</li>
<li><a href="https://sublime.wbond.net/packages/AutoPEP8">AutoPEP8</a>：格式化Python代码。</li>
<li><a href="https://sublime.wbond.net/packages/Alignment">Alignment</a>：进行智能对齐。</li>
</ul>


<h3>自动完成（Auto Completion）</h3>

<p>Sublime Text 支持一定的自动完成，按<code>Tab</code>自动补全。</p>

<p><img src="http://i.imgur.com/cqBI3NW.jpg" alt="自动完成" /></p>

<h3>括号（Brackets）</h3>

<p>编写代码时会碰到大量的括号，利用<code>Ctrl + M</code>可以快速的在起始括号和结尾括号间切换，<code>Ctrl + Shift + M</code>则可以快速选择括号间的内容，对于缩进型语言（例如Python）则可以使用<code>Ctrl + Shift + J</code>。</p>

<p><img src="http://i.imgur.com/oxWjAo9.gif" alt="括号演示" /></p>

<p>此外，我使用<a href="https://sublime.wbond.net/packages/BracketHighlighter">BracketHighlighter</a>插件以高亮显示配对括号以及当前光标所在区域，效果如下：</p>

<p><img src="http://i.imgur.com/QQpG99h.gif" alt="插件演示" /></p>

<h3>命令行（Command Line）</h3>

<p>尽管提供了Python控制台，但Sublime Text的控制台仅支持单行输入，十分不方便，所以我使用<a href="https://sublime.wbond.net/packages/SublimeREPL">Sublime​REPL</a>以进行一些编码实验（Experiments）。</p>

<p><img src="http://i.imgur.com/dZgi8QZ.gif" alt="SublimeREPL演示" /></p>

<h2>其它（Miscellaneous）</h2>

<p>尽管我试图在本文包含尽可能多的Sublime Text实用技能，但受限于篇幅和我的个人经验，本文仍不免有所遗漏，欢迎在评论里指出本文的错误及遗漏。</p>

<p>下面是一些可能有用但我很少用到的功能：</p>

<ul>
<li>宏（Macro）：Sublime Text支持<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/extensibility/macros.html">录制宏</a>，但我在实际工作中并未发现宏有多大用处。</li>
<li>其它平台（Other Platforms）：本文只介绍了Windows平台上Sublime Text的使用，不过Linux和OS X上Sublime Text的使用方式和Windows差别不大，只是在快捷键上有所差异，请参考<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_win.html">Windows/Linux快捷键</a>和<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html">OS X快捷键</a>。</li>
<li>项目（Projects）：Sublime Text支持简单的<a href="http://www.sublimetext.com/docs/3/projects.html">项目管理</a>，但我一般只用到文件夹。</li>
<li>Vim模式（Vintage）：Sublime Text自带<a href="http://www.sublimetext.com/docs/3/vintage.html">Vim模式</a>。</li>
<li>构建（Build）：通过配置，Sublime Text可以进行<a href="http://docs.sublimetext.info/en/latest/file_processing/build_systems.html">源码构建</a>。</li>
<li>调试（Debug）：通过安装<a href="https://sublime.wbond.net/search/debug">插件</a>，Sublime Text可以对代码进行调试。</li>
</ul>


<h2>快捷键列表（Shortcuts Cheatsheet）</h2>

<p>我把本文出现的Sublime Text按其类型整理在这里，以便查阅。</p>

<h3>通用（General）</h3>

<ul>
<li><code>↑↓←→</code>：上下左右移动光标，注意不是不是<code>KJHL</code>！</li>
<li><code>Alt</code>：调出菜单</li>
<li><code>Ctrl + Shift + P</code>：调出命令板（Command Palette）</li>
<li><code>Ctrl + `</code>：调出控制台</li>
</ul>


<h3>编辑（Editing）</h3>

<ul>
<li><code>Ctrl + Enter</code>：在当前行下面新增一行然后跳至该行</li>
<li><code>Ctrl + Shift + Enter</code>：在当前行上面增加一行并跳至该行</li>
<li><code>Ctrl + ←/→</code>：进行逐词移动</li>
<li><code>Ctrl + Shift + ←/→</code>进行逐词选择</li>
<li><code>Ctrl + ↑/↓</code>移动当前显示区域</li>
<li><code>Ctrl + Shift + ↑/↓</code>移动当前行</li>
</ul>


<h3>选择（Selecting）</h3>

<ul>
<li><code>Ctrl + D</code>：选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑</li>
<li><code>Ctrl + Shift + L</code>：将当前选中区域打散</li>
<li><code>Ctrl + J</code>：把当前选中区域合并为一行</li>
<li><code>Ctrl + M</code>：在起始括号和结尾括号间切换</li>
<li><code>Ctrl + Shift + M</code>：快速选择括号间的内容</li>
<li><code>Ctrl + Shift + J</code>：快速选择同缩进的内容</li>
<li><code>Ctrl + Shift + Space</code>：快速选择当前作用域（Scope）的内容</li>
</ul>


<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<ul>
<li><code>F3</code>：跳至当前关键字下一个位置</li>
<li><code>Shift + F3</code>：跳到当前关键字上一个位置</li>
<li><code>Alt + F3</code>：选中当前关键字出现的所有位置</li>
<li><code>Ctrl + F/H</code>：进行标准查找/替换，之后：

<ul>
<li><code>Alt + C</code>：切换大小写敏感（Case-sensitive）模式</li>
<li><code>Alt + W</code>：切换整字匹配（Whole matching）模式</li>
<li><code>Alt + R</code>：切换正则匹配（Regex matching）模式</li>
<li><code>Ctrl + Shift + H</code>：替换当前关键字</li>
<li><code>Ctrl + Alt + Enter</code>：替换所有关键字匹配</li>
</ul>
</li>
<li><code>Ctrl + Shift + F</code>：多文件搜索&amp;替换</li>
</ul>


<h3>跳转（Jumping）</h3>

<ul>
<li><code>Ctrl + P</code>：跳转到指定文件，输入文件名后可以：

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>
</li>
<li><code>Ctrl + R</code>：跳转到指定符号</li>
<li><code>Ctrl + G</code>：跳转到指定行号</li>
</ul>


<h3>窗口（Window）</h3>

<ul>
<li><code>Ctrl + Shift + N</code>：创建一个新窗口</li>
<li><code>Ctrl + N</code>：在当前窗口创建一个新标签</li>
<li><code>Ctrl + W</code>：关闭当前标签，当窗口内没有标签时会关闭该窗口</li>
<li><code>Ctrl + Shift + T</code>：恢复刚刚关闭的标签</li>
</ul>


<h3>屏幕（Screen）</h3>

<ul>
<li><code>F11</code>：切换普通全屏</li>
<li><code>Shift + F11</code>：切换无干扰全屏</li>
<li><code>Alt + Shift + 2</code>：进行左右分屏</li>
<li><code>Alt + Shift + 8</code>：进行上下分屏</li>
<li><code>Alt + Shift + 5</code>：进行上下左右分屏</li>
<li>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏</li>
</ul>


<h2>延伸阅读（Further Reading）</h2>

<h3>书籍（Books）</h3>

<ul>
<li><a href="http://www.amazon.com/Mastering-Sublime-Community-Experience-Distilled/dp/1849698422/">Mastering Sublime Text</a>：我读过的唯一一本关于Sublime Text的书籍，书中介绍的插件很实用，但对编辑技巧介绍不全。</li>
<li><a href="http://www.amazon.com/Instant-Sublime-Text-Starter-Haughee/dp/1849693927/">Instant Sublime Text Starter</a>：另外一本关于Sublime Text的书，我没有读过。</li>
</ul>


<h3>链接（Links）</h3>

<ul>
<li>官方文档：<a href="http://www.sublimetext.com/docs/3/">http://www.sublimetext.com/docs/3/</a></li>
<li>官方论坛：<a href="http://www.sublimetext.com/forum/">http://www.sublimetext.com/forum/</a></li>
<li>Stack Overflow的Sublime Text频道：

<ul>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext">http://stackoverflow.com/questions/tagged/sublimetext</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext2">http://stackoverflow.com/questions/tagged/sublimetext2</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext3">http://stackoverflow.com/questions/tagged/sublimetext3</a></li>
</ul>
</li>
<li>非官方文档：<a href="http://sublime-text-unofficial-documentation.readthedocs.org/">http://sublime-text-unofficial-documentation.readthedocs.org/</a> 甚至比官方文档还要全面！</li>
<li>Package Control：<a href="https://sublime.wbond.net/">https://sublime.wbond.net/</a> 大量的Sublime Text插件和主题。</li>
</ul>


<h3>视频（Videos）</h3>

<ul>
<li>Getting Started with SublimeText：<a href="https://www.youtube.com/watch?v=04gKiTiRlq8">https://www.youtube.com/watch?v=04gKiTiRlq8</a></li>
<li>Sublime Text Pefect Workflow：<a href="https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g">https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g</a></li>
</ul>


<h2>关于作者（About Me）</h2>

<p><a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<p>正在尽量努力成为一名靠谱的软件工程师 :&ndash;|</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——1. Horror Vacui]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/"/>
    <updated>2014-07-26T16:10:03-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-1-horror-vacui</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<strong>设计</strong>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/design-of-design-0-horror-prologue/">设计中的设计——0. Prologue</a></li>
<li><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">设计中的设计——1. Horror Vacui</a></li>
</ol>


<h2>Horror Vacui</h2>

<blockquote><p>Horror Vacui——a Latin expression meaning &ldquo;fear of emptiness&#8221;——regards the desire to fill empty spaces with information of objects.</p></blockquote>

<p><strong><a href="http://en.wikipedia.org/wiki/Horror_vacui">Horror Vacui</a></strong>源自人对空旷空间的畏惧感——它是一种要将空间填满的心理，也是一种不留任何空白空间的艺术风格，这种风格的代表设计师包括David Carson和Vaughan Oliver，有兴趣的童鞋请自行Google他们的代表作品。</p>

<p>不过这篇文章讨论的并不是<strong>Horror Vacui</strong>艺术风格，而是<strong>Horror Vacui</strong>心理。</p>

<!-- more -->


<p>研究表明，<strong>Horror Vacui</strong>和<strong>价值感知（Value Perception）</strong>间存在反比关系——随着<strong>Horror Vacui</strong>的升高，价值感知随之下降。简单的来说——同样的空间，放的东西越多，给人的廉价感越强烈，反之亦然（vice versa）。</p>

<p>以服装店店面的设计为例：</p>

<p><img src="http://i.imgur.com/FFblJhS.png" alt="Horror Vacui" /></p>

<p>研究者做了一个调查，对于上面的店面设计风格，从左到右的空间利用率越来越低，然而给人的价值感知正好相反——几乎所有被调查者都认为最左的廉价感最强，而最右的高端感最强。</p>

<p>再来几个现实例子：</p>

<h3>店铺</h3>

<p><img src="http://i.imgur.com/5LsZvER.jpg" width="600" height="400" title="西单某服装店" ></p>

<p><img src="http://i.imgur.com/CtXZzWw.jpg" width="600" height="400" title="优衣库" ></p>

<p><img src="http://i.imgur.com/CUwAJDd.jpg" width="600" height="400" title="Burberry" ></p>

<p>你觉得哪一个店更贵？</p>

<h3>食物</h3>

<p><img src="http://i.imgur.com/YwI3YGU.jpg" width="600" height="400" title="东北乱炖" ></p>

<p><img src="http://i.imgur.com/pw8iVAa.jpg" width="600" height="400" title="法式食物" ></p>

<p>你认为哪道菜更贵？</p>

<h2>Horror Vacui vs Minimalism</h2>

<p>Horror Vacui设计是Minimalism设计的反面，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>在介绍Horror Vacui时给出了下面刻薄但又实用的建议：</p>

<blockquote><p>To promote associations of high value, favor minimalism for affluent and well-educated audiences and horror vacui for poorer and less-educated audiences, and vice versa.</p></blockquote>

<p>简单来说：</p>

<ul>
<li>对于教育程度高或富有的用户，使用minimalism（极简）设计以带来高价值认知。</li>
<li>对于教育程度低或较穷的用户，使用horror vacui设计以带来高性价比认知。</li>
</ul>


<p>反之也一样：</p>

<ul>
<li>对于教育程度低或较穷的用户，minimalism设计会让他们认为这货性价比太低，不值得。</li>
<li>对于教育程度高或富有的用户，horror vacui设计会让他们认为这货太廉价，没必要。</li>
</ul>


<p>总之，不用给矮矬穷营造高大上，也不要给高帅富灌输便宜大碗，会有反效果。</p>

<h2>Universal Principles of Design</h2>

<p><img src="http://i.imgur.com/EEueKvz.jpg" alt="Universal Principles of Design" /></p>

<p>我在之前的<a href="http://zh.lucida.me/blog/on-reading-books/">如何阅读书籍</a>中提到利用结论型/指南型书籍精炼阅读专业周边书籍，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>就是设计中结论型书籍的代表作：</p>

<ol>
<li>包含一百多种实用设计原则，这些原则涵盖了改善可用性（Enhance usability）、影响感知（Infuluence Perception）、提升吸引力（Increase Appeal）、做出更好的设计决策（Make Better Design Decisions）以及设计教学（Teach through Design）这五大方面。</li>
<li>全书按照字母顺序（Alphabetical Order）组织，同时也包含按类别组织的目录，既方便查阅，也方便针对性阅读。</li>
<li>每一种设计原则都配有详细的文字介绍、图解、案例以及参考文献。</li>
</ol>


<p><img src="http://i.imgur.com/eqTjTqK.jpg" alt="样章" /></p>

<p>总之，这本书对于专业设计师可能比较初级，但对于设计入门者是绝好的书籍。任何涉及到制作最终用户产品的人员（包括开发、测试和产品等）都应该阅读此书，从而了解基本设计原则（principle）和术语（terminology），以便与设计师进行交流，做出令用户满意的高价值设计。</p>

<p>这本书有<a href="http://www.amazon.cn/%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%B3%95%E5%88%99-%E5%A8%81%E5%BB%89%E2%80%A2%E7%AB%8B%E5%BE%B7%E5%A8%81%E5%B0%94/dp/B00ES8JL8W/">中文译版</a>，但个人强烈推荐<a href="http://www.amazon.cn/Universal-Principles-of-Design-Lidwell-William/dp/1592535879/">原版</a>：因为这类书籍翻译过来会损失相当多的信息（注意并非否认翻译水平），此外原版价格也相当实惠。</p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们都爱黑巴西——德国神虐巴西之后]]></title>
    <link href="http://zh.lucida.me/blog/after-germany-screwed-brazil/"/>
    <updated>2014-07-09T15:02:44-07:00</updated>
    <id>http://zh.lucida.me/blog/after-germany-screwed-brazil</id>
    <content type="html"><![CDATA[<p>比赛的结果大家都知道——世界杯史上最惨烈的半决赛，巴西国家队生生的被德国打成了中国少先队。</p>

<p>比赛之前的Google Doodle：</p>

<p><img src="http://i.imgur.com/NN26YIR.gif" alt="Original Doodle" /></p>

<p>上半场结束后的Doodle：</p>

<p><img src="http://i.imgur.com/KmCNKZZ.gif" alt="Updated Doodle" /></p>

<p>全场结束后的Doodle：</p>

<!-- more -->


<p><img src="http://i.imgur.com/le8xFzz.gif" alt="Finished Doodle" /></p>

<p>整场比赛大致是这样：</p>

<p><img src="http://i.imgur.com/ZERmlv2.gif" alt="Hulk" /></p>

<p>也可以说是这样：</p>

<p><img src="http://i.imgur.com/qHnxq3n.gif" alt="Beer" /></p>

<p>巴西守门员的表现：</p>

<p><img src="http://i.imgur.com/lp1nRDE.gif" alt="守门员" /></p>

<p>所以也许只有Howard才能拯救巴西：</p>

<p><img src="http://i.imgur.com/SJwVQdO.png" alt="Howard" /></p>

<p>耶稣都哭了：</p>

<p><img src="http://i.imgur.com/tkmwfnX.png" alt="Crying Jesus" /></p>

<p>然后准备跑路：</p>

<p><img src="http://i.imgur.com/4Mq6CKZ.png" alt="Escaping Jesus" /></p>

<p>一些球迷认为巴西应该换一面国旗</p>

<p><img src="http://i.imgur.com/9Rhh3B3.png" alt="New Flag" /></p>

<p>阿根廷陷入了沉思：</p>

<p><img src="http://i.imgur.com/CYQzqw0.png" alt="Argentina Dilemma" /></p>

<p>西班牙松了一口气：</p>

<p><img src="http://i.imgur.com/IxbY9YE.png" alt="Spanish" /></p>

<p>美国则表示哥比巴西强多了</p>

<p><img src="http://i.imgur.com/2is6Eum.png" alt="American" /></p>

<p>甚至连加拿大也长出一口气（加拿大在预选赛中被洪都拉斯黑成8:1）</p>

<p><img src="http://i.imgur.com/KNevvMp.png" alt="Canadian" /></p>

<p>码农表示一轮Build没跑完德国已经进了仨：</p>

<p><img src="http://i.imgur.com/lIer2vQ.png" alt="Build" /></p>

<p>美工表示对于2014世界杯Logo有了新解读：</p>

<p><img src="http://i.imgur.com/3vClfHw.png" alt="Logo" /></p>

<p>前端表示当时没考虑到这种情况所以出了Bug：</p>

<p><img src="http://i.imgur.com/xKmFl3a.png" alt="Scroll Bar" /></p>

<p>总之</p>

<p><img src="http://i.imgur.com/1JdyRgN.png" alt="German LGTM" /></p>

<p><img src="http://i.imgur.com/tNFyNlX.png" alt="Brazil OMG" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逗逼足球——Xorb Football]]></title>
    <link href="http://zh.lucida.me/blog/xorb-football/"/>
    <updated>2014-06-29T14:58:09-07:00</updated>
    <id>http://zh.lucida.me/blog/xorb-football</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/xorb-football/">原文链接</a></p>

<h2>关于</h2>

<p>我的Blog副标题是<strong>Tech</strong>, <strong>Life</strong>, <strong>Love</strong>，不过开博到现在几乎全是<strong>Tech</strong>相关的文章，<strong>Life</strong>相关的文章几乎没有（<a href="http://zh.lucida.me/blog/stories-of-masturbations/">打飞机故事集</a>那篇不算-_&ndash;#），更不要说<strong>Love</strong>。所以我决定改变一下这个局面。</p>

<p>不知道为什么国内舆论总喜欢把程序员黑化，以至于程序员给人的感觉就像只会修电脑——极端一些，类似下面：</p>

<p><img src="http://i.imgur.com/2suKYmO.jpg" alt="僵尸般的程序员" /></p>

<p>但实际上并未如此，程序员也是正常人，甚至比其它职业更加多才多艺。</p>

<p>以我为例，业余爱好包括<a href="http://en.wikipedia.org/wiki/Capoeira">Capoeira</a>（业余玩）、跆拳道（蓝带）、桌球、看书（对历史经济设计心理哲学等感兴趣）、收集耳机（到现在搞了接近20余副）等等，而这些爱好没有一项和计算机相关：</p>

<!-- more -->


<p>逗逼桌球</p>

<p><img src="http://i.imgur.com/CSW3XH4.jpg" width="500" height="375" title="逗逼桌球" ></p>

<p>逗逼踢腿</p>

<p><img src="http://i.imgur.com/J5EcsWE.jpg" width="500" height="375" title="逗逼踢腿" ></p>

<p>逗逼射箭</p>

<p><img src="http://i.imgur.com/3wzwaew.jpg" width="500" height="375" title="逗逼射箭" ></p>

<p>貌似扯得有点远，回到Xorb Football。</p>

<h2>Xorb Football</h2>

<h3>什么是Xorb？</h3>

<p>Football不用多说，世界第一运动。</p>

<p>但Xorb就比较冷门了：Xorb又称Zorb，中文翻译成太空球或左宾球，大体原理是把人装进一个大充气球里然后做各种运动（比如翻滚，降落和弹起等）。有兴趣的童鞋可以参考<a href="http://en.wikipedia.org/wiki/Zorbing">Zorbing</a>的Wiki或<a href="http://baike.baidu.com/view/6922282.htm">百科</a>介绍。</p>

<h3>Xorb + Football &ndash;> Xorb Football</h3>

<p>Xorb和Football结合到一起就出现了Xorb Football这项逗逼运动——给人套上一个1.5米直径的大号充气球踢足球，可以利用充气球把人撞倒，但不允许背后撞人。</p>

<p>比如断球的效果是这样：</p>

<p><img src="http://i.imgur.com/Rq2NbOw.gif" width="400" height="240" title="抢断" ></p>

<p>我搜了一下貌似国内还没有这项运动，会翻墙的同学可以到Youtube上查询Xorb Football，逗逼无极限。</p>

<h3>实际感受</h3>

<p>Google London这边一般月末Team都会有自己的活动，这次赶上巴西世界杯，大家决定踢一场足球。于是某个逗逼同事就想到了Xorb Football。</p>

<p>我们去的是位于Shoreditch Station附近的一处Football Club。</p>

<p>比较有意思的是，来这里踢球的不仅有年轻人，大把的四五十岁的中年人也踢的不亦乐乎。</p>

<p>套上Zorb球后才发现有些坑爹，不仅视线受阻而且呼吸困难。</p>

<p><img src="http://i.imgur.com/ul1nPbS.jpg" width="270" height="190" title="我感到整个人都要崩溃了" ></p>

<p>好像配错图了，这张更合适：</p>

<p><img src="http://i.imgur.com/qX9lbXN.jpg" width="270" height="190" title="我感到整个人都要窒息了" ></p>

<p>然后听到有人叫我，刚回头就被我Mentor&#8221;一球&#8221;撞飞。</p>

<p>Xorb Football的玩法有下面几种：</p>

<ul>
<li>5 vs 5：和正常足球类似，除了每人身上的逗逼气球。</li>
<li>1 vs 1：单挑。</li>
<li>2 vs 2：组队对战。</li>
<li>One man standing：效果类似于碰碰车，一群人戴着逗逼球撞来撞去，被撞倒的出局，直到最后一个人为止。</li>
</ul>


<p>刚开始大家还比较拘谨——因为是第一次玩，此外也不太好意思对同事“下手”，于是只是像足球一般带球，传球，射门。</p>

<p>我还进了一球（GOALLLLLLL!!!），不过进球后就跪了（真跪了）。</p>

<p><img src="http://i.imgur.com/icMQoCs.gif" width="400" height="240" title="偶的进球" ></p>

<p>不过和平的局面没有持续多久，从一个波兰同事撞倒数名同事开始，场面就开始混乱了——大家互相撞来撞去，一时间满地都是翻滚的同事（充气球）。</p>

<p><img src="http://i.imgur.com/Rq2NbOw.gif" width="400" height="240" title="抢断" ></p>

<p>到了后来貌似大家就把Football抛之脑后——因为撞人实在太好玩了！</p>

<p>我和Mentor的激烈碰撞（失败告终-_&ndash;#）</p>

<p><img src="http://i.imgur.com/TKXP6on.gif" width="400" height="240" title="撞死你撞死你！" ></p>

<p>玩的巨爽无比，应该是我玩过的最逗逼的集体运动了！除了第二天早起发现肩膀和胳膊酸的要死——估计是在充气球内的长期逗逼体位所致。</p>

<p>以上</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/xorb-football/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——2. Blunders, Typos, Mismatches, and Language Liability]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-2/"/>
    <updated>2014-06-27T15:46:53-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-2</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-2/">Blunders, Typos, Mismatches, and Language Liability</a></li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>对编程错误的分析</h2>

<p>上篇文章（<a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a>）介绍了Knuth对编程错误的分类，基于Knuth的分类和我自己的编程经验，从这篇文章开始我将会给出各类编程错误的<strong>案例</strong>、<strong>诱因</strong>和<strong>对策</strong>。</p>

<p>按照复杂程度的不同，Knuth将编程错误分为三大类，这篇文章介绍第一类错误——简单的错误：</p>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<!-- more -->


<h2>粗心大意（a trivial typo）</h2>

<blockquote><p>Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</p>

<p>我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</p></blockquote>

<p><strong>粗心大意</strong>这类差错源自于Knuth奇葩的开发方式——先把程序在纸上写好然后再&#8221;誊写&#8221;到计算机中，而在&#8221;誊写&#8221;时可能会敲错几个字符，从而导致程序出错。</p>

<p>除去面试时的白板编码，我认为现代程序开发不可能在纸上进行——从而也不可能产生这种差错，所以不加赘述。</p>

<h2>鬼使神差（a blunder or botch）</h2>

<blockquote><p>Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</p>

<p>我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</p></blockquote>

<h3>案例</h3>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>中提到一个低级Bug：TEX代码里有两个变量<code>new_line</code>和<code>next_line</code>：<code>new_line</code>用于表示程序当前的状态，而<code>next_line</code>则指代换行符。然而开发过程中Knuth混淆了这两个变量的用途——由于这两个变量属于同一类型所以编译器无法检测出这个问题，这个Bug直到后来程序运行了一段时间才被发现。</p>

<h3>诱因</h3>

<ul>
<li>变量名含糊不清：导致之后的误用。</li>
<li>编程语言过分宽容：某些编程语言对代码特别宽容——比如动态编程语言会将静态编程语言在编译时做的类型检查拖到运行时，尽管获得了灵活性，但却损失了精确性。从而导致<strong>鬼使神差</strong>这类静态语言编译期就能检查到的错误直到运行时才会被发现。</li>
<li>加班超负荷工作：从而导致写出翔一般的代码。</li>
</ul>


<h3>对策</h3>

<ol>
<li>使用精准的名字：

<ul>
<li>作用域越长的变量的名字越要精确。</li>
<li>使用精准的英文词汇描述变量。</li>
<li>更多关于命名的信息请参考<a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/">Code Complete</a>中<strong>The Power of Variable Names</strong>一节。</li>
</ul>
</li>
<li>严格控制全局变量：

<ul>
<li>能不用则不用。</li>
<li>如果不得不使用，使用明确的名字，进行详细的注释，并注明不得不使用全局变量的原因。。</li>
</ul>
</li>
<li>优先使用强类型：例如对于内置强类型枚举（Enum）的语言（例如Java，C#，和C++），使用枚举类型表示状态（State），而非整数类型。</li>
<li>将编译器警告调到最高级：然后清除代码中所有的Warning。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>单步（Step Into）自己的代码：编写新代码后进行单步调试——你脑中的代码和实际可能不一样。</li>
<li>进行代码审查：可以参考<a href="http://coolshell.cn/articles/11432.html">这篇文章</a>。</li>
<li>不要在混沌状态提交代码。</li>
</ol>


<h2>丢三落四（a forgotten function）</h2>

<blockquote><p>Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</p>

<p>我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</p></blockquote>

<h3>案例</h3>

<h4>烫烫烫烫烫</h4>

<p>C语言中忘记初始化数组，从而输出喜闻乐见的“烫烫烫烫烫烫烫烫烫烫烫烫”。</p>

<p><img src="http://i.imgur.com/9RcLu2x.png" alt="烫烫烫烫烫烫" /></p>

<p>对于需要手动管理内存的语言（C/C++），忘记释放内存或忘记初始化内存都会导致各种奇诡的问题。</p>

<h4>过早优化</h4>

<p>在开发TEX时，Knuth试图去优化<code>get_next</code>这个被频繁调用的函数。经过一番思考，Knuth认为<code>cur_cs = 0</code>这段代码是不必要的，于是他将这段代码删除，代码依然&#8221;正常&#8221;运行。然而过了一段时间后Knuth发现TEX在处理对齐（Alignment）时有时会出现问题——经过一番调试，Knuth发现原来那段被删除的代码是必要的（necessary）。</p>

<p>郁闷之余，Knuth援引了那句著名的话（Hoare&rsquo;s dictum）——过早优化是万恶之源（Premature optimization is the root of all evil in programming），很多书都以为这句话是Knuth说的，实际上它属于<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>。</p>

<h3>诱因</h3>

<h4>远距离操作</h4>

<p>远距离操作指那些间隔特别长的操作，例如下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj.Init()
</span><span class='line'>obj.DoSomething()
</span><span class='line'>// Hundred of lines
</span><span class='line'>obj.DoSomething()
</span><span class='line'>obj.Close()</span></code></pre></td></tr></table></div></figure>


<p>从<code>Init</code>到<code>Close</code>的距离过远，在编写了几十甚至上百行其它代码之后，很容易漏掉<code>obj.Close()</code>从而导致资源泄漏。</p>

<h4>贸然修改代码</h4>

<p>我个人认为Knuth所犯的错误不在于过早优化，而在于他在对代码理解不充分的情况下就去贸然修改——这往往会带来各种问题。</p>

<h3>应对</h3>

<ul>
<li>避免远距离操作：

<ul>
<li>对于内存管理：C++提供了智能指针。</li>
<li>多数编程语言提供了上下文管理器（Context Manager）：例如Java 7的<code>try</code>，C#的<code>using</code>，以及Python的<code>with</code>，利用这些机制，可以有效的减少远距离操作，比如前文的代码用Python可以这么写：</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">with</span> <span class="n">Obj</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span> <span class="k">as</span> <span class="n">obj</span><span class="p">:</span>
</span><span class='line'>  <span class="n">obj</span><span class="o">.</span><span class="n">DoSomething</span><span class="p">()</span>
</span><span class='line'>  <span class="o">//</span> <span class="n">Hundred</span> <span class="n">of</span> <span class="n">lines</span>
</span><span class='line'>  <span class="n">obj</span><span class="o">.</span><span class="n">DoSomething</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 整理代码段落，避免复杂交织的逻辑，这里可以参考<a href="http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293">The Art of Readable Code</a>对Aesthetics的定义。</li>
</ul>


<p><img class="right" src="http://i.imgur.com/Mvr8zx2.jpg" width="180" height="250" title="Working Effectively with Legacy Code" ></p>

<ul>
<li><p>不要贸然修改代码：</p>

<ul>
<li>修改代码前要确保充分理解代码的原理，以及修改会带来的影响（Effect Analysis）。</li>
<li>修改代码后要保证被修改的部分得到测试，<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively with Legacy Code</a>提供了很多优秀的修改实践。</li>
</ul>
</li>
<li><p>代码审查：代码审查可以有效的控制编程差错。</p></li>
<li>不要在混沌状态提交代码。</li>
</ul>


<h2>言非所指（a language liability）</h2>

<blockquote><p>Here I misused or misunderstood the programming language or system hardware I was working with.</p>

<p>我对编程语言（或是系统硬件）理解有误，从而造成错误。</p></blockquote>

<h3>案例</h3>

<h4>JavaScript</h4>

<p>下面是JavaScript的真值表（源自Douglas Crockford）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s1">&#39;&#39;</span>        <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// false</span>
</span><span class='line'><span class="mi">0</span>         <span class="o">==</span>   <span class="s1">&#39;&#39;</span>            <span class="c1">// true</span>
</span><span class='line'><span class="mi">0</span>         <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// true</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="s1">&#39;false&#39;</span>       <span class="c1">// false</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// true</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="kc">undefined</span>     <span class="c1">// false</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="kc">null</span>          <span class="c1">// false</span>
</span><span class='line'><span class="kc">null</span>      <span class="o">==</span>   <span class="kc">undefined</span>     <span class="c1">// true</span>
</span><span class='line'><span class="s2">&quot; \t\r\n&quot;</span> <span class="o">==</span>   <span class="mi">0</span>             <span class="c1">// true</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外还有下面这个对比：</p>

<p><img src="http://i.imgur.com/5RCkNLK.jpg" alt="JavaScript the Good Parts" /></p>

<p>对于这种翔一样的语言，想不掉进坑里是非常困难的。</p>

<p>（讽刺的是，JavaScript统治了浏览器端，而且它还试图染指服务器端。）</p>

<h4>操作符优先级</h4>

<p><img class="right" src="http://i.imgur.com/5WjUpyd.jpg" width="160" height="200" title="the Practice of Programming" ></p>

<p>[Brian Kernighan]曾在在<a href="http://cm.bell-labs.com/cm/cs/tpop/index.html">the Practice of Programming</a>中提到<code>if (x &amp; MASK == BITS)</code>这个例子：</p>

<p>我们一般会把<code>if (x &amp; MASK == BITS)</code>理解为<code>if ((x &amp; MASK) == BITS)</code>；</p>

<p>但实际上<code>if (x &amp; MASK == BITS)</code>和<code>if (x &amp; (MASK == BITS))</code>等价，而这显然不是我们想要的结果。</p>

<h3>诱因</h3>

<ul>
<li>对编程语言不够了解。</li>
<li>编程语言本身设计有问题。</li>
<li>对操作符优先级理解不足。</li>
</ul>


<h5>应对</h5>

<ul>
<li>深入理解编程语言——知道哪有坑：

<ul>
<li>学习编程语言不只是学它的语法——还要学习它的用法（Usages），最佳实践（Best Practices），误区（Traps），惯例（Conventions）和风格（Styles）等等，阅读<em>Effective</em>、<em>More Effective</em>、<em>Exceptional</em>、<em>More Exceptional</em>、<em>Pitfalls/Traps</em>和<em>the Good Parts</em>等系列的编程书籍以了解这些内容。</li>
<li><a href="http://joearms.github.io/">Joe Armstrong</a>在<a href="http://codersatwork.com/">Coders at work</a>的访谈中提到学习编程语言最好的方式是实现它（“The best way to learn a programming language is to implement it yourself”），我尝试用这种方法学习JavaScript，效果还不错。</li>
</ul>
</li>
<li>使用且仅使用语言的良子集——避开那些坑：

<ul>
<li><a href="http://crockford.com/">Douglas Crockford</a>在<a href="http://www.amazon.com/exec/obidos/ASIN/0596517742/">JavaScript: the Good Parts</a>中仅仅摘取了一个很小的JavaScript良子集进行编程，Kernighan和Plauger在<a href="http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/">Software Tools</a>则扩展了Fortran的一个良子集进行编程。语言提供的特性不代表你必须要使用它，容易产生错误（Error Prone）的语言特性应当被禁用。</li>
</ul>
</li>
<li>使用括号明确（Explicitify）操作符优先级——哪怕你能一眼看出<code>return true || true &amp;&amp; false</code>的返回值。</li>
<li>谨慎使用宏（macro）。</li>
<li>代码审查：提交代码之前至少需要一个该精通语言的人的审查，以免踩进语言的坑里。</li>
</ul>


<h2>事与愿违（a mismatch between modules）</h2>

<blockquote><p>Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</p>

<p>我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</p></blockquote>

<h3>案例</h3>

<h4>火星探测器坠毁</h4>

<p>史上最贵的<strong>事与愿违</strong>的Bug出现在1998年的NASA火星探测器中，这个Bug直接导致火星探测器坠毁，损失高达<a href="http://www.computerworld.com/s/article/9183580/Epic_failures_11_infamous_software_bugs">3.27亿美元</a>。</p>

<p>而这个Bug的成因在我们看来实际很可笑——Lockheed Martin公司在<a href="http://www.jpl.nasa.gov/news/releases/99/mcoloss1.html">调查</a>后发现，由于不同开发团队使用的计量单位不同——一个团队使用英制单位（英寸，英尺或英镑等），而其它开发团队使用公制（厘米或公斤等），从而导致系统运算错误，最终导致探测器坠毁。</p>

<h4>愚蠢的API设计</h4>

<p>以前在Microsoft实习时，我曾经编写过一个动画方法，用于移动屏幕上某个控件，这个方法大概是下面这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// Returns a DoubleAnimation which moves control from (x1, y1) to (x2, y2).</span>
</span><span class='line'><span class="k">public</span> <span class="n">DoubleAnimation</span> <span class="nf">CreateAnimation</span><span class="p">(</span><span class="n">Control</span> <span class="n">control</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Some code...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>CreateAnimation</code>用于创建一个<code>DoubleAnimation</code>，把某个控件从<code>(x1, y1)</code>移动到<code>(x2, y2)</code>，移动耗时<code>duration</code>毫秒。</p>

<p>之后就出现了下面一系列翔一般的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation1</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="n">grid1</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">grid1</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">gridAnimation2</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">grid2</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">grid2</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">popUpAnimation</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">popUp</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">320</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">320</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以及误用（组员（包括我自己）把<code>duration</code>当成秒来用）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation1</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">800</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0.5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法如同<strong>病毒</strong>一般，既使得调用代码变的丑陋不堪，同时带来了各种Bug，导致后来的维护者叫苦不迭，</p>

<p>现在回想下，我肯定不会把它设计成这副模样——一种方法是使用<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation</span> <span class="p">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">FromCurrentPosition</span><span class="p">().</span><span class="n">MoveTo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="m">0</span><span class="p">).</span><span class="n">InMilliSeconds</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">popUpAnimation</span> <span class="p">=</span> <span class="n">popUp</span><span class="p">.</span><span class="n">From</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">-</span><span class="m">320</span><span class="p">).</span><span class="n">MoveTo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="m">320</span><span class="p">).</span><span class="n">InMilliSeconds</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而使代码简洁明确。</p>

<h3>诱因</h3>

<p><strong>事与愿违</strong>源于糟糕的设计——人会犯错误，而糟糕的设计会大大加剧错误几率。</p>

<p><img class="right" src="http://i.imgur.com/jdeK9F0.jpg" width="270" height="270" title="Tony Hoare" ></p>

<p>然而良好的设计非常困难——<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>曾在他的图灵奖获奖感言（<a href="http://zoo.cs.yale.edu/classes/cs422/2014/bib/hoare81emperor.pdf">The Emperor&rsquo;s Old Clothes</a>）中指出：</p>

<blockquote><p>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.</p></blockquote>

<h3>应对</h3>

<p>尽管Knuth把<strong>事与愿违</strong>归类为简单的差错，但我并不这么认为。<strong>事与愿违</strong>源于错误的设计，解决<strong>事与愿违</strong>的关键不在于修复其造成的差错，而在于处理造成<strong>事与愿违</strong>原因。修复<strong>事与愿违</strong>的错误很简单，但处理<strong>事与愿违</strong>的原因就复杂多了。</p>

<p><img class="right" src="http://i.imgur.com/tll1S89.jpg" width="180" height="240" title="Awaken the Giant Within" ></p>

<p><a href="http://www.tonyrobbins.com/">Tony Robbins</a>曾在<a href="http://www.amazon.com/Awaken-Giant-Within-Immediate-Emotional/dp/0671791540/">Awaken the Giant Within</a>一书中讲了这样一个故事：</p>

<blockquote><p>一个医生在河边发现有一个人溺水，然后她跳进河里，把溺水者救上岸进行抢救。然而没过多久她又听到呼救声，她继续跳进河里，把溺水者救上岸抢救，然后她又听到求救，于是她又跳进河里…… 不幸的是，这名医生忙于抢救眼前的溺水者，而没有时间去上游查看是谁把这些人扔到水里的。</p></blockquote>

<p><img class="right" src="http://i.imgur.com/t5zjiGY.jpg" width="180" height="240" title="Stream Analysis" ></p>

<p><a href="http://www.jerryporras.com/">Jerry Porras</a>也在<a href="http://www.amazon.com/Stream-Analysis-Organizational-Addison-Wesley-Organization/dp/0201056933/">Stream Analysis</a>中提到：</p>

<blockquote><p>People, especially people in organizations, tend to work on getting rid of symptoms, rather than solving the real problems.</p></blockquote>

<p>因此，处理<strong>事与愿违</strong>要从设计着手（Solving the real problems），这里从设计者和使用者两个角度出发：</p>

<h4>设计者</h4>

<ol>
<li>谨慎设计API：

<ul>
<li>API应该由经验丰富的人设计。</li>
<li>API设计应遵循一定的原则，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Josha Bloch</a>曾在Google做过一个非常出色的关于API设计的演讲：<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">How To Design A Good API and Why it Matters</a>。</li>
<li>API在投入使用前应进行可用性测试——糟糕的API不仅会降低开发效率，还会像病毒一般引入各种各样的差错。</li>
</ul>
</li>
<li>利用类型系统：

<ul>
<li>避免基本类型（Primitive Type）：对于有意义的数据，使用其类型而非基本类型。例如：使用<code>Money</code>表示金钱，而非使用<code>double</code>。</li>
<li>避免使用动态语言（例如Python和Ruby）构建大型系统：动态语言的作用仅限于快速开发原型系统，在我看来，动态语言像是纸和胶水，可以用它们快速构建一些玩具模型（原型系统），但用它们建造摩天大厦（大型系统）就太离谱了。</li>
</ul>
</li>
<li>设计文档+审查：软件设计在实现前应有详细的设计文档（Design Document），并至少通过两名以上经验丰富的开发者的审查。</li>
</ol>


<h4>使用者</h4>

<p><img class="right" src="http://i.imgur.com/3vIYjeg.jpg" width="180" height="240" title="Debugging" ></p>

<ol>
<li>仔细阅读文档——Read the manual, and read everything, cover to cover，参见<a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>里的第一条调试原则——<strong>Understand the system</strong>。</li>
<li>调用API时仔细阅读其样例代码（Sample Code）和文档说明，不要想当然。</li>
<li>对于已有（Existing）的糟糕API，考虑对其进行封装（Wrapping），以免接下来的误用。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>代码审查：代码审查可以有效的控制编程差错。</li>
</ol>


<p>关于&#8221;简单&#8221;的编程差错就介绍到这里，下篇将介绍源自算法和数据结构的错误——Algorithm + Data Structures &ndash;> Programming。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——1. A Taxonomy of Programming Errors]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-1/"/>
    <updated>2014-06-24T15:32:12-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-1</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>编程错误的分类</h2>

<p>前文讲到Knuth在开发TEX的过程中遇到了各式各样的差错，为了理解并控制编程错误，Knuth将这些错误整理到<a href="http://texdoc.net/texmf-dist/doc/generic/knuth/errata/errorlog.pdf">记录日志</a>，并将这些差错分为15类。为了引用方便，我将它们翻译成中文。</p>

<p>注意：</p>

<ol>
<li>为了引用方便，Knuth使用英文首字母指代各个编程错误的分类，出于同样的原因，我将这些分类一一翻译为成语。</li>
<li>保留原文，以便读者理解，以免信息丢失。</li>
<li>原文中的&#8221;my&#8221;和&#8221;I&#8221;以及译文中的&#8221;我&#8221;均指Knuth本人。</li>
<li>如果认为翻译不靠谱请在评论中指出 :)</li>
</ol>


<p>下面是Knuth对TEX错误的分类：</p>

<!-- more -->


<hr />

<ul>
<li><strong>A: an algorithm awry.</strong> Here my original method proved to be incorrect or inadequate.</li>
<li><strong>不可胜算</strong>：我最初设想的算法有误或存在不足。</li>
</ul>


<hr />

<ul>
<li><strong>B: a blunder or botch.</strong> Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</li>
<li><strong>鬼使神差</strong>：我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</li>
</ul>


<hr />

<ul>
<li><strong>C: a cleanup for consistency or clarity.</strong> Here I changed the rules of the language to make things easier to remember and/or more logical.</li>
<li><strong>得心应手</strong>：我对语言（TEX）规则进行整理，使其符合逻辑，更加易用。</li>
</ul>


<hr />

<ul>
<li><strong>D: a data structure debacle.</strong> Here I didn&rsquo;t properly update the representation of information to preserve the appropriate invariants.</li>
<li><strong>差之毫厘</strong>：我对数据结构的操作有误，使其处在不一致的状态（破坏了其本应维持的不变式）。</li>
</ul>


<hr />

<ul>
<li><strong>E: an efficiency enhancement.</strong> Here I changed the program so that it would run faster; the existing code was correct but slow.</li>
<li><strong>多快好省</strong>：尽管原来的代码正确，但速度很慢，于是我修改代码以改善程序的性能。</li>
</ul>


<hr />

<ul>
<li><strong>F: a forgotten function.</strong> Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</li>
<li><strong>丢三落四</strong>：我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</li>
</ul>


<hr />

<ul>
<li><strong>G: a generalization or growth of ability.</strong> Here I realized that some extension of the existing specifications was desirable.</li>
<li><strong>虚怀若谷</strong>：我将一些已有的代码进行扩展/抽象使其更加通用。</li>
</ul>


<hr />

<ul>
<li><strong>I: an interactive improvement.</strong> Here I made TEX respond better to the user&rsquo;s needs.</li>
<li><strong>各得其所</strong>：我使TEX对用户更加友好。</li>
</ul>


<hr />

<ul>
<li><strong>L: a language liability.</strong> Here I misused or misunderstood the programming language or system hardware I was working with.</li>
<li><strong>言非所指</strong>：我对编程语言（或是系统硬件）理解有误，从而造成错误。</li>
</ul>


<hr />

<ul>
<li><strong>M: a mismatch between modules.</strong> Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</li>
<li><strong>事与愿违</strong>：我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</li>
</ul>


<hr />

<ul>
<li><strong>P: a promotion of portability.</strong> Here I changed the organization or documentation of the program; this affected only a person who would try to read or modify the code, not a person who tried to run it.</li>
<li><strong>焕然一新</strong>：我对程序的结构或是文档进行改善，从而在不改变程序的前提下改善其可读性和可修改性。</li>
</ul>


<hr />

<ul>
<li><strong>Q: a quest for quality.</strong> Here I changed the specifications of what the program should output from given input, when I learned how to improve the typographic appearance of the output.</li>
<li><strong>精益求精</strong>：在对字体版式有了更深入的理解之后，我对程序进行修改，以获得更好的输出效果。</li>
</ul>


<hr />

<ul>
<li><strong>R: a reinforcement of robustness.</strong> Whenever I realized that TEX could loop or crash in the presence of certain erroneous input, I tried to make the code bulletproof.</li>
<li><strong>百毒不侵</strong>：一旦我意识到TEX有可能在极端情况下崩溃，我就会想方设法使程序变的更加健壮。</li>
</ul>


<hr />

<ul>
<li><strong>S: a surprising scenario.</strong> Errors of type S were particularly bad bugs that forced me to change my original ideas, because of unforeseen interactions between various parts of the program.</li>
<li><strong>出乎意料</strong>：由于我最初对问题的定义或是对程序间模块的交互理解不足，导致一些无法预见的错误——这类错误往往很棘手。</li>
</ul>


<hr />

<ul>
<li><strong>T: a trivial typo.</strong> Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</li>
<li><strong>粗心大意</strong>：我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</li>
</ul>


<hr />

<h2>进一步的分类</h2>

<h3>Knuth随后将这15个分类分为两大类：</h3>

<ul>
<li><strong>不可胜算</strong>、<strong>鬼使神差</strong>、<strong>差之毫厘</strong>、<strong>丢三落四</strong>、<strong>言非所指</strong>、<strong>事与愿违</strong>、<strong>百毒不侵</strong>、<strong>出乎意料</strong>和<strong>粗心大意</strong>属于程序的差错（Bugs）。</li>
<li><strong>得心应手</strong>、<strong>多快好省</strong>、<strong>虚怀若谷</strong>、<strong>各得其所</strong>、<strong>焕然一新</strong>和<strong>精益求精</strong>属于对程序的改进（Enhancements）。</li>
</ul>


<h3>然后按复杂程度把差错（Bugs）分为三类：</h3>

<h4>简单的差错</h4>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<h4>复杂的差错</h4>

<ul>
<li><strong>不可胜算</strong>：算法设计不当。</li>
<li><strong>差之毫厘</strong>：数据结构维护不周。</li>
</ul>


<h4>棘手的差错</h4>

<ul>
<li><strong>百毒不侵</strong>：对错误输入处理不当而造成的问题。</li>
<li><strong>出乎意料</strong>：由于对问题的理解不足，从而导致各种诡异的问题。</li>
</ul>


<h2><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>的不足</h2>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对TEX的错误进行了详细的分析，并对这些错误进行了系统的分类，但我认为这篇文章仍有一些不足：</p>

<ol>
<li>Knuth并未对编程错误给出应对策略。</li>
<li><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文成于1989年，其中记载的是1978年至1982年Knuth开发TEX时碰到的各种问题——30年前的编程语言和现在严重脱节。</li>
</ol>


<p>所以，我打算（不自量力的）结合自己的经验，在Knuth的分析基础上再进一步——从下篇开始，我会为每一类编程错误给出其案例，诱因和应对策略。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——0. Knuth, Tex, and the Errors of TEX]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-0/"/>
    <updated>2014-06-23T15:14:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-0</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<p>原本我计划在一篇文章完成所有内容，然而随着写作的深入，我发现文章的篇幅越来越长——考虑到可读性，我决定将这篇文章拓展为一个系列，计划如下：</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li>A Taxonomy of Programming Errors</li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<!-- more -->


<h2>免责声明（Disclaimer）</h2>

<p>几天前我在知乎上读到一篇关于Swift的<a href="http://www.zhihu.com/question/24002984">讨论</a>：</p>

<p>胡搅蛮缠</p>

<p><img src="http://i.imgur.com/ezV72EP.png" alt="讨论1" /></p>

<p>无知者无畏</p>

<p><img src="http://i.imgur.com/XXo9TlC.png" alt="讨论2" /></p>

<p>为了避免无谓的讨论，如果您认为iPhone系统闹钟可以用200行代码搞定，或者觉着Python适合编写大型项目，那么这个系列不适合您阅读。</p>

<h2>编程错误（Programming Errors）</h2>

<p>作为软件开发者，我自己写过一些微型程序（500行左右）和一些中小型应用（5&#8217;000~20&#8217;000行），实习时做过一些小项目（2&#8217;000行左右），到现在参与大型项目（100&#8217;000行以上）。如果让我总结这些项目的共同点，那么就是我在这些项目里都犯了各式各样的错误——小到喜闻乐见的&#8221;烫烫烫烫烫烫烫烫&#8221;，大到破坏整个应用兼容性导致上千用户流失，有的错误很愚蠢，有的错误则是聪明反被聪明误。</p>

<p>不过我可以安慰自己，因为我并非孤独——计算机程序向来以错误百出而臭名昭著，以至于计算机先驱<a href="http://en.wikipedia.org/wiki/Grace_hopper">Grace Hopper</a>近乎自嘲的为计算机程序错误取了一个别名——Bug。在之后的六十余年，Bug和其衍生词Debug一直是了所有程序员的梦魇。</p>

<p>Grace Hopper发现的“Bug”</p>

<p><img src="http://i.imgur.com/m36RhHW.jpg" alt="第一个Bug" /></p>

<p>随着经验的累积，我隐隐感觉到这些编程错误有一定的规律，因为我开始发现一些错误似乎在哪里见过，于是我开始寻找这方面的书籍和文献，以控制/减少自己的编程错误。</p>

<blockquote><p>Those who cannot remember the past are condemned to repeat it.</p>

<p>George Santayana</p></blockquote>

<p>然后我找到了<a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>的<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>。</p>

<h2>the Errors of TEX</h2>

<h3>背景</h3>

<p><img src="http://i.imgur.com/UF1uTSy.jpg" alt="Knuth" /></p>

<p>相信任何学计算机的人都知道Knuth和他神话（或神化）般（的<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>七卷本（未完成），但对Knuth开发的TEX以及Knuth开发TEX的流程可能就不是那么了解了，所以我在这里简单介绍下。</p>

<p><img src="http://i.imgur.com/3HzERY5.jpg" alt="TAOCP" /></p>

<p>撰写并出版<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>前三卷之后，Knuth发现印刷排版烂的一逼，在没有好使的数字排版系统的情况下，Knuth决定自己搞一个出来——于是就有了TEX。</p>

<p><img src="http://i.imgur.com/e6FqiCM.jpg" alt="TEX" /></p>

<p>不过排版系统并非简单的（Trivial）系统，即便如Knuth此般异禀天赋，也无法从容应付——事实上Knuth在开发TEX的过程中遇到了大量的错误，这些错误从TEX初版（1978年）到<a href="http://tug.org/TUGboat/tb35-1/tb109knut.pdf">最近的一次性能调优</a>（2014年），源源不断，挥之不去。</p>

<p>这些错误让Knuth很头痛，为了理解并控制编程错误，Knuth将这些错误整理到记录日志，并对这些编程错误进行分类，这成为了<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文的基础。</p>

<h3>插曲</h3>

<p>Knuth开发TEX的流程在我等屌丝码农看来绝对匪夷所思，在<a href="http://www.codersatwork.com/">Coders at Work</a>一书对Knuth的访谈里，Knuth提到：</p>

<blockquote><p>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>

<p>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p></blockquote>

<p>尽管有可能是1978年还没有好用的交互编程环境（Interactive Programming Environment），但Knuth六个月纸上设计纸上写代码的开发方式仍可以说是编程史上的一朵奇葩。如果放到今天，Knuth一定会被各路敏捷极限TDD编程<em>高手</em>喷出翔。</p>

<p>插曲到此为止，下篇进入正题——编程错误的分类（A Taxonomy of Programming Errors）。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——0. Prologue]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-0-prologue/"/>
    <updated>2014-06-06T15:06:06-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-0-prologue</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<em>设计</em>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<p>此外，副标题里使用<strong>Prologue</strong>，主要是因为我接下来提到的产品（设计）大多没有中文名——为了一致，我决定在这一系列所有文章的副标题中统一使用英文。</p>

<p>最后，这一系列博文和原研哉的<a href="http://book.douban.com/subject/1336111/">設計中的設計</a>无关，尽管它们名字相同。</p>

<h2>为什么要写这个系列？</h2>

<p>作为一个码农，按理说我应该和设计绝缘——设计是美工的事情嘛，码农负责写好代码就成。事实上我之前也一直这么认为。</p>

<!-- more -->


<p>但在三年前我这个看法被动摇了——2011年是国内移动互联网井喷的一年，随着iPhone及其模仿者的大行其道，曾经的手机王者Nokia被迅速的淘汰出市场；随着手机应用开发门槛的降低（从Symbian到iOS或Android），各种手机应用喷涌而出。</p>

<p>在这段时间我编写了一些手机应用，并通过QQ群，邮件列表以及论坛等渠道直接与用户交流，在这个过程中，我悲观的发现用户的思维模式和我（开发者）的思维模式完全不同，我认为理所当然的东西他们认为不可理喻，反之亦然。</p>

<p>在那段时间里我一度绝望的认为所有的用户都是神经病、弱智或是某些代谢产物，后来在Microsoft ATC实习时结识了几个设计师朋友（<a href="http://weibo.com/u/3848053360">@Xing</a>和<a href="http://weibo.com/u/2104950751">@Yan</a>），我向他们大吐苦水，他们则非常腹黑的讲了一个笑话：</p>

<blockquote><p>丈夫驾车出门。妻子在家听广播，听到一则报道，妻子连忙拿起电话。</p>

<p>妻子：老公啊，我刚听广播上说，高速公路上有一辆车在逆行，你千万要小心。</p>

<p>老公：哪是一辆啊，我看有好几百辆车都在逆行。</p></blockquote>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/hei.png" alt="黑" /></p>

<p>被善意的黑出翔之后，我认为我不能这样一直逆行下去——于是我开始天天死皮赖脸的向他们请教：从设计的原则，到设计的书籍，再到用户的心理，我强迫自己跳出码农的思维模式，像正常人一样思考。</p>

<p>感谢他们的指导，尽管我无法成为像他们一样专业的优秀设计师，但我形成了一个大体的设计观：比如一个好设计应该是什么样子，而一个烂设计又应该是什么样子。</p>

<p>在这个设计观的指引下，接下来我编写的手机应用都获得了不错的评价（几乎全五星），在做私活时也总能做出令客户满意的产品。</p>

<h2>优秀的产品&amp;杰出的设计</h2>

<p>在朋友的推荐下，最近把《道德经》看了一遍，我认为《道德经》里面的一段文字可以套用在产品和设计上：</p>

<blockquote><p>太上，不知有之；</p>

<p>其次，亲而誉之；</p>

<p>其次，畏之；</p>

<p>其次，侮之；</p>

<p>信不足焉，有不信焉。</p>

<p>—— 《道德经》 十七章</p></blockquote>

<p>把上面的文字应用到产品和设计：</p>

<ul>
<li>优秀的设计使用户专注于产品本身，而忽略设计的存在。（例如Google（搜索引擎）和iPad）</li>
<li>不错的设计使用户感到舒适，用户会称赞它的设计。（例如iPod Classic，<a href="http://www.parrot.com/zik/uk/">Parrot Zik</a>和Amazon Kindle）</li>
<li>马虎的设计使用户感到不适，用户很难掌握产品的功能。（例如早期版本的Microsoft Office，vim编辑器和JavaScript语言）</li>
<li>糟糕的设计会毁掉一个产品，用户会把产品和产品的设计骂出翔。（例如Nokia的Symbian触屏手机和绝大多数Linux桌面系统）</li>
</ul>


<p>需要注意，我在上面列举的产品都具有强大的功能——它们有的成功，有的失败，区别就在于设计。</p>

<h2>The Inmates are Running the Asylum</h2>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/inmates_asylum.jpg" alt="The Inmates are Running the Asylum" /></p>

<p><a href="http://www.amazon.com/The-Inmates-Are-Running-Asylum/dp/0672326140/">The Inmates are Running the Asylum</a>的全名是：The Inmates Are Running the Asylum : Why High Tech Products Drive Us Crazy and How to Restore the Sanity，直译成中文是：疯子开精神病院（为什么高科技产品总让我们抓狂以及如何打破这个窘境），可能是这个书名太惊悚，所以它的中文书名被分别译为<a href="http://book.douban.com/subject/1237849/">软件创新之路</a>（第一版）和<a href="http://book.douban.com/subject/1493316/">交互设计之路</a>（第二版）。</p>

<p>在这本书中，VB的创造者Alan Cooper创造性的把所有程序员黑了一遍——让程序员创造面向用户的软件，等价于让一群疯子开精神病院——因为能成为程序员的人思维本身就不正常：</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/ynm3000.png" alt="要你命3000" /></p>

<p>这是<a href="http://movie.douban.com/subject/1307739/">达文西</a>发明的要你命3000。</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/crazy_app.jpg" alt="要你命3000000000" /></p>

<p>这是程序员发明的要你命3000000000。</p>

<p>当然这本书不只是为了黑程序员，作者花了大量篇幅解释为什么现在的产品随着科技含量的提高反而愈发不好用，并提出了<a href="http://en.wikipedia.org/wiki/Interaction_design#Goal-oriented_design">认知摩擦（Cognitive friction）</a>、<a href="http://www.slideshare.net/PublishingTechnology/dancing-bears-pubtech">跳舞的熊（Dancing bear）</a>以及逻辑人（Homo logicus）等令人耳目一新的概念。总而言之，<a href="http://en.wikipedia.org/wiki/Interaction_design">交互设计（Interaction Design）</a>对于软件开发必不可少。</p>

<p>如果你是一个想做出好产品的程序员（码农），那么这本书值得一读——它会打破你现有的观念，让你意识到优秀的产品需要设计。就像我的朋友讲的那个笑话，它会让你意识到<strong>是你在逆行，而不是你面前的几百辆车在逆行。</strong></p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[来自苹果的编程语言——Swift简介]]></title>
    <link href="http://zh.lucida.me/blog/an-introduction-to-swift/"/>
    <updated>2014-06-02T18:22:19-07:00</updated>
    <id>http://zh.lucida.me/blog/an-introduction-to-swift</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>这篇文章简要介绍了苹果于<a href="https://developer.apple.com/wwdc/">WWDC 2014</a>发布的编程语言——Swift。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>

<h2>前言</h2>

<p>在这里我认为有必要提一下<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，Swift编程环境的大部分概念都源自于<a href="http://worrydream.com/">Bret</a>这个演讲。</p>

<p>接下来进入正题。</p>

<h2>Swift是什么？</h2>

<p>Swift是苹果于WWDC 2014发布的编程语言，这里引用<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>的原话：</p>

<blockquote><p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>

<p>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible and more fun.</p>

<p>Swift&rsquo;s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to imagine how software development works.</p>

<p>Swift is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</p></blockquote>

<p>简单的说：</p>

<ol>
<li>Swift用来写iOS和OS X程序。（估计也不会支持其它屌丝系统）</li>
<li>Swift吸取了C和Objective-C的优点，且更加强大易用。</li>
<li>Swift可以使用现有的Cocoa和Cocoa Touch框架。</li>
<li>Swift兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</li>
</ol>


<h2>Swift语言概览</h2>

<!-- more -->


<h3>基本概念</h3>

<p>注：这一节的代码源自<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>中的<em>A Swift Tour</em>。</p>

<h4>Hello, world</h4>

<p>类似于脚本语言，下面的代码即是一个完整的Swift程序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>变量与常量</h4>

<p>Swift使用<code>var</code>声明变量，<code>let</code>声明常量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">myVariable</span> <span class="p">=</span> <span class="m">42</span>
</span><span class='line'><span class="n">myVariable</span> <span class="p">=</span> <span class="m">50</span>
</span><span class='line'><span class="n">let</span> <span class="n">myConstant</span> <span class="p">=</span> <span class="m">42</span>
</span></code></pre></td></tr></table></div></figure>


<h4>类型推导</h4>

<p>Swift支持类型推导（Type Inference），所以上面的代码不需指定类型，如果需要指定类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">explicitDouble</span> <span class="p">:</span> <span class="n">Double</span> <span class="p">=</span> <span class="m">70</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift不支持隐式类型转换（Implicitly casting），所以下面的代码需要显式类型转换（Explicitly casting）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;The width is &quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">width</span> <span class="p">=</span> <span class="m">94</span>
</span><span class='line'><span class="n">let</span> <span class="n">labelWidth</span> <span class="p">=</span> <span class="n">label</span> <span class="p">+</span> <span class="n">String</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>字符串格式化</h4>

<p>Swift使用<code>\(item)</code>的形式进行字符串格式化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">apples</span> <span class="p">=</span> <span class="m">3</span>
</span><span class='line'><span class="n">let</span> <span class="n">oranges</span> <span class="p">=</span> <span class="m">5</span>
</span><span class='line'><span class="n">let</span> <span class="n">appleSummary</span> <span class="p">=</span> <span class="s">&quot;I have \(apples) apples.&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">fruitSummary</span> <span class="p">=</span> <span class="s">&quot;I have \(apples + oranges) pieces of fruit.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数组和字典</h3>

<p>Swift使用<code>[]</code>操作符声明数组（array）和字典（dictionary）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">shoppingList</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;catfish&quot;</span><span class="p">,</span> <span class="s">&quot;water&quot;</span><span class="p">,</span> <span class="s">&quot;tulips&quot;</span><span class="p">,</span> <span class="s">&quot;blue paint&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">shoppingList</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;bottle of water&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">occupations</span> <span class="p">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="s">&quot;Malcolm&quot;</span><span class="p">:</span> <span class="s">&quot;Captain&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;Kaylee&quot;</span><span class="p">:</span> <span class="s">&quot;Mechanic&quot;</span><span class="p">,</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="n">occupations</span><span class="p">[</span><span class="s">&quot;Jayne&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Public Relations&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般使用初始化器（initializer）语法创建空数组和空字典：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">emptyArray</span> <span class="p">=</span> <span class="n">String</span><span class="p">[]()</span>
</span><span class='line'><span class="n">let</span> <span class="n">emptyDictionary</span> <span class="p">=</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Float</span><span class="p">&gt;()</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果类型信息已知，则可以使用<code>[]</code>声明空数组，使用<code>[:]</code>声明空字典。</p>

<h3>控制流</h3>

<h4>概览</h4>

<p>Swift的条件语句包含<code>if</code>和<code>switch</code>，循环语句包含<code>for-in</code>、<code>for</code>、<code>while</code>和<code>do-while</code>，循环/判断条件不需要括号，但循环/判断体（body）必需括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">individualScores</span> <span class="p">=</span> <span class="p">[</span><span class="m">75</span><span class="p">,</span> <span class="m">43</span><span class="p">,</span> <span class="m">103</span><span class="p">,</span> <span class="m">87</span><span class="p">,</span> <span class="m">12</span><span class="p">]</span>
</span><span class='line'><span class="kt">var</span> <span class="n">teamScore</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">score</span> <span class="k">in</span> <span class="n">individualScores</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">score</span> <span class="p">&gt;</span> <span class="m">50</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">teamScore</span> <span class="p">+=</span> <span class="m">3</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">teamScore</span> <span class="p">+=</span> <span class="m">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>可空类型</h4>

<p>结合<code>if</code>和<code>let</code>，可以方便的处理可空变量（nullable variable）。对于空值，需要在类型声明后添加<code>?</code>显式标明该类型可空。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">optionalString</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="n">optionalString</span> <span class="p">==</span> <span class="n">nil</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">optionalName</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;John Appleseed&quot;</span>
</span><span class='line'><span class="kt">var</span> <span class="n">gretting</span> <span class="p">=</span> <span class="s">&quot;Hello!&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">name</span> <span class="p">=</span> <span class="n">optionalName</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">gretting</span> <span class="p">=</span> <span class="s">&quot;Hello, \(name)&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>灵活的switch</h4>

<p>Swift中的<code>switch</code>支持各种各样的比较操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">vegetable</span> <span class="p">=</span> <span class="s">&quot;red pepper&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;celery&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Add some raisins and make ants on a log.&quot;</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;cucumber&quot;</span><span class="p">,</span> <span class="s">&quot;watercress&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;That would make a good tea sandwich.&quot;</span>
</span><span class='line'><span class="k">case</span> <span class="n">let</span> <span class="n">x</span> <span class="k">where</span> <span class="n">x</span><span class="p">.</span><span class="n">hasSuffix</span><span class="p">(</span><span class="s">&quot;pepper&quot;</span><span class="p">):</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Is it a spicy \(x)?&quot;</span>
</span><span class='line'><span class="k">default</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Everything tastes good in soup.&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>其它循环</h4>

<p><code>for-in</code>除了遍历数组也可以用来遍历字典：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">interestingNumbers</span> <span class="p">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="s">&quot;Prime&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">13</span><span class="p">],</span>
</span><span class='line'>    <span class="s">&quot;Fibonacci&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span><span class="p">],</span>
</span><span class='line'>    <span class="s">&quot;Square&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">25</span><span class="p">],</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="kt">var</span> <span class="n">largest</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span> <span class="k">in</span> <span class="n">interestingNumbers</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">number</span> <span class="p">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">largest</span> <span class="p">=</span> <span class="n">number</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">largest</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>while</code>循环和<code>do-while</code>循环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="m">100</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">n</span> <span class="p">=</span> <span class="n">n</span> <span class="p">*</span> <span class="m">2</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">n</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">m</span> <span class="p">=</span> <span class="n">m</span> <span class="p">*</span> <span class="m">2</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="n">m</span> <span class="p">&lt;</span> <span class="m">100</span>
</span><span class='line'><span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift支持传统的<code>for</code>循环，此外也可以通过结合<code>..</code>（生成一个区间）和<code>for-in</code>实现同样的逻辑。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">firstForLoop</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="m">3</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">firstForLoop</span> <span class="p">+=</span> <span class="n">i</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">firstForLoop</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">secondForLoop</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">secondForLoop</span> <span class="p">+=</span> <span class="m">1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">secondForLoop</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：Swift除了<code>..</code>还有<code>...</code>：<code>..</code>生成前闭后开的区间，而<code>...</code>生成前闭后闭的区间。</p>

<h3>函数和闭包</h3>

<h4>函数</h4>

<p>Swift使用<code>func</code>关键字声明函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">day</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello \(name), today is \(day).&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">greet</span><span class="p">(</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过元组（Tuple）返回多个值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">getGasPrices</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="m">3.59</span><span class="p">,</span> <span class="m">3.69</span><span class="p">,</span> <span class="m">3.79</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">getGasPrices</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>支持带有变长参数的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">sumOf</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="n">Int</span><span class="p">...)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="p">+=</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sum</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">sumOf</span><span class="p">()</span>
</span><span class='line'><span class="n">sumOf</span><span class="p">(</span><span class="m">42</span><span class="p">,</span> <span class="m">597</span><span class="p">,</span> <span class="m">12</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数也可以嵌套函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">returnFifteen</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="m">10</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">y</span> <span class="p">+=</span> <span class="m">5</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">add</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">y</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">returnFifteen</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>作为头等对象，函数既可以作为返回值，也可以作为参数传递：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="m">1</span> <span class="p">+</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">addOne</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">increment</span> <span class="p">=</span> <span class="n">makeIncrementer</span><span class="p">()</span>
</span><span class='line'><span class="n">increment</span><span class="p">(</span><span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">hasAnyMatches</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">Int</span><span class="p">[],</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">list</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nf">condition</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">true</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="nf">lessThanTen</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">number</span> <span class="p">&lt;</span> <span class="m">10</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="m">20</span><span class="p">,</span> <span class="m">19</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">12</span><span class="p">]</span>
</span><span class='line'><span class="n">hasAnyMatches</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">lessThanTen</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>闭包</h4>

<p>本质来说，函数是特殊的闭包，Swift中可以利用<code>{}</code>声明匿名闭包：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">({</span>
</span><span class='line'>    <span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">result</span> <span class="p">=</span> <span class="m">3</span> <span class="p">*</span> <span class="n">number</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>    <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>当闭包的类型已知时，可以使用下面的简化写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="m">3</span> <span class="p">*</span> <span class="n">number</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外还可以通过参数的位置来使用参数，当函数最后一个参数是闭包时，可以使用下面的语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">sort</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">2</span><span class="p">])</span> <span class="p">{</span> <span class="err">$</span><span class="m">0</span> <span class="p">&gt;</span> <span class="err">$</span><span class="m">1</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类和对象</h3>

<h4>创建和使用类</h4>

<p>Swift使用<code>class</code>创建一个类，类可以包含字段和方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A shape with \(numberOfSides) sides.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建<code>Shape</code>类的实例，并调用其字段和方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">shape</span> <span class="p">=</span> <span class="n">Shape</span><span class="p">()</span>
</span><span class='line'><span class="n">shape</span><span class="p">.</span><span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">7</span>
</span><span class='line'><span class="kt">var</span> <span class="n">shapeDescription</span> <span class="p">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过<code>init</code>构建对象，既可以使用<code>self</code>显式引用成员字段（<code>name</code>），也可以隐式引用（<code>numberOfSides</code>）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numberOfSides</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A shape with \(numberOfSides) sides.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>deinit</code>进行清理工作。</p>

<h4>继承和多态</h4>

<p>Swift支持继承和多态（<code>override</code>父类方法）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Square</span><span class="p">:</span> <span class="n">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">sideLength</span>
</span><span class='line'>        <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">4</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">area</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sideLength</span> <span class="p">*</span> <span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A square with sides of length \(sideLength).&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">test</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">5.2</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;my test square&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">test</span><span class="p">.</span><span class="n">area</span><span class="p">()</span>
</span><span class='line'><span class="n">test</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：如果这里的<code>simpleDescription</code>方法没有被标识为<code>override</code>，则会引发编译错误。</p>

<h4>属性</h4>

<p>为了简化代码，Swift引入了属性（property），见下面的<code>perimeter</code>字段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">EquilateralTriangle</span><span class="p">:</span> <span class="n">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span> <span class="p">=</span> <span class="m">0.0</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">sideLength</span>
</span><span class='line'>        <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">var</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">get</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="m">3.0</span> <span class="p">*</span> <span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">set</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">/</span> <span class="m">3.0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;An equilateral triagle with sides of length \(sideLength).&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">triangle</span> <span class="p">=</span> <span class="n">EquilateralTriangle</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">3.1</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;a triangle&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">perimeter</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">perimeter</span> <span class="p">=</span> <span class="m">9.9</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：赋值器（setter）中，接收的值被自动命名为<code>newValue</code>。</p>

<h4>willSet和didSet</h4>

<p><code>EquilateralTriangle</code>的构造器进行了如下操作：</p>

<ol>
<li>为子类型的属性赋值。</li>
<li>调用父类型的构造器。</li>
<li>修改父类型的属性。</li>
</ol>


<p>如果不需要计算属性的值，但需要在赋值前后进行一些操作的话，使用<code>willSet</code>和<code>didSet</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">TriangleAndSquare</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">EquilateralTriangle</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">willSet</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">square</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">square</span><span class="p">:</span> <span class="n">Square</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">willSet</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">square</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">triangle</span> <span class="p">=</span> <span class="n">EquilateralTriangle</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">triangleAndSquare</span> <span class="p">=</span> <span class="n">TriangleAndSquare</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="m">10</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;another test shape&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">square</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">square</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">50</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;larger square&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而保证<code>triangle</code>和<code>square</code>拥有相等的<code>sideLength</code>。</p>

<h4>调用方法</h4>

<p>Swift中，函数的参数名称只能在函数内部使用，但方法的参数名称除了在内部使用外还可以在外部使用（第一个参数除外），例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">incrementBy</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">numberOfTimes</span> <span class="n">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">count</span> <span class="p">+=</span> <span class="n">amount</span> <span class="p">*</span> <span class="n">times</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">counter</span> <span class="p">=</span> <span class="n">Counter</span><span class="p">()</span>
</span><span class='line'><span class="n">counter</span><span class="p">.</span><span class="n">incrementBy</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">numberOfTimes</span><span class="p">:</span> <span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意Swift支持为方法参数取别名：在上面的代码里，<code>numberOfTimes</code>面向外部，<code>times</code>面向内部。</p>

<h4>?的另一种用途</h4>

<p>使用可空值时，<code>?</code>可以出现在方法、属性或下标前面。如果<code>?</code>前的值为<code>nil</code>，那么<code>?</code>后面的表达式会被忽略，而原表达式直接返回<code>nil</code>，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">optionalSquare</span><span class="p">:</span> <span class="n">Square</span><span class="p">?</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">2.5</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;optional </span>
</span><span class='line'><span class="n">square</span><span class="s">&quot;)</span>
</span><span class='line'><span class="n">let</span> <span class="n">sideLength</span> <span class="p">=</span> <span class="n">optionalSquare</span><span class="p">?.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>当<code>optionalSquare</code>为<code>nil</code>时，<code>sideLength</code>属性调用会被忽略。</p>

<h3>枚举和结构</h3>

<h4>枚举</h4>

<p>使用<code>enum</code>创建枚举——注意Swift的枚举可以关联方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">Rank</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Ace</span> <span class="p">=</span> <span class="m">1</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Two</span><span class="p">,</span> <span class="n">Three</span><span class="p">,</span> <span class="n">Four</span><span class="p">,</span> <span class="n">Five</span><span class="p">,</span> <span class="n">Six</span><span class="p">,</span> <span class="n">Seven</span><span class="p">,</span> <span class="n">Eight</span><span class="p">,</span> <span class="n">Nine</span><span class="p">,</span> <span class="n">Ten</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Jack</span><span class="p">,</span> <span class="n">Queen</span><span class="p">,</span> <span class="n">King</span>
</span><span class='line'>        <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Ace</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;ace&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Jack</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;jack&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Queen</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;queen&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">King</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;king&quot;</span>
</span><span class='line'>            <span class="k">default</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="nf">String</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">toRaw</span><span class="p">())</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">ace</span> <span class="p">=</span> <span class="n">Rank</span><span class="p">.</span><span class="n">Ace</span>
</span><span class='line'><span class="n">let</span> <span class="n">aceRawValue</span> <span class="p">=</span> <span class="n">ace</span><span class="p">.</span><span class="n">toRaw</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>toRaw</code>和<code>fromRaw</code>在原始（raw）数值和枚举值之间进行转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">convertedRank</span> <span class="p">=</span> <span class="n">Rank</span><span class="p">.</span><span class="n">fromRaw</span><span class="p">(</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">threeDescription</span> <span class="p">=</span> <span class="n">convertedRank</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意枚举中的成员值（member value）是实际的值（actual value），和原始值（raw value）没有必然关联。</p>

<p>一些情况下枚举不存在有意义的原始值，这时可以直接忽略原始值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">Suit</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Spades</span><span class="p">,</span> <span class="n">Hearts</span><span class="p">,</span> <span class="n">Diamonds</span><span class="p">,</span> <span class="n">Clubs</span>
</span><span class='line'>        <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Spades</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;spades&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Hearts</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;hearts&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Diamonds</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;diamonds&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Clubs</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;clubs&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">hearts</span> <span class="p">=</span> <span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span>
</span><span class='line'><span class="n">let</span> <span class="n">heartsDescription</span> <span class="p">=</span> <span class="n">hearts</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了可以关联方法，枚举还支持在其成员上关联值，同一枚举的不同成员可以有不同的关联的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">ServerResponse</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Result</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Error</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">success</span> <span class="p">=</span> <span class="n">ServerResponse</span><span class="p">.</span><span class="n">Result</span><span class="p">(</span><span class="s">&quot;6:00 am&quot;</span><span class="p">,</span> <span class="s">&quot;8:09 pm&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">failure</span> <span class="p">=</span> <span class="n">ServerResponse</span><span class="p">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Out of cheese.&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">success</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="p">.</span><span class="n">Result</span><span class="p">(</span><span class="n">sunrise</span><span class="p">,</span> <span class="n">sunset</span><span class="p">):</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">serverResponse</span> <span class="p">=</span> <span class="s">&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="p">.</span><span class="n">Error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">serverResponse</span> <span class="p">=</span> <span class="s">&quot;Failure... \(error)&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>结构</h4>

<p>Swift使用<code>struct</code>关键字创建结构。结构支持构造器和方法这些类的特性。结构和类的最大区别在于：结构的实例按值传递（passed by value），而类的实例按引用传递（passed by reference）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">struct</span> <span class="nc">Card</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">rank</span><span class="p">:</span> <span class="n">Rank</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">suit</span><span class="p">:</span> <span class="n">Suit</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">threeOfSpades</span> <span class="p">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">rank</span><span class="p">:</span> <span class="p">.</span><span class="n">Three</span><span class="p">,</span> <span class="n">suit</span><span class="p">:</span> <span class="p">.</span><span class="n">Spades</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">threeOfSpadesDescription</span> <span class="p">=</span> <span class="n">threeOfSpades</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>协议（protocol）和扩展（extension）</h3>

<h4>协议</h4>

<p>Swift使用<code>protocol</code>定义协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">protocol</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型、枚举和结构都可以实现（adopt）协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">SimpleClass</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;A very simple class.&quot;</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">anotherProperty</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">69105</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">simpleDescription</span> <span class="p">+=</span> <span class="s">&quot; Now 100% adjusted.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">SimpleClass</span><span class="p">()</span>
</span><span class='line'><span class="n">a</span><span class="p">.</span><span class="n">adjust</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">aDescription</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">simpleDescription</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="nc">SimpleStructure</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;A simple structure&quot;</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">simpleDescription</span> <span class="p">+=</span> <span class="s">&quot; (adjusted)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">SimpleStructure</span><span class="p">()</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">adjust</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">bDescription</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">simpleDescription</span>
</span></code></pre></td></tr></table></div></figure>


<h4>扩展</h4>

<p>扩展用于在已有的类型上增加新的功能（比如新的方法或属性），Swift使用<code>extension</code>声明扩展：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">extension</span> <span class="n">Int</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;The number \(self)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span> <span class="p">+=</span> <span class="m">42</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="m">7.</span><span class="n">simpleDescription</span>
</span></code></pre></td></tr></table></div></figure>


<h3>泛型（generics）</h3>

<p>Swift使用<code>&lt;&gt;</code>来声明泛型函数或泛型类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="n">repeat</span><span class="p">&lt;</span><span class="n">ItemType</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">ItemType</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ItemType</span><span class="p">[]</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">ItemType</span><span class="p">[]()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="n">times</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="p">+=</span> <span class="n">item</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">repeat</span><span class="p">(</span><span class="s">&quot;knock&quot;</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift也支持在类、枚举和结构中使用泛型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// Reimplement the Swift standard library&#39;s optional type</span>
</span><span class='line'><span class="k">enum</span> <span class="n">OptionalValue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">None</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">possibleInteger</span><span class="p">:</span> <span class="n">OptionalValue</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="n">None</span>
</span><span class='line'><span class="n">possibleInteger</span> <span class="p">=</span> <span class="p">.</span><span class="n">Some</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有时需要对泛型做一些需求（requirements），比如需求某个泛型类型实现某个接口或继承自某个特定类型、两个泛型类型属于同一个类型等等，Swift通过<code>where</code>描述这些需求：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="n">anyCommonElements</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span><span class="p">:</span> <span class="n">Equatable</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span> <span class="p">==</span> <span class="n">U</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span><span class="p">&gt;</span> <span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">lhsItem</span> <span class="k">in</span> <span class="n">lhs</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">rhsItem</span> <span class="k">in</span> <span class="n">rhs</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">lhsItem</span> <span class="p">==</span> <span class="n">rhsItem</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">true</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">anyCommonElements</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">],</span> <span class="p">[</span><span class="m">3</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift语言概览就到这里，有兴趣的朋友请进一步阅读<a href="">The Swift Programming Language</a>。</p>

<p>接下来聊聊个人对Swift的一些感受。</p>

<h2>个人感受</h2>

<p><strong>注意</strong>：下面的感受纯属个人意见，仅供参考。</p>

<h3>大杂烩</h3>

<p>尽管我接触Swift不足两小时，但很容易看出Swift吸收了大量其它编程语言中的元素，这些元素包括但不限于：</p>

<ol>
<li>属性（Property）、可空值（Nullable type）语法和泛型（Generic Type）语法源自C#。</li>
<li>格式风格与Go相仿（没有句末的分号，判断条件不需要括号）。</li>
<li>Python风格的当前实例引用语法（使用<code>self</code>）和列表字典声明语法。</li>
<li>Haskell风格的区间声明语法（比如<code>1..3</code>，<code>1...3</code>）。</li>
<li>协议和扩展源自Objective-C（自家产品随便用）。</li>
<li>枚举类型很像Java（可以拥有成员或方法）。</li>
<li><code>class</code>和<code>struct</code>的概念和C#极其相似。</li>
</ol>


<p>注意这里不是说Swift是抄袭——实际上编程语言能玩的花样基本就这些，况且Swift选的都是在我看来相当不错的特性。</p>

<p>而且，这个大杂烩有一个好处——就是任何其它编程语言的开发者都不会觉得Swift很陌生——这一点很重要。</p>

<h3>拒绝隐式（Refuse implicity）</h3>

<p>Swift去除了一些隐式操作，比如隐式类型转换和隐式方法重载这两个坑，干的漂亮。</p>

<h3>Swift的应用方向</h3>

<p>我认为Swift主要有下面这两个应用方向：</p>

<h4>教育</h4>

<p>我指的是编程教育。现有编程语言最大的问题就是交互性奇差，从而导致学习曲线陡峭。相信Swift及其交互性极强的编程环境能够打破这个局面，让更多的人——尤其是青少年，学会编程。</p>

<p>这里有必要再次提到<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，看了这个视频你就会明白一个交互性强的编程环境能够带来什么。</p>

<h4>应用开发</h4>

<p>现有的iOS和OS X应用开发均使用Objective-C，而Objective-C是一门及其繁琐（verbose）且学习曲线比较陡峭的语言，如果Swift能够提供一个同现有Obj-C框架的简易互操作接口，我相信会有大量的程序员转投Swift；与此同时，Swift简易的语法也会带来相当数量的其它平台开发者。</p>

<p>总之，上一次某家大公司大张旗鼓的推出一门编程语言及其编程平台还是在2000年（微软推出C#），将近15年之后，苹果推出Swift——作为开发者，我很高兴能够见证一门编程语言的诞生。</p>

<p>以上。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于锤子手机和锤子手机发布会]]></title>
    <link href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/"/>
    <updated>2014-05-24T01:33:38-07:00</updated>
    <id>http://zh.lucida.me/blog/on-the-keynote-of-t-one</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>本文记录了作者对<a href="http://v.youku.com/v_show/id_XNzE0Nzc0OTQ0.html">锤子手机发布会</a>和<a href="http://www.smartisan.com/">锤子手机</a>的一点感受，仅代表个人看法，但欢迎评论。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">http://zh.lucida.me/blog/on-the-keynote-of-t-one/</a></p>

<h2>重复</h2>

<p>演讲（或说服）有一个要点是重复，老罗显然深得此道，整场发布会下面的句式均被重复了不止五遍：</p>

<ul>
<li>作为一个大众消费品…………（表明自己站在消费者这边）</li>
<li>作为一个小厂商…………（博取听众（消费者）的同情（sympathy）和容忍（tolerance））</li>
<li>作为一个企业家，我不该…………（在贬低其它企业之后均以此句开脱）</li>
</ul>


<h2>误导</h2>

<p>在提到锤子手机音质时老罗举了这样的例子：</p>

<blockquote><p>我老婆之前认为自己是木耳，听不出音质的区别，但把苹果耳机换成几百森海塞尔后，她明显感到音质有了很大的提升。</p></blockquote>

<p>以证明即便是普通人也可以感受到音质的区别。</p>

<p>但这里有个问题：老罗夫人感受到的音质的提升源自于<strong>耳机</strong>，而非<strong>音源</strong>。在同等耳机的情况下，我怀疑老罗夫人是否还能听出锤子手机和同类手机间音质的区别。</p>

<p>此外，在提到无法更换壁纸的问题时老罗是这么解释的：</p>

<blockquote><p>我无法忍受把一堆图标堆在亲人的脸上。</p></blockquote>

<p>似乎确实很有道理，但再想一想，为什么一定要用亲人头像做壁纸呢？如果我要用风景或是纯色呢？</p>

<!-- more -->


<h2>冷知识</h2>

<p>老罗很擅长用一些冷门知识去吸引人，这样的例子在这次发布会上数不胜数：</p>

<ul>
<li>不断的列出硬件厂商的渊源。</li>
<li>指出锤子手机手机盒子使用了某英国著名公司的纸。</li>
<li>强调光线传感器的设计。</li>
<li>自带螺丝刀和若干螺丝钉。</li>
</ul>


<p>个人认为这些东西是Boilerplate——懂编程的童鞋应该明白我的意思。</p>

<h2>拍照效果</h2>

<p>老罗宣称锤子手机是目前最好的拍照手机之一，并花了大量时间去阐述他在打造拍照效果上所付出的努力，比如：</p>

<ul>
<li>寻找最好的拍照调校团队。</li>
<li>使用最好的摄像镜头。</li>
</ul>


<p>但令我疑惑的是：发布会并没有任何拍照效果的对比，甚至连锤子手机的拍照样张都没有——如果拍照效果真的那么强大，我不认为老罗会放这个贬低其他竞争对手的机会于不顾。</p>

<h2>双音量键</h2>

<p>锤子手机有一个很有趣的设计是双音量键——在单独使用时可以分别作为音量调节和亮度调节使用，而一起使用时则可以进行抢拍或快速启动某个指定应用程序。</p>

<p>这也带来了老罗所宣称的“全世界最快的抢拍手机”这个卖点。</p>

<p>但我还是有几个疑问：</p>

<ol>
<li>双音量键一起使用是一个很不直观的设计。</li>
<li>同时使用双音量键很不自然，不信的话你在你的手机上试试这个姿势。</li>
<li>从设计图上可以看出音量键并没有明显凸起——这意味着操作时需要按<strong>进</strong>音量键，也意味着任何手机壳或是bumper之类阻隔音量键的手机饰品均会妨碍音量键的正常使用。</li>
</ol>


<h2>对苹果的模仿</h2>

<h3>锤子手机在模仿iPhone5</h3>

<p>这里借用某条<a href="http://weibo.com/1847542877/B5fhi9RoE">微博</a>里的图片：</p>

<p><img src="http://i.imgur.com/VOSZ1dX.jpg" alt="无处不在的模仿" /></p>

<h3>锤子手机发布会处处在模仿iPhone1发布会</h3>

<p>iPhone1发布会时Jobs曾给出一个转盘手机的假想图：</p>

<p><img src="http://i.imgur.com/sfOzhfx.png" alt="转盘手机" /></p>

<p>老罗则给出一个锤子手机的假想图：</p>

<p><img src="http://i.imgur.com/fkoM9QQ.png" alt="锤子手机" /></p>

<p>iPhone1发布时Jobs强调三位一体的概念：</p>

<p><img src="http://i.imgur.com/WDmytpx.png" alt="三位一体" /></p>

<p>老罗也是如此：</p>

<p><img src="http://i.imgur.com/FK5fsC2.png" alt="又一个三位一体" /></p>

<p>Jobs经常在发布会最后来一个“One more thing”：</p>

<p><img src="http://i.imgur.com/ebmQPgi.png" alt="One more thing" /></p>

<p>到了老罗这里变成“还有两个好东西”：</p>

<p><img src="http://i.imgur.com/6yXVZ4a.png" alt="还有两个好东西" /></p>

<h2>软件改进</h2>

<p>下面是老罗重点介绍的锤子手机的软件改进：</p>

<ul>
<li>可以更换的主题：这个我真觉的不是啥改进——除非要和Windows Phone比。</li>
<li>手指横扫解决单手操作问题：很有创意的想法，但我注意到即便老罗本人如此操作锤子手机时也有相当的失误率——我怀疑这个功能的实用性。</li>
<li>通过短信内容智能新建日历：无论是Google还是Apple都已经有这个功能。</li>
<li>定时解除静音：很赞，这是我一直希望的功能。</li>
<li>区域截屏：看似很赞，但仔细一想几乎所有的手机聊天应用里面都带有编辑图片的选项，此外我个人对这个功能的稳定性有疑问。</li>
</ul>


<h2>总结</h2>

<p>锤子手机发布会最大的亮点是对OpenSSL的捐款，至于锤子手机本身……抱歉我没看到什么亮点。</p>

<p>但令我诧异的是很多资深人士纷纷表示看好锤子手机（发布会），<a href="http://www.weibo.com/fenng">fenng</a>甚至在微信上宣称这是手机行业迄今为止最好的产品发布会——</p>

<p><img src="http://i.imgur.com/MqEKRBk.jpg" alt="最好的产品发布会？？" /></p>

<p>我不清楚他是否也把iPhone发布会算在内。</p>

<p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress，就这场发布会所得到的信息，我依然认为锤子手机没有希望。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打飞机故事集]]></title>
    <link href="http://zh.lucida.me/blog/stories-of-masturbations/"/>
    <updated>2014-05-06T16:54:37-07:00</updated>
    <id>http://zh.lucida.me/blog/stories-of-masturbations</id>
    <content type="html"><![CDATA[<h2>免责声明（Disclamer）</h2>

<p><img src="http://i.imgur.com/ppEA9uM.jpg" alt="少儿不宜" /></p>

<p>本文包含大量三俗内容，18岁以下少年儿童请勿阅读，或者请在家长指导下阅读。</p>

<h2>关于</h2>

<p><img src="http://i.imgur.com/JzkPabq.jpg" alt="打飞机英雄集" /></p>

<p>本文记录了本屌这些年打飞机的所见所闻，希望能够对众屌有所启发，也欢迎大家留言讨论分享经验。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/stories-of-masturbations/">http://zh.lucida.me/blog/stories-of-masturbations/</a></p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<!-- more -->


<h2>水浒</h2>

<p><img src="http://i.imgur.com/QLWDwi1.jpg" alt="98版水浒传" /></p>

<p><a href="http://baike.baidu.com/subview/2578/4991919.htm#viewPageContent">98版水浒传</a>创造了无数的经典，同时也是那个年代少年儿童的性教育启蒙片：作为当时为数不多的带有床戏的而且可以在电视播放的电视剧——要知道那个年代没有迅雷没有BT。而且水浒中某些桥段放在现在也毫不逊色：</p>

<p><img src="http://i.imgur.com/KG0EJQ4.jpg" alt="剧照1" /></p>

<p><img src="http://i.imgur.com/6R5CHHY.jpg" alt="剧照2" /></p>

<p>过去的电视节目十分贫乏——所以往往同一部电视剧会被放上两遍甚至三遍，第一天晚上一遍，第二天上午一遍，第二天下午又一遍，晚上粑粑麻麻在所以孩子是不能看这些三俗的，所以只能白天趁粑粑麻麻上班出门的时候独自赏析。</p>

<p>至今记得当时重播西门大战金莲那集时，本屌半个班都空了——只剩一半是女生，当时班主任以为这帮混小子要组团去哪里搞事，吓的挨个给家长打电话，但却得知这帮小子都在家里，班主任至今百思不得其解。</p>

<p><img src="http://i.imgur.com/CzsOdlo.jpg" alt="剧照" /></p>

<p>殊不知众屌全守在电视机前等西门叔叔和金莲姐姐呢。</p>

<h2>暖手</h2>

<p><img src="http://i.imgur.com/zVUPYfA.jpg" alt="害羞" /></p>

<p>六年级寒假时本屌参加作文培训班，在捡地上的笔时发现后面的姐姐一脸潮红的把手插在身边哥哥的裤裆里，当时就觉着这个哥哥好伟大，天这么冷还给这个姐姐暖手。</p>

<h2>收音</h2>

<p>初中之后本屌发现一些小电视台经常会在午夜播放一些略劲爆的港台影视剧，其尺度甚至较之水浒传中杨雄老婆勾和尚还要大胆——但问题是电视在本屌粑粑的屋里，如果本屌把电视打开声音放出来肯定会被粑粑打个半死。</p>

<p>但没有声音再好的戏也出不来。</p>

<p><img src="http://i.imgur.com/kVrmN7r.jpg" alt="掩面" /></p>

<p>忧郁了两天之后，本屌在百无聊赖中想出了一个奇法——收音机——把收音机调到电视台里面的频道频段，然后插上耳机。</p>

<p><img src="http://i.imgur.com/b93H0gE.jpg" alt="大拇指" /></p>

<p>天籁之音，效果怒赞，尽管时常音画异步。</p>

<h3>盗版</h3>

<p>初中时经常组团去高富帅A君家里看爱情动作片——</p>

<ol>
<li>A君家里既有一部大号电视，又有两个几乎和我们一般高的音箱，如同一个小型影院一般。</li>
<li>A君父母做生意，周末经常不在家。</li>
</ol>


<p>于是每次都看的如痴如醉，流连忘返，直到之后的盗版事件：</p>

<p>正看到黑白双方难解难分，突然听到楼道里有声音，我擦A君的粑粑回来了！众屌忙提上裤子，关上电视，正襟危坐。</p>

<p>A君粑粑进来看，发现众屌面部呆滞：</p>

<p><img src="http://i.imgur.com/uLRMnR3.jpg" alt="呆滞" /></p>

<p>A君粑粑觉得有必要缓解下气氛：“小朋友们看电视哈”。</p>

<p><img src="http://i.imgur.com/kVrmN7r.jpg" alt="掩面" /></p>

<p>“尼玛这放的什么东西！！”</p>

<p>“电……电…………电影………………”</p>

<p>“什么电影！！？”</p>

<p>“……………………盗版电影”</p>

<h2>百米</h2>

<p>初中生物老师是个极其猥琐的中年胖子，别的老师讲人体生殖系统顶多讲20分钟，这个家伙一讲讲了三周。还提到男性XX一次是非常剧烈的运动——相当于<strong>冲刺100米</strong>或是<strong>慢跑500米</strong>。</p>

<p>然后就有了如下对话：</p>

<p>“昨天晚上小跑了1500米，你呢？”</p>

<p>“还是你猛，我冲刺到200米就顶不住了……”</p>

<h2>速眠</h2>

<p>高考前压力很大，成绩不稳定，晚上经常失眠，心神不宁。</p>

<p>后来发现每次飞机之后睡的都很沉。</p>

<p>又发现蹲一小会站起来会头晕目眩。</p>

<p>如果把飞机和蹲起结合在一起会发生什么呢？</p>

<p>于是本屌在床前尝试了一次，直接双眼一黑晕倒在床，直到第二天才来，精神百倍。</p>

<p>于是蹲撸速眠成了本屌的新技能——每逢大考小考前日使用一次，次日成绩极佳。</p>

<h2>动物</h2>

<p>大一寒假后回到学校，路过大连火车站时感觉有人尾随，警觉的回头一看是位猥琐大妈：</p>

<p>“小伙要片吗”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>擦，哥硬盘里多着呢，继续往前走。</p>

<p>“要日本的吗？”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>尼玛烦不烦，继续前行。</p>

<p>“要不欧美的？”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>我擦要不要这么专业，继续前行。</p>

<p>“动物的也有！”</p>

<p><img src="http://i.imgur.com/Oabz9Rv.jpg" alt="纳尼" /></p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的算法学习之路]]></title>
    <link href="http://zh.lucida.me/blog/on-learning-algorithms/"/>
    <updated>2014-05-04T13:43:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-learning-algorithms</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>严格来说，本文题目应该是<strong>我的数据结构和算法学习之路</strong>，但这个写法实在太绕口——况且CS中的算法往往暗指数据结构和算法（例如<strong>算法导论</strong>指的实际上是<strong>数据结构和算法导论</strong>），所以我认为本文题目是合理的。</p>

<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/">http://zh.lucida.me/blog/on-learning-algorithms/</a></p>

<p>原文作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<h3>这篇文章讲了什么？</h3>

<ul>
<li>我这些年学习数据结构和算法的总结。</li>
<li>一些不错的算法书籍和教程。</li>
<li>算法的重要性。</li>
</ul>


<h2>初学</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的&#8221;学长&#8221;和&#8221;大神&#8221;请教应该读哪些算法书籍，&#8221;学长&#8221;们均推荐算法导论，还有几个&#8221;大神&#8221;推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了<a href="http://www.douban.com/">豆瓣</a>这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些&#8221;学长&#8221;或是&#8221;大神&#8221;靠谱的多得多。</p>

<!-- more -->


<h3>数据结构与算法分析——C语言描述</h3>

<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt="数据结构与算法分析——C语言描述" /></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N<sup>3</sup>)杀到O(N<sup>2</sup>)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h3>微软的梦工厂</h3>

<p><img src="http://img3.douban.com/lpic/s3322643.jpg" alt="微软的梦工厂" /></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了&#8221;找工作就要这样的公司&#8221;的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己&#8221;毕业就工作&#8221;的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h3>算法设计与分析</h3>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://img3.douban.com/lpic/s2019521.jpg" alt="算法设计与分析基础" /></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具。</p>

<h3>算法引论</h3>

<p><img src="http://img5.douban.com/lpic/s4230097.jpg" alt="算法引论" /></p>

<p><a href="http://book.douban.com/subject/4178907/">算法引论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://img3.douban.com/lpic/s2019521.jpg">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ol>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ol>


<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h3>百度实习面试</h3>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个<code>stof</code>（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li>原来自己连百度实习面试都过不去。</li>
<li>原来自己还是一个编程弱逼。</li>
<li>原来自己还是一个算法菜逼。</li>
</ul>


<p>痛定思痛，我开始了第二个&#8221;五年计划&#8221;，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h3>Elements of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s4243636.jpg" alt="Elements of Programming" /></p>

<p>由于一直觉得名字里带&#8221;Elements of&#8221;的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h3>C Interfaces and Implementation</h3>

<p><img src="http://img5.douban.com/lpic/s1686769.jpg" alt="C Interfaces and Implementation" /></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826292/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的<a href="http://www.amazon.com/review/RMXKDJNH8UOPU/">评论</a>：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是<code>stof</code>这种简单到爆的&#8221;算法&#8221;。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——<strong>纸上编码</strong>。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的<a href="http://book.douban.com/review/3733680/">文章</a>来黑那些动不动就&#8221;基础&#8221;或&#8221;内功&#8221;的所谓&#8221;大牛&#8221;们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote><p>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</p></blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸。</p>

<h3>LL(k)</h3>

<p>我在微软实习的第一个项目做的是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>分析——计算T-SQL存储过程的代码覆盖率。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://img5.douban.com/lpic/s24921197.jpg" alt="Language Implementation Patterns" /></p>

<p>比较奇诡的是，做这个项目时当时我刚好把<a href="http://www.antlr.org/">ANTLR</a>作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h3>拼音索引</h3>

<p>拼音索引是我接的一个手机应用私活里的小模块，用户期待在手机文本框可以根据输入给出智能提示：</p>

<p>比如说输入中国：</p>

<p><img src="http://i.imgur.com/tjKjyzN.png" alt="智能提示" /></p>

<p>同样，输入拼音也应给出提示：</p>

<p><img src="http://i.imgur.com/zTjEBik.png" alt="智能提示" /></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ol>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用<code>Int16</code>索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用<code>Int64</code>建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个<code>Int64</code>里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ol>


<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，<strong>如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞</strong>。</p>

<h3>快速字符串匹配</h3>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找&#8221;张晓明&#8221;，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。</p>

<p><img src="http://i.imgur.com/R3JalOH.jpg" alt="E51" /></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><img src="http://i.imgur.com/Pfff0e9.jpg" alt="Cry" /></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://img3.douban.com/lpic/s8978030.jpg" alt="Algorithms on Strings, Trees and Sequences" /></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h3>Writing Efficient Programs</h3>

<p>之后又做了若干个项目，多多少少都用到了&#8221;自制&#8221;的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种<strong>将有限计算资源发挥到极致</strong>的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://img3.douban.com/lpic/s3780111.jpg" alt="Writing Efficient Programs" /></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了<strong>过早优化是万恶之源</strong>之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h3>Algorithm Design Manual</h3>

<p><img src="http://img3.douban.com/lpic/s10347625.jpg" alt="Algorithm Design Manual" /></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3072383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h3>编程珠玑&amp;更多的编程珠玑</h3>

<p><img src="http://img3.douban.com/lpic/s2712842.jpg" alt="Programming Pearls" /></p>

<p><img src="http://img3.douban.com/lpic/s7073511.jpg" alt="More Programming Pearls" /></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h3>The Science of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s2812798.jpg" alt="The Science of Programming" /></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>引用的书籍，撸完<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>之后，本屌获得了<strong>证明简单代码段的正确性</strong>这个技能——求职面试三板斧之二。</p>

<p><strong>证明简单代码段的正确性</strong>是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的<a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">博客</a>，总之就是<strong>项目经历</strong>、<strong>纸上代码</strong>加<strong>正确性证明</strong>这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称<strong>拼写</strong>出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h3>Algorithms 4th</h3>

<p><img src="http://img5.douban.com/lpic/s8938479.jpg" alt="Algorithms" /></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h3>6.851 Advanced Data Structures</h3>

<p><img src="http://courses.csail.mit.edu/6.851/spring12/illus.png" alt="Advanced Data Structures" /></p>

<p><a href="http://courses.csail.mit.edu/6.851/">Advanced Data Structures</a>是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google <strong>Advanced Data Structures</strong>第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带&#8221;记忆&#8221;的数据结构（Data Structure with Persistence）。</li>
<li>van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。</li>
<li>o(1)时间复杂度的的LCA、RMQ和LA解法。</li>
<li>奇幻的o(n)时间复杂度的Suffix Tree构建方法。</li>
<li>o(lglgn)的BST。</li>
<li>&hellip;</li>
</ul>


<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决<strong>实际</strong>问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p><a href="http://norvig.com/">Peter Norvig</a>曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：</p>

<blockquote><p>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：</p>

<blockquote><p>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</p></blockquote>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>

<p>By <a href="http://zh.lucida.me">Lucida</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习&使用技术的四种层次]]></title>
    <link href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/"/>
    <updated>2014-04-12T17:53:21-07:00</updated>
    <id>http://zh.lucida.me/blog/levels-on-learning-and-using-technologies</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>技术，生活，反思。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/</a></p>

<h2>关于</h2>

<p>Bjarne Stroustrup在他的新书《<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A tour of C++</a>》</p>

<p><img src="http://i.imgur.com/VlQ7ROA.jpg" alt="A tour of C++" style="max-height: 370px;"/></p>

<p>里面举了一个旅行的例子来比喻初学编程语言：</p>

<blockquote><p>&hellip;as an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions what to see next&hellip;</p>

<p>&hellip;you do not know the city after such a tour. You do not understand all you have seen and heard. You do not know how to navigate the formal and informal rules that govern life in the city&hellip;</p>

<p>&hellip;to really know a city, you have to live in it, often for years.</p></blockquote>

<p>简而言之，编程语言是City，而开发者则是Traveller——这是一个很有意思的比喻，在这篇文章里，我试图<strong>延续</strong>这个类比（Analogy）——把这个类比放大到初学，掌握，了解以至精通一门技术的层面。</p>

<p>不过需要注意：我自己并没有精通哪一门技术——所以这篇文章的内容是值得怀疑（susceptible）的，但它可以作为一个不错的参考。</p>

<!-- more -->


<h2>0. Stranger（陌生人）</h2>

<p>使用一项技术最初的层次就是听说过没用过——就像我们之中的大多数人都听过南极，听过北极，知道南极有企鹅，北极有北极熊，但是却从来没有去过南极或北极。</p>

<p>Stranger具有以下的特征：</p>

<ul>
<li>知道这项技术的名字。</li>
<li>知道这项技术的一些术语。</li>
<li>知道这项技术的一些关键人物的名字。</li>
<li>了解少量技术的细节，但没有使用这项技术的实际经验。</li>
</ul>


<p>以我本人和RoR来打个比方：</p>

<ul>
<li>知道RoR是Ruby on Rails。</li>
<li>知道Rails，Gem和Rake的存在。</li>
<li>知道DHH也知道松本行弘。</li>
<li>看过<a href="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/">The Ruby Programming Language</a>，还使用一个基于RoR的博客框架<a href="http://octopress.org/">Octopress</a>写博客。</li>
<li>但从来没有使用RoR去搭建网站。</li>
</ul>


<p>所以我是一个RoR的Stranger。</p>

<p>对于新技术，绝大多数人都是Stranger——但是就我对国内技术社区的观察，相当数量的Stranger意识不到自己还是Stranger——认为知道一点术语一些人名就算了解一门技术，甚至把它写在简历上（Familiar with XXX）或是开始与别人进行讨论（当然都是毫无意义的讨论）。</p>

<h2>1. Tourist（旅行者）</h2>

<p>当开发者真正开始用一项技术作出了可以用的东西：</p>

<ul>
<li>面向用户的产品（End-User-Oriented Product），比如一个手机应用，或是一个浏览器插件。</li>
<li>或是面向程序员的工具（Programmer-Oriented Tools），比如一个页面抓取框架，或一个简单的Parser Generator。</li>
<li>注意教科书范例（Textbook examples）和Hello world不属于可以用的东西——这些只是Dead Code——被执行一两次，然后被遗忘。</li>
</ul>


<p>这时这个开发者就进入到了Tourist阶段：</p>

<ul>
<li>了解这项技术的基本元素。</li>
<li>使用这项技术做出了实用的产品或工具。</li>
<li>了解对这项技术的部分细节。</li>
</ul>


<p>根据的学习目的的不同，Tourist又可以分为Salesman和Sightseer。</p>

<h3>1.1. Salesman（旅行商）</h3>

<p><img src="http://i.imgur.com/k5oucJ5.jpg" alt="Salesman" style="max-height: 370px;"/></p>

<p>Salesman是具有明确目的的Tourist——他们学习技术的目标是为了完成某一项业务，就像旅行商去某地出差是为了卖商品而非观光一样。</p>

<p>绝大多数职业开发者在开发生涯中都会扮演Salesman这个角色——接到一个任务，涉及到某项不熟悉的技术，需要在限定时间内完成。</p>

<h3>1.2. Sightseer（观光者）</h3>

<p><img src="http://i.imgur.com/RpYoDXc.gif" alt="Sightseer" style="max-height: 370px;"/></p>

<p>和Salesman相反，Sightseer学习技术的目标是为了拓展视野，增加见识，而非完成某项特定业务。</p>

<p>具有主动学习精神的开发者在业余时会时常扮演Sightseer角色——找到自己认为有价值的新技术或是基础知识进行系统学习，从而拓宽视野，提高水平。</p>

<h2>2. Resident（居住者）</h2>

<p>如果一个旅行者在一个地方待了半年以上，那么他/她就会变得原来越像当地人。随着Tourist对某项技术的日益精进，他/她会逐渐演变成这项技术的Resident：</p>

<ul>
<li>熟悉这项技术的基本元素。</li>
<li>熟悉这项技术的生态系统（Ecology）：既包括开发工具（编辑器，命令行工具，集成开发环境等），也包括开发社区（讨论组，邮件列表等）。</li>
<li>了解这项技术能做什么，不能做什么。</li>
<li>了解这项技术有那些坑，如何绕过这些坑，以及识别这些坑带来的问题。</li>
<li>对某些领域有深入的研究——但并不受限于特定领域。</li>
<li>使用这项技术做出了有相当价值的产品或工具。</li>
</ul>


<p>同Tourist一样，根据使用技术的目标不同，Resident可以分为Worker和Craftsman：</p>

<h2>2.1. Worker（工人）</h2>

<p><img src="http://i.imgur.com/jGNNrQp.jpg" alt="Worker" style="max-height: 370px;"/></p>

<p>技术是Worker的谋生手段，一个优秀的Worker应具备以下特征：</p>

<ul>
<li>对于给定问题，知道如何给出经济有效的解决方案。</li>
<li>以团队合作为主，了解团队合作的价值，能够推动团队项目健康前进。</li>
<li>追求按时交付。</li>
</ul>


<h3>2.2. Craftsman（工匠）</h3>

<p><img src="http://i.imgur.com/9RRUjmb.jpg" alt="Craftsman" style="max-height: 370px;"/></p>

<p>同Worker不同，技术并非Craftsman的谋生手段，而是某种“副业”——用来提升声望，修炼开发水平。</p>

<p>一个优秀的Craftman往往具备以下特点：</p>

<ul>
<li>对于给定问题，知道如何给出优雅的解决方案。</li>
<li>以单兵作战为主，主要靠个人推进项目，但也能进行一定程度的团队合作。</li>
<li>追求极致美感。</li>
</ul>


<h2>3. Architect（架构者）</h2>

<p>有想法且有能力的人在一个地方待久了都会有将这个地方变的更好的冲动——一种方式是从源头出发，推翻旧制度建立新社会，也就是革命；另一种方式则是保留现有的制度，对其进行温和但持续的改进，也就是改良。</p>

<p>技术也是如此，任何技术都跟不上开发者成长的脚步，当这种差距到达一定程度时，就会有卓越的开发者站出来，创造出新的技术，他们就是Architect：</p>

<ul>
<li>熟悉多项互相关联的技术，并了解他们的优势和不足。</li>
<li>具备强大的领导能力，深厚的基础和大量实际开发经验。</li>
<li>能够带动整个技术的生态系统发展。</li>
<li>好吧，我编不下去了（尼玛我要都知道我还至于是IT苦屌么 &ndash;_-）</li>
</ul>


<p>如果你看过<a href="http://movie.douban.com/subject/1304141/">Matrix 2: Reloaded</a></p>

<p><img src="http://i.imgur.com/EDyNv4F.jpg" alt="Matrix 2: Reloaded" style="max-height: 370px;"/></p>

<p>就会知道Architect这个词放在这里再好不过。</p>

<p>根据目标不同，Architect分为Reformist和Revolutionist。</p>

<h3>3.1. Reformist（改良者）</h3>

<p><img src="http://i.imgur.com/xp2SzWu.jpg" alt="Reformist" style="max-height: 370px;"/></p>

<p>改良者的目标：<strong>把现有技术变的更好</strong>。（<strong>Makes</strong> existing technology better）</p>

<p>例如：</p>

<ul>
<li>GoF总结<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Pattern</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/John_Resig">John Resig</a>创造<a href="http://en.wikipedia.org/wiki/Jquery">jQuery</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>为C#引入<a href="http://en.wikipedia.org/wiki/LINQ">LINQ</a>。</li>
</ul>


<h3>3.2. Revolutionist（革命者）</h3>

<p><img src="http://i.imgur.com/cpmjDCC.jpg" alt="Revolutionist" style="max-height: 370px;"/></p>

<p>革命者的目标：<strong>用更好的技术取代现有技术</strong>。（<strong>Replaces</strong> existing technology with better one）</p>

<p>例如：</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Alan_kay">Alan Kay</a>把细胞的概念引入软件开发]进而创造出<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的核心概念。</li>
<li><a href="http://en.wikipedia.org/wiki/Donald_Knuth">Don Knuth</a>对计算机算法（<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>）以及计算机排版（TEX）的贡献。</li>
<li>iPhone于2010年之前的任何手机（iPhone4除外）。</li>
</ul>


<h2>小结</h2>

<p>这篇文章利用<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>里的隐喻，把学习/使用技术分成了四个层次七个头衔：Stranger，Tourist（Salesman，Sightseer），Resident（Worker，Craftsman），Architect（Reformist，Revolutionist），然后给出了各个头衔所应具备的特征和能力。</p>

<h3>关于同类文章</h3>

<p>之前也有类似的文章，例如<a href="http://blog.itpub.net/6517/viewspace-611506/">程序员的十层境界</a>和<a href="http://blog.csdn.net/happydeer/article/details/8107560">开发者的八种境界</a></p>

<p>这些文章的共同点：</p>

<ol>
<li>看似很牛逼但回想一下啥都没说。</li>
<li>不会给人带来什么价值。</li>
<li>没有一个鉴别的标准。</li>
<li>没有指导性，也没有使用价值。</li>
</ol>


<h3>本文的应用场景</h3>

<h4>考察状态</h4>

<p>以我自己对编程语言的掌握为例：</p>

<ul>
<li>C/C++: Stranger.</li>
<li>Python: Craftsman.</li>
<li>Java: Worker.</li>
<li>C#: Craftsman.</li>
<li>JavaScript: Sightseer.</li>
<li>Scheme: Sightseer</li>
</ul>


<p>将上面的列表转置：</p>

<ul>
<li>Stranger: C/C++</li>
<li>Sightseer: JavaScript, Scheme</li>
<li>Worker: Java</li>
<li>Craftsman: C#, Python</li>
</ul>


<p>结合这些头衔的定义，一目了然。</p>

<h4>制定计划</h4>

<p>运用本文的词汇，可以进行非常精炼的计划制定：</p>

<ul>
<li>例如 Make a thoroughly <strong>sightseeing</strong> of <strong>C++</strong>；</li>
<li>或是 Become a proficient <strong>worker</strong> on <strong>IntelliJ</strong>；</li>
<li>抑或 Take a short <strong>tour</strong> of <strong>Sublime Text</strong>。</li>
</ul>


<p>以上。</p>
]]></content>
  </entry>
  
</feed>
