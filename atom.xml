<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Lucida]]></title>
  <link href="http://zh.lucida.me/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-11-02T00:25:25-07:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[精益技术简历之道——改善技术简历的47条原则]]></title>
    <link href="http://zh.lucida.me/blog/lean-technical-resume/"/>
    <updated>2014-11-01T21:08:43-07:00</updated>
    <id>http://zh.lucida.me/blog/lean-technical-resume</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>这篇文章围绕着技术简历这个话题，从版式、个人信息、技术能力、项目经历和教育背景等方面出发，给出了编写高质量技术简历所应遵循的47条原则。它们既有益于求职者编写高质量的简历，也有助于招聘者筛选合格的求职者。</p>

<h2>为什么要编写这篇文章？</h2>

<p>技术简历既是技术人员求职必不可少的一环，也是找工作的第一步，其重要性不言而喻。然而关于如何编写技术简历的靠谱教程却少之又少，以至于求职者无法编写出合格的简历，而招聘者无法从简历中看出求职者的真实水平。</p>

<p>一些人可能会反对：如何编写技术简历还不简单，网上到处都是嘛！找一个教程，套一个模板，简历不就出来了嘛！</p>

<ul>
<li><a href="http://jingyan.baidu.com/article/363872ecf0fa656e4ba16f80.html">求职简历怎么写</a>，</li>
<li><a href="http://bbs.yingjiesheng.com/thread-180175-1-1.html">资深HR告诉你到底怎么写一份好的简历</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4a388a6d01008cza.html">技术人员的简历编写技巧</a></li>
<li><a href="http://wenku.baidu.com/view/98f781d528ea81c758f57876.html">精美简历模板集合</a></li>
<li><a href="http://wenku.baidu.com/link?url=ocsWDBteInQGBzY562PWrz7_ZRZHF9BkzonuRAYmFCFGFCmMjXLPB3wSMxuQOFmbzx8FnuhJXogWHVmS8ViYt2nfkY_Xj3RT7ifLZH2WoZe">IT求职简历模板</a></li>
</ul>


<p>上面的教程和模板是我在谷歌和百度搜索“如何编写技术简历”和“技术简历模板”得到的结果，它们的共性是<strong>完全不适用于技术领域</strong>：这些教程和模板会指导你写出一篇<del>屁话连连空话连篇看似出彩但</del>毫无实质内容的嘴遁简历，是的，它们可能适用于一些国有企业，但对于追求实际的外企和民企完全不适用。</p>

<p>技术领域追求<strong>简练、客观、实际和成就</strong>，而不是<strong>冗余、主观、抽象和过程</strong>。如果求职者使用上面的教程或模板编写技术简历，那么结果注定会非常糟糕；如果招聘者使用上面的教程来甄别求职者，那么注定会招进一群光说不做的饭桶。我不是在开玩笑——尽管算上实习我只工作了三年，但我已经见证过很多优秀的童鞋因为简历被公司拒之门外，也见证过招聘者/HR因为不懂甄别简历，搞进来一群莫名其妙的家伙来面试，既浪费时间，又浪费资源。</p>

<p>所以我决定写一篇如何编写技术简历的文章，也就是<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>：</p>

<ol>
<li>为技术人员提供一个靠谱实用的技术简历编写教程</li>
<li>为招聘人员提供一个便捷高效的技术简历甄别教程</li>
</ol>


<p>结合国外书籍/文章和我自己的经验，我总结出47项编写高质量技术简历的原则，<strong>这些原则既可以作为求职者编写技术简历的准则，也可以作为招聘人员筛选技术简历的标准。</strong></p>

<p>此外，随着越来越多的人开始海外求职，我特别针对英文简历编写了9项原则，以帮助国人编写合格的英文技术简历。</p>

<p>注：本文标题中的的“精益”（Lean）源于精益创业（<a href="http://theleanstartup.com/">the Lean Startup</a>）。</p>

<h2>注意</h2>

<p>为了完成这篇文章，我从我的微博关注者中征集了一系列简历（感谢你们的信任！）。下文有可能会出现你们简历中的部分内容（当然我会进行改动以便保护你们的隐私），如果觉得不妥，请与我联系，我会将其删除。</p>

<p>下面进入正文。</p>

<!-- more -->


<hr />

<h2>精益技术简历原则</h2>

<h3>关于</h3>

<p>为了使本文更加严谨有序，我在组织简历原则时参考了编程书籍中著名的Effective系列（例如<a href="http://book.douban.com/subject/1842426/">Effective C++</a>和<a href="http://book.douban.com/subject/3360807/">Effective Java</a>）以及<a href="http://book.douban.com/subject/3267575/">Framework Design Guidelines</a>的行文风格：</p>

<ul>
<li>“使用……”、“对……进行……”、“按照……”这些原则属于必须遵循的原则</li>
<li>“不要使用……”、“不要……”、“避免……”这些原则属于必须避免的原则</li>
<li>“考虑……”、“不必……”、“谨慎……”这些原则属于我个人建议的原则，你可以去违反它们，但我个人不推荐这样做</li>
</ul>


<p>为了便于阅读和理解，我将这些原则按照进行了分类：</p>

<ul>
<li><strong>排版</strong>分类中的原则介绍了如何写出美观的简历</li>
<li>一般来说一封简历都会包含<strong>个人信息</strong>、<strong>技术能力</strong>、<strong>项目经验</strong>、<strong>教育背景</strong>和<strong>个人爱好</strong>，所以我将简历内容相关的原则按照这些分类进行了组织</li>
<li><strong>英文简历</strong>分类介绍了如何改善你的英文简历</li>
<li>未被分组的原则被归类到<strong>其他</strong></li>
</ul>


<h3><a name="sec1">版式</a></h3>

<p>版式（排版和样式）并不是简历内容的一部分，但却会对简历给人的第一印象造成很大影响——“字如其人”，简历版式可以反映其作者是否严谨是否认真。如果版式过于糟糕，那么简历很可能会被直接筛掉。</p>

<h4><a name="rule1">1. 使用对齐</a></h4>

<p>对齐（Alignment）是良好排版的第一要素——对齐不仅使简历层次分明，也会给人有力的感觉，例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="未对齐的简历" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="对齐的简历" /></p>

<h4><a name="rule2">2. 不必使用居中</a></h4>

<p>居中会破坏对齐，减弱整体的层次感，所以我不建议在简历中使用居中。例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="居中标题" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="非居中标题" /></p>

<p>是的，这条原则里使用的图片来自<a href="#rule1">原则 1. 使用对齐</a>，请牢记：<strong>左/右对齐优于居中对齐。</strong></p>

<h4><a name="rule3">3. 谨慎使用<strong>粗体</strong></a></h4>

<p>粗体是一个很强大的工具，它可以有效的去引导简历阅读者的视线，并突出重要的内容。但我在阅读简历的时候发现不少人对粗体使用不当——滥用，用错，甚至是全文使用粗体，这使得简历完全无法被正常阅读。</p>

<p>粗体适用于去突出<strong>成就</strong>（Achievements），例如：</p>

<ul>
<li>量化的成就：将页面加载速度提升<strong>50%</strong></li>
<li>良好的成绩：GPA <strong>4.0/4.0</strong></li>
<li>奖项：ICPC/ACM比赛中获得XX赛区<strong>一等奖</strong></li>
<li>他人的推荐语：<strong>“XX是我见过的最优秀的实习生”</strong></li>
</ul>


<p>在其它场景下，我不推荐使用粗体，此外注意不要过多使用粗体——<strong>粗体是为了突出成就，不是为了突出技术关键字</strong>，<strong>太多的粗体会导致什么也突出不出来。</strong></p>

<h4><a name="rule4">4. 避免不必要的折行</a></h4>

<p>折行（Wrap）指当一行内容过长时会自动进入下一行。我不是说不可以折行（那就成了古龙小说了 :&ndash;/），而是说不要使用不必要的折行，比如说：</p>

<p><img src="http://i.imgur.com/oWHWfnO.png" alt="不必要的折行" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/RHoQFdQ.png" alt="去掉折行" /></p>

<p>不必要的折行会降低简历的密度，破坏简历的层次感，而且会给人没话说有意占行数的感觉。请务必避免这样的折行。</p>

<h4><a name="rule5">5. 使用制表符辅助对齐</a></h4>

<p>为了进行对齐，我们往往需要添加一些空白符。在这里请使用制表符（tab）而非空格（space），因为：</p>

<ol>
<li>空格往往不会带来严格的对齐（因为简历字体往往不是等宽的）</li>
<li>制表符在打印版本下的表现更佳</li>
</ol>


<h3><a name="sec2">个人信息</a></h3>

<p>个人信息部分决定了简历阅读者对简历的第一印象，请务必在这部分内容多下功夫。</p>

<h4><a name="rule6">6. 不要使用不必要的条目名称</a></h4>

<p>条目名称（Column name）这个词很拗口，我举一个例子：“姓名：张大锤”和“电话：135-9112-7890”里的“姓名”和“电话”就是条目名称。</p>

<p>绝大多数的条目名称都是不必要的——“张大锤”一看就是一个名字，“135-9112-7890”一看就是一个手机号码。这种条目信息会让简历变得拖沓啰嗦，请务必删除它们。</p>

<p>此外，请牢记<strong>“个人简历”是简历上最大的废话</strong>——这当然是一封简历，不用你提醒。可笑的是很多所谓的“500强简历模板”还把“个人简历”作为简历抬头（Header）。</p>

<h4><a name="rule7">7. 使用分隔符增强电话号码的可读性</a></h4>

<p>请使用“-”和“()”格式化你的电话号码，例如：把<strong>8618601007070</strong> 改为 <strong>(+86) 186-0100-7070</strong>，以便简历阅读者能够正确便捷的拨打你的号码，此外这样的号码也显得更加专业。</p>

<h4><a name="rule8">8. 使用可以点击的链接</a></h4>

<ul>
<li>使用<a href="http://zh.lucida.me">http://zh.lucida.me</a>而非http<nolink>://zh.lucida.me</li>
<li>使用<a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x6d;&#x79;&#109;&#x61;&#105;&#108;&#64;&#103;&#x67;&#103;&#x2e;&#x63;&#x6f;&#109;">&#x6d;&#x79;&#x6d;&#x61;&#105;&#108;&#64;&#x67;&#x67;&#x67;&#46;&#x63;&#111;&#109;</a>而非mymail<nolink>@ggg.com</li>
</ul>


<p>这样简历阅读者就可以直接点击，而不是费力的把链接复制粘贴到某个输入栏中。</p>

<h4><a name="rule9">9. 不要使用照片</a></h4>

<p>照片不会对你的简历产生任何正面价值，而且它会破坏简历的结构，请不要在简历中使用照片。</p>

<h4><a name="rule10">10. 不要写无关个人信息</a></h4>

<p>是的，你是在写技术简历，而不是在写入党申请或征婚启事之类的东西，所以请不要在简历中出现下面这些信息：</p>

<ul>
<li>性别</li>
<li>生日</li>
<li>星座</li>
<li>籍贯</li>
<li>通信地址</li>
<li>民族</li>
<li>政治面貌（WTF!!??）</li>
<li>身高/体重</li>
</ul>


<p>理想的个人信息应该包括姓名、联系方式（电邮地址和手机号码），如果你有不错的技术博客也可以把它放在上面。</p>

<h4><a name="rule11">11. 使用客观事实而非主观描述</a></h4>

<p>我经常在简历里面看到诸如“我是一个热爱编程的开发者”或是“我精力充沛，热爱学习，能够长时间从事编程工作”之类的个人评价，总之就是把雇主希望看到的性格特点堆在一起，有时感动的我都想哭。</p>

<p>但感动归感动，这些感人肺腑的个人评价我向来直接无视——<strong>我为什么要相信你呢？</strong>引用<a href="https://lkml.org/lkml/2000/8/25/132">Linus的话</a>，<strong>Talk is cheap, show me the code</strong>。如果要说明你是一个热爱编程的开发者，那么请出你的Github页面或优秀的个人作品；如果要说明你热爱学习，请给出你读过的书或写过的书评。总之，使用客观事实，而非主观描述。</p>

<h4><a name="rule12">12. 考虑提供他人的评价</a></h4>

<p>这条原则是上一条原则的扩充——找你的导师、老板或者同事为你写一个评语，相对于主观描述，他人的评价往往更加可信。如果你的评价者是业内权威，那么效果就会更好。</p>

<h4><a name="rule13">13. 不必写求职目标</a></h4>

<p>我读过的很多简历都有“Objective”（求职目标）这一栏，一般求职者会在这里写他所期待的职位。我个人非常不喜欢求职目标这一栏，因为求职目标给我一种海投简历的感觉。如果走的是内部推荐，或者使用目标公司的求职页面，请去掉求职目标，你应该已经了解投递职位，不需要在简历里面重复。</p>

<h3><a name="sec3">技术能力</a></h3>

<p>技术能力是技术简历里面重要的一环，一般来说简历阅读者会通过这部分内容了解你的技能集（Skill set），从而构成对你的第一技术印象。</p>

<h4><a name="rule14">14. 不要堆砌技术名词</a></h4>

<p>技术简历中一个常见误区是堆砌技术名词，一些求职者认为在简历上写的技术越多越好，于是把自己会的、用过的、见过的甚至没见过的技术都堆在一起，比如：</p>

<p>Technical Skills</p>

<ul>
<li>Programming Language: HTML, CSS, PHP, JavaScript, SQL, Haskell, Perl, Python, C, C++, Java, Ruby, Prolog, .NET, C#, Assembly, REXX, Verilog, R, Visual Basic, MATLAB, jQuery, Angular, SASS</li>
<li>Operating System: Unix/Linux, Mac, MS-DOS, Windows 7/8, Windows Server 2003/2008/2012, z/VM</li>
<li>Software: Adobe Creative Cloud Dreamweaver, Photoshop, InDesign, Audition. WordPress, OmniUpdate, Google Analytics, Eclipse, NetBeans, LaTex, Microsoft Office Suite, Microsoft Excel, Project, Visio, Visual Studio</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>是的，一个人可以同时掌握甚至精通多种编程语言，但一般来说这种可能性很小。当我看到这样的技术描述，我会迅速的跳转到简历的项目经验环节，如果我无法在项目经验里找到对应的技术，我会直接把这个简历筛掉。（我把它叫做“未声明引用”（Undeclared reference）：你说你精通C++，但你却没有C++的项目经验，你确定不是在逗我？）</p>

<p>所以，不要堆砌技术名词，技术简历并非多多益善，熟悉什么技术就写什么技术，然后在项目经验里面给出你熟悉该技术的证据（evidence），这样会使你的简历更有说服力。</p>

<h4><a name="rule15">15. 对技术进行分类</a></h4>

<p>技术能力部分的另一个常见问题是缺乏分类或者分类错误，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Visual Studio, Shell, Python, Eclipse, Java</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/PpAXta9.jpg" alt="分类不清" /></p>

<p>这样的简历也会被直接扔进废纸篓——连编程语言和编程环境都分不清，招你作甚。</p>

<p>正确分类后就清楚了很多：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Java, Python, Shell
</span><span class='line'>开发环境：Visual Studio, Eclipse</span></code></pre></td></tr></table></div></figure>


<h4><a name="rule16">16. 使用正确的技术名称</a></h4>

<p>这个原则非常简单（甚至有点弱智）——正确拼写技术名称，并使用正确的大小写。我在这里摘取了一些我见过的技术名词错误：</p>

<ul>
<li>Andoid &ndash;> Android</li>
<li>IOS, ios &ndash;> iOS</li>
<li>javascript &ndash;> JavaScript</li>
<li>coffescript &ndash;> CoffeeScript</li>
<li>intelij &ndash;> IntelliJ</li>
<li>Dikjstra &ndash;> Dijkstra</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="别字错误" /></p>

<p>请严格检查此类错误——这类错误会大大降低你的简历的专业性，并给人非常不好的印象</p>

<h4><a name="rule17">17. 不要写电脑能力</a></h4>

<p>技术简历需要展现你的技术能力（Technical Skills），而不是电脑能力（Computer Skills），这两个概念比较拗口，所以我在这里举几个例子：</p>

<ul>
<li>技术能力包括：编程（C++/Java/Python），开发环境（Visual Studio/IntelliJ/Eclipse），测试（JUnit/TestNG/mockito/truth），用户体验（Axure/Expression Blend）等等。</li>
<li>电脑能力包括：日常办公（Word/Excel/PowerPoint/Office），图形界面操作系统（Windows 7/8）的使用，浏览器（IE/Chrome/Safari）的使用等等。</li>
</ul>


<p>电脑能力不但会稀释你的简历含金量，还会给人极不专业的感觉。不要在技术简历里面出现任何电脑能力——据说某公司甚至定了一个规矩，<strong>只要在技术简历里面看到Office字样就直接滤掉</strong>（靠谱！）。</p>

<h4><a name="rule18">18. 按照熟悉程度对技术能力进行排序</a></h4>

<p>这个原则十分简单——使用合适的词汇描述你的技术能力，并按照熟悉程度排序，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++, C#, Java, Python, JavaScript</span></code></pre></td></tr></table></div></figure>


<p>就不如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：熟悉C++、C#和Java，了解Python和JavaScript</span></code></pre></td></tr></table></div></figure>


<p>另一种方式是使用比较符：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>编程语言：C++ = C# &gt; Java &gt; Python = JavaScript</span></code></pre></td></tr></table></div></figure>


<p>注意：没有必要在技术能力后面加上使用时间，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>技术名称     熟练程度     使用时间
</span><span class='line'>C++           精通         8年
</span><span class='line'>Java          熟悉         5年</span></code></pre></td></tr></table></div></figure>


<p>时间没有意义——搞技术的都明白技术的使用时间和技术的熟练程度没有任何关系（谁知道这货是不是用了1个月C++然后在后面的95个月不断重复第一个月的东西？），只可惜有些HR永远都不懂这个道理，也不肯懂。</p>

<h4><a name="rule19">19. 不要写过于特定的技术</a></h4>

<p>什么叫做过于特定（Specific）的技术呢？举个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>熟悉单例（Singleton）模式</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="捂脸" /></p>

<p>且不说单例是不是一个好模式，单例模式有什么好熟悉的？这种东西也配写到简历上吗？至少在我看来，“熟悉单例模式”就跟“熟悉for循环”、“精通if语句”一般可笑。</p>

<h4><a name="rule20">20. 谨慎使用精通</a></h4>

<p>精通和Proficient是非常Strong的词汇，在简历上写精通类词汇也许会帮你得到面试机会，但你要面对难度更高的面试——招聘者会通过更高难度的问题来确认你真的是精通，而不是在嘴遁。</p>

<p>但如果你真的精通某项技术，那就自信的写上精通，然后用项目经历和面试中的表现说服招聘者，这样往往有助于你拿到Strong Offer。</p>

<h4><a name="rule21">21. 使用项目经验印证技术能力</a></h4>

<p>这条原则在<a href="#rule13">原则13 不要堆砌技术名词</a>也有提到——你的技术能力应该在你的项目经历中得到<strong>全部</strong>体现，技术能力展现你的技能集（Skills Set），而项目经验为其提供证据（Evidence）。打个比方，如果你提到你熟悉C++，那么你就需要在项目经验中提到C++，否则我认为你在说谎或者忘记把C++的项目经验写在简历上，说谎和健忘，两者都不是好事。</p>

<h3><a name="sec4">项目经历</a></h3>

<p>项目经历是简历阅读者进一步了解求职者技术能力的重要依据，良好的项目经历应当清晰，简洁，既印证前面提到的技术能力，也反映出求职者应对复杂度（Handle complexity）的能力。</p>

<h4><a name="rule22">22. 按照时间对项目经历排序</a></h4>

<p>一般来说，项目经历应该按照时间倒序排序——最新的项目经历放在最前。此外，考虑去掉过于久远（比如说，七八年前）的项目经历，因为你很有可能已经忘了七八年前做过的东西了。</p>

<p>另外一种排序方式是按照项目的重要程度排序——最重要的项目放在最前，但我个人不推荐这种方式，因为往往最重要的项目都在最近，如果你最重要的项目在很多年，那么很有可能你这些年毫无长进。</p>

<h4><a name="rule23">23. 不要列出过多的项目</a></h4>

<p>我经常看到非常长的简历：三四页纸，两三千字，十余个项目，恨不得把他/她做过的东西全都铺上去。而事实证明写出这样简历的人水平都不怎么样——至少就我的个人经验而言。</p>

<p>项目经历不是自传，不用把你全部的经历铺上去，也不要写过多的项目经历——三个项目是一个不错的选择，五个就有点多，十个就会没人看。要知道三个优秀的项目远胜十个一般的项目。</p>

<p>所以问题来了，什么是优秀的项目呢？就技术项目而言，我的评估标准是复杂度（Complexity）和影响力（Impact）：一个项目，如果复杂度和影响力都有那是最好，如果只有一个也不错，如果都没有那就呵呵。我会在<a href="#rule25">原则25 强调影响力和复杂度</a>中进一步说明。</p>

<h4><a name="rule24">24. 强调成果而非过程</a></h4>

<p>我在我之前的<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">关于锤子手机和锤子手机发布会</a>提到过：</p>

<blockquote><p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress。</p></blockquote>

<p>技术简历也是如此，不要在项目经历中过度强调你有多努力。“连续高强度工作三个月”和“在深夜重构了XX项目中的代码”并不是一个好的项目描述：如果你“连续高强度工作三个月”却无法说明你的工作成果，“在深夜重构了XX项目中的代码”却无法说明重构后代码改进了多少，那我认为你的“努力”毫无意义。</p>

<p>强调你的项目成果（Achievements）而非过程，“将网站访问量提升300%”、“将响应时间从1.5s减少到0.1s以内”都是不错的成果。</p>

<h4><a name="rule25">25. 使用量化结果而非抽象描述</a></h4>

<p>我经常在简历上看到“改善了代码的质量”、“提升了启动速度”和“大大增加了网站访问量”之类的描述，我的第一反应就是：</p>

<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p><strong>用个数字你会死啊！！！看新闻联播看多了吧亲！！！！</strong></p>

<p>接下来的反应是：</p>

<ul>
<li>“改善了代码的质量”——改善了多少？你是如何评估的？圈复杂度？测试覆盖度？Bug的数量？ ？？？</li>
<li>“提升了启动速度”——提升了多少？用户的反馈如何？是否在可接受的范围内？ ？？？</li>
<li>“大大增加了网站访问量”——“大大”是什么？访问量增加了多少？访问量原来是多少？ ？？？</li>
</ul>


<p>如果我找不到上面问题的答案，我会直接无视这些抽象描述——还是那句话，我为什么要相信你的一面之词？而且你连话都说不清。</p>

<h4><a name="rule26">26. 强调影响力和复杂度</a></h4>

<blockquote><p>&ldquo;Controlling complexity is the essence of computer programming.&rdquo;</p>

<p>Brian Kernighan</p></blockquote>

<p>控制复杂度使程序设计的根本（essense），所以绝大多数IT公司在招聘时都会把应对复杂度（Handle complexity）放在职位描述里面——你如果能把难题搞定，那么简单题也不在话下。如果你做过的项目足够复杂，那么就证明你能扛得住复杂度，是个好<del>备胎</del>备选（Candidate）。</p>

<p>那么什么样的项目经历称得上复杂呢？我在这里给出一个不严谨的分类，仅供参考：</p>

<ul>
<li>编程复杂度：操作系统，编译器/解释器，图形学编程，网络协议设计与实现等</li>
<li>算法复杂度：算法竞赛奖项等（不好意思我不熟悉算法所以给不出啥例子 &ndash;_-）</li>
<li>设计复杂度：大型网站，企业级应用，分布式应用等</li>
</ul>


<p>衡量项目的另一个重要依据是影响力（Impact），有的软件项目可能不那么复杂，但是它具有相当大的影响力，例如jQuery、RoR和JUnit：</p>

<blockquote><p>&ldquo;Never in the field of software development have so many owed so much to so few lines of code (JUnit).&rdquo;</p>

<p>Martin Fowler</p></blockquote>

<p>如果你的项目并不复杂，那么请强调它的影响力，用户量超过十万的手机应用和被广泛应用的类库都是很好的项目，尽管它们可能并不复杂。</p>

<p>如果一个项目既没有复杂度，也没有影响力，那么直接删掉它——不要犹豫，它不会为你的简历提供任何价值。</p>

<h3><a name="sec5">教育背景</a></h3>

<p>教育背景是简历的另一项重要内容，它对于应届生尤其重要——因为应届生往往没有太多的工作经历。</p>

<h4><a name="rule27">27. 不要写大学之前的教育经历</a></h4>

<p>我不明白为什么很多人把高中甚至初中都写在简历里——也许你的高中/初中很出色，不过那么多年前的事情就不用再提了吧 &ndash;_&ndash;||</p>

<h4><a name="rule28">28. 不要写课程列表</a></h4>

<p>我在简历的教育背景部分发现的另一个奇怪的现象是课程列表（Courseworks）：求职者把大学专业课程一水排开，放在简历里面，颇是壮观：</p>

<p>专业课程：</p>

<ul>
<li>计算机科学导论，C语言及程序设计，计算机组成原理，数据结构，算法设计，离散数学，操作系统原理，编译原理，计算机网络，数据库系统原理，面向对象编程，软件工程，图像处理技术，人工智能及其应用，网络工程</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>更加令人啼笑皆非的是把<strong>所有</strong>的大学课程放在一起：</p>

<p>大学课程：</p>

<ul>
<li>高等数学，线性代数，大学物理，概率与数理统计，毛泽东思想概论，思想道德修养，邓小平理论，马列政治经济学原理……</li>
</ul>


<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p>每当看到这样的简历我都在想我是该筛掉你呢还是筛掉你呢还是筛掉你呢？</p>

<p><strong>不要写课程列表</strong>，除非你有想特别强调的特殊专业课，而且你在该课上有突出表现（比如“编译原理（实现了带下标检查的扩展C编译器）”就不错）。</p>

<h4><a name="rule29">29. 考虑使用成绩或排名</a></h4>

<p>如果你的大学成绩或排名还不错，那么请把它放在教育背景中，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2009 ~ 2013    学士    大连理工大学    软件工程    GPA: 3.8/4.0，排名：3/153</span></code></pre></td></tr></table></div></figure>


<p>就不错。</p>

<p>但如果你的成绩一般（80%一下）或排名一般（前20%开外），那么就不要提它们（我就是这么做的，-_&ndash;#）</p>

<h4><a name="rule30">30. 考虑使用导师（老师）的评语</a></h4>

<p>这条原则和<a href="#rule12">原则12. 考虑提供他人的评价</a>相类似，与其说你在学校多么努力，不如让你的专业课老师（导师）给你一个评价。</p>

<p>注意：不要使用辅导员的评价，是的，辅导员在大学很重要，但辅导员对学生的评价往往没有<strong>专业</strong>参考价值。</p>

<h4><a name="rule31">31. 考虑使用学业相关的奖项</a></h4>

<p>请把在校期间的<strong>重要奖项</strong>放在教育背景中，比如“一等奖学金”，“数学建模大赛一等奖”就不错。</p>

<p>我在阅读简历时见到过很多学霸——学校里面获得的奖项接近一页纸之多。这是个好事，不过放太多奖无益于突出重点，所以请参考<a href="#rule23">原则 23. 不要列出过多的项目</a>：精选3到5个最有说服力的奖项，然后把它们放在教育背景中。</p>

<h3><a name="sec6">个人爱好</a></h3>

<p>个人爱好对技术简历往往毫无价值，所以这里的原则只有一条——</p>

<h4><a name="rule32">32. 避免写个人爱好</a></h4>

<p>除非你在个人爱好上取得了相当的成就，否则不要写个人爱好。每个人都喜欢音乐，都喜欢看书，也都喜欢技术，这种<del>屁话</del>套话还是留到入职邮件再说也不迟。</p>

<h3><a name="sec7">英文简历</a></h3>

<p>海外求职需要英文简历，而英文简历需要专业的英语——阅读你简历的人很有可能只懂英文，如果你的英文太糟糕那么他/她很可能会无视你的技术而直接把你筛掉。</p>

<h4><a name="rule33">33. 不要出现拼写错误</a></h4>

<p>请打开拼写检查——要知道简历里面的拼写错误是致命的。我在这里给出一些常见的拼写错误：</p>

<ul>
<li>explaination &ndash;> explanation</li>
<li>convenence &ndash;> convenience</li>
<li>seperate &ndash;> separate</li>
<li>Febuary &ndash;> February</li>
<li>embarass &ndash;> embarrass</li>
<li>consience &ndash;> conscience</li>
<li>mispell &ndash;> misspell</li>
<li>enginner &ndash;> engineer</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="金馆长" /></p>

<p>更多的拼写错误请参考<a href="http://grammar.yourdictionary.com/spelling-and-word-lists/misspelled.html">这里</a>。</p>

<h4><a name="rule34">34. 不要使用全角字符</a></h4>

<p>务必不要在英文简历中使用全角字符：</p>

<ol>
<li>全角字符会影响英文排版，使其变的很难看</li>
<li>对方的机器上可能没有对应的字库，因而无法显示全角字符</li>
</ol>


<p>我个人推荐在英文简历中只使用ASCII字符集里的字符。</p>

<h4><a name="rule35">35. 使用正确的词汇</a></h4>

<p><img src="http://i.imgur.com/SJF8N2m.jpg" alt="神翻译" /></p>

<p>国人英文简历的一大通病是用词不当，下面是我阅读英文技术简历时所发现的最常见的三个错误：</p>

<ol>
<li>“<strong>实现</strong>了xx功能”：使用<strong>Implement</strong>，而不是<strong>Achieve</strong></li>
<li>“软件工程师”：使用<strong>Software Developer</strong>或<strong>Software Engineer</strong>，而不是<strong>Software Programmer</strong></li>
<li>“我对xxx<strong>感兴趣</strong>”：使用<strong>I am interested in &hellip;</strong>，而不是<strong>I am interesting in</strong>，详见<a href="http://www.learnersdictionary.com/qa/what-is-the-difference-between-interested-and-interesting">这里</a></li>
</ol>


<p>用词不当会影响简历阅读者的理解，为其带来相当负面的印象。为了减少这类错误，你应该去阅读更多的专业英文著作，或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule36">36. 使用简洁的句子</a></h4>

<p>受中式思维的影响，我们的英文往往很冗余（Verbose），我举两个简单的例子</p>

<ul>
<li>“during the development period”应该是“during the development”：因为“development”本身已经包含“过程（period）”的意思。</li>
<li>“implemented xxx successfully”应当是“implemented xxx”：既然使用了过去式，那么你已经把它实现（implement）了，那自然就是“成功”实现。如果想要强调“成功”，那么可以用“accomplished xxx”。</li>
</ul>


<p>这里水一句：一般来说中国人对这种英语完全不敏感，反而很亲切（因为更接近中式思维），那为什么我对这种英语特别在意呢？因为我有几个伦敦同事特别在意英语的纯正性，初到伦敦时，无论是吃饭、聊天还是提交代码，他们都会无时无刻的纠正我的语法错误和发音错误（我想我已经被他们纠正几千多次了-_&ndash;#），所以我现在对此类中式英语异常敏感。</p>

<p>此外在简历里面我们有时可以忽略主语（Subject），例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Project A:
</span><span class='line'>    I implemented the communication module.
</span><span class='line'>    I wrote tests for the communication module.
</span><span class='line'>    I deployed the module into our system.</span></code></pre></td></tr></table></div></figure>


<p>可以这么写</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Project A:
</span><span class='line'>    Implemented the communication module.
</span><span class='line'>    Wrote tests for the communication module.
</span><span class='line'>    Deployed the module into our system.</span></code></pre></td></tr></table></div></figure>


<p>这样不但更加简洁，而且用动词开头会让句子显得更加有力，给人以自信的感觉。</p>

<p>为了使简历中的英文句子更加简洁，你应该去阅读更多的英文写作书籍（例如<a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>和<a href="http://www.amazon.com/Writing-Well-30th-Anniversary-Edition/dp/0060891548/">On writing well</a>），或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule37">37. 避免中式英语</a></h4>

<p>这个原则实际上是<a href="#rule35">原则35. 使用正确的词汇</a>和<a href="#rule36">原则36. 使用简洁的句子</a>的扩展，因为这两个原则都属于中式英语的范畴。</p>

<p>中式英语的源头在于用中式思维将中文逐字转化成英语，尽管我们不会搞出这样的错误：</p>

<p><img src="http://i.imgur.com/PfkAXV7.jpg" alt="神翻译" /></p>

<p>但是小错是难免的，我已经不止三次的听到有人使用&#8221;red color&#8221;这个神奇的短语了。（red本身就是颜色，所以完全不需要后面的color）如果你打算根除中式英语，你有两种途径：</p>

<ol>
<li>找几个腹黑伦敦同事。-_&ndash;#</li>
<li>阅读<a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a></li>
</ol>


<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p>这是我读过最好的（貌似也是唯一的）讲中式英语的书籍。</p>

<p>当然，如果你只是把简历改的不那么中式，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule38">38. 使用一致的时态</a></h4>

<p>这个原则很简单——使用一致的时态：</p>

<ul>
<li>对于个人评价：使用现代式。</li>
<li>对于项目经历：使用过去式。</li>
</ul>


<p>之所以把这么简单的原则提出来，是因为我都过的英文简历几乎都违反了这个原则——它们或者在个人评价里“I was a passionate programmer”（嗯，你过去很激情那么现在呢？），或者在项目经历里“Implement xxx”（一直实现到现在不容易啊童鞋！）。</p>

<h4><a name="rule39">39. 考虑提供缩写词的解释</a></h4>

<p>不是所有人都了解你的工作或研究，所以对于<strong>不常用</strong>和<strong>有歧义</strong>的首字母缩写词（Acronym），请提供全称。</p>

<p>注意我说的是<strong>不常用</strong>和<strong>有歧义</strong>的缩写词，你无需告诉简历阅读者HTML的全称是HyperText Markup Language，也无需说明MVC是Model View Controller，但你可能需要说明AST是Abstract Syntax Tree，DSL是Domain Specific Language（而不是Digital Subscriber Line）。</p>

<h4><a name="rule40">40. 使用Bullets组织长段</a></h4>

<p>如果一段项目过长，请使用Bullets而不是“Firstly&hellip;, secondly&hellip;, finally&hellip;”，例如：</p>

<p>Firstly, I collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java. Secondly, I developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos. Finally, I improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</p>

<p>即便是一个English native speaker，看到这样的大长段也会发怵，这里可以利用Bullets改善可读性：</p>

<ol>
<li>Collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java.</li>
<li>Developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos.</li>
<li>Improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</li>
</ol>


<h4><a name="rule41">41. 打下良好的英文基础</a></h4>

<p>归根到底，写好英文简历需要良好的英文基础，所以我在这里推荐几本不错的英语基础书籍：</p>

<p><img src="http://img3.douban.com/lpic/s1446975.jpg" alt="Practical English Usage" /></p>

<p><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a>：简洁，精炼，学习英文语法和口语的必备书籍。</p>

<p><img src="http://img5.douban.com/lpic/s11442466.jpg" alt="Collins Pocket English Thesaurus" /></p>

<p><a href="http://www.amazon.com/Collins-Pocket-English-Thesaurus-Dictionaries/dp/0007450567/">Collins Pocket English Thesaurus</a>：个人无责任推荐——每天看一点，这本书不会提升你的词汇量（Total Vocabulary），但会提升你的有效词汇量（Effective Vocabulary）。</p>

<p><img src="http://img5.douban.com/lpic/s4228916.jpg" alt="Elements of Style" /></p>

<p><a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>：英语写作第一书。无论是写作，还是编程，都能从本书受益良多。</p>

<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a>：可能是目前唯一一本讲述中式英语的书籍，尽管书中的例子有点政治化，但不妨碍本书是一本好书。</p>

<p>这篇文章的主题并非英语学习，如果你对英语学习有兴趣可以去Google和<del>逼乎</del>知乎搜索更相关的答案。</p>

<p>当然，如果你只是想得到一个不错的英文简历，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h3><a name="sec8">其它</a></h3>

<p>剩下的是一些通用原则。</p>

<h4><a name="rule42">42. 考虑使用超链接</a></h4>

<p>这项原则是<em>原则8. 使用可以点击的链接</em>的扩充——超链接适用于简历全文，而不只适用于个人信息里的个人主页和邮箱地址：</p>

<ul>
<li>如果你的作品/项目有介绍链接，请提供它</li>
<li>如果你的作品/项目有在线演示，请提供它</li>
<li>如果你的作品/项目有用户反馈，请提供它</li>
</ul>


<p>使用超链接时要注意一点：使用隐式超链接而非显式超链接，例如使用<a href="http://www.google.com">Google</a>而非<a href="http://www.google.com">http://www.google.com</a>。因为显式超链接往往很长而且不可读，还会破坏打印版简历的效果。</p>

<h4><a name="rule43">43. 考虑提供一个“加强版”简历</a></h4>

<p>这项原则是<a href="#rule42">原则42. 考虑使用超链接</a>的补充，简历受限于篇幅（一般是一页）和格式（一般是PDF），无法提供更多丰富多彩的内容。但你可以用超链接关联一个外部“加强版”简历。</p>

<p>一个典型例子是<a href="http://iconmoon.com/about/">JJ Ying</a>的在线“简历”（使用Parallax效果），这种“加强版”简历往往会使简历阅读者眼前一亮，从而大大增加你的简历通过率。</p>

<h4><a name="rule44">44. 考虑提供开发社区账号</a></h4>

<p>如果你有非常活跃的开发社区（例如<a href="http://stackoverflow.com/">Stack Overflow</a>，<a href="https://github.com/">GitHub</a>和<a href="http://www.reddit.com/r/programming/">Reddit Programming</a>等开发社区）账号，那么请在简历中提供它们。</p>

<p>注意我说的开发社区账号，而不是社交网络账号：提供<a href="http://www.renren.com/">人人</a>、<a href="http://www.weibo.com/">微博</a>或<a href="https://www.facebook.com/">Facebook</a>账号不会对简历有任何帮助。</p>

<h4><a name="rule45">45. 持续更新简历</a></h4>

<p>优秀的简历应该是<del>与时俱进</del>持续更新的。从现在开始，定一个周期（一个月或三个月），然后以这个周期持续更新简历，这样你可以：</p>

<ol>
<li>随时拥有最新的简历，而不是在求职时挖空心思编写</li>
<li>形成一个成长记录，以便自我改善</li>
<li>时刻提醒自己持续学习，如果你发现这个周期的简历同上个周期变化不大，你就要好好反思下了</li>
</ol>


<p>以我自己为例，我维护着一个Markdown简历，每两个月一更新，通过更新记录/当前简历/下一步计划，我可以更有效的指导我的学习和工作。</p>

<h4><a name="rule46">46. 不断提升个人能力</a></h4>

<blockquote><p>“没有声音，再好的戏也出不来”
某广告语</p></blockquote>

<p>简历原则有助于展示（Demostrate）实力，而不是放大（Amplify）实力——打个比方，你的实力有100分，低劣的简历会让你看起来只有50分，而良好的简历则会展现出你100分，但不要指望简历会把你变成200分——我承认有些人可以通过说谎/造假/吹牛达到这个效果，但我不推荐这种透支信用的做法。</p>

<p>所以，优秀简历的根本是强大的实力，多学习，多做有影响力/复杂度（参考<a href="#rule26">原则26. 强调影响力和复杂度</a>）的项目，而不是在马上找工作的时候挖空心思编项目堆技能。没有声音，再好的戏也出不来。</p>

<h4><a name="rule47">47. 考虑征求他人意见</a></h4>

<blockquote><p>“当局者迷，旁观者清”</p></blockquote>

<p>在投递简历前，最好去征求他人意见——外人往往可以看出你简历的不足，指出低级错误，给出不错的建议。</p>

<p>当然你也可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h2>总结</h2>

<p>在这里我把精益技术简历的47条原则整理在一起，以便阅读整理：</p>

<h3><a href="#sec1">版式</a></h3>

<ol>
<li><a href="#rule1">原则1：使用对齐</a></li>
<li><a href="#rule2">原则2：不必使用居中</a></li>
<li><a href="#rule3">原则3：谨慎使用<strong>粗体</strong></a></li>
<li><a href="#rule4">原则4：避免不必要的折行</a></li>
<li><a href="#rule5">原则5：使用制表符辅助对齐</a></li>
</ol>


<h3><a href="#sec2">个人信息</a></h3>

<ol>
<li><a href="#rule6">原则6：不要使用不必要的条目名称</a></li>
<li><a href="#rule7">原则7：使用分隔符增强电话号码的可读性</a></li>
<li><a href="#rule8">原则8：使用可以点击的链接</a></li>
<li><a href="#rule9">原则9：不要使用照片</a></li>
<li><a href="#rule10">原则10：不要写无关个人信息</a></li>
<li><a href="#rule11">原则11：使用客观事实而非主观描述</a></li>
<li><a href="#rule12">原则12：考虑提供他人的评价</a></li>
<li><a href="#rule13">原则13：不必写求职目标</a></li>
</ol>


<h3><a href="#sec3">技术能力</a></h3>

<ol>
<li><a href="#rule14">原则14：不要堆砌技术名词</a></li>
<li><a href="#rule15">原则15：对技术进行分类</a></li>
<li><a href="#rule16">原则16：使用正确的技术名称</a></li>
<li><a href="#rule17">原则17：不要写电脑能力</a></li>
<li><a href="#rule18">原则18：按照熟悉程度对技术能力进行排序</a></li>
<li><a href="#rule19">原则19：不要写过于特定的技术</a></li>
<li><a href="#rule20">原则20：谨慎使用精通</a></li>
<li><a href="#rule21">原则21：使用项目经验印证技术能力</a></li>
</ol>


<h3><a href="#sec4">项目经历</a></h3>

<ol>
<li><a href="#rule22">原则22：按照时间对项目经历排序</a></li>
<li><a href="#rule23">原则23：不要列出过多的项目</a></li>
<li><a href="#rule24">原则24：强调成果而非过程</a></li>
<li><a href="#rule25">原则25：使用量化结果而非抽象描述</a></li>
<li><a href="#rule26">原则26：强调影响力和复杂度</a></li>
</ol>


<h3><a href="#sec5">教育背景</a></h3>

<ol>
<li><a href="#rule27">原则27：不要写大学之前的教育经历</a></li>
<li><a href="#rule28">原则28：不要写课程列表</a></li>
<li><a href="#rule29">原则29：考虑使用成绩或排名</a></li>
<li><a href="#rule30">原则30：考虑使用导师（老师）的评语</a></li>
<li><a href="#rule31">原则31：考虑使用学业相关的奖项</a></li>
</ol>


<h3><a href="#sec6">个人爱好</a></h3>

<ol>
<li><a href="#rule32">原则32：避免写个人爱好</a></li>
</ol>


<h3><a href="#sec7">英文简历</a></h3>

<ol>
<li><a href="#rule33">原则33：不要出现拼写错误</a></li>
<li><a href="#rule34">原则34：不要使用全角字符</a></li>
<li><a href="#rule35">原则35：使用正确的词汇</a></li>
<li><a href="#rule36">原则36：使用简洁的句子</a></li>
<li><a href="#rule37">原则37：避免中式英语</a></li>
<li><a href="#rule38">原则38：使用一致的时态</a></li>
<li><a href="#rule39">原则39：考虑提供缩写词的解释</a></li>
<li><a href="#rule40">原则40：使用Bullets组织长段</a></li>
<li><a href="#rule41">原则41：打下良好的英文基础</a></li>
</ol>


<h3><a href="#sec8">其它</a></h3>

<ol>
<li><a href="#rule42">原则42：考虑使用超链接</a></li>
<li><a href="#rule43">原则43：考虑提供一个“加强版”简历</a></li>
<li><a href="#rule44">原则44：考虑提供开发社区账号</a></li>
<li><a href="#rule45">原则45：持续更新简历</a></li>
<li><a href="#rule46">原则46：不断提升个人能力</a></li>
<li><a href="#rule47">原则47：考虑征求他人意见</a></li>
</ol>


<h2>参考</h2>

<p>书籍：</p>

<ol>
<li><a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X/">Cracking the Coding Interview: 150 Programming Questions and Solutions</a></li>
<li><a href="http://www.amazon.com/The-Google-Resume-Prepare-Microsoft/dp/0470927623/">The Google Resume: How to Prepare for a Career and Land a Job at Apple, Microsoft, Google, or any Top Tech Company</a></li>
<li><a href="http://www.amazon.com/Land-Tech-Love-Pragmatic-Life/dp/1934356263/">Land the Tech Job You Love</a></li>
<li><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a></li>
<li><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a></li>
</ol>


<p>链接：</p>

<ol>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></li>
<li><a href="http://www.weibo.com/p/1001603769729557894059">英文简历咨询服务</a>：再次谢谢关注者的简历！</li>
</ol>


<hr />

<p>以上。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/"/>
    <updated>2014-10-23T23:54:02-07:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li>深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<h2>关于</h2>

<p>本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>一文的翻译，那么问题来了：</p>

<h3>为什么要写（翻译）这个系列？</h3>

<!-- more -->


<ol>
<li>工作之后，我开始大量使用Java</li>
<li>公司将会在不久的未来使用Java 8</li>
<li>作为资质平庸的开发者，我需要打一点提前量，以免到时拙计</li>
<li>为了学习Java 8（主要是其中的lambda及相关库），我先后阅读了Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>，<a href="http://www.amazon.com/Cay-S.-Horstmann/e/B000AQ1QDY/">Cay Horstmann</a>（<a href="http://www.amazon.com/Core-Volume-I--Fundamentals-Edition-Series/dp/0137081898/">Core Java</a>的作者）的<a href="http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/">Java 8 for the Really Impatient</a>和Richard Warburton的<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a></li>
<li>但我感到并没有多大收获，Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>涉及了lambda表达式的每一个概念，但都是点到辄止；后两本书（尤其是<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>）花了大量篇幅介绍Java lambda及其类库，但实质内容不多，读完了还是没有对Java lambda产生一个清晰的认识</li>
<li>关键在于这些文章和书都没有解决我对Java lambda的困惑，比如：

<ul>
<li>Java 8中的lambda为什么要设计成这样？（为什么要一个lambda对应一个接口？而不是Structural Typing？）</li>
<li>lambda和匿名类型的关系是什么？lambda是匿名对象的语法糖吗？</li>
<li>Java 8是如何对lambda进行类型推导的？它的类型推导做到了什么程度？</li>
<li>Java 8为什么要引入默认方法？</li>
<li>Java编译器如何处理lambda？</li>
<li>等等……</li>
</ul>
</li>
<li>之后我在Google搜索这些问题，然后就找到<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的三篇关于Java lambda的文章（<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>，<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of Lambda libraries version</a>和<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">Translation of lambda</a>），读完之后上面的问题都得到了解决</li>
<li>为了加深理解，我决定翻译这一系列文章</li>
</ol>


<h3>警告（Caveats）</h3>

<p>如果你不知道什么是函数式编程，或者不了解<code>map</code>，<code>filter</code>，<code>reduce</code>这些常用的高阶函数，那么你不适合阅读本文，请先学习函数式编程基础（比如<a href="http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/">这本书</a>）。</p>

<hr />

<h1><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a> by <a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a></h1>

<blockquote><p>The high-level goal of Project Lambda is to enable programming patterns that require modeling code as data to be convenient and idiomatic in Java.</p></blockquote>

<h2>关于</h2>

<p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>

<ul>
<li>lambda表达式（又被成为“闭包”或“匿名方法”）</li>
<li>方法引用和构造方法引用</li>
<li>扩展的目标类型和类型推导</li>
<li>接口中的默认方法和静态方法</li>
</ul>


<h2>1. 背景</h2>

<p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>

<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ActionListener</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里并不需要专门定义一个类来实现<code>ActionListener</code>接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="n">ActionListener</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>

<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的<a href="http://blogs.oracle.com/jrose/entry/better_closures">选择</a>，因为：</p>

<ol>
<li>语法过于冗余</li>
<li>匿名类中的<code>this</code>和变量名容易使人产生误解</li>
<li>类型载入和实例创建语义不够灵活</li>
<li>无法捕获非<code>final</code>的局部变量</li>
<li>无法对控制流进行抽象</li>
</ol>


<p>上面的多数问题均在Java SE 8中得以解决：</p>

<ul>
<li>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2</li>
<li>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3</li>
<li>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰</li>
</ul>


<p>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>

<h2>2. 函数式接口（Functional interfaces）</h2>

<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>

<ul>
<li>接口是Java类型系统的一部分</li>
<li>接口天然就拥有其运行时表示（Runtime representation）</li>
<li>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）</li>
</ul>


<p>上面提到的<code>ActionListener</code>接口只有一个方法，大多数回调接口都拥有这个特征：比如<code>Runnable</code>接口和<code>Comparator</code>接口。我们把这些只拥有一个方法的接口称为<em>函数式接口</em>。（之前它们被称为<em>SAM类型</em>，即<em>单抽象方法类型</em>（Single Abstract Method））</p>

<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个<code>Object</code>已经提供的方法，比如<code>toString()</code>，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过<code>@FunctionalInterface</code>注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>

<p>实现函数式类型的另一种方式是引入一个全新的<em>结构化</em>函数类型，我们也称其为“箭头”类型。例如，一个接收<code>String</code>和<code>Object</code>并返回<code>int</code>的函数类型可以被表示为<code>(String, Object) -&gt; int</code>。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>

<ul>
<li>它会为Java类型系统引入额外的复杂度，并带来<a href="http://en.wikipedia.org/wiki/Structural_type_system">结构类型（Structural Type）</a>和<a href="http://en.wikipedia.org/wiki/Nominal_type_system">指名类型（Nominal Type）</a>的混用。（Java几乎全部使用指名类型）</li>
<li>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型</li>
<li>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后</li>
<li>每个函数类型很难拥有其运行时表示，这意味着开发者会受到<a href="http://en.wikipedia.org/wiki/Type_erasure">类型擦除（erasure）</a>的困扰和局限。比如说，我们无法对方法<code>m(T-&gt;U)</code>和<code>m(X-&gt;Y)</code>进行重载（Overload）</li>
</ul>


<p>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：</p>

<ul>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html">java.security.PrivilegedAction</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html">java.util.Comparator</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html">java.io.FileFilter</a></li>
<li><a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html">java.beans.PropertyChangeListener</a></li>
</ul>


<p>除此之外，Java SE 8中增加了一个新的包：<code>java.util.function</code>，它里面包含了常用的函数式接口，例如：</p>

<ul>
<li><code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code></li>
<li><code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象，不返回值</li>
<li><code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象，返回<code>R</code>对象</li>
<li><code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂），不接收值</li>
<li><code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象，返回<code>T</code>对象</li>
<li><code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象，返回<code>T</code>对象</li>
</ul>


<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>。（我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如<code>BiFunction&lt;T, U, R&gt;</code>，它接收<code>T</code>对象和<code>U</code>对象，返回<code>R</code>对象。</p>

<h2>3. lambda表达式（lambda expressions）</h2>

<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作。</p>

<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>

<p>下面是一些lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'><span class="o">()</span> <span class="o">-&gt;</span> <span class="mi">42</span>
</span><span class='line'><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个lambda表达式接收<code>x</code>和<code>y</code>这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数&#8217;42&#8217;；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>

<p>lambda表达式的语法由参数列表、箭头符号<code>-&gt;</code>和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——

<ul>
<li><code>return</code>语句会把控制权交给匿名方法的调用者</li>
<li><code>break</code>和<code>continue</code>只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li>
</ul>
</li>
</ul>


<p>表达式函数体适合小型lambda表达式，它消除了<code>return</code>关键字，使得语法更加简洁。</p>

<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<p>下面是一些出现在语句中的lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">FileFilter</span> <span class="n">java</span> <span class="o">=</span> <span class="o">(</span><span class="n">File</span> <span class="n">f</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;*.java&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">String</span> <span class="n">user</span> <span class="o">=</span> <span class="n">doPrivileged</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;user.name&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">connectToService</span><span class="o">();</span>
</span><span class='line'>  <span class="n">sendNotification</span><span class="o">();</span>
</span><span class='line'><span class="o">}).</span><span class="na">start</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>4. 目标类型（Target typing）</h2>

<p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是<code>ActionListener</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">ActionListener</span> <span class="n">l</span> <span class="o">=</span> <span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">&quot;done&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">&quot;done&quot;</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个lambda表达式<code>() -&gt; "done"</code>是<code>Callable</code>的实例，而第二个lambda表达式则是<code>PrivilegedAction</code>的实例。</p>

<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导，这个<strong>被期待的类型</strong>被称为<em>目标类型</em>。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>

<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型<code>T</code>：</p>

<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li>
<li>lambda表达式的返回值和<code>T</code>的方法返回值相兼容（Compatible）</li>
<li>lambda表达式内所抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li>
</ul>


<p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareToIgnoreCase</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的例子里，编译器可以推导出<code>s1</code>和<code>s2</code>的类型是<code>String</code>。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">FileFilter</span> <span class="n">java</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.java&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="na">dazzle</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>

<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">li</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5. 目标类型的上下文（Contexts for target typing）</h2>

<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>

<ul>
<li>变量声明</li>
<li>赋值</li>
<li>返回语句</li>
<li>数组初始化器</li>
<li>方法和构造方法的参数</li>
<li>lambda表达式函数体</li>
<li>条件表达式（<code>? :</code>）</li>
<li>转型（Cast）表达式</li>
</ul>


<p>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">;</span>
</span><span class='line'><span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span> <span class="n">s1</span><span class="o">,</span> <span class="n">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareToIgnoreCase</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="n">Runnable</span> <span class="nf">toDoLater</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;later&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">filterFiles</span><span class="o">(</span><span class="k">new</span> <span class="n">FileFilter</span><span class="o">[]</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">(),</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">canRead</span><span class="o">(),</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;q&quot;</span><span class="o">)</span>
</span><span class='line'>            <span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>

<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有<strong>显式类型</strong>（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有<strong>隐式类型</strong>（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>

<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Stream</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，<code>ps</code>的类型是<code>List&lt;Person&gt;</code>，所以<code>ps.stream()</code>的返回类型是<code>Stream&lt;Person&gt;</code>。<code>map()</code>方法接收一个类型为<code>Function&lt;T, R&gt;</code>的函数式接口，这里<code>T</code>的类型即是<code>Stream</code>元素的类型，也就是<code>Person</code>，而<code>R</code>的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导<code>R</code>的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回<code>String</code>，因此<code>R</code>的类型是<code>String</code>，因而<code>map()</code>返回<code>Stream&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>

<ul>
<li>使用显式lambda表达式（为参数<code>p</code>提供显式类型）以提供额外的类型信息</li>
<li>把lambda表达式转型为<code>Function&lt;Person, String&gt;</code></li>
<li>为泛型参数<code>R</code>提供一个实际类型。（<code>.&lt;String&gt;map(p -&gt; p.getName())</code>）</li>
</ul>


<p>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">);</span> <span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">?</span> <span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">23</span><span class="o">)</span> <span class="o">:</span> <span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">42</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// Object o = () -&gt; { System.out.println(&quot;hi&quot;); }; 这段代码是非法的</span>
</span><span class='line'><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="o">(</span><span class="n">Runnable</span><span class="o">)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">);</span> <span class="o">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>

<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">checkedList</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(),</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">si</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">?</span> <span class="n">Collections</span><span class="o">.</span><span class="na">singleton</span><span class="o">(</span><span class="mi">23</span><span class="o">)</span> <span class="o">:</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptySet</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<h2>6. 词法作用域（Lexical scoping）</h2>

<p>在内部类中使用变量名（以及<code>this</code>）非常容易出错。内部类中通过继承得到的成员（包括来自<code>Object</code>的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的<code>this</code>引用会指向内部类自己而非外部类。</p>

<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，&#8217;this&#8217;关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>

<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把<code>"Hello, world!"</code>打印两遍：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> <span class="o">}</span>
</span><span class='line'>  <span class="n">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">toString</span><span class="o">());</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>  <span class="k">return</span> <span class="s">&quot;Hello, world&quot;</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">Hello</span><span class="o">().</span><span class="na">r1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">Hello</span><span class="o">().</span><span class="na">r2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与之相类似的内部类实现则会打印出类似<code>Hello$1@5b89a773</code>和<code>Hello$2@537a7706</code>之类的字符串，这往往会使开发者大吃一惊。</p>

<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如<code>for</code>循环和<code>catch</code>从句）一致。</p>

<p><strong>个人补充</strong>：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//这里会出现编译错误，因为i已经在for循环外部声明过了</span>
</span><span class='line'>  <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>7. 变量捕获（Variable capture）</h2>

<p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合<em>有效只读</em>（Effectively final）的局部变量。</p>

<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上<code>final</code>后也不会导致编译错误的局部变量就是有效只读变量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">helloCallable</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">hello</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段的引用和未限定方法的调用在本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其它情况下，lambda对象不会保留任何对<code>this</code>的引用。</p>

<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>

<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对<em>值</em>封闭，对<em>变量</em>开放。</p>

<p><strong>个人补充</strong>：lambda表达式对<em>值</em>封闭，对<em>变量</em>开放的原文是：lambda expressions close over <em>values</em>, not <em>variables</em>，我在这里增加一个例子以说明这个特性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">});</span> <span class="c1">// Illegal, close over values</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">aList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">aList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span> <span class="o">});</span> <span class="c1">// Legal, open over variables</span>
</span></code></pre></td></tr></table></div></figure>


<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。<code>java.util.stream</code>包提供了各种通用的和专用的规约操作（例如<code>sum</code>、<code>min</code>和<code>max</code>），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替<code>forEach</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>              <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>              <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>sum()</code>等价于下面的规约操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>              <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
</span><span class='line'>              <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span> <span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="mi">0</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">list</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>

<h2>8. 方法引用（Method references）</h2>

<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在<em>已有的</em>方法上实现同样的特性。</p>

<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>

<p>以下面的代码为例，假设我们要按照<code>name</code>或<code>age</code>为<code>Person</code>数组进行排序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">age</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">name</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Person</span><span class="o">[]</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">byName</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'><span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">byName</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里我们可以用方法引用代替lambda表达式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">byName</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>Person::getName</code>可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>

<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">b1</span> <span class="o">=</span> <span class="nl">System:</span><span class="o">:</span><span class="n">exit</span><span class="o">;</span>    <span class="c1">// void exit(int status)</span>
</span><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">[]&gt;</span> <span class="n">b2</span> <span class="o">=</span> <span class="nl">Arrays:</span><span class="n">sort</span><span class="o">;</span>    <span class="c1">// void sort(Object[] a)</span>
</span><span class='line'><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">b3</span> <span class="o">=</span> <span class="nl">MyProgram:</span><span class="o">:</span><span class="n">main</span><span class="o">;</span>  <span class="c1">// void main(String... args)</span>
</span><span class='line'><span class="n">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="nl">Myprogram:</span><span class="o">:</span><span class="n">mapToInt</span>        <span class="c1">// void main(String... args)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>9. 方法引用的种类（Kinds of method references）</h2>

<p>方法引用有很多种，它们的语法如下：</p>

<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>


<p>对于静态方法引用，我们需要在类名和方法名之间加入<code>::</code>分隔符，例如<code>Integer::sum</code>。</p>

<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">knownNames</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">isKnown</span> <span class="o">=</span> <span class="nl">knownNames:</span><span class="o">:</span><span class="n">contains</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的隐式lambda表达式（也就是实例方法引用）会从<code>knownNames</code>中捕获<code>String</code>对象，而它的方法体则会通过<code>Set.contains</code>使用该<code>String</code>对象。</p>

<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Callable</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Privileged</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="nl">c:</span><span class="o">:</span><span class="n">call</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">upperfier</span> <span class="o">=</span> <span class="nl">String:</span><span class="o">:</span><span class="n">toUpperCase</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的隐式lambda表达式（即<code>String::toUpperCase</code>实例方法引用）有一个<code>String</code>参数，这个参数会被<code>toUpperCase</code>方法使用。</p>

<p>如果类型的实例方法是泛型的，那么我们就需要在<code>::</code>分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>

<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>

<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在<code>::</code>分隔符之前提供参数类型信息。</p>

<p>和静态方法引用类似，构造方法也可以通过<code>new</code>关键字被直接引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">SocketImplFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nl">MySocketImpl:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>

<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照&#8221;菱形&#8221;构造方法调用时的方式进行推导。</p>

<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收<code>int</code>参数的数组构造方法。参考下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">IntFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">arrayMaker</span> <span class="o">=</span> <span class="kt">int</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">arrayMaker</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> <span class="c1">// 创建数组 int[10]</span>
</span></code></pre></td></tr></table></div></figure>


<h2>10. 默认方法和静态接口方法（Default and static interface methods）</h2>

<p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把<em>代码即数据</em>（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>

<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。<em>默认方法</em>（之前被称为<em>虚拟扩展方法</em>或<em>守护方法</em>）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>

<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如<code>removeAll</code>方法应该被泛化为接收一个函数式接口<code>Predicate</code>，但这个新的方法应该被放在哪里呢？我们无法直接在<code>Collection</code>接口上新增方法——不然就会破坏现有的<code>Collection</code>实现。我们倒是可以在<code>Collections</code>工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>

<p><em>默认方法</em>利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是<em>抽象的</em>或是<em>默认的</em>。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>

<p>下面的例子展示了如何向<code>Iterator</code>接口增加默认方法<code>skip</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>
</span><span class='line'>  <span class="n">E</span> <span class="nf">next</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">remove</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">default</span> <span class="kt">void</span> <span class="nf">skip</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">hasNext</span><span class="o">();</span> <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">next</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据上面的<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会自动继承<code>skip</code>方法。在使用者的眼里，<code>skip</code>不过是接口新增的一个虚拟方法。在没有覆盖<code>skip</code>方法的<code>Iterator</code>子类实例上调用<code>skip</code>会执行<code>skip</code>的默认实现：调用<code>hasNext</code>和<code>next</code>若干次。子类可以通过覆盖<code>skip</code>来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>

<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>

<p>除了默认方法，Java SE 8还在允许在接口中定义<em>静态</em>方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如<code>Collections</code>）。比如，我们一般需要使用静态辅助方法生成实现<code>Comparator</code>的比较器，在Java SE 8中我们可以直接把该静态方法定义在<code>Comparator</code>接口中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">U</span><span class="o">&gt;&gt;</span>
</span><span class='line'>    <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">comparing</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c1</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c2</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>11. 继承默认方法（Inheritance of default methods）</h2>

<p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>

<ul>
<li>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。</li>
<li>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。</li>
</ul>


<p>为了演示第二条规则，我们假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法。在下面的<code>implement</code>从句中，<code>List</code>中的方法声明会优先于<code>Queue</code>中的方法声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Robot</span> <span class="kd">implements</span> <span class="n">Artist</span><span class="o">,</span> <span class="n">Gun</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">default</span> <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span> <span class="n">Artist</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">draw</span><span class="o">();</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>super</code>前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>

<p>最后，接口在<code>inherits</code>和<code>extends</code>从句中的声明顺序和它们被实现的顺序无关。</p>

<h2>12. 融会贯通（Putting it together）</h2>

<p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>

<p>比如说下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Person</span> <span class="n">x</span><span class="o">,</span> <span class="n">Person</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getLastName</span><span class="o">());</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>冗余代码实在太多了！</p>

<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Person</span> <span class="n">x</span><span class="o">,</span> <span class="n">Person</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getLastName</span><span class="o">().</span><span class="na">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助<code>Comparator</code>里的<code>comparing</code>方法实现比较操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">((</span><span class="n">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们注意到这里的lambda表达式实际上是<code>getLastName</code>的代理（forwarder），于是我们可以用方法引用代替它：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">people</span><span class="o">,</span> <span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，使用<code>Collections.sort</code>这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现<code>List</code>接口的数据结构提供特定（specialized）的高效实现，而且由于<code>Collections.sort</code>方法不属于<code>List</code>接口，用户在阅读<code>List</code>接口的文档时不会察觉在另外的<code>Collections</code>类中还有一个针对<code>List</code>接口的排序（<code>sort()</code>）方法。</p>

<p>默认方法可以有效的解决这个问题，我们为<code>List</code>增加默认方法<code>sort()</code>，然后就可以这样调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">));;</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外，如果我们为<code>Comparator</code>接口增加一个默认方法<code>reversed()</code>（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getLastName</span><span class="o">).</span><span class="na">reversed</span><span class="o">());;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>13. 小结（Summary）</h2>

<p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Top Coder算法题目浏览器]]></title>
    <link href="http://zh.lucida.me/blog/top-code-offline-browser/"/>
    <updated>2014-10-14T23:37:29-07:00</updated>
    <id>http://zh.lucida.me/blog/top-code-offline-browser</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>

<h2>关于</h2>

<p><a href="http://weibo.com/haoel">左耳朵耗子</a>在最近发了一条关于leetcode的微博：</p>

<p><img src="http://i.imgur.com/alUuOmx.jpg" alt="微博截图" /></p>

<p>佩服之余，想起自己两年前找工作时随手写的一个小程序：Top Coder算法题目浏览器，硬盘里翻了翻没找到，于是找师弟要了一份copy，截了几张图放到微博上。</p>

<p><img src="http://i.imgur.com/bIiXNR4.jpg" alt="微博截图" /></p>

<p>没想到不少人表示很感兴趣，还有些同学留下邮箱索要这个算法题目浏览器——我是懒的一个个发邮箱，所以干脆放到博客上，顺便提高下访问量 :)</p>

<!-- more -->


<h2>介绍</h2>

<h3>TC Browser</h3>

<p><strong>TC Browser</strong>：全称<strong>Top Coder offline Browser</strong>，是我为了方便自己练习算法题目而花一下午制作的Windows小程序。</p>

<p><strong>TC Browser</strong>内置2933道算法题目，这些算法题目覆盖动态规划（Dynamic Programming）、递归（Recursion）、迭代（Iteration）、暴力（Brute Force）和图论（Graph Theory）等17个分类，并按照级别（Level）不同和难度（Success Rate）不同进行分类，以便从简单到复杂逐步练习。</p>

<h4>TC Browser可以</h4>

<ul>
<li>离线浏览算法题目 &ndash;_&ndash;</li>
<li>按照算法、级别和难度过滤题目，以便逐步提高水平。</li>
<li>随机出题 &ndash;_&ndash;</li>
</ul>


<h4>TC Browser不可以</h4>

<ul>
<li>评判（Judge）题目，如它的名字，TC Browser只是一个题目浏览器，而非一个完整的OJ（Online Judge）。不过好在TC题目的Sample Input/Output比较全。</li>
<li>提供答案（Answer），嗯，这些题目都没有答案，所以对于初学者可能不合适。</li>
</ul>


<h3>为什么选择<a href="http://www.topcoder.com/">Top Coder</a>？</h3>

<ol>
<li>大量的算法题目：<strong>TC Browser</strong>是我两年半前写的，当时有2933道题目，现在的题目只会更多。</li>
<li>题目具有良好的分类：Top Coder里的每道算法题目都有明确的分类：类型（Category）、级别（Level）、难度（Success Rate）。</li>
<li>良好的题目陈述（Problem Statement）：Top Coder的题目陈述非常清晰，并且都带有若干组示例输入/输出（Sample Input/Output）。</li>
<li>题目相对实际（Practical）：相对于一些OJ的纯算法题目，Top Coder里面的题目更加实际——更接近与实际的编程而非单纯的算法演练，对于非算法竞赛出身的我非常合适。</li>
<li>Top Coder在线不稳定：也许是我的网络原因，我经常登陆不进Top Coder，这也是我编写离线版TC的原因之一。</li>
</ol>


<h2>使用</h2>

<h3>Top Coder术语</h3>

<p>如果你玩过Top Coder，请跳过本节 :&ndash;)</p>

<p>Top Coder的题目分为两个区（Division，简称D），每个区又分为三个级别（Level，简称L），每道题目有其通过率（Success Rate）。D1难度小于D2，L1难度小于L2小于L3，通过率越高难度越低。</p>

<p>举例来说，一道D1L1SR50的题目适合初学者练习，一道D2L2SR30的题目就可能需要相当的算法水准才能搞定。</p>

<h3>我如何使用TC Browser</h3>

<p>在找工作初期，我的算法水平非常拙计，于是我所练习的题目大多都是D1L2和D1L3，SR>40的题目，同时根据往届师兄师姐的面试经验，我会重点练习动态规划、递归、字符串操作和搜索这几个类型的题目。</p>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="截图" /></p>

<p>到了中后期，随着经验的累计，我开始练习D1L3的题目，并尝试一些D2L1的题目。</p>

<p><img src="http://i.imgur.com/yHE02Qi.jpg" alt="截图" /></p>

<p>到了最后，就开始使用Random模式——从D2L1和D2L2中随机出一道题目然后思考解决思路，想出来之后再随机下一道。</p>

<p>为了练习方便，我为TC Browser加了一个做题模式——其实就是把题目选择区隐藏，这样就可以方便的双窗口操作。</p>

<h4>浏览模式：</h4>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="浏览模式" /></p>

<h4>做题模式：</h4>

<p><img src="http://i.imgur.com/gNn58vt.jpg" alt="做题模式" /></p>

<p>顺便提一句，TC Browser左上角的Config、Switch Mode和About三个按钮只有Switch Mode能用——一个按钮，三倍情怀。</p>

<h3>面试有多难？</h3>

<p>就我的面试经验来说，D2L1的题目已经相当够用了——绝大多数的编程题目都没有超过D1L3的难度，要知道面试只有45分钟，搞那些惊天地泣鬼神的算法题目面试官和面试者谁都受不了。</p>

<p>但也要注意，我没有算法竞赛背景，所以面试官不会问太难的题目，但对于那些算法竞赛选手就是另一种情况了——面试官需要用更难的题目来确认你是一个合格的算法选手，正所谓道高一尺，魔高一丈。</p>

<h2>下载地址</h2>

<p>所以下载地址在这里：<a href="http://pan.baidu.com/s/1fGX5c">网盘地址</a></p>

<p>解压密码是宇宙的终极答案（The ultimate anwser to the universe）。</p>

<p>谢谢试用，至于代码可以自行反编译阅读（写的翔一般还是不读为好），恕不赘述。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 全程指南]]></title>
    <link href="http://zh.lucida.me/blog/sublime-text-complete-guide/"/>
    <updated>2014-09-27T13:57:15-07:00</updated>
    <id>http://zh.lucida.me/blog/sublime-text-complete-guide</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>摘要（Abstract）</h2>

<p>本文系统全面的介绍了Sublime Text，旨在成为最优秀的Sublime Text中文教程。</p>

<h3>更新记录</h3>

<ol>
<li>2014/09/27：完成初稿</li>
<li>2014/09/28：

<ul>
<li>更正打开控制台的快捷键为<code>Ctrl + `</code></li>
<li>更正全局替换的快捷键为<code>Ctrl + Alt + Enter</code></li>
</ul>
</li>
</ol>


<h2>前言（Prologue）</h2>

<p>Sublime Text是一款跨平台代码编辑器（Code Editor），从最初的Sublime Text 1.0，到现在的Sublime Text 3.0，Sublime Text从一个不知名的编辑器演变到现在几乎是各平台首选的GUI编辑器。而这样优秀的编辑器却没有一个靠谱的中文教程，所以我试图通过本文弥补这个缺陷。</p>

<h3>编辑器的选择（Editor Choices）</h3>

<p>从初学编程到现在，我用过的编辑器有EditPlus、UltraEdit、Notepad++、Vim、TextMate和Sublime Text，如果让我从中推荐，我会毫不犹豫的推荐Vim和Sublime Text，原因有下面几点：</p>

<!-- more -->


<ol>
<li><strong>跨平台</strong>：Vim和Sublime Text均为跨平台编辑器（在Linux、OS X和Windows下均可使用）。作为一个程序员，切换系统是常有的事情，为了减少重复学习，使用一个跨平台的编辑器是很有必要的。</li>
<li><strong>可扩展</strong>：Vim和Sublime Text都是可扩展的（Extensible），并包含大量实用插件，我们可以通过安装自己领域的插件来成倍提高工作效率。</li>
<li><strong>互补</strong>：Vim和Sublime Text分别是命令行环境（CLI）和图形界面环境（GUI）下的最佳选择，同时使用两者会大大提高工作效率。</li>
</ol>


<h3>个人背景（Personal Background）</h3>

<p>我是一名非常典型的程序员：平时工作主要在Linux环境下使用Java和Python，偶尔会用HTML+CSS+JavaScript编写网页；业余时会在Windows环境编写一些C#程序（包括控制台程序（Console Application）和移动应用（Mobile App），也会玩一些非主流语言（比如Haskell，ML和Ruby等）以拓展见识。</p>

<p>所以这篇文章会我的个人工作内容为主要使用场景（Scenario），尽管无法覆盖到所有的使用场景，但我认为依然可以覆盖到绝大部分，如果您认为我遗漏了什么内容，请在文章下面回复，我会尽量更新。</p>

<h3>本文风格（Writing Style）</h3>

<p>受益于<a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R C</a>的写作风格，我倾向于以实际案例来讲解Sublime Text的功能，所以本文中的例子均源于我在实际开发时遇到的问题。</p>

<p>此外，把本文会使用大量动画（GIF）演示Sublime Text的编辑功能，因为我发现图片难以演示完整的编辑流程（Workflow），而视频又过于重量级。本文的GIF动画均使用<a href="http://screentogif.codeplex.com/">ScreenToGif</a>进行录制。</p>

<h3>编辑器（Editor） vs 集成开发环境（Integrated Development Environment，下文简称IDE）</h3>

<p>我经常看到一些程序员拿编辑器和IDE进行比较，诸如Vim比Eclipse强大或是Visual Studio太慢不如Notepad++好使之类的讨论比比皆是，个人认为这些讨论没有意义，因为编辑器和IDE根本是面向两种不同使用场景的工具：</p>

<ul>
<li>编辑器面向无语义的纯文本，不涉及领域逻辑，因此速度快体积小，适合编写单独的配置文件和动态语言脚本（Shell、Python和Ruby等）。</li>
<li>IDE面向有语义的代码，会涉及到大量领域逻辑，因此速度偏慢体积庞大，适合编写静态语言项目（Java、C++和C#等）。</li>
</ul>


<p>我认为应当使用正确的工具去做有价值的事情，并把效率最大化，所以我会用Eclipse编写Java项目，用Vim编写Shell，用Sublime Text编写JavaScript/HTML/Python，用Visual Studio编写C#。</p>

<p>前言到此结束，下面进入正题。</p>

<h2>安装（Installation）</h2>

<p>Sublime Text<a href="http://www.sublimetext.com/">官方网站</a>提供了Sublime Text各系统各版本的下载，目前Sublime Text的最新版本是<a href="http://www.sublimetext.com/3">Sublime Text 3</a>。这里以Windows版本的Sublime Text安装为例。</p>

<p>注意在安装时勾选<strong>Add to explorer context menu</strong>，这样在右键单击文件时就可以直接使用Sublime Text打开。</p>

<p><img src="http://i.imgur.com/zVtiXNP.jpg" alt="右键打开" /></p>

<h3>添加Sublime Text到环境变量</h3>

<p>使用<code>Win + R</code>运行<code>sysdm.cpl</code>打开“系统属性”。</p>

<p><img src="http://i.imgur.com/ysZe1BH.jpg" alt="sysdm.cpl" /></p>

<p>然后在“高级”选项卡里选择“环境变量”，编辑“Path”，增加Sublime Text的安装目录（例如<code>D:\Program Files\Sublime Text 3</code>）。</p>

<p><img src="http://i.imgur.com/dY5EaZX.jpg" alt="添加环境变量" /></p>

<p>接下来你就可以在命令行里面利用<code>subl</code>命令直接使用Sublime Text了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>subl file    :: 使用Sublime Text打开file文件
</span><span class='line'>subl folder  :: 使用Sublime Text打开folder文件夹
</span><span class='line'>subl .       :: 使用Sublime Text当前文件夹</span></code></pre></td></tr></table></div></figure>


<h3>安装Package Control</h3>

<p>前文提到Sublime Text支持大量插件，如何找到并管理这些插件就成了一个问题，Package Control正是为了解决这个问题而出现的，利用它我们可以很方便的浏览、安装和卸载Sublime Text中的插件。</p>

<p>进入Package Control的<a href="https://sublime.wbond.net/">官网</a>，里面有详细的<a href="https://sublime.wbond.net/installation">安装教程</a>。Package Control支持Sublime Text 2和3，本文只给出3的安装流程：</p>

<ul>
<li>使用<code>Ctrl + `</code>打开Sublime Text控制台。</li>
<li>将下面的代码粘贴到控制台里：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>等待Package Control安装完成。之后使用<code>Ctrl + Shift + P</code>打开命令板，输入<code>PC</code>应出现Package Control：</li>
</ul>


<p><img src="http://i.imgur.com/fgnl2Qj.jpg" alt="Package Control安装成功" /></p>

<p>成功安装Package Control之后，我们就可以方便的安装使用Sublime Text的各种插件：</p>

<p><img src="http://i.imgur.com/pnuar4c.gif" alt="使用Package Control安装插件" /></p>

<h2>购买（Purchase）</h2>

<p>Sublime Text是一个收费闭源软件，这在一定程度上成为了我支持Sublime Text的理由（我心中的软件靠谱程度：免费开源 &lt;&lt; 免费闭源 &lt; 收费开源 &lt; 收费闭源）：在<a href="https://www.sublimetext.com/buy">这里</a>购买。</p>

<p>不过不购买Sublime Text也可以“正常”使用它，只是Sublime Text会时不时的弹出一个对话框提醒你购买，此外窗口处会有一个很屌丝很low逼的<strong>(UNREGISTERED)</strong>。（在高频操作下，一般20分钟提示一次，个人认为算是很厚道了）</p>

<p><img src="http://i.imgur.com/hPNqz66.jpg" alt="提示注册" /></p>

<p>也许不少人会觉着Sublime Text 70刀的价格太贵，但相比它的功能和带来的效率提升，70刀真的不值一提，如果你不方便使用Paypal付款可以邮件联系我，你支付宝给我打款然后我帮你付款，价格按当日汇率折算（450元左右）。</p>

<p><img src="http://i.imgur.com/gWt2eLA.jpg" alt="购买之后" /></p>

<h2>概览（Tour）</h2>

<h3>基本概念（Basic Concepts）</h3>

<p>Sublime Text的界面如下：</p>

<p><img src="http://i.imgur.com/XrUYmH8.jpg" alt="Sublime Text" /></p>

<ul>
<li>标签（Tab）：无需介绍。</li>
<li>编辑区（Editing Area）：无需介绍。</li>
<li>侧栏（Side Bar）：包含当前打开的文件以及文件夹视图。</li>
<li>缩略图（Minimap）：如其名。</li>
<li>命令板（Command Palette）：Sublime Text的操作中心，它使得我们基本可以脱离鼠标和菜单栏进行操作。</li>
<li>控制台（Console）：使用<code>Ctrl + `</code>调出，它既是一个标准的Python REPL，也可以直接对Sublime Text进行配置。</li>
<li>状态栏（Status Bar）：显示当前行号、当前语言和Tab格式等信息。</li>
</ul>


<h3>配置（Settings）</h3>

<p>与其他GUI环境下的编辑器不同，Sublime Text并没有一个专门的配置界面，与之相反，Sublime Text使用JSON配置文件，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "font_size": 12,
</span><span class='line'>  "highlight_line": true,
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>会将默认字体大小调整为12，并高亮当前行。</p>

<p>JSON配置文件的引入简化了Sublime Text的界面，但也使得配置变的复杂，一般我会到<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/settings.html">这里</a>查看可用的Sublime Text配置。</p>

<h2>编辑（Editing）</h2>

<p>Sublime Text的编辑十分人性化——它不像Vim那样反人类（尽管我也用Vim但我还是要说Vim的快捷键设定绝壁连代谢产物都不如），少量的快捷键就可以完成绝大多数编辑任务。</p>

<h3>基本编辑（Basic Editing）</h3>

<p><code>↑↓←→</code>就是<code>↑↓←→</code>，不是<code>KJHL</code>，（没错我就是在吐槽Vim，尼玛设成<code>WSAD</code>也比这个强啊），粘贴剪切复制均和系统一致。</p>

<p><code>Ctrl + Enter</code>在当前行下面新增一行然后跳至该行；<code>Ctrl + Shift + Enter</code>在当前行上面增加一行并跳至该行。</p>

<p><img src="http://i.imgur.com/rvzS9Ok.gif" alt="演示新增行" /></p>

<p><code>Ctrl + ←/→</code>进行逐词移动，相应的，<code>Ctrl + Shift + ←/→</code>进行逐词选择。</p>

<p><img src="http://i.imgur.com/jFnTDl3.gif" alt="演示逐词移动及选择" /></p>

<p><code>Ctrl + ↑/↓</code>移动当前显示区域，<code>Ctrl + Shift + ↑/↓</code>移动当前行。</p>

<p><img src="http://i.imgur.com/v31pd3k.gif" alt="演示移动当前行" /></p>

<h3>选择（Selecting）</h3>

<p>Sublime Text的一大亮点是支持多重选择——同时选择多个区域，然后同时进行编辑。</p>

<p><code>Ctrl + D</code>选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑。</p>

<p>多重选词的一大应用场景就是重命名——从而使得代码更加整洁。尽管Sublime Text无法像IDE（例如Eclipse）那样进行自动重命名，但我们可以通过多重选词+多重编辑进行直观且便捷的重命名：</p>

<p><img src="http://i.imgur.com/IRVbUTJ.gif" alt="利用多重选词进行重命名" /></p>

<p>有时我们需要对一片区域的所有行进行同时编辑，<code>Ctrl + Shift + L</code>可以将当前选中区域打散，然后进行同时编辑：</p>

<p><img src="http://i.imgur.com/0NHpXFl.gif" alt="利用打散为列表套上引号" /></p>

<p>有打散自然就有合并，<code>Ctrl + J</code>可以把当前选中区域合并为一行：</p>

<p><img src="http://i.imgur.com/hfRAyiy.gif" alt="合并选中行" /></p>

<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<p>Sublime Text提供了强大的查找（和替换）功能，为了提供一个清晰的介绍，我将Sublime Text的查找功能分为<strong>快速查找</strong>、<strong>标准查找</strong>和<strong>多文件查找</strong>三种类型。</p>

<h4>快速查找&amp;替换</h4>

<p>多数情况下，我们需要查找文中某个关键字出现的其它位置，这时并不需要重新将该关键字重新输入一遍然后搜索，我们只需要使用<code>Shift + ←/→</code>或<code>Ctrl + D</code>选中关键字，然后<code>F3</code>跳到其下一个出现位置，<code>Shift + F3</code>跳到其上一个出现位置，此外还可以用<code>Alt + F3</code>选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p>

<p><img src="http://i.imgur.com/gcaHacI.gif" alt="使用快速替换" /></p>

<h4>标准查找&amp;替换</h4>

<p>另一种常见的使用场景是搜索某个已知但不在当前显示区域的关键字，这时可以使用<code>Ctrl + F</code>调出搜索框进行搜索：</p>

<p><img src="http://i.imgur.com/6AaBiRS.jpg" alt="Sublime Text的搜索框" /></p>

<p>以及使用<code>Ctrl + H</code>进行替换：</p>

<p><img src="http://i.imgur.com/4NnE9SN.jpg" alt="Sublime Text的替换框" /></p>

<h5>关键字查找&amp;替换</h5>

<p>对于普通用户来说，常规的关键字搜索就可以满足其需求：在搜索框输入关键字后<code>Enter</code>跳至关键字当前光标的下一个位置，<code>Shift + Enter</code>跳至上一个位置，<code>Alt + Enter</code>选中其出现的所有位置（同样的，接下来可以进行快速替换）。</p>

<p>Sublime Text的查找有不同的模式：<code>Alt + C</code>切换大小写敏感（Case-sensitive）模式，<code>Alt + W</code>切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"auto_find_in_selection": true</span></code></pre></td></tr></table></div></figure>


<p>这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：</p>

<p><img src="http://i.imgur.com/QRIsDra.gif" alt="使用范围搜索进行局部重命名" /></p>

<p>使用<code>Ctrl + H</code>进行标准替换，输入替换内容后，使用<code>Ctrl + Shift + H</code>替换当前关键字，<code>Ctrl + Alt + Enter</code>替换所有匹配关键字。</p>

<h5>正则表达式查找&amp;替换</h5>

<p><a href="http://en.wikipedia.org/wiki/Regular_expression">正则表达式</a>是非常强大的文本查找&amp;替换工具，Sublime Text中使用<code>Alt + R</code>切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html">Boost里的Perl正则表达式风格</a>。</p>

<p>出于篇幅原因，本文不会对正则表达式进行详细介绍，<a href="http://regex.info/">Mastering Regex</a>（中译本：<a href="http://book.douban.com/subject/2154713/">精通正则表达式</a>）对正则表达式的原理和各语言下的使用进行了详细介绍。此外网上有大量正则表达式的优秀教程（<a href="http://deerchao.net/tutorials/regex/regex.htm">“正则表达式30分钟入门教程”</a>和<a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90">MSDN正则表达式教程</a>.aspx)），以及在线测试工具（<a href="http://regexpal.com/">regexpal</a>和<a href="http://www.regexr.com/">regexer</a>）。</p>

<h4>多文件搜索&amp;替换</h4>

<p>使用<code>Ctrl + Shift + F</code>开启多文件搜索&amp;替换（注意此快捷键和搜狗输入法的简繁切换快捷键有冲突）：</p>

<p><img src="http://i.imgur.com/05Fchle.jpg" alt="多文件搜索界面" /></p>

<p>多文件搜索&amp;替换默认在当前打开的文件和文件夹进行搜索/替换，我们也可以指定文件/文件夹进行搜索/替换。</p>

<h3>跳转（Jumping）</h3>

<p>Sublime Text提供了强大的跳转功能使得我们可以在不同的文件/方法/函数中无缝切换。就我的使用经验而言，目前还没有哪一款编辑器可以在这个方面超越Sublime Text。</p>

<h4>跳转到文件</h4>

<p><code>Ctrl + P</code>会列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后<code>Enter</code>跳转至该文件。</p>

<p>需要注意的是，Sublime Text使用模糊字符串匹配（Fuzzy String Matching），这也就意味着你可以通过文件名的前缀、首字母或是某部分进行匹配：例如，<code>EIS</code>、<code>Eclip</code>和<code>Stupid</code>都可以匹配<code>EclipseIsStupid.java</code>。</p>

<p><img src="http://i.imgur.com/db15c5n.gif" alt="跳转到文件" /></p>

<h4>跳转到符号</h4>

<p>尽管是一个文本编辑器，Sublime Text能够对代码符号进行一定程度的索引。<code>Ctrl + R</code>会列出当前文件中的符号（例如类名和函数名，但无法深入到变量名），输入符号名称<code>Enter</code>即可以跳转到该处。此外，还可以使用<code>F12</code>快速跳转到当前光标所在符号的定义处（Jump to Definition）。</p>

<p><img src="http://i.imgur.com/D2rGDck.gif" alt="跳转到符号" /></p>

<p>比较有意思的是，对于Markdown，<code>Ctrl + R</code>会列出其大纲，非常实用。</p>

<p><img src="http://i.imgur.com/qDnjcNn.jpg" alt="Markdown大纲" /></p>

<h4>跳转到某行</h4>

<p><code>Ctrl + G</code>然后输入行号以跳转到指定行：</p>

<p><img src="http://i.imgur.com/F5BLsae.gif" alt="跳转到某行" /></p>

<h4>组合跳转</h4>

<p>在<code>Ctrl + P</code>匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p>

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>


<p><img src="http://i.imgur.com/3y9MG88.gif" alt="组合跳转演示" /></p>

<p>所以Sublime Text把<code>Ctrl + P</code>称之为<strong>“Go To Anything”</strong>，这个功能如此好用，以至于我认为没有其它编辑器能够超越它。</p>

<h3>中文输入法的问题</h3>

<p>从Sublime Text的初版（1.0）到现在（3.0 3065），中文输入法（包括日文输入法）都有一个问题：输入框不跟随。</p>

<p><img src="http://i.imgur.com/VQQ87Rr.jpg" alt="输入框不跟随" /></p>

<p>目前官方还没有修复这个bug，解决方法是安装<code>IMESupport</code>插件，之后重启Sublime Text问题就解决了。</p>

<p><img src="http://i.imgur.com/ErbK7wH.jpg" alt="修复之后输入框跟随" /></p>

<h3>文件夹（Folders）</h3>

<p>Sublime Text支持以文件夹做为单位进行编辑，这在编辑一个文件夹下的代码时尤其有用。在<code>File</code>下<code>Open Folder</code>：</p>

<p><img src="http://i.imgur.com/xS9Nriz.jpg" alt="文件夹视图" /></p>

<p>你会发现右边多了一个侧栏，这个侧栏列出了当前打开的文件和文件夹的文件，使用<code>Ctrl + K, Ctrl + B</code>显示或隐藏侧栏，使用<code>Ctrl + P</code>快速跳转到文件夹里的文件。</p>

<h2>窗口&amp;标签（Windows &amp; Tabs）</h2>

<p>Sublime Text是一个多窗口多标签编辑器：我们既可以开多个Sublime Text窗口，也可以在一个Sublime Text窗口内开多个标签。</p>

<h3>窗口（Window）</h3>

<p>使用<code>Ctrl + Shift + N</code>创建一个新窗口（该快捷键再次和搜狗输入法快捷键冲突，个人建议禁用所有搜狗输入法快捷键）。</p>

<p>当窗口内没有标签时，使用<code>Ctrl + W</code>关闭该窗口。</p>

<h3>标签（Tab）</h3>

<p>使用<code>Ctrl + N</code>在当前窗口创建一个新标签，<code>Ctrl + W</code>关闭当前标签，<code>Ctrl + Shift + T</code>恢复刚刚关闭的标签。</p>

<p>编辑代码时我们经常会开多个窗口，所以分屏很重要。<code>Alt + Shift + 2</code>进行左右分屏，<code>Alt + Shift + 8</code>进行上下分屏，<code>Alt + Shift + 5</code>进行上下左右分屏（即分为四屏）。</p>

<p><img src="http://i.imgur.com/lAvhuX6.gif" alt="各种分屏" /></p>

<p>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏。例如，<code>Ctrl + 1</code>会跳转到1屏，而<code>Ctrl + Shift + 2</code>会将当前屏移动到2屏。</p>

<h3>全屏（Full Screen）</h3>

<p>Sublime Text有两种全屏模式：普通全屏和无干扰全屏。</p>

<p>个人强烈建议在开启全屏前关闭菜单栏（Toggle Menu），否则全屏效果会大打折扣。</p>

<p><code>F11</code>切换普通全屏：</p>

<p><img src="http://i.imgur.com/Kdj9eEX.jpg" alt="普通全屏" /></p>

<p><code>Shift + F11</code>切换无干扰全屏：</p>

<p><img src="http://i.imgur.com/mnTIFQk.jpg" alt="无干扰全屏" /></p>

<h2>风格（Styles）</h2>

<p>风格对于任何软件都很重要，对编辑器也是如此，尤其是GUI环境下的编辑器。作为一个程序员，我希望我的编辑器足够简洁且足够个性。</p>

<p>Notepad++默认界面</p>

<p><img src="http://i.imgur.com/MZb7AsV.png" alt="Notepad++" /></p>

<p>Sublime Text默认界面</p>

<p><img src="http://i.imgur.com/ZzwQ0sI.png" alt="Sublime Text" /></p>

<p>所以在用过Sublime Text之后，我立刻就卸掉了Notepad++。</p>

<p>Sublime Text自带的风格是我喜欢的深色风格（也可以调成浅色），默认主题是<code>Monokai Bright</code>，这两者的搭配已经很不错了，不过我们还可以做得更好：接下来我将会展示如何通过设置偏好项和添加自定义风格/主题使得Sublime Text更加Stylish。</p>

<h3>一些设置（Miscellaneous Settings）</h3>

<p>下面是我个人使用的设置项。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 设置Sans-serif（无衬线）等宽字体，以便阅读
</span><span class='line'>"font_face": "YaHei Consolas Hybrid",
</span><span class='line'>"font_size": 12,
</span><span class='line'>// 使光标闪动更加柔和
</span><span class='line'>"caret_style": "phase",
</span><span class='line'>// 高亮当前行
</span><span class='line'>"highlight_line": true,
</span><span class='line'>// 高亮有修改的标签
</span><span class='line'>"highlight_modified_tabs": true,</span></code></pre></td></tr></table></div></figure>


<p>设置之后的效果如下：</p>

<p><img src="http://i.imgur.com/MkyHff5.jpg" alt="设置效果" /></p>

<h3>主题（Themes）</h3>

<p>Sublime Text有大量第三方主题：[<a href="https://sublime.wbond.net/browse/labels/theme">https://sublime.wbond.net/browse/labels/theme</a>]，这里我给出几个个人感觉不错的主题：</p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Light</a></h4>

<p><img src="http://i.imgur.com/exxgbm1.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Dark</a></h4>

<p><img src="http://i.imgur.com/YsrCJMe.png" alt="深色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a></h4>

<p><img src="http://i.imgur.com/ECLGEWD.png" alt="Nexus" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland</a></h4>

<p><img src="http://i.imgur.com/LT0AyhR.png" alt="Flatland" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Light</a></h4>

<p><img src="http://i.imgur.com/j0hJqeV.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Dark</a></h4>

<p><img src="http://i.imgur.com/CJJhvTj.png" alt="深色版" /></p>

<h3>配色（Color）</h3>

<p><a href="http://colorsublime.com/">colorsublime</a>包含了大量Sublime Text配色方案，并支持在线预览，配色方案的安装教程在<a href="http://colorsublime.com/how-to-install-a-theme">这里</a>，恕不赘述。</p>

<p>我个人使用的是<a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a>主题和<a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland Dark</a>配色，配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>"theme": "Nexus.sublime-theme",
</span><span class='line'>"color_scheme": "Packages/Theme - Flatland/Flatland Dark.tmTheme",</span></code></pre></td></tr></table></div></figure>


<p>效果如下：</p>

<p><img src="http://i.imgur.com/gCxTGii.jpg" alt="Nexus+Flatland" /></p>

<h2>编码（Coding）</h2>

<p>优秀的编辑器使编码变的更加容易，所以Sublime Text提供了一系列功能以提高开发效率。</p>

<h3>良好实践（Good Practices）</h3>

<p>良好的代码应该是规范的，所以Google为每一门主流语言都设置了其代码规范（Code Style Guideline）。我自己通过下面的设置使以规范化自己的代码。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 设置tab的大小为2
</span><span class='line'>"tab_size": 2,
</span><span class='line'>// 使用空格代替tab
</span><span class='line'>"translate_tabs_to_spaces": true,
</span><span class='line'>// 添加行宽标尺
</span><span class='line'>"rulers": [80, 100],
</span><span class='line'>// 显示空白字符
</span><span class='line'>"draw_white_space": "all",
</span><span class='line'>// 保存时自动去除行末空白
</span><span class='line'>"trim_trailing_white_space_on_save": true,
</span><span class='line'>// 保存时自动增加文件末尾换行
</span><span class='line'>"ensure_newline_at_eof_on_save": true,</span></code></pre></td></tr></table></div></figure>


<h3>代码段（Code Snippets）</h3>

<p>Sublime Text支持代码段（Code Snippet），输入代码段名称后<code>Tab</code>即可生成代码段。</p>

<p><img src="http://i.imgur.com/EQc1zNX.gif" alt="代码段效果" /></p>

<p>你可以通过Package Control安装第三方代码段，也可以自己创建代码段，参考<a href="http://www.hongkiat.com/blog/sublime-code-snippets/">这里</a>。</p>

<h3>格式化（Formatting）</h3>

<p>Sublime Text基本的手动格式化操作包括：<code>Ctrl + [</code>向左缩进，<code>Ctrl + ]</code>向右缩进，此外<code>Ctrl + Shift + V</code>可以以当前缩进粘贴代码（非常实用）。</p>

<p>除了手动格式化，我们也可以通过安装插件实现自动缩进和智能对齐：</p>

<ul>
<li><a href="https://sublime.wbond.net/packages/HTMLBeautify">HTMLBeautify</a>：格式化HTML。</li>
<li><a href="https://sublime.wbond.net/packages/AutoPEP8">AutoPEP8</a>：格式化Python代码。</li>
<li><a href="https://sublime.wbond.net/packages/Alignment">Alignment</a>：进行智能对齐。</li>
</ul>


<h3>自动完成（Auto Completion）</h3>

<p>Sublime Text 支持一定的自动完成，按<code>Tab</code>自动补全。</p>

<p><img src="http://i.imgur.com/cqBI3NW.jpg" alt="自动完成" /></p>

<h3>括号（Brackets）</h3>

<p>编写代码时会碰到大量的括号，利用<code>Ctrl + M</code>可以快速的在起始括号和结尾括号间切换，<code>Ctrl + Shift + M</code>则可以快速选择括号间的内容，对于缩进型语言（例如Python）则可以使用<code>Ctrl + Shift + J</code>。</p>

<p><img src="http://i.imgur.com/oxWjAo9.gif" alt="括号演示" /></p>

<p>此外，我使用<a href="https://sublime.wbond.net/packages/BracketHighlighter">BracketHighlighter</a>插件以高亮显示配对括号以及当前光标所在区域，效果如下：</p>

<p><img src="http://i.imgur.com/QQpG99h.gif" alt="插件演示" /></p>

<h3>命令行（Command Line）</h3>

<p>尽管提供了Python控制台，但Sublime Text的控制台仅支持单行输入，十分不方便，所以我使用<a href="https://sublime.wbond.net/packages/SublimeREPL">Sublime​REPL</a>以进行一些编码实验（Experiments）。</p>

<p><img src="http://i.imgur.com/dZgi8QZ.gif" alt="SublimeREPL演示" /></p>

<h2>其它（Miscellaneous）</h2>

<p>尽管我试图在本文包含尽可能多的Sublime Text实用技能，但受限于篇幅和我的个人经验，本文仍不免有所遗漏，欢迎在评论里指出本文的错误及遗漏。</p>

<p>下面是一些可能有用但我很少用到的功能：</p>

<ul>
<li>宏（Macro）：Sublime Text支持<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/extensibility/macros.html">录制宏</a>，但我在实际工作中并未发现宏有多大用处。</li>
<li>其它平台（Other Platforms）：本文只介绍了Windows平台上Sublime Text的使用，不过Linux和OS X上Sublime Text的使用方式和Windows差别不大，只是在快捷键上有所差异，请参考<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_win.html">Windows/Linux快捷键</a>和<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html">OS X快捷键</a>。</li>
<li>项目（Projects）：Sublime Text支持简单的<a href="http://www.sublimetext.com/docs/3/projects.html">项目管理</a>，但我一般只用到文件夹。</li>
<li>Vim模式（Vintage）：Sublime Text自带<a href="http://www.sublimetext.com/docs/3/vintage.html">Vim模式</a>。</li>
<li>构建（Build）：通过配置，Sublime Text可以进行<a href="http://docs.sublimetext.info/en/latest/file_processing/build_systems.html">源码构建</a>。</li>
<li>调试（Debug）：通过安装<a href="https://sublime.wbond.net/search/debug">插件</a>，Sublime Text可以对代码进行调试。</li>
</ul>


<h2>快捷键列表（Shortcuts Cheatsheet）</h2>

<p>我把本文出现的Sublime Text按其类型整理在这里，以便查阅。</p>

<h3>通用（General）</h3>

<ul>
<li><code>↑↓←→</code>：上下左右移动光标，注意不是不是<code>KJHL</code>！</li>
<li><code>Alt</code>：调出菜单</li>
<li><code>Ctrl + Shift + P</code>：调出命令板（Command Palette）</li>
<li><code>Ctrl + `</code>：调出控制台</li>
</ul>


<h3>编辑（Editing）</h3>

<ul>
<li><code>Ctrl + Enter</code>：在当前行下面新增一行然后跳至该行</li>
<li><code>Ctrl + Shift + Enter</code>：在当前行上面增加一行并跳至该行</li>
<li><code>Ctrl + ←/→</code>：进行逐词移动</li>
<li><code>Ctrl + Shift + ←/→</code>进行逐词选择</li>
<li><code>Ctrl + ↑/↓</code>移动当前显示区域</li>
<li><code>Ctrl + Shift + ↑/↓</code>移动当前行</li>
</ul>


<h3>选择（Selecting）</h3>

<ul>
<li><code>Ctrl + D</code>：选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑</li>
<li><code>Ctrl + Shift + L</code>：将当前选中区域打散</li>
<li><code>Ctrl + J</code>：把当前选中区域合并为一行</li>
<li><code>Ctrl + M</code>：在起始括号和结尾括号间切换</li>
<li><code>Ctrl + Shift + M</code>：快速选择括号间的内容</li>
<li><code>Ctrl + Shift + J</code>：快速选择同缩进的内容</li>
<li><code>Ctrl + Shift + Space</code>：快速选择当前作用域（Scope）的内容</li>
</ul>


<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<ul>
<li><code>F3</code>：跳至当前关键字下一个位置</li>
<li><code>Shift + F3</code>：跳到当前关键字上一个位置</li>
<li><code>Alt + F3</code>：选中当前关键字出现的所有位置</li>
<li><code>Ctrl + F/H</code>：进行标准查找/替换，之后：

<ul>
<li><code>Alt + C</code>：切换大小写敏感（Case-sensitive）模式</li>
<li><code>Alt + W</code>：切换整字匹配（Whole matching）模式</li>
<li><code>Alt + R</code>：切换正则匹配（Regex matching）模式</li>
<li><code>Ctrl + Shift + H</code>：替换当前关键字</li>
<li><code>Ctrl + Alt + Enter</code>：替换所有关键字匹配</li>
</ul>
</li>
<li><code>Ctrl + Shift + F</code>：多文件搜索&amp;替换</li>
</ul>


<h3>跳转（Jumping）</h3>

<ul>
<li><code>Ctrl + P</code>：跳转到指定文件，输入文件名后可以：

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>
</li>
<li><code>Ctrl + R</code>：跳转到指定符号</li>
<li><code>Ctrl + G</code>：跳转到指定行号</li>
</ul>


<h3>窗口（Window）</h3>

<ul>
<li><code>Ctrl + Shift + N</code>：创建一个新窗口</li>
<li><code>Ctrl + N</code>：在当前窗口创建一个新标签</li>
<li><code>Ctrl + W</code>：关闭当前标签，当窗口内没有标签时会关闭该窗口</li>
<li><code>Ctrl + Shift + T</code>：恢复刚刚关闭的标签</li>
</ul>


<h3>屏幕（Screen）</h3>

<ul>
<li><code>F11</code>：切换普通全屏</li>
<li><code>Shift + F11</code>：切换无干扰全屏</li>
<li><code>Alt + Shift + 2</code>：进行左右分屏</li>
<li><code>Alt + Shift + 8</code>：进行上下分屏</li>
<li><code>Alt + Shift + 5</code>：进行上下左右分屏</li>
<li>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏</li>
</ul>


<h2>延伸阅读（Further Reading）</h2>

<h3>书籍（Books）</h3>

<ul>
<li><a href="http://www.amazon.com/Mastering-Sublime-Community-Experience-Distilled/dp/1849698422/">Mastering Sublime Text</a>：我读过的唯一一本关于Sublime Text的书籍，书中介绍的插件很实用，但对编辑技巧介绍不全。</li>
<li><a href="http://www.amazon.com/Instant-Sublime-Text-Starter-Haughee/dp/1849693927/">Instant Sublime Text Starter</a>：另外一本关于Sublime Text的书，我没有读过。</li>
</ul>


<h3>链接（Links）</h3>

<ul>
<li>官方文档：<a href="http://www.sublimetext.com/docs/3/">http://www.sublimetext.com/docs/3/</a></li>
<li>官方论坛：<a href="http://www.sublimetext.com/forum/">http://www.sublimetext.com/forum/</a></li>
<li>Stack Overflow的Sublime Text频道：

<ul>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext">http://stackoverflow.com/questions/tagged/sublimetext</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext2">http://stackoverflow.com/questions/tagged/sublimetext2</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext3">http://stackoverflow.com/questions/tagged/sublimetext3</a></li>
</ul>
</li>
<li>非官方文档：<a href="http://sublime-text-unofficial-documentation.readthedocs.org/">http://sublime-text-unofficial-documentation.readthedocs.org/</a> 甚至比官方文档还要全面！</li>
<li>Package Control：<a href="https://sublime.wbond.net/">https://sublime.wbond.net/</a> 大量的Sublime Text插件和主题。</li>
</ul>


<h3>视频（Videos）</h3>

<ul>
<li>Getting Started with SublimeText：<a href="https://www.youtube.com/watch?v=04gKiTiRlq8">https://www.youtube.com/watch?v=04gKiTiRlq8</a></li>
<li>Sublime Text Pefect Workflow：<a href="https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g">https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g</a></li>
</ul>


<h2>关于作者（About Me）</h2>

<p><a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<p>正在尽量努力成为一名靠谱的软件工程师 :&ndash;|</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——1. Horror Vacui]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/"/>
    <updated>2014-07-26T16:10:03-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-1-horror-vacui</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<strong>设计</strong>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/design-of-design-0-horror-prologue/">设计中的设计——0. Prologue</a></li>
<li><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">设计中的设计——1. Horror Vacui</a></li>
</ol>


<h2>Horror Vacui</h2>

<blockquote><p>Horror Vacui——a Latin expression meaning &ldquo;fear of emptiness&#8221;——regards the desire to fill empty spaces with information of objects.</p></blockquote>

<p><strong><a href="http://en.wikipedia.org/wiki/Horror_vacui">Horror Vacui</a></strong>源自人对空旷空间的畏惧感——它是一种要将空间填满的心理，也是一种不留任何空白空间的艺术风格，这种风格的代表设计师包括David Carson和Vaughan Oliver，有兴趣的童鞋请自行Google他们的代表作品。</p>

<p>不过这篇文章讨论的并不是<strong>Horror Vacui</strong>艺术风格，而是<strong>Horror Vacui</strong>心理。</p>

<!-- more -->


<p>研究表明，<strong>Horror Vacui</strong>和<strong>价值感知（Value Perception）</strong>间存在反比关系——随着<strong>Horror Vacui</strong>的升高，价值感知随之下降。简单的来说——同样的空间，放的东西越多，给人的廉价感越强烈，反之亦然（vice versa）。</p>

<p>以服装店店面的设计为例：</p>

<p><img src="http://i.imgur.com/FFblJhS.png" alt="Horror Vacui" /></p>

<p>研究者做了一个调查，对于上面的店面设计风格，从左到右的空间利用率越来越低，然而给人的价值感知正好相反——几乎所有被调查者都认为最左的廉价感最强，而最右的高端感最强。</p>

<p>再来几个现实例子：</p>

<h3>店铺</h3>

<p><img src="http://i.imgur.com/5LsZvER.jpg" width="600" height="400" title="西单某服装店" ></p>

<p><img src="http://i.imgur.com/CtXZzWw.jpg" width="600" height="400" title="优衣库" ></p>

<p><img src="http://i.imgur.com/CUwAJDd.jpg" width="600" height="400" title="Burberry" ></p>

<p>你觉得哪一个店更贵？</p>

<h3>食物</h3>

<p><img src="http://i.imgur.com/YwI3YGU.jpg" width="600" height="400" title="东北乱炖" ></p>

<p><img src="http://i.imgur.com/pw8iVAa.jpg" width="600" height="400" title="法式食物" ></p>

<p>你认为哪道菜更贵？</p>

<h2>Horror Vacui vs Minimalism</h2>

<p>Horror Vacui设计是Minimalism设计的反面，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>在介绍Horror Vacui时给出了下面刻薄但又实用的建议：</p>

<blockquote><p>To promote associations of high value, favor minimalism for affluent and well-educated audiences and horror vacui for poorer and less-educated audiences, and vice versa.</p></blockquote>

<p>简单来说：</p>

<ul>
<li>对于教育程度高或富有的用户，使用minimalism（极简）设计以带来高价值认知。</li>
<li>对于教育程度低或较穷的用户，使用horror vacui设计以带来高性价比认知。</li>
</ul>


<p>反之也一样：</p>

<ul>
<li>对于教育程度低或较穷的用户，minimalism设计会让他们认为这货性价比太低，不值得。</li>
<li>对于教育程度高或富有的用户，horror vacui设计会让他们认为这货太廉价，没必要。</li>
</ul>


<p>总之，不用给矮矬穷营造高大上，也不要给高帅富灌输便宜大碗，会有反效果。</p>

<h2>Universal Principles of Design</h2>

<p><img src="http://i.imgur.com/EEueKvz.jpg" alt="Universal Principles of Design" /></p>

<p>我在之前的<a href="http://zh.lucida.me/blog/on-reading-books/">如何阅读书籍</a>中提到利用结论型/指南型书籍精炼阅读专业周边书籍，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>就是设计中结论型书籍的代表作：</p>

<ol>
<li>包含一百多种实用设计原则，这些原则涵盖了改善可用性（Enhance usability）、影响感知（Infuluence Perception）、提升吸引力（Increase Appeal）、做出更好的设计决策（Make Better Design Decisions）以及设计教学（Teach through Design）这五大方面。</li>
<li>全书按照字母顺序（Alphabetical Order）组织，同时也包含按类别组织的目录，既方便查阅，也方便针对性阅读。</li>
<li>每一种设计原则都配有详细的文字介绍、图解、案例以及参考文献。</li>
</ol>


<p><img src="http://i.imgur.com/eqTjTqK.jpg" alt="样章" /></p>

<p>总之，这本书对于专业设计师可能比较初级，但对于设计入门者是绝好的书籍。任何涉及到制作最终用户产品的人员（包括开发、测试和产品等）都应该阅读此书，从而了解基本设计原则（principle）和术语（terminology），以便与设计师进行交流，做出令用户满意的高价值设计。</p>

<p>这本书有<a href="http://www.amazon.cn/%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%B3%95%E5%88%99-%E5%A8%81%E5%BB%89%E2%80%A2%E7%AB%8B%E5%BE%B7%E5%A8%81%E5%B0%94/dp/B00ES8JL8W/">中文译版</a>，但个人强烈推荐<a href="http://www.amazon.cn/Universal-Principles-of-Design-Lidwell-William/dp/1592535879/">原版</a>：因为这类书籍翻译过来会损失相当多的信息（注意并非否认翻译水平），此外原版价格也相当实惠。</p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我们都爱黑巴西——德国神虐巴西之后]]></title>
    <link href="http://zh.lucida.me/blog/after-germany-screwed-brazil/"/>
    <updated>2014-07-09T15:02:44-07:00</updated>
    <id>http://zh.lucida.me/blog/after-germany-screwed-brazil</id>
    <content type="html"><![CDATA[<p>比赛的结果大家都知道——世界杯史上最惨烈的半决赛，巴西国家队生生的被德国打成了中国少先队。</p>

<p>比赛之前的Google Doodle：</p>

<p><img src="http://i.imgur.com/NN26YIR.gif" alt="Original Doodle" /></p>

<p>上半场结束后的Doodle：</p>

<p><img src="http://i.imgur.com/KmCNKZZ.gif" alt="Updated Doodle" /></p>

<p>全场结束后的Doodle：</p>

<!-- more -->


<p><img src="http://i.imgur.com/le8xFzz.gif" alt="Finished Doodle" /></p>

<p>整场比赛大致是这样：</p>

<p><img src="http://i.imgur.com/ZERmlv2.gif" alt="Hulk" /></p>

<p>也可以说是这样：</p>

<p><img src="http://i.imgur.com/qHnxq3n.gif" alt="Beer" /></p>

<p>巴西守门员的表现：</p>

<p><img src="http://i.imgur.com/lp1nRDE.gif" alt="守门员" /></p>

<p>所以也许只有Howard才能拯救巴西：</p>

<p><img src="http://i.imgur.com/SJwVQdO.png" alt="Howard" /></p>

<p>耶稣都哭了：</p>

<p><img src="http://i.imgur.com/tkmwfnX.png" alt="Crying Jesus" /></p>

<p>然后准备跑路：</p>

<p><img src="http://i.imgur.com/4Mq6CKZ.png" alt="Escaping Jesus" /></p>

<p>一些球迷认为巴西应该换一面国旗</p>

<p><img src="http://i.imgur.com/9Rhh3B3.png" alt="New Flag" /></p>

<p>阿根廷陷入了沉思：</p>

<p><img src="http://i.imgur.com/CYQzqw0.png" alt="Argentina Dilemma" /></p>

<p>西班牙松了一口气：</p>

<p><img src="http://i.imgur.com/IxbY9YE.png" alt="Spanish" /></p>

<p>美国则表示哥比巴西强多了</p>

<p><img src="http://i.imgur.com/2is6Eum.png" alt="American" /></p>

<p>甚至连加拿大也长出一口气（加拿大在预选赛中被洪都拉斯黑成8:1）</p>

<p><img src="http://i.imgur.com/KNevvMp.png" alt="Canadian" /></p>

<p>码农表示一轮Build没跑完德国已经进了仨：</p>

<p><img src="http://i.imgur.com/lIer2vQ.png" alt="Build" /></p>

<p>美工表示对于2014世界杯Logo有了新解读：</p>

<p><img src="http://i.imgur.com/3vClfHw.png" alt="Logo" /></p>

<p>前端表示当时没考虑到这种情况所以出了Bug：</p>

<p><img src="http://i.imgur.com/xKmFl3a.png" alt="Scroll Bar" /></p>

<p>总之</p>

<p><img src="http://i.imgur.com/1JdyRgN.png" alt="German LGTM" /></p>

<p><img src="http://i.imgur.com/tNFyNlX.png" alt="Brazil OMG" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[逗逼足球——Xorb Football]]></title>
    <link href="http://zh.lucida.me/blog/xorb-football/"/>
    <updated>2014-06-29T14:58:09-07:00</updated>
    <id>http://zh.lucida.me/blog/xorb-football</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/xorb-football/">原文链接</a></p>

<h2>关于</h2>

<p>我的Blog副标题是<strong>Tech</strong>, <strong>Life</strong>, <strong>Love</strong>，不过开博到现在几乎全是<strong>Tech</strong>相关的文章，<strong>Life</strong>相关的文章几乎没有（<a href="http://zh.lucida.me/blog/stories-of-masturbations/">打飞机故事集</a>那篇不算-_&ndash;#），更不要说<strong>Love</strong>。所以我决定改变一下这个局面。</p>

<p>不知道为什么国内舆论总喜欢把程序员黑化，以至于程序员给人的感觉就像只会修电脑——极端一些，类似下面：</p>

<p><img src="http://i.imgur.com/2suKYmO.jpg" alt="僵尸般的程序员" /></p>

<p>但实际上并未如此，程序员也是正常人，甚至比其它职业更加多才多艺。</p>

<p>以我为例，业余爱好包括<a href="http://en.wikipedia.org/wiki/Capoeira">Capoeira</a>（业余玩）、跆拳道（蓝带）、桌球、看书（对历史经济设计心理哲学等感兴趣）、收集耳机（到现在搞了接近20余副）等等，而这些爱好没有一项和计算机相关：</p>

<!-- more -->


<p>逗逼桌球</p>

<p><img src="http://i.imgur.com/CSW3XH4.jpg" width="500" height="375" title="逗逼桌球" ></p>

<p>逗逼踢腿</p>

<p><img src="http://i.imgur.com/J5EcsWE.jpg" width="500" height="375" title="逗逼踢腿" ></p>

<p>逗逼射箭</p>

<p><img src="http://i.imgur.com/3wzwaew.jpg" width="500" height="375" title="逗逼射箭" ></p>

<p>貌似扯得有点远，回到Xorb Football。</p>

<h2>Xorb Football</h2>

<h3>什么是Xorb？</h3>

<p>Football不用多说，世界第一运动。</p>

<p>但Xorb就比较冷门了：Xorb又称Zorb，中文翻译成太空球或左宾球，大体原理是把人装进一个大充气球里然后做各种运动（比如翻滚，降落和弹起等）。有兴趣的童鞋可以参考<a href="http://en.wikipedia.org/wiki/Zorbing">Zorbing</a>的Wiki或<a href="http://baike.baidu.com/view/6922282.htm">百科</a>介绍。</p>

<h3>Xorb + Football &ndash;> Xorb Football</h3>

<p>Xorb和Football结合到一起就出现了Xorb Football这项逗逼运动——给人套上一个1.5米直径的大号充气球踢足球，可以利用充气球把人撞倒，但不允许背后撞人。</p>

<p>比如断球的效果是这样：</p>

<p><img src="http://i.imgur.com/Rq2NbOw.gif" width="400" height="240" title="抢断" ></p>

<p>我搜了一下貌似国内还没有这项运动，会翻墙的同学可以到Youtube上查询Xorb Football，逗逼无极限。</p>

<h3>实际感受</h3>

<p>Google London这边一般月末Team都会有自己的活动，这次赶上巴西世界杯，大家决定踢一场足球。于是某个逗逼同事就想到了Xorb Football。</p>

<p>我们去的是位于Shoreditch Station附近的一处Football Club。</p>

<p>比较有意思的是，来这里踢球的不仅有年轻人，大把的四五十岁的中年人也踢的不亦乐乎。</p>

<p>套上Zorb球后才发现有些坑爹，不仅视线受阻而且呼吸困难。</p>

<p><img src="http://i.imgur.com/ul1nPbS.jpg" width="270" height="190" title="我感到整个人都要崩溃了" ></p>

<p>好像配错图了，这张更合适：</p>

<p><img src="http://i.imgur.com/qX9lbXN.jpg" width="270" height="190" title="我感到整个人都要窒息了" ></p>

<p>然后听到有人叫我，刚回头就被我Mentor&#8221;一球&#8221;撞飞。</p>

<p>Xorb Football的玩法有下面几种：</p>

<ul>
<li>5 vs 5：和正常足球类似，除了每人身上的逗逼气球。</li>
<li>1 vs 1：单挑。</li>
<li>2 vs 2：组队对战。</li>
<li>One man standing：效果类似于碰碰车，一群人戴着逗逼球撞来撞去，被撞倒的出局，直到最后一个人为止。</li>
</ul>


<p>刚开始大家还比较拘谨——因为是第一次玩，此外也不太好意思对同事“下手”，于是只是像足球一般带球，传球，射门。</p>

<p>我还进了一球（GOALLLLLLL!!!），不过进球后就跪了（真跪了）。</p>

<p><img src="http://i.imgur.com/icMQoCs.gif" width="400" height="240" title="偶的进球" ></p>

<p>不过和平的局面没有持续多久，从一个波兰同事撞倒数名同事开始，场面就开始混乱了——大家互相撞来撞去，一时间满地都是翻滚的同事（充气球）。</p>

<p><img src="http://i.imgur.com/Rq2NbOw.gif" width="400" height="240" title="抢断" ></p>

<p>到了后来貌似大家就把Football抛之脑后——因为撞人实在太好玩了！</p>

<p>我和Mentor的激烈碰撞（失败告终-_&ndash;#）</p>

<p><img src="http://i.imgur.com/TKXP6on.gif" width="400" height="240" title="撞死你撞死你！" ></p>

<p>玩的巨爽无比，应该是我玩过的最逗逼的集体运动了！除了第二天早起发现肩膀和胳膊酸的要死——估计是在充气球内的长期逗逼体位所致。</p>

<p>以上</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/xorb-football/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——2. Blunders, Typos, Mismatches, and Language Liability]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-2/"/>
    <updated>2014-06-27T15:46:53-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-2</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-2/">Blunders, Typos, Mismatches, and Language Liability</a></li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>对编程错误的分析</h2>

<p>上篇文章（<a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a>）介绍了Knuth对编程错误的分类，基于Knuth的分类和我自己的编程经验，从这篇文章开始我将会给出各类编程错误的<strong>案例</strong>、<strong>诱因</strong>和<strong>对策</strong>。</p>

<p>按照复杂程度的不同，Knuth将编程错误分为三大类，这篇文章介绍第一类错误——简单的错误：</p>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<!-- more -->


<h2>粗心大意（a trivial typo）</h2>

<blockquote><p>Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</p>

<p>我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</p></blockquote>

<p><strong>粗心大意</strong>这类差错源自于Knuth奇葩的开发方式——先把程序在纸上写好然后再&#8221;誊写&#8221;到计算机中，而在&#8221;誊写&#8221;时可能会敲错几个字符，从而导致程序出错。</p>

<p>除去面试时的白板编码，我认为现代程序开发不可能在纸上进行——从而也不可能产生这种差错，所以不加赘述。</p>

<h2>鬼使神差（a blunder or botch）</h2>

<blockquote><p>Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</p>

<p>我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</p></blockquote>

<h3>案例</h3>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>中提到一个低级Bug：TEX代码里有两个变量<code>new_line</code>和<code>next_line</code>：<code>new_line</code>用于表示程序当前的状态，而<code>next_line</code>则指代换行符。然而开发过程中Knuth混淆了这两个变量的用途——由于这两个变量属于同一类型所以编译器无法检测出这个问题，这个Bug直到后来程序运行了一段时间才被发现。</p>

<h3>诱因</h3>

<ul>
<li>变量名含糊不清：导致之后的误用。</li>
<li>编程语言过分宽容：某些编程语言对代码特别宽容——比如动态编程语言会将静态编程语言在编译时做的类型检查拖到运行时，尽管获得了灵活性，但却损失了精确性。从而导致<strong>鬼使神差</strong>这类静态语言编译期就能检查到的错误直到运行时才会被发现。</li>
<li>加班超负荷工作：从而导致写出翔一般的代码。</li>
</ul>


<h3>对策</h3>

<ol>
<li>使用精准的名字：

<ul>
<li>作用域越长的变量的名字越要精确。</li>
<li>使用精准的英文词汇描述变量。</li>
<li>更多关于命名的信息请参考<a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/">Code Complete</a>中<strong>The Power of Variable Names</strong>一节。</li>
</ul>
</li>
<li>严格控制全局变量：

<ul>
<li>能不用则不用。</li>
<li>如果不得不使用，使用明确的名字，进行详细的注释，并注明不得不使用全局变量的原因。。</li>
</ul>
</li>
<li>优先使用强类型：例如对于内置强类型枚举（Enum）的语言（例如Java，C#，和C++），使用枚举类型表示状态（State），而非整数类型。</li>
<li>将编译器警告调到最高级：然后清除代码中所有的Warning。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>单步（Step Into）自己的代码：编写新代码后进行单步调试——你脑中的代码和实际可能不一样。</li>
<li>进行代码审查：可以参考<a href="http://coolshell.cn/articles/11432.html">这篇文章</a>。</li>
<li>不要在混沌状态提交代码。</li>
</ol>


<h2>丢三落四（a forgotten function）</h2>

<blockquote><p>Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</p>

<p>我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</p></blockquote>

<h3>案例</h3>

<h4>烫烫烫烫烫</h4>

<p>C语言中忘记初始化数组，从而输出喜闻乐见的“烫烫烫烫烫烫烫烫烫烫烫烫”。</p>

<p><img src="http://i.imgur.com/9RcLu2x.png" alt="烫烫烫烫烫烫" /></p>

<p>对于需要手动管理内存的语言（C/C++），忘记释放内存或忘记初始化内存都会导致各种奇诡的问题。</p>

<h4>过早优化</h4>

<p>在开发TEX时，Knuth试图去优化<code>get_next</code>这个被频繁调用的函数。经过一番思考，Knuth认为<code>cur_cs = 0</code>这段代码是不必要的，于是他将这段代码删除，代码依然&#8221;正常&#8221;运行。然而过了一段时间后Knuth发现TEX在处理对齐（Alignment）时有时会出现问题——经过一番调试，Knuth发现原来那段被删除的代码是必要的（necessary）。</p>

<p>郁闷之余，Knuth援引了那句著名的话（Hoare&rsquo;s dictum）——过早优化是万恶之源（Premature optimization is the root of all evil in programming），很多书都以为这句话是Knuth说的，实际上它属于<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>。</p>

<h3>诱因</h3>

<h4>远距离操作</h4>

<p>远距离操作指那些间隔特别长的操作，例如下面的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>obj.Init()
</span><span class='line'>obj.DoSomething()
</span><span class='line'>// Hundred of lines
</span><span class='line'>obj.DoSomething()
</span><span class='line'>obj.Close()</span></code></pre></td></tr></table></div></figure>


<p>从<code>Init</code>到<code>Close</code>的距离过远，在编写了几十甚至上百行其它代码之后，很容易漏掉<code>obj.Close()</code>从而导致资源泄漏。</p>

<h4>贸然修改代码</h4>

<p>我个人认为Knuth所犯的错误不在于过早优化，而在于他在对代码理解不充分的情况下就去贸然修改——这往往会带来各种问题。</p>

<h3>应对</h3>

<ul>
<li>避免远距离操作：

<ul>
<li>对于内存管理：C++提供了智能指针。</li>
<li>多数编程语言提供了上下文管理器（Context Manager）：例如Java 7的<code>try</code>，C#的<code>using</code>，以及Python的<code>with</code>，利用这些机制，可以有效的减少远距离操作，比如前文的代码用Python可以这么写：</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">with</span> <span class="n">Obj</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span> <span class="k">as</span> <span class="n">obj</span><span class="p">:</span>
</span><span class='line'>  <span class="n">obj</span><span class="o">.</span><span class="n">DoSomething</span><span class="p">()</span>
</span><span class='line'>  <span class="o">//</span> <span class="n">Hundred</span> <span class="n">of</span> <span class="n">lines</span>
</span><span class='line'>  <span class="n">obj</span><span class="o">.</span><span class="n">DoSomething</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li> 整理代码段落，避免复杂交织的逻辑，这里可以参考<a href="http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293">The Art of Readable Code</a>对Aesthetics的定义。</li>
</ul>


<p><img class="right" src="http://i.imgur.com/Mvr8zx2.jpg" width="180" height="250" title="Working Effectively with Legacy Code" ></p>

<ul>
<li><p>不要贸然修改代码：</p>

<ul>
<li>修改代码前要确保充分理解代码的原理，以及修改会带来的影响（Effect Analysis）。</li>
<li>修改代码后要保证被修改的部分得到测试，<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively with Legacy Code</a>提供了很多优秀的修改实践。</li>
</ul>
</li>
<li><p>代码审查：代码审查可以有效的控制编程差错。</p></li>
<li>不要在混沌状态提交代码。</li>
</ul>


<h2>言非所指（a language liability）</h2>

<blockquote><p>Here I misused or misunderstood the programming language or system hardware I was working with.</p>

<p>我对编程语言（或是系统硬件）理解有误，从而造成错误。</p></blockquote>

<h3>案例</h3>

<h4>JavaScript</h4>

<p>下面是JavaScript的真值表（源自Douglas Crockford）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s1">&#39;&#39;</span>        <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// false</span>
</span><span class='line'><span class="mi">0</span>         <span class="o">==</span>   <span class="s1">&#39;&#39;</span>            <span class="c1">// true</span>
</span><span class='line'><span class="mi">0</span>         <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// true</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="s1">&#39;false&#39;</span>       <span class="c1">// false</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="s1">&#39;0&#39;</span>           <span class="c1">// true</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="kc">undefined</span>     <span class="c1">// false</span>
</span><span class='line'><span class="kc">false</span>     <span class="o">==</span>   <span class="kc">null</span>          <span class="c1">// false</span>
</span><span class='line'><span class="kc">null</span>      <span class="o">==</span>   <span class="kc">undefined</span>     <span class="c1">// true</span>
</span><span class='line'><span class="s2">&quot; \t\r\n&quot;</span> <span class="o">==</span>   <span class="mi">0</span>             <span class="c1">// true</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外还有下面这个对比：</p>

<p><img src="http://i.imgur.com/5RCkNLK.jpg" alt="JavaScript the Good Parts" /></p>

<p>对于这种翔一样的语言，想不掉进坑里是非常困难的。</p>

<p>（讽刺的是，JavaScript统治了浏览器端，而且它还试图染指服务器端。）</p>

<h4>操作符优先级</h4>

<p><img class="right" src="http://i.imgur.com/5WjUpyd.jpg" width="160" height="200" title="the Practice of Programming" ></p>

<p>[Brian Kernighan]曾在在<a href="http://cm.bell-labs.com/cm/cs/tpop/index.html">the Practice of Programming</a>中提到<code>if (x &amp; MASK == BITS)</code>这个例子：</p>

<p>我们一般会把<code>if (x &amp; MASK == BITS)</code>理解为<code>if ((x &amp; MASK) == BITS)</code>；</p>

<p>但实际上<code>if (x &amp; MASK == BITS)</code>和<code>if (x &amp; (MASK == BITS))</code>等价，而这显然不是我们想要的结果。</p>

<h3>诱因</h3>

<ul>
<li>对编程语言不够了解。</li>
<li>编程语言本身设计有问题。</li>
<li>对操作符优先级理解不足。</li>
</ul>


<h5>应对</h5>

<ul>
<li>深入理解编程语言——知道哪有坑：

<ul>
<li>学习编程语言不只是学它的语法——还要学习它的用法（Usages），最佳实践（Best Practices），误区（Traps），惯例（Conventions）和风格（Styles）等等，阅读<em>Effective</em>、<em>More Effective</em>、<em>Exceptional</em>、<em>More Exceptional</em>、<em>Pitfalls/Traps</em>和<em>the Good Parts</em>等系列的编程书籍以了解这些内容。</li>
<li><a href="http://joearms.github.io/">Joe Armstrong</a>在<a href="http://codersatwork.com/">Coders at work</a>的访谈中提到学习编程语言最好的方式是实现它（“The best way to learn a programming language is to implement it yourself”），我尝试用这种方法学习JavaScript，效果还不错。</li>
</ul>
</li>
<li>使用且仅使用语言的良子集——避开那些坑：

<ul>
<li><a href="http://crockford.com/">Douglas Crockford</a>在<a href="http://www.amazon.com/exec/obidos/ASIN/0596517742/">JavaScript: the Good Parts</a>中仅仅摘取了一个很小的JavaScript良子集进行编程，Kernighan和Plauger在<a href="http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/">Software Tools</a>则扩展了Fortran的一个良子集进行编程。语言提供的特性不代表你必须要使用它，容易产生错误（Error Prone）的语言特性应当被禁用。</li>
</ul>
</li>
<li>使用括号明确（Explicitify）操作符优先级——哪怕你能一眼看出<code>return true || true &amp;&amp; false</code>的返回值。</li>
<li>谨慎使用宏（macro）。</li>
<li>代码审查：提交代码之前至少需要一个该精通语言的人的审查，以免踩进语言的坑里。</li>
</ul>


<h2>事与愿违（a mismatch between modules）</h2>

<blockquote><p>Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</p>

<p>我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</p></blockquote>

<h3>案例</h3>

<h4>火星探测器坠毁</h4>

<p>史上最贵的<strong>事与愿违</strong>的Bug出现在1998年的NASA火星探测器中，这个Bug直接导致火星探测器坠毁，损失高达<a href="http://www.computerworld.com/s/article/9183580/Epic_failures_11_infamous_software_bugs">3.27亿美元</a>。</p>

<p>而这个Bug的成因在我们看来实际很可笑——Lockheed Martin公司在<a href="http://www.jpl.nasa.gov/news/releases/99/mcoloss1.html">调查</a>后发现，由于不同开发团队使用的计量单位不同——一个团队使用英制单位（英寸，英尺或英镑等），而其它开发团队使用公制（厘米或公斤等），从而导致系统运算错误，最终导致探测器坠毁。</p>

<h4>愚蠢的API设计</h4>

<p>以前在Microsoft实习时，我曾经编写过一个动画方法，用于移动屏幕上某个控件，这个方法大概是下面这个样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// Returns a DoubleAnimation which moves control from (x1, y1) to (x2, y2).</span>
</span><span class='line'><span class="k">public</span> <span class="n">DoubleAnimation</span> <span class="nf">CreateAnimation</span><span class="p">(</span><span class="n">Control</span> <span class="n">control</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">duration</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Some code...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>CreateAnimation</code>用于创建一个<code>DoubleAnimation</code>，把某个控件从<code>(x1, y1)</code>移动到<code>(x2, y2)</code>，移动耗时<code>duration</code>毫秒。</p>

<p>之后就出现了下面一系列翔一般的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation1</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="n">grid1</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">grid1</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">gridAnimation2</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">grid2</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">grid2</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">popUpAnimation</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">popUp</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">320</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">320</span><span class="p">,</span> <span class="m">500</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以及误用（组员（包括我自己）把<code>duration</code>当成秒来用）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation1</span> <span class="p">=</span> <span class="n">CreateAnimation</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">800</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0.5</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法如同<strong>病毒</strong>一般，既使得调用代码变的丑陋不堪，同时带来了各种Bug，导致后来的维护者叫苦不迭，</p>

<p>现在回想下，我肯定不会把它设计成这副模样——一种方法是使用<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">gridAnimation</span> <span class="p">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">FromCurrentPosition</span><span class="p">().</span><span class="n">MoveTo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="m">0</span><span class="p">).</span><span class="n">InMilliSeconds</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>
</span><span class='line'><span class="kt">var</span> <span class="n">popUpAnimation</span> <span class="p">=</span> <span class="n">popUp</span><span class="p">.</span><span class="n">From</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">-</span><span class="m">320</span><span class="p">).</span><span class="n">MoveTo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="m">320</span><span class="p">).</span><span class="n">InMilliSeconds</span><span class="p">(</span><span class="m">500</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而使代码简洁明确。</p>

<h3>诱因</h3>

<p><strong>事与愿违</strong>源于糟糕的设计——人会犯错误，而糟糕的设计会大大加剧错误几率。</p>

<p><img class="right" src="http://i.imgur.com/jdeK9F0.jpg" width="270" height="270" title="Tony Hoare" ></p>

<p>然而良好的设计非常困难——<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>曾在他的图灵奖获奖感言（<a href="http://zoo.cs.yale.edu/classes/cs422/2014/bib/hoare81emperor.pdf">The Emperor&rsquo;s Old Clothes</a>）中指出：</p>

<blockquote><p>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.</p></blockquote>

<h3>应对</h3>

<p>尽管Knuth把<strong>事与愿违</strong>归类为简单的差错，但我并不这么认为。<strong>事与愿违</strong>源于错误的设计，解决<strong>事与愿违</strong>的关键不在于修复其造成的差错，而在于处理造成<strong>事与愿违</strong>原因。修复<strong>事与愿违</strong>的错误很简单，但处理<strong>事与愿违</strong>的原因就复杂多了。</p>

<p><img class="right" src="http://i.imgur.com/tll1S89.jpg" width="180" height="240" title="Awaken the Giant Within" ></p>

<p><a href="http://www.tonyrobbins.com/">Tony Robbins</a>曾在<a href="http://www.amazon.com/Awaken-Giant-Within-Immediate-Emotional/dp/0671791540/">Awaken the Giant Within</a>一书中讲了这样一个故事：</p>

<blockquote><p>一个医生在河边发现有一个人溺水，然后她跳进河里，把溺水者救上岸进行抢救。然而没过多久她又听到呼救声，她继续跳进河里，把溺水者救上岸抢救，然后她又听到求救，于是她又跳进河里…… 不幸的是，这名医生忙于抢救眼前的溺水者，而没有时间去上游查看是谁把这些人扔到水里的。</p></blockquote>

<p><img class="right" src="http://i.imgur.com/t5zjiGY.jpg" width="180" height="240" title="Stream Analysis" ></p>

<p><a href="http://www.jerryporras.com/">Jerry Porras</a>也在<a href="http://www.amazon.com/Stream-Analysis-Organizational-Addison-Wesley-Organization/dp/0201056933/">Stream Analysis</a>中提到：</p>

<blockquote><p>People, especially people in organizations, tend to work on getting rid of symptoms, rather than solving the real problems.</p></blockquote>

<p>因此，处理<strong>事与愿违</strong>要从设计着手（Solving the real problems），这里从设计者和使用者两个角度出发：</p>

<h4>设计者</h4>

<ol>
<li>谨慎设计API：

<ul>
<li>API应该由经验丰富的人设计。</li>
<li>API设计应遵循一定的原则，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Josha Bloch</a>曾在Google做过一个非常出色的关于API设计的演讲：<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">How To Design A Good API and Why it Matters</a>。</li>
<li>API在投入使用前应进行可用性测试——糟糕的API不仅会降低开发效率，还会像病毒一般引入各种各样的差错。</li>
</ul>
</li>
<li>利用类型系统：

<ul>
<li>避免基本类型（Primitive Type）：对于有意义的数据，使用其类型而非基本类型。例如：使用<code>Money</code>表示金钱，而非使用<code>double</code>。</li>
<li>避免使用动态语言（例如Python和Ruby）构建大型系统：动态语言的作用仅限于快速开发原型系统，在我看来，动态语言像是纸和胶水，可以用它们快速构建一些玩具模型（原型系统），但用它们建造摩天大厦（大型系统）就太离谱了。</li>
</ul>
</li>
<li>设计文档+审查：软件设计在实现前应有详细的设计文档（Design Document），并至少通过两名以上经验丰富的开发者的审查。</li>
</ol>


<h4>使用者</h4>

<p><img class="right" src="http://i.imgur.com/3vIYjeg.jpg" width="180" height="240" title="Debugging" ></p>

<ol>
<li>仔细阅读文档——Read the manual, and read everything, cover to cover，参见<a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>里的第一条调试原则——<strong>Understand the system</strong>。</li>
<li>调用API时仔细阅读其样例代码（Sample Code）和文档说明，不要想当然。</li>
<li>对于已有（Existing）的糟糕API，考虑对其进行封装（Wrapping），以免接下来的误用。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>代码审查：代码审查可以有效的控制编程差错。</li>
</ol>


<p>关于&#8221;简单&#8221;的编程差错就介绍到这里，下篇将介绍源自算法和数据结构的错误——Algorithm + Data Structures &ndash;> Programming。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——1. A Taxonomy of Programming Errors]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-1/"/>
    <updated>2014-06-24T15:32:12-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-1</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>编程错误的分类</h2>

<p>前文讲到Knuth在开发TEX的过程中遇到了各式各样的差错，为了理解并控制编程错误，Knuth将这些错误整理到<a href="http://texdoc.net/texmf-dist/doc/generic/knuth/errata/errorlog.pdf">记录日志</a>，并将这些差错分为15类。为了引用方便，我将它们翻译成中文。</p>

<p>注意：</p>

<ol>
<li>为了引用方便，Knuth使用英文首字母指代各个编程错误的分类，出于同样的原因，我将这些分类一一翻译为成语。</li>
<li>保留原文，以便读者理解，以免信息丢失。</li>
<li>原文中的&#8221;my&#8221;和&#8221;I&#8221;以及译文中的&#8221;我&#8221;均指Knuth本人。</li>
<li>如果认为翻译不靠谱请在评论中指出 :)</li>
</ol>


<p>下面是Knuth对TEX错误的分类：</p>

<!-- more -->


<hr />

<ul>
<li><strong>A: an algorithm awry.</strong> Here my original method proved to be incorrect or inadequate.</li>
<li><strong>不可胜算</strong>：我最初设想的算法有误或存在不足。</li>
</ul>


<hr />

<ul>
<li><strong>B: a blunder or botch.</strong> Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</li>
<li><strong>鬼使神差</strong>：我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</li>
</ul>


<hr />

<ul>
<li><strong>C: a cleanup for consistency or clarity.</strong> Here I changed the rules of the language to make things easier to remember and/or more logical.</li>
<li><strong>得心应手</strong>：我对语言（TEX）规则进行整理，使其符合逻辑，更加易用。</li>
</ul>


<hr />

<ul>
<li><strong>D: a data structure debacle.</strong> Here I didn&rsquo;t properly update the representation of information to preserve the appropriate invariants.</li>
<li><strong>差之毫厘</strong>：我对数据结构的操作有误，使其处在不一致的状态（破坏了其本应维持的不变式）。</li>
</ul>


<hr />

<ul>
<li><strong>E: an efficiency enhancement.</strong> Here I changed the program so that it would run faster; the existing code was correct but slow.</li>
<li><strong>多快好省</strong>：尽管原来的代码正确，但速度很慢，于是我修改代码以改善程序的性能。</li>
</ul>


<hr />

<ul>
<li><strong>F: a forgotten function.</strong> Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</li>
<li><strong>丢三落四</strong>：我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</li>
</ul>


<hr />

<ul>
<li><strong>G: a generalization or growth of ability.</strong> Here I realized that some extension of the existing specifications was desirable.</li>
<li><strong>虚怀若谷</strong>：我将一些已有的代码进行扩展/抽象使其更加通用。</li>
</ul>


<hr />

<ul>
<li><strong>I: an interactive improvement.</strong> Here I made TEX respond better to the user&rsquo;s needs.</li>
<li><strong>各得其所</strong>：我使TEX对用户更加友好。</li>
</ul>


<hr />

<ul>
<li><strong>L: a language liability.</strong> Here I misused or misunderstood the programming language or system hardware I was working with.</li>
<li><strong>言非所指</strong>：我对编程语言（或是系统硬件）理解有误，从而造成错误。</li>
</ul>


<hr />

<ul>
<li><strong>M: a mismatch between modules.</strong> Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</li>
<li><strong>事与愿违</strong>：我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</li>
</ul>


<hr />

<ul>
<li><strong>P: a promotion of portability.</strong> Here I changed the organization or documentation of the program; this affected only a person who would try to read or modify the code, not a person who tried to run it.</li>
<li><strong>焕然一新</strong>：我对程序的结构或是文档进行改善，从而在不改变程序的前提下改善其可读性和可修改性。</li>
</ul>


<hr />

<ul>
<li><strong>Q: a quest for quality.</strong> Here I changed the specifications of what the program should output from given input, when I learned how to improve the typographic appearance of the output.</li>
<li><strong>精益求精</strong>：在对字体版式有了更深入的理解之后，我对程序进行修改，以获得更好的输出效果。</li>
</ul>


<hr />

<ul>
<li><strong>R: a reinforcement of robustness.</strong> Whenever I realized that TEX could loop or crash in the presence of certain erroneous input, I tried to make the code bulletproof.</li>
<li><strong>百毒不侵</strong>：一旦我意识到TEX有可能在极端情况下崩溃，我就会想方设法使程序变的更加健壮。</li>
</ul>


<hr />

<ul>
<li><strong>S: a surprising scenario.</strong> Errors of type S were particularly bad bugs that forced me to change my original ideas, because of unforeseen interactions between various parts of the program.</li>
<li><strong>出乎意料</strong>：由于我最初对问题的定义或是对程序间模块的交互理解不足，导致一些无法预见的错误——这类错误往往很棘手。</li>
</ul>


<hr />

<ul>
<li><strong>T: a trivial typo.</strong> Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</li>
<li><strong>粗心大意</strong>：我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</li>
</ul>


<hr />

<h2>进一步的分类</h2>

<h3>Knuth随后将这15个分类分为两大类：</h3>

<ul>
<li><strong>不可胜算</strong>、<strong>鬼使神差</strong>、<strong>差之毫厘</strong>、<strong>丢三落四</strong>、<strong>言非所指</strong>、<strong>事与愿违</strong>、<strong>百毒不侵</strong>、<strong>出乎意料</strong>和<strong>粗心大意</strong>属于程序的差错（Bugs）。</li>
<li><strong>得心应手</strong>、<strong>多快好省</strong>、<strong>虚怀若谷</strong>、<strong>各得其所</strong>、<strong>焕然一新</strong>和<strong>精益求精</strong>属于对程序的改进（Enhancements）。</li>
</ul>


<h3>然后按复杂程度把差错（Bugs）分为三类：</h3>

<h4>简单的差错</h4>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<h4>复杂的差错</h4>

<ul>
<li><strong>不可胜算</strong>：算法设计不当。</li>
<li><strong>差之毫厘</strong>：数据结构维护不周。</li>
</ul>


<h4>棘手的差错</h4>

<ul>
<li><strong>百毒不侵</strong>：对错误输入处理不当而造成的问题。</li>
<li><strong>出乎意料</strong>：由于对问题的理解不足，从而导致各种诡异的问题。</li>
</ul>


<h2><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>的不足</h2>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对TEX的错误进行了详细的分析，并对这些错误进行了系统的分类，但我认为这篇文章仍有一些不足：</p>

<ol>
<li>Knuth并未对编程错误给出应对策略。</li>
<li><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文成于1989年，其中记载的是1978年至1982年Knuth开发TEX时碰到的各种问题——30年前的编程语言和现在严重脱节。</li>
</ol>


<p>所以，我打算（不自量力的）结合自己的经验，在Knuth的分析基础上再进一步——从下篇开始，我会为每一类编程错误给出其案例，诱因和应对策略。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——0. Knuth, Tex, and the Errors of TEX]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-0/"/>
    <updated>2014-06-23T15:14:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-0</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<p>原本我计划在一篇文章完成所有内容，然而随着写作的深入，我发现文章的篇幅越来越长——考虑到可读性，我决定将这篇文章拓展为一个系列，计划如下：</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li>A Taxonomy of Programming Errors</li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<!-- more -->


<h2>免责声明（Disclaimer）</h2>

<p>几天前我在知乎上读到一篇关于Swift的<a href="http://www.zhihu.com/question/24002984">讨论</a>：</p>

<p>胡搅蛮缠</p>

<p><img src="http://i.imgur.com/ezV72EP.png" alt="讨论1" /></p>

<p>无知者无畏</p>

<p><img src="http://i.imgur.com/XXo9TlC.png" alt="讨论2" /></p>

<p>为了避免无谓的讨论，如果您认为iPhone系统闹钟可以用200行代码搞定，或者觉着Python适合编写大型项目，那么这个系列不适合您阅读。</p>

<h2>编程错误（Programming Errors）</h2>

<p>作为软件开发者，我自己写过一些微型程序（500行左右）和一些中小型应用（5&#8217;000~20&#8217;000行），实习时做过一些小项目（2&#8217;000行左右），到现在参与大型项目（100&#8217;000行以上）。如果让我总结这些项目的共同点，那么就是我在这些项目里都犯了各式各样的错误——小到喜闻乐见的&#8221;烫烫烫烫烫烫烫烫&#8221;，大到破坏整个应用兼容性导致上千用户流失，有的错误很愚蠢，有的错误则是聪明反被聪明误。</p>

<p>不过我可以安慰自己，因为我并非孤独——计算机程序向来以错误百出而臭名昭著，以至于计算机先驱<a href="http://en.wikipedia.org/wiki/Grace_hopper">Grace Hopper</a>近乎自嘲的为计算机程序错误取了一个别名——Bug。在之后的六十余年，Bug和其衍生词Debug一直是了所有程序员的梦魇。</p>

<p>Grace Hopper发现的“Bug”</p>

<p><img src="http://i.imgur.com/m36RhHW.jpg" alt="第一个Bug" /></p>

<p>随着经验的累积，我隐隐感觉到这些编程错误有一定的规律，因为我开始发现一些错误似乎在哪里见过，于是我开始寻找这方面的书籍和文献，以控制/减少自己的编程错误。</p>

<blockquote><p>Those who cannot remember the past are condemned to repeat it.</p>

<p>George Santayana</p></blockquote>

<p>然后我找到了<a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>的<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>。</p>

<h2>the Errors of TEX</h2>

<h3>背景</h3>

<p><img src="http://i.imgur.com/UF1uTSy.jpg" alt="Knuth" /></p>

<p>相信任何学计算机的人都知道Knuth和他神话（或神化）般（的<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>七卷本（未完成），但对Knuth开发的TEX以及Knuth开发TEX的流程可能就不是那么了解了，所以我在这里简单介绍下。</p>

<p><img src="http://i.imgur.com/3HzERY5.jpg" alt="TAOCP" /></p>

<p>撰写并出版<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>前三卷之后，Knuth发现印刷排版烂的一逼，在没有好使的数字排版系统的情况下，Knuth决定自己搞一个出来——于是就有了TEX。</p>

<p><img src="http://i.imgur.com/e6FqiCM.jpg" alt="TEX" /></p>

<p>不过排版系统并非简单的（Trivial）系统，即便如Knuth此般异禀天赋，也无法从容应付——事实上Knuth在开发TEX的过程中遇到了大量的错误，这些错误从TEX初版（1978年）到<a href="http://tug.org/TUGboat/tb35-1/tb109knut.pdf">最近的一次性能调优</a>（2014年），源源不断，挥之不去。</p>

<p>这些错误让Knuth很头痛，为了理解并控制编程错误，Knuth将这些错误整理到记录日志，并对这些编程错误进行分类，这成为了<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文的基础。</p>

<h3>插曲</h3>

<p>Knuth开发TEX的流程在我等屌丝码农看来绝对匪夷所思，在<a href="http://www.codersatwork.com/">Coders at Work</a>一书对Knuth的访谈里，Knuth提到：</p>

<blockquote><p>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>

<p>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p></blockquote>

<p>尽管有可能是1978年还没有好用的交互编程环境（Interactive Programming Environment），但Knuth六个月纸上设计纸上写代码的开发方式仍可以说是编程史上的一朵奇葩。如果放到今天，Knuth一定会被各路敏捷极限TDD编程<em>高手</em>喷出翔。</p>

<p>插曲到此为止，下篇进入正题——编程错误的分类（A Taxonomy of Programming Errors）。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——0. Prologue]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-0-prologue/"/>
    <updated>2014-06-06T15:06:06-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-0-prologue</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<em>设计</em>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<p>此外，副标题里使用<strong>Prologue</strong>，主要是因为我接下来提到的产品（设计）大多没有中文名——为了一致，我决定在这一系列所有文章的副标题中统一使用英文。</p>

<p>最后，这一系列博文和原研哉的<a href="http://book.douban.com/subject/1336111/">設計中的設計</a>无关，尽管它们名字相同。</p>

<h2>为什么要写这个系列？</h2>

<p>作为一个码农，按理说我应该和设计绝缘——设计是美工的事情嘛，码农负责写好代码就成。事实上我之前也一直这么认为。</p>

<!-- more -->


<p>但在三年前我这个看法被动摇了——2011年是国内移动互联网井喷的一年，随着iPhone及其模仿者的大行其道，曾经的手机王者Nokia被迅速的淘汰出市场；随着手机应用开发门槛的降低（从Symbian到iOS或Android），各种手机应用喷涌而出。</p>

<p>在这段时间我编写了一些手机应用，并通过QQ群，邮件列表以及论坛等渠道直接与用户交流，在这个过程中，我悲观的发现用户的思维模式和我（开发者）的思维模式完全不同，我认为理所当然的东西他们认为不可理喻，反之亦然。</p>

<p>在那段时间里我一度绝望的认为所有的用户都是神经病、弱智或是某些代谢产物，后来在Microsoft ATC实习时结识了几个设计师朋友（<a href="http://weibo.com/u/3848053360">@Xing</a>和<a href="http://weibo.com/u/2104950751">@Yan</a>），我向他们大吐苦水，他们则非常腹黑的讲了一个笑话：</p>

<blockquote><p>丈夫驾车出门。妻子在家听广播，听到一则报道，妻子连忙拿起电话。</p>

<p>妻子：老公啊，我刚听广播上说，高速公路上有一辆车在逆行，你千万要小心。</p>

<p>老公：哪是一辆啊，我看有好几百辆车都在逆行。</p></blockquote>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/hei.png" alt="黑" /></p>

<p>被善意的黑出翔之后，我认为我不能这样一直逆行下去——于是我开始天天死皮赖脸的向他们请教：从设计的原则，到设计的书籍，再到用户的心理，我强迫自己跳出码农的思维模式，像正常人一样思考。</p>

<p>感谢他们的指导，尽管我无法成为像他们一样专业的优秀设计师，但我形成了一个大体的设计观：比如一个好设计应该是什么样子，而一个烂设计又应该是什么样子。</p>

<p>在这个设计观的指引下，接下来我编写的手机应用都获得了不错的评价（几乎全五星），在做私活时也总能做出令客户满意的产品。</p>

<h2>优秀的产品&amp;杰出的设计</h2>

<p>在朋友的推荐下，最近把《道德经》看了一遍，我认为《道德经》里面的一段文字可以套用在产品和设计上：</p>

<blockquote><p>太上，不知有之；</p>

<p>其次，亲而誉之；</p>

<p>其次，畏之；</p>

<p>其次，侮之；</p>

<p>信不足焉，有不信焉。</p>

<p>—— 《道德经》 十七章</p></blockquote>

<p>把上面的文字应用到产品和设计：</p>

<ul>
<li>优秀的设计使用户专注于产品本身，而忽略设计的存在。（例如Google（搜索引擎）和iPad）</li>
<li>不错的设计使用户感到舒适，用户会称赞它的设计。（例如iPod Classic，<a href="http://www.parrot.com/zik/uk/">Parrot Zik</a>和Amazon Kindle）</li>
<li>马虎的设计使用户感到不适，用户很难掌握产品的功能。（例如早期版本的Microsoft Office，vim编辑器和JavaScript语言）</li>
<li>糟糕的设计会毁掉一个产品，用户会把产品和产品的设计骂出翔。（例如Nokia的Symbian触屏手机和绝大多数Linux桌面系统）</li>
</ul>


<p>需要注意，我在上面列举的产品都具有强大的功能——它们有的成功，有的失败，区别就在于设计。</p>

<h2>The Inmates are Running the Asylum</h2>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/inmates_asylum.jpg" alt="The Inmates are Running the Asylum" /></p>

<p><a href="http://www.amazon.com/The-Inmates-Are-Running-Asylum/dp/0672326140/">The Inmates are Running the Asylum</a>的全名是：The Inmates Are Running the Asylum : Why High Tech Products Drive Us Crazy and How to Restore the Sanity，直译成中文是：疯子开精神病院（为什么高科技产品总让我们抓狂以及如何打破这个窘境），可能是这个书名太惊悚，所以它的中文书名被分别译为<a href="http://book.douban.com/subject/1237849/">软件创新之路</a>（第一版）和<a href="http://book.douban.com/subject/1493316/">交互设计之路</a>（第二版）。</p>

<p>在这本书中，VB的创造者Alan Cooper创造性的把所有程序员黑了一遍——让程序员创造面向用户的软件，等价于让一群疯子开精神病院——因为能成为程序员的人思维本身就不正常：</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/ynm3000.png" alt="要你命3000" /></p>

<p>这是<a href="http://movie.douban.com/subject/1307739/">达文西</a>发明的要你命3000。</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/crazy_app.jpg" alt="要你命3000000000" /></p>

<p>这是程序员发明的要你命3000000000。</p>

<p>当然这本书不只是为了黑程序员，作者花了大量篇幅解释为什么现在的产品随着科技含量的提高反而愈发不好用，并提出了<a href="http://en.wikipedia.org/wiki/Interaction_design#Goal-oriented_design">认知摩擦（Cognitive friction）</a>、<a href="http://www.slideshare.net/PublishingTechnology/dancing-bears-pubtech">跳舞的熊（Dancing bear）</a>以及逻辑人（Homo logicus）等令人耳目一新的概念。总而言之，<a href="http://en.wikipedia.org/wiki/Interaction_design">交互设计（Interaction Design）</a>对于软件开发必不可少。</p>

<p>如果你是一个想做出好产品的程序员（码农），那么这本书值得一读——它会打破你现有的观念，让你意识到优秀的产品需要设计。就像我的朋友讲的那个笑话，它会让你意识到<strong>是你在逆行，而不是你面前的几百辆车在逆行。</strong></p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[来自苹果的编程语言——Swift简介]]></title>
    <link href="http://zh.lucida.me/blog/an-introduction-to-swift/"/>
    <updated>2014-06-02T18:22:19-07:00</updated>
    <id>http://zh.lucida.me/blog/an-introduction-to-swift</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>这篇文章简要介绍了苹果于<a href="https://developer.apple.com/wwdc/">WWDC 2014</a>发布的编程语言——Swift。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>

<h2>前言</h2>

<p>在这里我认为有必要提一下<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，Swift编程环境的大部分概念都源自于<a href="http://worrydream.com/">Bret</a>这个演讲。</p>

<p>接下来进入正题。</p>

<h2>Swift是什么？</h2>

<p>Swift是苹果于WWDC 2014发布的编程语言，这里引用<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>的原话：</p>

<blockquote><p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>

<p>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible and more fun.</p>

<p>Swift&rsquo;s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to imagine how software development works.</p>

<p>Swift is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</p></blockquote>

<p>简单的说：</p>

<ol>
<li>Swift用来写iOS和OS X程序。（估计也不会支持其它屌丝系统）</li>
<li>Swift吸取了C和Objective-C的优点，且更加强大易用。</li>
<li>Swift可以使用现有的Cocoa和Cocoa Touch框架。</li>
<li>Swift兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</li>
</ol>


<h2>Swift语言概览</h2>

<!-- more -->


<h3>基本概念</h3>

<p>注：这一节的代码源自<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>中的<em>A Swift Tour</em>。</p>

<h4>Hello, world</h4>

<p>类似于脚本语言，下面的代码即是一个完整的Swift程序。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello, world&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>变量与常量</h4>

<p>Swift使用<code>var</code>声明变量，<code>let</code>声明常量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">myVariable</span> <span class="p">=</span> <span class="m">42</span>
</span><span class='line'><span class="n">myVariable</span> <span class="p">=</span> <span class="m">50</span>
</span><span class='line'><span class="n">let</span> <span class="n">myConstant</span> <span class="p">=</span> <span class="m">42</span>
</span></code></pre></td></tr></table></div></figure>


<h4>类型推导</h4>

<p>Swift支持类型推导（Type Inference），所以上面的代码不需指定类型，如果需要指定类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">explicitDouble</span> <span class="p">:</span> <span class="n">Double</span> <span class="p">=</span> <span class="m">70</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift不支持隐式类型转换（Implicitly casting），所以下面的代码需要显式类型转换（Explicitly casting）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;The width is &quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">width</span> <span class="p">=</span> <span class="m">94</span>
</span><span class='line'><span class="n">let</span> <span class="n">labelWidth</span> <span class="p">=</span> <span class="n">label</span> <span class="p">+</span> <span class="n">String</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>字符串格式化</h4>

<p>Swift使用<code>\(item)</code>的形式进行字符串格式化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">apples</span> <span class="p">=</span> <span class="m">3</span>
</span><span class='line'><span class="n">let</span> <span class="n">oranges</span> <span class="p">=</span> <span class="m">5</span>
</span><span class='line'><span class="n">let</span> <span class="n">appleSummary</span> <span class="p">=</span> <span class="s">&quot;I have \(apples) apples.&quot;</span>
</span><span class='line'><span class="n">let</span> <span class="n">fruitSummary</span> <span class="p">=</span> <span class="s">&quot;I have \(apples + oranges) pieces of fruit.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数组和字典</h3>

<p>Swift使用<code>[]</code>操作符声明数组（array）和字典（dictionary）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">shoppingList</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;catfish&quot;</span><span class="p">,</span> <span class="s">&quot;water&quot;</span><span class="p">,</span> <span class="s">&quot;tulips&quot;</span><span class="p">,</span> <span class="s">&quot;blue paint&quot;</span><span class="p">]</span>
</span><span class='line'><span class="n">shoppingList</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;bottle of water&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">occupations</span> <span class="p">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="s">&quot;Malcolm&quot;</span><span class="p">:</span> <span class="s">&quot;Captain&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;Kaylee&quot;</span><span class="p">:</span> <span class="s">&quot;Mechanic&quot;</span><span class="p">,</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="n">occupations</span><span class="p">[</span><span class="s">&quot;Jayne&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Public Relations&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一般使用初始化器（initializer）语法创建空数组和空字典：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">emptyArray</span> <span class="p">=</span> <span class="n">String</span><span class="p">[]()</span>
</span><span class='line'><span class="n">let</span> <span class="n">emptyDictionary</span> <span class="p">=</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Float</span><span class="p">&gt;()</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果类型信息已知，则可以使用<code>[]</code>声明空数组，使用<code>[:]</code>声明空字典。</p>

<h3>控制流</h3>

<h4>概览</h4>

<p>Swift的条件语句包含<code>if</code>和<code>switch</code>，循环语句包含<code>for-in</code>、<code>for</code>、<code>while</code>和<code>do-while</code>，循环/判断条件不需要括号，但循环/判断体（body）必需括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">individualScores</span> <span class="p">=</span> <span class="p">[</span><span class="m">75</span><span class="p">,</span> <span class="m">43</span><span class="p">,</span> <span class="m">103</span><span class="p">,</span> <span class="m">87</span><span class="p">,</span> <span class="m">12</span><span class="p">]</span>
</span><span class='line'><span class="kt">var</span> <span class="n">teamScore</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">score</span> <span class="k">in</span> <span class="n">individualScores</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">score</span> <span class="p">&gt;</span> <span class="m">50</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">teamScore</span> <span class="p">+=</span> <span class="m">3</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">teamScore</span> <span class="p">+=</span> <span class="m">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>可空类型</h4>

<p>结合<code>if</code>和<code>let</code>，可以方便的处理可空变量（nullable variable）。对于空值，需要在类型声明后添加<code>?</code>显式标明该类型可空。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">optionalString</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="n">optionalString</span> <span class="p">==</span> <span class="n">nil</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">optionalName</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;John Appleseed&quot;</span>
</span><span class='line'><span class="kt">var</span> <span class="n">gretting</span> <span class="p">=</span> <span class="s">&quot;Hello!&quot;</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">name</span> <span class="p">=</span> <span class="n">optionalName</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">gretting</span> <span class="p">=</span> <span class="s">&quot;Hello, \(name)&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>灵活的switch</h4>

<p>Swift中的<code>switch</code>支持各种各样的比较操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">vegetable</span> <span class="p">=</span> <span class="s">&quot;red pepper&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">vegetable</span> <span class="p">{</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;celery&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Add some raisins and make ants on a log.&quot;</span>
</span><span class='line'><span class="k">case</span> <span class="s">&quot;cucumber&quot;</span><span class="p">,</span> <span class="s">&quot;watercress&quot;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;That would make a good tea sandwich.&quot;</span>
</span><span class='line'><span class="k">case</span> <span class="n">let</span> <span class="n">x</span> <span class="k">where</span> <span class="n">x</span><span class="p">.</span><span class="n">hasSuffix</span><span class="p">(</span><span class="s">&quot;pepper&quot;</span><span class="p">):</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Is it a spicy \(x)?&quot;</span>
</span><span class='line'><span class="k">default</span><span class="p">:</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">vegetableComment</span> <span class="p">=</span> <span class="s">&quot;Everything tastes good in soup.&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>其它循环</h4>

<p><code>for-in</code>除了遍历数组也可以用来遍历字典：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">interestingNumbers</span> <span class="p">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="s">&quot;Prime&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">13</span><span class="p">],</span>
</span><span class='line'>    <span class="s">&quot;Fibonacci&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">8</span><span class="p">],</span>
</span><span class='line'>    <span class="s">&quot;Square&quot;</span><span class="p">:</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">9</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="m">25</span><span class="p">],</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="kt">var</span> <span class="n">largest</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span> <span class="k">in</span> <span class="n">interestingNumbers</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">number</span> <span class="p">&gt;</span> <span class="n">largest</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">largest</span> <span class="p">=</span> <span class="n">number</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">largest</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>while</code>循环和<code>do-while</code>循环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="k">while</span> <span class="n">n</span> <span class="p">&lt;</span> <span class="m">100</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">n</span> <span class="p">=</span> <span class="n">n</span> <span class="p">*</span> <span class="m">2</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">n</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">m</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">m</span> <span class="p">=</span> <span class="n">m</span> <span class="p">*</span> <span class="m">2</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="n">m</span> <span class="p">&lt;</span> <span class="m">100</span>
</span><span class='line'><span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift支持传统的<code>for</code>循环，此外也可以通过结合<code>..</code>（生成一个区间）和<code>for-in</code>实现同样的逻辑。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">firstForLoop</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="m">3</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">firstForLoop</span> <span class="p">+=</span> <span class="n">i</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">firstForLoop</span>
</span><span class='line'>
</span><span class='line'><span class="kt">var</span> <span class="n">secondForLoop</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="k">for</span> <span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">secondForLoop</span> <span class="p">+=</span> <span class="m">1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">secondForLoop</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：Swift除了<code>..</code>还有<code>...</code>：<code>..</code>生成前闭后开的区间，而<code>...</code>生成前闭后闭的区间。</p>

<h3>函数和闭包</h3>

<h4>函数</h4>

<p>Swift使用<code>func</code>关键字声明函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">day</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;Hello \(name), today is \(day).&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">greet</span><span class="p">(</span><span class="s">&quot;Bob&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过元组（Tuple）返回多个值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">getGasPrices</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">,</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="m">3.59</span><span class="p">,</span> <span class="m">3.69</span><span class="p">,</span> <span class="m">3.79</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">getGasPrices</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>支持带有变长参数的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">sumOf</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="n">Int</span><span class="p">...)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="p">+=</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">sum</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">sumOf</span><span class="p">()</span>
</span><span class='line'><span class="n">sumOf</span><span class="p">(</span><span class="m">42</span><span class="p">,</span> <span class="m">597</span><span class="p">,</span> <span class="m">12</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数也可以嵌套函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">returnFifteen</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="m">10</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">y</span> <span class="p">+=</span> <span class="m">5</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">add</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">y</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">returnFifteen</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>作为头等对象，函数既可以作为返回值，也可以作为参数传递：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">makeIncrementer</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">addOne</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="m">1</span> <span class="p">+</span> <span class="n">number</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">addOne</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">increment</span> <span class="p">=</span> <span class="n">makeIncrementer</span><span class="p">()</span>
</span><span class='line'><span class="n">increment</span><span class="p">(</span><span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="nf">hasAnyMatches</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">Int</span><span class="p">[],</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">list</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nf">condition</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">true</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="nf">lessThanTen</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">number</span> <span class="p">&lt;</span> <span class="m">10</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="p">[</span><span class="m">20</span><span class="p">,</span> <span class="m">19</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">12</span><span class="p">]</span>
</span><span class='line'><span class="n">hasAnyMatches</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">lessThanTen</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>闭包</h4>

<p>本质来说，函数是特殊的闭包，Swift中可以利用<code>{}</code>声明匿名闭包：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">({</span>
</span><span class='line'>    <span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="k">in</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">result</span> <span class="p">=</span> <span class="m">3</span> <span class="p">*</span> <span class="n">number</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>    <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>当闭包的类型已知时，可以使用下面的简化写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">numbers</span><span class="p">.</span><span class="n">map</span><span class="p">({</span> <span class="n">number</span> <span class="k">in</span> <span class="m">3</span> <span class="p">*</span> <span class="n">number</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外还可以通过参数的位置来使用参数，当函数最后一个参数是闭包时，可以使用下面的语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">sort</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">12</span><span class="p">,</span> <span class="m">2</span><span class="p">])</span> <span class="p">{</span> <span class="err">$</span><span class="m">0</span> <span class="p">&gt;</span> <span class="err">$</span><span class="m">1</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类和对象</h3>

<h4>创建和使用类</h4>

<p>Swift使用<code>class</code>创建一个类，类可以包含字段和方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A shape with \(numberOfSides) sides.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建<code>Shape</code>类的实例，并调用其字段和方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">var</span> <span class="n">shape</span> <span class="p">=</span> <span class="n">Shape</span><span class="p">()</span>
</span><span class='line'><span class="n">shape</span><span class="p">.</span><span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">7</span>
</span><span class='line'><span class="kt">var</span> <span class="n">shapeDescription</span> <span class="p">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过<code>init</code>构建对象，既可以使用<code>self</code>显式引用成员字段（<code>name</code>），也可以隐式引用（<code>numberOfSides</code>）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numberOfSides</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A shape with \(numberOfSides) sides.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>deinit</code>进行清理工作。</p>

<h4>继承和多态</h4>

<p>Swift支持继承和多态（<code>override</code>父类方法）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Square</span><span class="p">:</span> <span class="n">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">sideLength</span>
</span><span class='line'>        <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">4</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">func</span> <span class="nf">area</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sideLength</span> <span class="p">*</span> <span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;A square with sides of length \(sideLength).&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">test</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">5.2</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;my test square&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">test</span><span class="p">.</span><span class="n">area</span><span class="p">()</span>
</span><span class='line'><span class="n">test</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：如果这里的<code>simpleDescription</code>方法没有被标识为<code>override</code>，则会引发编译错误。</p>

<h4>属性</h4>

<p>为了简化代码，Swift引入了属性（property），见下面的<code>perimeter</code>字段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">EquilateralTriangle</span><span class="p">:</span> <span class="n">NamedShape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span> <span class="p">=</span> <span class="m">0.0</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">sideLength</span>
</span><span class='line'>        <span class="n">super</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">numberOfSides</span> <span class="p">=</span> <span class="m">3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">var</span> <span class="n">perimeter</span><span class="p">:</span> <span class="n">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">get</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="m">3.0</span> <span class="p">*</span> <span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">set</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">/</span> <span class="m">3.0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;An equilateral triagle with sides of length \(sideLength).&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">triangle</span> <span class="p">=</span> <span class="n">EquilateralTriangle</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">3.1</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;a triangle&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">perimeter</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">perimeter</span> <span class="p">=</span> <span class="m">9.9</span>
</span><span class='line'><span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：赋值器（setter）中，接收的值被自动命名为<code>newValue</code>。</p>

<h4>willSet和didSet</h4>

<p><code>EquilateralTriangle</code>的构造器进行了如下操作：</p>

<ol>
<li>为子类型的属性赋值。</li>
<li>调用父类型的构造器。</li>
<li>修改父类型的属性。</li>
</ol>


<p>如果不需要计算属性的值，但需要在赋值前后进行一些操作的话，使用<code>willSet</code>和<code>didSet</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">TriangleAndSquare</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">triangle</span><span class="p">:</span> <span class="n">EquilateralTriangle</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">willSet</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">square</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">square</span><span class="p">:</span> <span class="n">Square</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">willSet</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">square</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>        <span class="n">triangle</span> <span class="p">=</span> <span class="n">EquilateralTriangle</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">triangleAndSquare</span> <span class="p">=</span> <span class="n">TriangleAndSquare</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="m">10</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;another test shape&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">square</span><span class="p">.</span><span class="n">sideLength</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">square</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">50</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;larger square&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">triangleAndSquare</span><span class="p">.</span><span class="n">triangle</span><span class="p">.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而保证<code>triangle</code>和<code>square</code>拥有相等的<code>sideLength</code>。</p>

<h4>调用方法</h4>

<p>Swift中，函数的参数名称只能在函数内部使用，但方法的参数名称除了在内部使用外还可以在外部使用（第一个参数除外），例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">count</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">incrementBy</span><span class="p">(</span><span class="n">amount</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">numberOfTimes</span> <span class="n">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">count</span> <span class="p">+=</span> <span class="n">amount</span> <span class="p">*</span> <span class="n">times</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">counter</span> <span class="p">=</span> <span class="n">Counter</span><span class="p">()</span>
</span><span class='line'><span class="n">counter</span><span class="p">.</span><span class="n">incrementBy</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">numberOfTimes</span><span class="p">:</span> <span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意Swift支持为方法参数取别名：在上面的代码里，<code>numberOfTimes</code>面向外部，<code>times</code>面向内部。</p>

<h4>?的另一种用途</h4>

<p>使用可空值时，<code>?</code>可以出现在方法、属性或下标前面。如果<code>?</code>前的值为<code>nil</code>，那么<code>?</code>后面的表达式会被忽略，而原表达式直接返回<code>nil</code>，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">let</span> <span class="n">optionalSquare</span><span class="p">:</span> <span class="n">Square</span><span class="p">?</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">sideLength</span><span class="p">:</span> <span class="m">2.5</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s">&quot;optional </span>
</span><span class='line'><span class="n">square</span><span class="s">&quot;)</span>
</span><span class='line'><span class="n">let</span> <span class="n">sideLength</span> <span class="p">=</span> <span class="n">optionalSquare</span><span class="p">?.</span><span class="n">sideLength</span>
</span></code></pre></td></tr></table></div></figure>


<p>当<code>optionalSquare</code>为<code>nil</code>时，<code>sideLength</code>属性调用会被忽略。</p>

<h3>枚举和结构</h3>

<h4>枚举</h4>

<p>使用<code>enum</code>创建枚举——注意Swift的枚举可以关联方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">Rank</span><span class="p">:</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Ace</span> <span class="p">=</span> <span class="m">1</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Two</span><span class="p">,</span> <span class="n">Three</span><span class="p">,</span> <span class="n">Four</span><span class="p">,</span> <span class="n">Five</span><span class="p">,</span> <span class="n">Six</span><span class="p">,</span> <span class="n">Seven</span><span class="p">,</span> <span class="n">Eight</span><span class="p">,</span> <span class="n">Nine</span><span class="p">,</span> <span class="n">Ten</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Jack</span><span class="p">,</span> <span class="n">Queen</span><span class="p">,</span> <span class="n">King</span>
</span><span class='line'>        <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Ace</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;ace&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Jack</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;jack&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Queen</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;queen&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">King</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;king&quot;</span>
</span><span class='line'>            <span class="k">default</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="nf">String</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">toRaw</span><span class="p">())</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">ace</span> <span class="p">=</span> <span class="n">Rank</span><span class="p">.</span><span class="n">Ace</span>
</span><span class='line'><span class="n">let</span> <span class="n">aceRawValue</span> <span class="p">=</span> <span class="n">ace</span><span class="p">.</span><span class="n">toRaw</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用<code>toRaw</code>和<code>fromRaw</code>在原始（raw）数值和枚举值之间进行转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">convertedRank</span> <span class="p">=</span> <span class="n">Rank</span><span class="p">.</span><span class="n">fromRaw</span><span class="p">(</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">threeDescription</span> <span class="p">=</span> <span class="n">convertedRank</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意枚举中的成员值（member value）是实际的值（actual value），和原始值（raw value）没有必然关联。</p>

<p>一些情况下枚举不存在有意义的原始值，这时可以直接忽略原始值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">Suit</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Spades</span><span class="p">,</span> <span class="n">Hearts</span><span class="p">,</span> <span class="n">Diamonds</span><span class="p">,</span> <span class="n">Clubs</span>
</span><span class='line'>        <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="n">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Spades</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;spades&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Hearts</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;hearts&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Diamonds</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;diamonds&quot;</span>
</span><span class='line'>            <span class="k">case</span> <span class="p">.</span><span class="n">Clubs</span><span class="p">:</span>
</span><span class='line'>                <span class="k">return</span> <span class="s">&quot;clubs&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">hearts</span> <span class="p">=</span> <span class="n">Suit</span><span class="p">.</span><span class="n">Hearts</span>
</span><span class='line'><span class="n">let</span> <span class="n">heartsDescription</span> <span class="p">=</span> <span class="n">hearts</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了可以关联方法，枚举还支持在其成员上关联值，同一枚举的不同成员可以有不同的关联的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">enum</span> <span class="n">ServerResponse</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Result</span><span class="p">(</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Error</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">let</span> <span class="n">success</span> <span class="p">=</span> <span class="n">ServerResponse</span><span class="p">.</span><span class="n">Result</span><span class="p">(</span><span class="s">&quot;6:00 am&quot;</span><span class="p">,</span> <span class="s">&quot;8:09 pm&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">failure</span> <span class="p">=</span> <span class="n">ServerResponse</span><span class="p">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Out of cheese.&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">success</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="p">.</span><span class="n">Result</span><span class="p">(</span><span class="n">sunrise</span><span class="p">,</span> <span class="n">sunset</span><span class="p">):</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">serverResponse</span> <span class="p">=</span> <span class="s">&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">let</span> <span class="p">.</span><span class="n">Error</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">serverResponse</span> <span class="p">=</span> <span class="s">&quot;Failure... \(error)&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>结构</h4>

<p>Swift使用<code>struct</code>关键字创建结构。结构支持构造器和方法这些类的特性。结构和类的最大区别在于：结构的实例按值传递（passed by value），而类的实例按引用传递（passed by reference）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">struct</span> <span class="nc">Card</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">rank</span><span class="p">:</span> <span class="n">Rank</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">suit</span><span class="p">:</span> <span class="n">Suit</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">simpleDescription</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">threeOfSpades</span> <span class="p">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">rank</span><span class="p">:</span> <span class="p">.</span><span class="n">Three</span><span class="p">,</span> <span class="n">suit</span><span class="p">:</span> <span class="p">.</span><span class="n">Spades</span><span class="p">)</span>
</span><span class='line'><span class="n">let</span> <span class="n">threeOfSpadesDescription</span> <span class="p">=</span> <span class="n">threeOfSpades</span><span class="p">.</span><span class="n">simpleDescription</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3>协议（protocol）和扩展（extension）</h3>

<h4>协议</h4>

<p>Swift使用<code>protocol</code>定义协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">protocol</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类型、枚举和结构都可以实现（adopt）协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">class</span> <span class="nc">SimpleClass</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;A very simple class.&quot;</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">anotherProperty</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">69105</span>
</span><span class='line'>    <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">simpleDescription</span> <span class="p">+=</span> <span class="s">&quot; Now 100% adjusted.&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">SimpleClass</span><span class="p">()</span>
</span><span class='line'><span class="n">a</span><span class="p">.</span><span class="n">adjust</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">aDescription</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">simpleDescription</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="nc">SimpleStructure</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;A simple structure&quot;</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">simpleDescription</span> <span class="p">+=</span> <span class="s">&quot; (adjusted)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">SimpleStructure</span><span class="p">()</span>
</span><span class='line'><span class="n">b</span><span class="p">.</span><span class="n">adjust</span><span class="p">()</span>
</span><span class='line'><span class="n">let</span> <span class="n">bDescription</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">simpleDescription</span>
</span></code></pre></td></tr></table></div></figure>


<h4>扩展</h4>

<p>扩展用于在已有的类型上增加新的功能（比如新的方法或属性），Swift使用<code>extension</code>声明扩展：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">extension</span> <span class="n">Int</span><span class="p">:</span> <span class="n">ExampleProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">simpleDescription</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;The number \(self)&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">mutating</span> <span class="n">func</span> <span class="nf">adjust</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">self</span> <span class="p">+=</span> <span class="m">42</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="m">7.</span><span class="n">simpleDescription</span>
</span></code></pre></td></tr></table></div></figure>


<h3>泛型（generics）</h3>

<p>Swift使用<code>&lt;&gt;</code>来声明泛型函数或泛型类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="n">repeat</span><span class="p">&lt;</span><span class="n">ItemType</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">ItemType</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ItemType</span><span class="p">[]</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">ItemType</span><span class="p">[]()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="n">times</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="p">+=</span> <span class="n">item</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">repeat</span><span class="p">(</span><span class="s">&quot;knock&quot;</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift也支持在类、枚举和结构中使用泛型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// Reimplement the Swift standard library&#39;s optional type</span>
</span><span class='line'><span class="k">enum</span> <span class="n">OptionalValue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">None</span>
</span><span class='line'>    <span class="k">case</span> <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">var</span> <span class="n">possibleInteger</span><span class="p">:</span> <span class="n">OptionalValue</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="n">None</span>
</span><span class='line'><span class="n">possibleInteger</span> <span class="p">=</span> <span class="p">.</span><span class="n">Some</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有时需要对泛型做一些需求（requirements），比如需求某个泛型类型实现某个接口或继承自某个特定类型、两个泛型类型属于同一个类型等等，Swift通过<code>where</code>描述这些需求：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">func</span> <span class="n">anyCommonElements</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span><span class="p">:</span> <span class="n">Equatable</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span> <span class="p">==</span> <span class="n">U</span><span class="p">.</span><span class="n">GeneratorType</span><span class="p">.</span><span class="n">Element</span><span class="p">&gt;</span> <span class="p">(</span><span class="n">lhs</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">lhsItem</span> <span class="k">in</span> <span class="n">lhs</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">rhsItem</span> <span class="k">in</span> <span class="n">rhs</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">lhsItem</span> <span class="p">==</span> <span class="n">rhsItem</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">true</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">anyCommonElements</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">],</span> <span class="p">[</span><span class="m">3</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Swift语言概览就到这里，有兴趣的朋友请进一步阅读<a href="">The Swift Programming Language</a>。</p>

<p>接下来聊聊个人对Swift的一些感受。</p>

<h2>个人感受</h2>

<p><strong>注意</strong>：下面的感受纯属个人意见，仅供参考。</p>

<h3>大杂烩</h3>

<p>尽管我接触Swift不足两小时，但很容易看出Swift吸收了大量其它编程语言中的元素，这些元素包括但不限于：</p>

<ol>
<li>属性（Property）、可空值（Nullable type）语法和泛型（Generic Type）语法源自C#。</li>
<li>格式风格与Go相仿（没有句末的分号，判断条件不需要括号）。</li>
<li>Python风格的当前实例引用语法（使用<code>self</code>）和列表字典声明语法。</li>
<li>Haskell风格的区间声明语法（比如<code>1..3</code>，<code>1...3</code>）。</li>
<li>协议和扩展源自Objective-C（自家产品随便用）。</li>
<li>枚举类型很像Java（可以拥有成员或方法）。</li>
<li><code>class</code>和<code>struct</code>的概念和C#极其相似。</li>
</ol>


<p>注意这里不是说Swift是抄袭——实际上编程语言能玩的花样基本就这些，况且Swift选的都是在我看来相当不错的特性。</p>

<p>而且，这个大杂烩有一个好处——就是任何其它编程语言的开发者都不会觉得Swift很陌生——这一点很重要。</p>

<h3>拒绝隐式（Refuse implicity）</h3>

<p>Swift去除了一些隐式操作，比如隐式类型转换和隐式方法重载这两个坑，干的漂亮。</p>

<h3>Swift的应用方向</h3>

<p>我认为Swift主要有下面这两个应用方向：</p>

<h4>教育</h4>

<p>我指的是编程教育。现有编程语言最大的问题就是交互性奇差，从而导致学习曲线陡峭。相信Swift及其交互性极强的编程环境能够打破这个局面，让更多的人——尤其是青少年，学会编程。</p>

<p>这里有必要再次提到<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，看了这个视频你就会明白一个交互性强的编程环境能够带来什么。</p>

<h4>应用开发</h4>

<p>现有的iOS和OS X应用开发均使用Objective-C，而Objective-C是一门及其繁琐（verbose）且学习曲线比较陡峭的语言，如果Swift能够提供一个同现有Obj-C框架的简易互操作接口，我相信会有大量的程序员转投Swift；与此同时，Swift简易的语法也会带来相当数量的其它平台开发者。</p>

<p>总之，上一次某家大公司大张旗鼓的推出一门编程语言及其编程平台还是在2000年（微软推出C#），将近15年之后，苹果推出Swift——作为开发者，我很高兴能够见证一门编程语言的诞生。</p>

<p>以上。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于锤子手机和锤子手机发布会]]></title>
    <link href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/"/>
    <updated>2014-05-24T01:33:38-07:00</updated>
    <id>http://zh.lucida.me/blog/on-the-keynote-of-t-one</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>本文记录了作者对<a href="http://v.youku.com/v_show/id_XNzE0Nzc0OTQ0.html">锤子手机发布会</a>和<a href="http://www.smartisan.com/">锤子手机</a>的一点感受，仅代表个人看法，但欢迎评论。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">http://zh.lucida.me/blog/on-the-keynote-of-t-one/</a></p>

<h2>重复</h2>

<p>演讲（或说服）有一个要点是重复，老罗显然深得此道，整场发布会下面的句式均被重复了不止五遍：</p>

<ul>
<li>作为一个大众消费品…………（表明自己站在消费者这边）</li>
<li>作为一个小厂商…………（博取听众（消费者）的同情（sympathy）和容忍（tolerance））</li>
<li>作为一个企业家，我不该…………（在贬低其它企业之后均以此句开脱）</li>
</ul>


<h2>误导</h2>

<p>在提到锤子手机音质时老罗举了这样的例子：</p>

<blockquote><p>我老婆之前认为自己是木耳，听不出音质的区别，但把苹果耳机换成几百森海塞尔后，她明显感到音质有了很大的提升。</p></blockquote>

<p>以证明即便是普通人也可以感受到音质的区别。</p>

<p>但这里有个问题：老罗夫人感受到的音质的提升源自于<strong>耳机</strong>，而非<strong>音源</strong>。在同等耳机的情况下，我怀疑老罗夫人是否还能听出锤子手机和同类手机间音质的区别。</p>

<p>此外，在提到无法更换壁纸的问题时老罗是这么解释的：</p>

<blockquote><p>我无法忍受把一堆图标堆在亲人的脸上。</p></blockquote>

<p>似乎确实很有道理，但再想一想，为什么一定要用亲人头像做壁纸呢？如果我要用风景或是纯色呢？</p>

<!-- more -->


<h2>冷知识</h2>

<p>老罗很擅长用一些冷门知识去吸引人，这样的例子在这次发布会上数不胜数：</p>

<ul>
<li>不断的列出硬件厂商的渊源。</li>
<li>指出锤子手机手机盒子使用了某英国著名公司的纸。</li>
<li>强调光线传感器的设计。</li>
<li>自带螺丝刀和若干螺丝钉。</li>
</ul>


<p>个人认为这些东西是Boilerplate——懂编程的童鞋应该明白我的意思。</p>

<h2>拍照效果</h2>

<p>老罗宣称锤子手机是目前最好的拍照手机之一，并花了大量时间去阐述他在打造拍照效果上所付出的努力，比如：</p>

<ul>
<li>寻找最好的拍照调校团队。</li>
<li>使用最好的摄像镜头。</li>
</ul>


<p>但令我疑惑的是：发布会并没有任何拍照效果的对比，甚至连锤子手机的拍照样张都没有——如果拍照效果真的那么强大，我不认为老罗会放这个贬低其他竞争对手的机会于不顾。</p>

<h2>双音量键</h2>

<p>锤子手机有一个很有趣的设计是双音量键——在单独使用时可以分别作为音量调节和亮度调节使用，而一起使用时则可以进行抢拍或快速启动某个指定应用程序。</p>

<p>这也带来了老罗所宣称的“全世界最快的抢拍手机”这个卖点。</p>

<p>但我还是有几个疑问：</p>

<ol>
<li>双音量键一起使用是一个很不直观的设计。</li>
<li>同时使用双音量键很不自然，不信的话你在你的手机上试试这个姿势。</li>
<li>从设计图上可以看出音量键并没有明显凸起——这意味着操作时需要按<strong>进</strong>音量键，也意味着任何手机壳或是bumper之类阻隔音量键的手机饰品均会妨碍音量键的正常使用。</li>
</ol>


<h2>对苹果的模仿</h2>

<h3>锤子手机在模仿iPhone5</h3>

<p>这里借用某条<a href="http://weibo.com/1847542877/B5fhi9RoE">微博</a>里的图片：</p>

<p><img src="http://i.imgur.com/VOSZ1dX.jpg" alt="无处不在的模仿" /></p>

<h3>锤子手机发布会处处在模仿iPhone1发布会</h3>

<p>iPhone1发布会时Jobs曾给出一个转盘手机的假想图：</p>

<p><img src="http://i.imgur.com/sfOzhfx.png" alt="转盘手机" /></p>

<p>老罗则给出一个锤子手机的假想图：</p>

<p><img src="http://i.imgur.com/fkoM9QQ.png" alt="锤子手机" /></p>

<p>iPhone1发布时Jobs强调三位一体的概念：</p>

<p><img src="http://i.imgur.com/WDmytpx.png" alt="三位一体" /></p>

<p>老罗也是如此：</p>

<p><img src="http://i.imgur.com/FK5fsC2.png" alt="又一个三位一体" /></p>

<p>Jobs经常在发布会最后来一个“One more thing”：</p>

<p><img src="http://i.imgur.com/ebmQPgi.png" alt="One more thing" /></p>

<p>到了老罗这里变成“还有两个好东西”：</p>

<p><img src="http://i.imgur.com/6yXVZ4a.png" alt="还有两个好东西" /></p>

<h2>软件改进</h2>

<p>下面是老罗重点介绍的锤子手机的软件改进：</p>

<ul>
<li>可以更换的主题：这个我真觉的不是啥改进——除非要和Windows Phone比。</li>
<li>手指横扫解决单手操作问题：很有创意的想法，但我注意到即便老罗本人如此操作锤子手机时也有相当的失误率——我怀疑这个功能的实用性。</li>
<li>通过短信内容智能新建日历：无论是Google还是Apple都已经有这个功能。</li>
<li>定时解除静音：很赞，这是我一直希望的功能。</li>
<li>区域截屏：看似很赞，但仔细一想几乎所有的手机聊天应用里面都带有编辑图片的选项，此外我个人对这个功能的稳定性有疑问。</li>
</ul>


<h2>总结</h2>

<p>锤子手机发布会最大的亮点是对OpenSSL的捐款，至于锤子手机本身……抱歉我没看到什么亮点。</p>

<p>但令我诧异的是很多资深人士纷纷表示看好锤子手机（发布会），<a href="http://www.weibo.com/fenng">fenng</a>甚至在微信上宣称这是手机行业迄今为止最好的产品发布会——</p>

<p><img src="http://i.imgur.com/MqEKRBk.jpg" alt="最好的产品发布会？？" /></p>

<p>我不清楚他是否也把iPhone发布会算在内。</p>

<p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress，就这场发布会所得到的信息，我依然认为锤子手机没有希望。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打飞机故事集]]></title>
    <link href="http://zh.lucida.me/blog/stories-of-masturbations/"/>
    <updated>2014-05-06T16:54:37-07:00</updated>
    <id>http://zh.lucida.me/blog/stories-of-masturbations</id>
    <content type="html"><![CDATA[<h2>免责声明（Disclamer）</h2>

<p><img src="http://i.imgur.com/ppEA9uM.jpg" alt="少儿不宜" /></p>

<p>本文包含大量三俗内容，18岁以下少年儿童请勿阅读，或者请在家长指导下阅读。</p>

<h2>关于</h2>

<p><img src="http://i.imgur.com/JzkPabq.jpg" alt="打飞机英雄集" /></p>

<p>本文记录了本屌这些年打飞机的所见所闻，希望能够对众屌有所启发，也欢迎大家留言讨论分享经验。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/stories-of-masturbations/">http://zh.lucida.me/blog/stories-of-masturbations/</a></p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<!-- more -->


<h2>水浒</h2>

<p><img src="http://i.imgur.com/QLWDwi1.jpg" alt="98版水浒传" /></p>

<p><a href="http://baike.baidu.com/subview/2578/4991919.htm#viewPageContent">98版水浒传</a>创造了无数的经典，同时也是那个年代少年儿童的性教育启蒙片：作为当时为数不多的带有床戏的而且可以在电视播放的电视剧——要知道那个年代没有迅雷没有BT。而且水浒中某些桥段放在现在也毫不逊色：</p>

<p><img src="http://i.imgur.com/KG0EJQ4.jpg" alt="剧照1" /></p>

<p><img src="http://i.imgur.com/6R5CHHY.jpg" alt="剧照2" /></p>

<p>过去的电视节目十分贫乏——所以往往同一部电视剧会被放上两遍甚至三遍，第一天晚上一遍，第二天上午一遍，第二天下午又一遍，晚上粑粑麻麻在所以孩子是不能看这些三俗的，所以只能白天趁粑粑麻麻上班出门的时候独自赏析。</p>

<p>至今记得当时重播西门大战金莲那集时，本屌半个班都空了——只剩一半是女生，当时班主任以为这帮混小子要组团去哪里搞事，吓的挨个给家长打电话，但却得知这帮小子都在家里，班主任至今百思不得其解。</p>

<p><img src="http://i.imgur.com/CzsOdlo.jpg" alt="剧照" /></p>

<p>殊不知众屌全守在电视机前等西门叔叔和金莲姐姐呢。</p>

<h2>暖手</h2>

<p><img src="http://i.imgur.com/zVUPYfA.jpg" alt="害羞" /></p>

<p>六年级寒假时本屌参加作文培训班，在捡地上的笔时发现后面的姐姐一脸潮红的把手插在身边哥哥的裤裆里，当时就觉着这个哥哥好伟大，天这么冷还给这个姐姐暖手。</p>

<h2>收音</h2>

<p>初中之后本屌发现一些小电视台经常会在午夜播放一些略劲爆的港台影视剧，其尺度甚至较之水浒传中杨雄老婆勾和尚还要大胆——但问题是电视在本屌粑粑的屋里，如果本屌把电视打开声音放出来肯定会被粑粑打个半死。</p>

<p>但没有声音再好的戏也出不来。</p>

<p><img src="http://i.imgur.com/kVrmN7r.jpg" alt="掩面" /></p>

<p>忧郁了两天之后，本屌在百无聊赖中想出了一个奇法——收音机——把收音机调到电视台里面的频道频段，然后插上耳机。</p>

<p><img src="http://i.imgur.com/b93H0gE.jpg" alt="大拇指" /></p>

<p>天籁之音，效果怒赞，尽管时常音画异步。</p>

<h3>盗版</h3>

<p>初中时经常组团去高富帅A君家里看爱情动作片——</p>

<ol>
<li>A君家里既有一部大号电视，又有两个几乎和我们一般高的音箱，如同一个小型影院一般。</li>
<li>A君父母做生意，周末经常不在家。</li>
</ol>


<p>于是每次都看的如痴如醉，流连忘返，直到之后的盗版事件：</p>

<p>正看到黑白双方难解难分，突然听到楼道里有声音，我擦A君的粑粑回来了！众屌忙提上裤子，关上电视，正襟危坐。</p>

<p>A君粑粑进来看，发现众屌面部呆滞：</p>

<p><img src="http://i.imgur.com/uLRMnR3.jpg" alt="呆滞" /></p>

<p>A君粑粑觉得有必要缓解下气氛：“小朋友们看电视哈”。</p>

<p><img src="http://i.imgur.com/kVrmN7r.jpg" alt="掩面" /></p>

<p>“尼玛这放的什么东西！！”</p>

<p>“电……电…………电影………………”</p>

<p>“什么电影！！？”</p>

<p>“……………………盗版电影”</p>

<h2>百米</h2>

<p>初中生物老师是个极其猥琐的中年胖子，别的老师讲人体生殖系统顶多讲20分钟，这个家伙一讲讲了三周。还提到男性XX一次是非常剧烈的运动——相当于<strong>冲刺100米</strong>或是<strong>慢跑500米</strong>。</p>

<p>然后就有了如下对话：</p>

<p>“昨天晚上小跑了1500米，你呢？”</p>

<p>“还是你猛，我冲刺到200米就顶不住了……”</p>

<h2>速眠</h2>

<p>高考前压力很大，成绩不稳定，晚上经常失眠，心神不宁。</p>

<p>后来发现每次飞机之后睡的都很沉。</p>

<p>又发现蹲一小会站起来会头晕目眩。</p>

<p>如果把飞机和蹲起结合在一起会发生什么呢？</p>

<p>于是本屌在床前尝试了一次，直接双眼一黑晕倒在床，直到第二天才来，精神百倍。</p>

<p>于是蹲撸速眠成了本屌的新技能——每逢大考小考前日使用一次，次日成绩极佳。</p>

<h2>动物</h2>

<p>大一寒假后回到学校，路过大连火车站时感觉有人尾随，警觉的回头一看是位猥琐大妈：</p>

<p>“小伙要片吗”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>擦，哥硬盘里多着呢，继续往前走。</p>

<p>“要日本的吗？”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>尼玛烦不烦，继续前行。</p>

<p>“要不欧美的？”</p>

<p><img src="http://i.imgur.com/IzI197h.jpg" alt="抽烟" /></p>

<p>我擦要不要这么专业，继续前行。</p>

<p>“动物的也有！”</p>

<p><img src="http://i.imgur.com/Oabz9Rv.jpg" alt="纳尼" /></p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的算法学习之路]]></title>
    <link href="http://zh.lucida.me/blog/on-learning-algorithms/"/>
    <updated>2014-05-04T13:43:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-learning-algorithms</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>严格来说，本文题目应该是<strong>我的数据结构和算法学习之路</strong>，但这个写法实在太绕口——况且CS中的算法往往暗指数据结构和算法（例如<strong>算法导论</strong>指的实际上是<strong>数据结构和算法导论</strong>），所以我认为本文题目是合理的。</p>

<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/">http://zh.lucida.me/blog/on-learning-algorithms/</a></p>

<p>原文作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<h3>这篇文章讲了什么？</h3>

<ul>
<li>我这些年学习数据结构和算法的总结。</li>
<li>一些不错的算法书籍和教程。</li>
<li>算法的重要性。</li>
</ul>


<h2>初学</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的&#8221;学长&#8221;和&#8221;大神&#8221;请教应该读哪些算法书籍，&#8221;学长&#8221;们均推荐算法导论，还有几个&#8221;大神&#8221;推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了<a href="http://www.douban.com/">豆瓣</a>这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些&#8221;学长&#8221;或是&#8221;大神&#8221;靠谱的多得多。</p>

<!-- more -->


<h3>数据结构与算法分析——C语言描述</h3>

<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt="数据结构与算法分析——C语言描述" /></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N<sup>3</sup>)杀到O(N<sup>2</sup>)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h3>微软的梦工厂</h3>

<p><img src="http://img3.douban.com/lpic/s3322643.jpg" alt="微软的梦工厂" /></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了&#8221;找工作就要这样的公司&#8221;的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己&#8221;毕业就工作&#8221;的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h3>算法设计与分析</h3>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://img3.douban.com/lpic/s2019521.jpg" alt="算法设计与分析基础" /></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具。</p>

<h3>算法引论</h3>

<p><img src="http://img5.douban.com/lpic/s4230097.jpg" alt="算法引论" /></p>

<p><a href="http://book.douban.com/subject/4178907/">算法引论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://img3.douban.com/lpic/s2019521.jpg">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ol>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ol>


<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h3>百度实习面试</h3>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个<code>stof</code>（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li>原来自己连百度实习面试都过不去。</li>
<li>原来自己还是一个编程弱逼。</li>
<li>原来自己还是一个算法菜逼。</li>
</ul>


<p>痛定思痛，我开始了第二个&#8221;五年计划&#8221;，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h3>Elements of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s4243636.jpg" alt="Elements of Programming" /></p>

<p>由于一直觉得名字里带&#8221;Elements of&#8221;的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h3>C Interfaces and Implementation</h3>

<p><img src="http://img5.douban.com/lpic/s1686769.jpg" alt="C Interfaces and Implementation" /></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826292/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的<a href="http://www.amazon.com/review/RMXKDJNH8UOPU/">评论</a>：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是<code>stof</code>这种简单到爆的&#8221;算法&#8221;。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——<strong>纸上编码</strong>。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的<a href="http://book.douban.com/review/3733680/">文章</a>来黑那些动不动就&#8221;基础&#8221;或&#8221;内功&#8221;的所谓&#8221;大牛&#8221;们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote><p>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</p></blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸。</p>

<h3>LL(k)</h3>

<p>我在微软实习的第一个项目做的是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>分析——计算T-SQL存储过程的代码覆盖率。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://img5.douban.com/lpic/s24921197.jpg" alt="Language Implementation Patterns" /></p>

<p>比较奇诡的是，做这个项目时当时我刚好把<a href="http://www.antlr.org/">ANTLR</a>作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h3>拼音索引</h3>

<p>拼音索引是我接的一个手机应用私活里的小模块，用户期待在手机文本框可以根据输入给出智能提示：</p>

<p>比如说输入中国：</p>

<p><img src="http://i.imgur.com/tjKjyzN.png" alt="智能提示" /></p>

<p>同样，输入拼音也应给出提示：</p>

<p><img src="http://i.imgur.com/zTjEBik.png" alt="智能提示" /></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ol>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用<code>Int16</code>索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用<code>Int64</code>建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个<code>Int64</code>里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ol>


<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，<strong>如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞</strong>。</p>

<h3>快速字符串匹配</h3>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找&#8221;张晓明&#8221;，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。</p>

<p><img src="http://i.imgur.com/R3JalOH.jpg" alt="E51" /></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><img src="http://i.imgur.com/Pfff0e9.jpg" alt="Cry" /></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://img3.douban.com/lpic/s8978030.jpg" alt="Algorithms on Strings, Trees and Sequences" /></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h3>Writing Efficient Programs</h3>

<p>之后又做了若干个项目，多多少少都用到了&#8221;自制&#8221;的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种<strong>将有限计算资源发挥到极致</strong>的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://img3.douban.com/lpic/s3780111.jpg" alt="Writing Efficient Programs" /></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了<strong>过早优化是万恶之源</strong>之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h3>Algorithm Design Manual</h3>

<p><img src="http://img3.douban.com/lpic/s10347625.jpg" alt="Algorithm Design Manual" /></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3072383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h3>编程珠玑&amp;更多的编程珠玑</h3>

<p><img src="http://img3.douban.com/lpic/s2712842.jpg" alt="Programming Pearls" /></p>

<p><img src="http://img3.douban.com/lpic/s7073511.jpg" alt="More Programming Pearls" /></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h3>The Science of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s2812798.jpg" alt="The Science of Programming" /></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>引用的书籍，撸完<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>之后，本屌获得了<strong>证明简单代码段的正确性</strong>这个技能——求职面试三板斧之二。</p>

<p><strong>证明简单代码段的正确性</strong>是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的<a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">博客</a>，总之就是<strong>项目经历</strong>、<strong>纸上代码</strong>加<strong>正确性证明</strong>这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称<strong>拼写</strong>出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h3>Algorithms 4th</h3>

<p><img src="http://img5.douban.com/lpic/s8938479.jpg" alt="Algorithms" /></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h3>6.851 Advanced Data Structures</h3>

<p><img src="http://courses.csail.mit.edu/6.851/spring12/illus.png" alt="Advanced Data Structures" /></p>

<p><a href="http://courses.csail.mit.edu/6.851/">Advanced Data Structures</a>是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google <strong>Advanced Data Structures</strong>第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带&#8221;记忆&#8221;的数据结构（Data Structure with Persistence）。</li>
<li>van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。</li>
<li>o(1)时间复杂度的的LCA、RMQ和LA解法。</li>
<li>奇幻的o(n)时间复杂度的Suffix Tree构建方法。</li>
<li>o(lglgn)的BST。</li>
<li>&hellip;</li>
</ul>


<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决<strong>实际</strong>问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p><a href="http://norvig.com/">Peter Norvig</a>曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：</p>

<blockquote><p>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：</p>

<blockquote><p>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</p></blockquote>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>

<p>By <a href="http://zh.lucida.me">Lucida</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习&使用技术的四种层次]]></title>
    <link href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/"/>
    <updated>2014-04-12T17:53:21-07:00</updated>
    <id>http://zh.lucida.me/blog/levels-on-learning-and-using-technologies</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>技术，生活，反思。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/</a></p>

<h2>关于</h2>

<p>Bjarne Stroustrup在他的新书《<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A tour of C++</a>》</p>

<p><img src="http://i.imgur.com/VlQ7ROA.jpg" alt="A tour of C++" style="max-height: 370px;"/></p>

<p>里面举了一个旅行的例子来比喻初学编程语言：</p>

<blockquote><p>&hellip;as an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions what to see next&hellip;</p>

<p>&hellip;you do not know the city after such a tour. You do not understand all you have seen and heard. You do not know how to navigate the formal and informal rules that govern life in the city&hellip;</p>

<p>&hellip;to really know a city, you have to live in it, often for years.</p></blockquote>

<p>简而言之，编程语言是City，而开发者则是Traveller——这是一个很有意思的比喻，在这篇文章里，我试图<strong>延续</strong>这个类比（Analogy）——把这个类比放大到初学，掌握，了解以至精通一门技术的层面。</p>

<p>不过需要注意：我自己并没有精通哪一门技术——所以这篇文章的内容是值得怀疑（susceptible）的，但它可以作为一个不错的参考。</p>

<!-- more -->


<h2>0. Stranger（陌生人）</h2>

<p>使用一项技术最初的层次就是听说过没用过——就像我们之中的大多数人都听过南极，听过北极，知道南极有企鹅，北极有北极熊，但是却从来没有去过南极或北极。</p>

<p>Stranger具有以下的特征：</p>

<ul>
<li>知道这项技术的名字。</li>
<li>知道这项技术的一些术语。</li>
<li>知道这项技术的一些关键人物的名字。</li>
<li>了解少量技术的细节，但没有使用这项技术的实际经验。</li>
</ul>


<p>以我本人和RoR来打个比方：</p>

<ul>
<li>知道RoR是Ruby on Rails。</li>
<li>知道Rails，Gem和Rake的存在。</li>
<li>知道DHH也知道松本行弘。</li>
<li>看过<a href="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/">The Ruby Programming Language</a>，还使用一个基于RoR的博客框架<a href="http://octopress.org/">Octopress</a>写博客。</li>
<li>但从来没有使用RoR去搭建网站。</li>
</ul>


<p>所以我是一个RoR的Stranger。</p>

<p>对于新技术，绝大多数人都是Stranger——但是就我对国内技术社区的观察，相当数量的Stranger意识不到自己还是Stranger——认为知道一点术语一些人名就算了解一门技术，甚至把它写在简历上（Familiar with XXX）或是开始与别人进行讨论（当然都是毫无意义的讨论）。</p>

<h2>1. Tourist（旅行者）</h2>

<p>当开发者真正开始用一项技术作出了可以用的东西：</p>

<ul>
<li>面向用户的产品（End-User-Oriented Product），比如一个手机应用，或是一个浏览器插件。</li>
<li>或是面向程序员的工具（Programmer-Oriented Tools），比如一个页面抓取框架，或一个简单的Parser Generator。</li>
<li>注意教科书范例（Textbook examples）和Hello world不属于可以用的东西——这些只是Dead Code——被执行一两次，然后被遗忘。</li>
</ul>


<p>这时这个开发者就进入到了Tourist阶段：</p>

<ul>
<li>了解这项技术的基本元素。</li>
<li>使用这项技术做出了实用的产品或工具。</li>
<li>了解对这项技术的部分细节。</li>
</ul>


<p>根据的学习目的的不同，Tourist又可以分为Salesman和Sightseer。</p>

<h3>1.1. Salesman（旅行商）</h3>

<p><img src="http://i.imgur.com/k5oucJ5.jpg" alt="Salesman" style="max-height: 370px;"/></p>

<p>Salesman是具有明确目的的Tourist——他们学习技术的目标是为了完成某一项业务，就像旅行商去某地出差是为了卖商品而非观光一样。</p>

<p>绝大多数职业开发者在开发生涯中都会扮演Salesman这个角色——接到一个任务，涉及到某项不熟悉的技术，需要在限定时间内完成。</p>

<h3>1.2. Sightseer（观光者）</h3>

<p><img src="http://i.imgur.com/RpYoDXc.gif" alt="Sightseer" style="max-height: 370px;"/></p>

<p>和Salesman相反，Sightseer学习技术的目标是为了拓展视野，增加见识，而非完成某项特定业务。</p>

<p>具有主动学习精神的开发者在业余时会时常扮演Sightseer角色——找到自己认为有价值的新技术或是基础知识进行系统学习，从而拓宽视野，提高水平。</p>

<h2>2. Resident（居住者）</h2>

<p>如果一个旅行者在一个地方待了半年以上，那么他/她就会变得原来越像当地人。随着Tourist对某项技术的日益精进，他/她会逐渐演变成这项技术的Resident：</p>

<ul>
<li>熟悉这项技术的基本元素。</li>
<li>熟悉这项技术的生态系统（Ecology）：既包括开发工具（编辑器，命令行工具，集成开发环境等），也包括开发社区（讨论组，邮件列表等）。</li>
<li>了解这项技术能做什么，不能做什么。</li>
<li>了解这项技术有那些坑，如何绕过这些坑，以及识别这些坑带来的问题。</li>
<li>对某些领域有深入的研究——但并不受限于特定领域。</li>
<li>使用这项技术做出了有相当价值的产品或工具。</li>
</ul>


<p>同Tourist一样，根据使用技术的目标不同，Resident可以分为Worker和Craftsman：</p>

<h2>2.1. Worker（工人）</h2>

<p><img src="http://i.imgur.com/jGNNrQp.jpg" alt="Worker" style="max-height: 370px;"/></p>

<p>技术是Worker的谋生手段，一个优秀的Worker应具备以下特征：</p>

<ul>
<li>对于给定问题，知道如何给出经济有效的解决方案。</li>
<li>以团队合作为主，了解团队合作的价值，能够推动团队项目健康前进。</li>
<li>追求按时交付。</li>
</ul>


<h3>2.2. Craftsman（工匠）</h3>

<p><img src="http://i.imgur.com/9RRUjmb.jpg" alt="Craftsman" style="max-height: 370px;"/></p>

<p>同Worker不同，技术并非Craftsman的谋生手段，而是某种“副业”——用来提升声望，修炼开发水平。</p>

<p>一个优秀的Craftman往往具备以下特点：</p>

<ul>
<li>对于给定问题，知道如何给出优雅的解决方案。</li>
<li>以单兵作战为主，主要靠个人推进项目，但也能进行一定程度的团队合作。</li>
<li>追求极致美感。</li>
</ul>


<h2>3. Architect（架构者）</h2>

<p>有想法且有能力的人在一个地方待久了都会有将这个地方变的更好的冲动——一种方式是从源头出发，推翻旧制度建立新社会，也就是革命；另一种方式则是保留现有的制度，对其进行温和但持续的改进，也就是改良。</p>

<p>技术也是如此，任何技术都跟不上开发者成长的脚步，当这种差距到达一定程度时，就会有卓越的开发者站出来，创造出新的技术，他们就是Architect：</p>

<ul>
<li>熟悉多项互相关联的技术，并了解他们的优势和不足。</li>
<li>具备强大的领导能力，深厚的基础和大量实际开发经验。</li>
<li>能够带动整个技术的生态系统发展。</li>
<li>好吧，我编不下去了（尼玛我要都知道我还至于是IT苦屌么 &ndash;_-）</li>
</ul>


<p>如果你看过<a href="http://movie.douban.com/subject/1304141/">Matrix 2: Reloaded</a></p>

<p><img src="http://i.imgur.com/EDyNv4F.jpg" alt="Matrix 2: Reloaded" style="max-height: 370px;"/></p>

<p>就会知道Architect这个词放在这里再好不过。</p>

<p>根据目标不同，Architect分为Reformist和Revolutionist。</p>

<h3>3.1. Reformist（改良者）</h3>

<p><img src="http://i.imgur.com/xp2SzWu.jpg" alt="Reformist" style="max-height: 370px;"/></p>

<p>改良者的目标：<strong>把现有技术变的更好</strong>。（<strong>Makes</strong> existing technology better）</p>

<p>例如：</p>

<ul>
<li>GoF总结<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Pattern</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/John_Resig">John Resig</a>创造<a href="http://en.wikipedia.org/wiki/Jquery">jQuery</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>为C#引入<a href="http://en.wikipedia.org/wiki/LINQ">LINQ</a>。</li>
</ul>


<h3>3.2. Revolutionist（革命者）</h3>

<p><img src="http://i.imgur.com/cpmjDCC.jpg" alt="Revolutionist" style="max-height: 370px;"/></p>

<p>革命者的目标：<strong>用更好的技术取代现有技术</strong>。（<strong>Replaces</strong> existing technology with better one）</p>

<p>例如：</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Alan_kay">Alan Kay</a>把细胞的概念引入软件开发]进而创造出<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的核心概念。</li>
<li><a href="http://en.wikipedia.org/wiki/Donald_Knuth">Don Knuth</a>对计算机算法（<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>）以及计算机排版（TEX）的贡献。</li>
<li>iPhone于2010年之前的任何手机（iPhone4除外）。</li>
</ul>


<h2>小结</h2>

<p>这篇文章利用<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>里的隐喻，把学习/使用技术分成了四个层次七个头衔：Stranger，Tourist（Salesman，Sightseer），Resident（Worker，Craftsman），Architect（Reformist，Revolutionist），然后给出了各个头衔所应具备的特征和能力。</p>

<h3>关于同类文章</h3>

<p>之前也有类似的文章，例如<a href="http://blog.itpub.net/6517/viewspace-611506/">程序员的十层境界</a>和<a href="http://blog.csdn.net/happydeer/article/details/8107560">开发者的八种境界</a></p>

<p>这些文章的共同点：</p>

<ol>
<li>看似很牛逼但回想一下啥都没说。</li>
<li>不会给人带来什么价值。</li>
<li>没有一个鉴别的标准。</li>
<li>没有指导性，也没有使用价值。</li>
</ol>


<h3>本文的应用场景</h3>

<h4>考察状态</h4>

<p>以我自己对编程语言的掌握为例：</p>

<ul>
<li>C/C++: Stranger.</li>
<li>Python: Craftsman.</li>
<li>Java: Worker.</li>
<li>C#: Craftsman.</li>
<li>JavaScript: Sightseer.</li>
<li>Scheme: Sightseer</li>
</ul>


<p>将上面的列表转置：</p>

<ul>
<li>Stranger: C/C++</li>
<li>Sightseer: JavaScript, Scheme</li>
<li>Worker: Java</li>
<li>Craftsman: C#, Python</li>
</ul>


<p>结合这些头衔的定义，一目了然。</p>

<h4>制定计划</h4>

<p>运用本文的词汇，可以进行非常精炼的计划制定：</p>

<ul>
<li>例如 Make a thoroughly <strong>sightseeing</strong> of <strong>C++</strong>；</li>
<li>或是 Become a proficient <strong>worker</strong> on <strong>IntelliJ</strong>；</li>
<li>抑或 Take a short <strong>tour</strong> of <strong>Sublime Text</strong>。</li>
</ul>


<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三月小结（暨TARQIE——一种量化成长的方法（下））]]></title>
    <link href="http://zh.lucida.me/blog/summary-of-march-2014/"/>
    <updated>2014-04-06T15:24:33-07:00</updated>
    <id>http://zh.lucida.me/blog/summary-of-march-2014</id>
    <content type="html"><![CDATA[<h2>目标实际完成情况</h2>

<h3>Tarqie-J</h3>

<ol>
<li>目标

<ul>
<li>高效完成Q1 OKR。 &ndash;> 1.0

<ul>
<li>搞定，超出Manager和Mentor的预期。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>成功迁移124个Test。 &ndash;> 1.0

<ul>
<li>搞定，并且构建了持续测试环境。</li>
</ul>
</li>
<li>为这些Test配置一个可稳定运行的环境。 &ndash;> 0.8

<ul>
<li>基本搞定，但仍存在少量（每天1~2次）的不稳定状况。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>恬着脸皮向不同的同事请教。 &ndash;> 1.0

<ul>
<li>达成——基本每个同事都被我骚扰了一遍 &ndash;_&ndash;</li>
</ul>
</li>
<li>理解当前Test的架构和流程。 &ndash;> 1.0

<ul>
<li>重建测试框架的过程中了解</li>
</ul>
</li>
<li>阅读The Art Of Unit Test，Guice Book和GuiceBerry Manual，了解如何用Guice写良好的Test。 &ndash;> 0.7

<ul>
<li>部分完成，阅读Google Guice Book，了解了Guice运作机制。</li>
</ul>
</li>
<li>阅读Java Best Practices和Effective Java。 &ndash;> 0.8

<ul>
<li>部分完成，重新阅读了JBP，但Effective Java只看了一多半。</li>
</ul>
</li>
<li>阅读Java Performance，了解JVM。 &ndash;> 0.7

<ul>
<li>部分完成，阅读了国产的<a href="http://book.douban.com/subject/24722612/">《深入理解Java虚拟机》</a>，了解Java内存管理/回收，字节码生成等内容。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>每周与mentor交流，进行进度控制/难点求助。 &ndash;> 0.6

<ul>
<li>由于mentor结婚度蜜月所以没有达成。</li>
</ul>
</li>
<li>Test的数量不断增加。 &ndash;> 1.0

<ul>
<li>达成——事实上全部搞定。</li>
</ul>
</li>
<li>CL中review的数量持续降低。 &ndash;> 1.0

<ul>
<li>搞定，成功的从每次提交代码20余个review降至小于6个。</li>
</ul>
</li>
<li>逐步理解项目代码背后的机理。 &ndash;> 0.6

<ul>
<li>部分搞定，对项目测试框架已经相当了解了（毕竟自己重新搭建了整个框架），但对整个项目的各个模块，交互流程还是一头雾水。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.85</p>

<!-- more -->


<h3>Tarqie-L</h3>

<ol>
<li>目标

<ul>
<li>提高精力，理解Python。 &ndash;> 0.8

<ul>
<li>精力小有提高，至于Python——实现机制不太了解，但Python语法和编程风格我现在有足够自信——毕竟写了一个程序解析合法的Python然后生成同等语义的Google风格的Python，再加上身边有一个Python Readability Reviewer，说自己现在达到中级Python开发者的水准应该不为过。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>精力提高（自然醒，不赖床）。 &ndash;> 0.6

<ul>
<li>自然醒但依然赖床——-_&ndash;</li>
</ul>
</li>
<li>熟悉Python及其实现。 &ndash;> 0.8

<ul>
<li>部分搞定，见上文。</li>
</ul>
</li>
<li>理解4个开源项目的架构。 &ndash;> 1.0

<ul>
<li>搞定，见下文。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>早睡早起（11:30 PM ~ 8:30 AM）+每天运动20分钟。 &ndash;> 0.7

<ul>
<li>早睡早起没做到，运动的频率两周一次。</li>
</ul>
</li>
<li>阅读相关技术书籍（Python源码剖析，开源项目架构等）。 &ndash;> 0.6

<ul>
<li>部分完成，Python源码剖析只读了第一章，但开源项目架构每周一篇。</li>
</ul>
</li>
<li>增强学习能力（阅读《Study Less, Learn More》） &ndash;> 1.0

<ul>
<li>完成。</li>
</ul>
</li>
<li>控制手淫频率至两周一次。 &ndash;> 1.0 &ndash;_&ndash;

<ul>
<li>完成。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>早睡早起+运动不间断。 &ndash;> 0.5

<ul>
<li>搞定一半。两天运动一次。</li>
</ul>
</li>
<li>学习能力增强（+系统学习能力）。 &ndash;> 1.0

<ul>
<li>部分做到，但很难验证——不过用十天搞出了另外一个家伙搞了5个月的东西应该能说明部分问题。</li>
</ul>
</li>
<li>逐步理解Python各个部分的实现（对象，语句，元组，列表，字典，控制流，异常，自定义类型，列表理解，生成器，模块，从源码了解其机制）。 &ndash;> 1.0

<ul>
<li>没有阅读代码，但完成了一个Python Formatter——把Python代码转换成AST再转换回等语义的<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>代码。</li>
</ul>
</li>
<li>每周理解1个开源项目的架构。 &ndash;> 1.0

<ul>
<li>完成——阅读了<a href="http://aosabook.org/en/bash.html">Bash</a>, <a href="http://aosabook.org/en/selenium.html">Selenium WebDriver</a>, <a href="http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">Chrome</a>和<a href="http://aosabook.org/en/posa/parsing-xml-at-the-speed-of-light.html">puginxml</a>。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.8</p>

<h3>成就</h3>

<h4>工作</h4>

<ol>
<li>构建新的测试环境并迁移原有的测试用例。

<ul>
<li>各种神坑，Team/MailList/Group/ReadTheFuckingSource。</li>
<li>manager一度问我是否需要support——想了想还是撑下来了，还好搞定了。</li>
<li>神奇的发现自己第一次实习时做的也是migration，尼玛难道是轮回？</li>
</ul>
</li>
<li>利用业余时间构建了pyfmt——基于AST的代码格式化工具，生成符合<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>的等语义代码。

<ul>
<li>速度是公司工具的6倍到50倍不等（已验证）。</li>
<li>速度是<a href="https://github.com/hhatto/autopep8">autopep8</a>的3倍到30倍（已验证）。</li>
<li>生成的代码质量基本等同（待验证）。</li>
<li>代码量是<a href="https://github.com/hhatto/autopep8">autopep8</a>的二分之一。</li>
<li>不依赖任何第三方库。</li>
<li>不使用任何正则表达式——Never send a regex to do a parser&rsquo;s job.</li>
</ul>
</li>
</ol>


<h4>生活</h4>

<ol>
<li>重新实现了自己两年前写的Lucida。

<ul>
<li>重新设计类型系统，进行尾递归优化。然后完成<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">《90分钟实现一门编程语言——极简解释器教程》</a>，写作之余想通了之前很多迷惑的地方。</li>
<li>功能基本等同，代码量是前一版的八分之一，运行速度是前一版的270倍（倒不是这一版效率有多高，主要是前一版写的太挫了）</li>
</ul>
</li>
<li><a href="http://zh.lucida.me/blog/on-reading-books/">《如何阅读书籍》</a>和<a href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/">《网络上瘾及其解决方法》</a>两篇议论型博客。</li>
<li>完整的完成一个引体向上。</li>
</ol>


<h3>阅读列表</h3>

<ul>
<li><a href="http://book.douban.com/subject/3814402/">The Quick Python Book</a></li>
<li><a href="http://book.douban.com/subject/25710862/">Getting Started with Google Guava</a></li>
<li><a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a></li>
<li><a href="http://book.douban.com/subject/24383461/">网络素养</a></li>
<li><a href="http://book.douban.com/subject/25783654/">如何高效学习</a></li>
<li><a href="http://book.douban.com/subject/3009235/">Google Guice</a></li>
<li><a href="http://aosabook.org/en/index.html">The Architecture of Open Source Applications</a></li>
</ul>


<h3>一些体会</h3>

<ol>
<li>慢读慎写——读书不是靠页数，代码不是拼行数。</li>
<li>精益求精——严肃认真对待自己的任何一个项目/作品，每一行代码，每一个细节都应有其意义。</li>
<li>Don&rsquo;t <a href="http://en.wikipedia.org/wiki/Satisfice">satisfice</a>—— 在时间充裕的情况下，尽力寻找最优解，而不是找到一个答案就满足。</li>
<li>Have a mentor/coach——无论学习什么，身边要有一个大师级人物，不要盲目相信自学能力——坑大多都是自己挖出来的。</li>
<li>在合适的抽象层工作（Working at a proper abstraction layer），包括下面几点：

<ul>
<li>找到与目标最契合的层次：

<ul>
<li>如果层级过高就会造成性能损失和功能缺失。</li>
<li>如果层次过低就会变成重造轮子。</li>
</ul>
</li>
<li>总是在同一个层次工作——以避免上下文切换。</li>
<li>将复杂度封装到各自对应的层次——以避免进行交互——<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li>
</ul>
</li>
</ol>


<h3>发现的问题</h3>

<ol>
<li>3月目标制定的过于宏大——尽管完成度不错，但代价也很大——工作时间从每天8小时增加到10小时，到了后期的阅读时间几乎被缩减到零，接下来会相应的缩小计划目标。</li>
<li>除了工作就是学习，导致略抑郁——尽管做出的东西带来了一点成就感。总之接下来需要更多的娱乐。</li>
<li>猛然反应过来所谓的TARQIE其实就是OKR（<a href="http://en.wikipedia.org/wiki/OKR">Objective-Key-Results</a>）——所以接下来直接使用<a href="http://en.wikipedia.org/wiki/OKR">OKR</a>制定计划，更加简洁。</li>
</ol>


<h3>4月计划</h3>

<h3>OKR-J</h3>

<ul>
<li>目标

<ol>
<li>完整迁移测试到原项目中。</li>
<li>稳定+推广pyfmt。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>成功迁移124个Test到原项目。</li>
<li>将测试的不稳定性控制在每天3次以下。</li>
<li>pyfmt通过Python Readability。</li>
<li>pyfmt有10个以上的用户。</li>
<li>pyfmt从experimental进入devtools（略激进，但值得一试）。</li>
</ol>
</li>
</ul>


<h3>OKR-L</h3>

<ul>
<li>目标

<ol>
<li>正常作息，提高精力。</li>
<li>结合pyfmt，深度理解Python。</li>
<li>加深对Java &amp; JVM的理解。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>理解Python各个部分的实现，从源码了解其机制。</li>
<li>阅读并理解两个以上的开源项目架构。</li>
<li>完成<a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a>，阅读<a href="http://www.amazon.co.uk/Java-Performance-Addison-Wesley-Charlie-Hunt/dp/0137142528/">《Java Performance》</a>至50%。</li>
<li>迁移测试的同时完成<a href="http://www.amazon.co.uk/Effective-Unit-Testing-guide-developers/dp/1935182579/">Effective Unit Testing: A guide for Java developers</a>的阅读。</li>
<li>早睡<em>晚</em>起（8:40 ~ 23:50）</li>
<li>控制手淫频率至两周一次。</li>
<li>至少两天一次20分钟的运动。</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[90分钟实现一门编程语言——极简解释器教程]]></title>
    <link href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/"/>
    <updated>2014-03-23T12:08:35-07:00</updated>
    <id>http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>解释器, C#, Scheme, 函数式编程</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/</a></p>

<h2>关于</h2>

<p>本文介绍了如何使用C#实现一个简化Scheme——iScheme及其解释器。</p>

<p>如果你对下面的内容感兴趣：</p>

<ul>
<li>实现基本的词法分析，语法分析并生成抽象语法树。</li>
<li>实现嵌套作用域和函数调用。</li>
<li>解释器的基本原理。</li>
<li>以及一些C#编程技巧。</li>
</ul>


<p>那么请继续阅读。</p>

<p>如果你对以下内容感兴趣：</p>

<ul>
<li>高级的词法/语法分析技术。</li>
<li>类型推导/分析。</li>
<li>目标代码优化。</li>
</ul>


<p>本文则过于初级，你可以跳过本文，但欢迎指出本文的错误 :&ndash;)</p>

<!-- more -->


<h2>代码样例</h2>

<figure class='code'><figcaption><span>代码示例</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="m">7</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="m">10</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码定义了<code>Add</code>函数，接下来的<code>&gt;&gt;</code>符号表示对<code>Add(3, 4)</code>进行求值，再下一行的<code>&gt;&gt; 7</code>表示上一行的求值结果，不同的求值用换行分开。可以把这里的<code>&gt;&gt;</code>理解成控制台提示符（即Terminal中的PS）。</p>

<h2>什么是解释器</h2>

<p><img src="http://i.imgur.com/C8lxHfr.jpg" alt="解释器图示" /></p>

<p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>（Interpreter）是一种程序，能够读入程序并直接输出结果，如上图。相对于<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>（Compiler），<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>并不会生成目标机器代码，而是直接运行源程序，简单来说：</p>

<blockquote><p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>是运行程序的程序。</p></blockquote>

<p>计算器就是一个典型的解释器，我们把数学公式（源程序）给它，它通过运行它内部的&#8221;解释器&#8221;给我们答案。</p>

<p><img src="http://i.imgur.com/FC1nqko.jpg" alt="CASIO 计算器" /></p>

<h2>iScheme编程语言</h2>

<p>iScheme是什么？</p>

<ul>
<li>Scheme语言的一个极简子集。</li>
<li>虽然小，但变量，算术|比较|逻辑运算，列表，函数和递归这些编程语言元素一应俱全。</li>
<li>非常非常慢——可以说它只是为演示本文的概念而存在。</li>
</ul>


<p>OK，那么Scheme是什么？</p>

<ul>
<li>一种函数式程序设计语言。</li>
<li>一种Lisp方言。</li>
<li>麻省理工学院程序设计入门课程使用的语言（参见<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">MIT 6.001</a>和《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造与解释</a>》）。</li>
</ul>


<p><img src="http://i.imgur.com/66TdRMD.jpg" alt="计算机程序的构造与解释" /></p>

<ul>
<li>使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>（Polish Notation）。</li>
<li>更多的介绍参见<a href="http://zh.wikipedia.org/wiki/Scheme">Scheme编程语言</a>。</li>
</ul>


<p>以计算阶乘为例：</p>

<figure class='code'><figcaption><span>C#版阶乘</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">n</span> <span class="p">*</span> <span class="n">Factorial</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>iScheme版阶乘</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">factorial</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span>
</span><span class='line'>    <span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>       <span class="mi">1</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">factorial</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数值类型</h3>

<p>由于iScheme只是一个用于演示的语言，所以目前只提供对整数的支持。iScheme使用C#的<code>Int64</code>类型作为其内部的数值表示方法。</p>

<h3>定义变量</h3>

<figure class='code'><figcaption><span>iScheme使用`def`关键字定义变量</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">def</span> <span class="nv">a</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">3</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="nv">a</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<h3>算术|逻辑|比较操作</h3>

<p>与常见的编程语言（C#, Java, C++, C）不同，Scheme使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>，即前缀表示法。例如：</p>

<figure class='code'><figcaption><span>C#中的算术|逻辑|比较操作</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="c1">// Arithmetic ops</span>
</span><span class='line'><span class="n">a</span> <span class="p">+</span> <span class="n">b</span> <span class="p">*</span> <span class="n">c</span>
</span><span class='line'><span class="n">a</span> <span class="p">/</span> <span class="p">(</span><span class="n">b</span> <span class="p">+</span> <span class="n">c</span> <span class="p">+</span> <span class="n">d</span><span class="p">)</span>
</span><span class='line'><span class="c1">// Logical ops</span>
</span><span class='line'><span class="p">(</span><span class="n">cond1</span> <span class="p">&amp;&amp;</span> <span class="n">cond2</span><span class="p">)</span> <span class="p">||</span> <span class="n">cond3</span>
</span><span class='line'><span class="c1">// Comparing ops</span>
</span><span class='line'><span class="n">a</span> <span class="p">==</span> <span class="n">b</span>
</span><span class='line'><span class="m">1</span> <span class="p">&lt;</span> <span class="n">a</span> <span class="p">&amp;&amp;</span> <span class="n">a</span> <span class="p">&lt;</span> <span class="m">3</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>对应的iScheme代码</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="c1">; Arithmetic ops</span>
</span><span class='line'><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nb">/ </span><span class="nv">a</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class='line'><span class="c1">; Logical ops</span>
</span><span class='line'><span class="p">(</span><span class="k">or </span><span class="p">(</span><span class="k">and </span><span class="nv">cond1</span> <span class="nv">cond2</span><span class="p">)</span> <span class="nv">cond3</span><span class="p">)</span>
</span><span class='line'><span class="c1">; Comparing ops</span>
</span><span class='line'><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nb">&lt; </span><span class="mi">1</span> <span class="nv">a</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的几点：</p>

<ol>
<li>iScheme中的操作符可以接受不止两个参数——这在一定程度上控制了括号的数量。</li>
<li>iScheme逻辑操作使用<code>and</code>, <code>or</code>和<code>not</code>代替了常见的<code>&amp;&amp;</code>, <code>||</code>和<code>!</code>——这在一定程度上增强了程序的可读性。</li>
</ol>


<h3>顺序语句</h3>

<p>iScheme使用<code>begin</code>关键字标识顺序语句，并以最后一条语句的值作为返回结果。以求两个数的平均值为例：</p>

<figure class='code'><figcaption><span>C#的顺序语句</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">c</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>iScheme的顺序语句</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">c</span> <span class="p">(</span><span class="nf">begin</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">def</span> <span class="nv">a</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">def</span> <span class="nv">b</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>控制流操作</h3>

<p>iScheme中的控制流操作只包含<code>if</code>。</p>

<figure class='code'><figcaption><span>if语句示例</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="nv">a</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<h3>列表类型</h3>

<p>iScheme使用<code>list</code>关键字定义列表，并提供<code>first</code>关键字获取列表的第一个元素；提供<code>rest</code>关键字获取列表除第一个元素外的元素。</p>

<figure class='code'><figcaption><span>iScheme的列表示例</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="k">define </span><span class="nv">alist</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>定义函数</h3>

<p>iScheme使用<code>func</code>关键字定义函数：</p>

<figure class='code'><figcaption><span>iScheme的函数定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">square</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">sum_square</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">b</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>对应的C#代码</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Square</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">SumSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">Square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">+</span> <span class="n">Square</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>递归</h3>

<p>由于iScheme中没有<code>for</code>或<code>while</code>这种命令式语言（Imperative Programming Language）的循环结构，递归成了重复操作的唯一选择。</p>

<p>以计算最大公约数为例：</p>

<figure class='code'><figcaption><span>iScheme计算最大公约数</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">gcd</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">b</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">a</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">b</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>对应的C#代码</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">GCD</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">GCD</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="p">%</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>高阶函数</h3>

<p>和Scheme一样，函数在iScheme中是头等对象，这意味着：</p>

<ul>
<li>可以定义一个变量为函数。</li>
<li>函数可以接受一个函数作为参数。</li>
<li>函数返回一个函数。</li>
</ul>


<figure class='code'><figcaption><span>iScheme的高阶函数示例</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="c1">; Defines a multiply function.</span>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">mul</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class='line'><span class="c1">; Defines a list map function.</span>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">map</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">alist</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">empty?</span> <span class="nv">alist</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">list </span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nb">append </span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">first</span> <span class="nv">alist</span><span class="p">)))</span> <span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="p">(</span><span class="nf">rest</span> <span class="nv">alist</span><span class="p">)))</span>
</span><span class='line'>        <span class="p">)))</span>
</span><span class='line'><span class="c1">; Doubles a list using map and mul.</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nf">mul</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>小结</h3>

<p>对iScheme的介绍就到这里——事实上这就是iScheme的所有元素，会不会太简单了？ &ndash;_&ndash;</p>

<p>接下来进入正题——从头开始构造iScheme的解释程序。</p>

<h2>解释器构造</h2>

<p>iScheme解释器主要分为两部分，解析（Parse）和求值（Evaluation）：</p>

<ul>
<li>解析（Parse）：解析源程序，并生成解释器可以理解的中间（Intermediate）结构。这部分包含词法分析，语法分析，语义分析，生成语法树。</li>
<li>求值（Evaluation）：执行解析阶段得到的中介结构然后得到运行结果。这部分包含作用域，类型系统设计和语法树遍历。</li>
</ul>


<h3>词法分析</h3>

<p>词法分析负责把源程序解析成一个个词法单元（Lex），以便之后的处理。</p>

<p>iScheme的词法分析极其简单——由于iScheme的词法元素只包含括号，空白，数字和变量名，因此C#自带的<code>String#Split</code>就足够。</p>

<figure class='code'><figcaption><span>iScheme的词法分析及测试</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">Tokenize</span><span class="p">(</span><span class="n">String</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">String</span><span class="p">[]</span> <span class="n">tokens</span> <span class="p">=</span> <span class="n">text</span><span class="p">.</span><span class="n">Replace</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="s">&quot; ( &quot;</span><span class="p">).</span><span class="n">Replace</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">,</span> <span class="s">&quot; ) &quot;</span><span class="p">).</span><span class="n">Split</span><span class="p">(</span><span class="s">&quot; \t\r\n&quot;</span><span class="p">.</span><span class="n">ToArray</span><span class="p">(),</span> <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">RemoveEmptyEntries</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">tokens</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Extends String.Join for a smooth API.</span>
</span><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">String</span> <span class="nf">Join</span><span class="p">(</span><span class="k">this</span> <span class="n">String</span> <span class="n">separator</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">separator</span><span class="p">,</span> <span class="n">values</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Displays the lexes in a readable form.</span>
</span><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">String</span> <span class="nf">PrettyPrint</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">lexes</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s">&quot;[&quot;</span> <span class="p">+</span> <span class="s">&quot;, &quot;</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">lexes</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="p">+</span> <span class="n">s</span> <span class="p">+</span> <span class="s">&quot;&#39;&quot;</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Some tests</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">PrettyPrint</span><span class="p">(</span><span class="n">Tokenize</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">PrettyPrint</span><span class="p">(</span><span class="n">Tokenize</span><span class="p">(</span><span class="s">&quot;(def a 3)&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="p">[</span><span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">def</span><span class="err">&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;)&#39;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">PrettyPrint</span><span class="p">(</span><span class="n">Tokenize</span><span class="p">(</span><span class="s">&quot;(begin (def a 3) (* a a))&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="p">[</span><span class="err">&#39;</span><span class="n">begin</span><span class="err">&#39;</span><span class="p">,</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">def</span><span class="err">&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;(&#39;</span><span class="p">,</span> <span class="sc">&#39;*&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;)&#39;</span><span class="p">,</span> <span class="sc">&#39;)&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>注意</h4>

<ul>
<li>个人不喜欢<code>String.Join</code>这个静态方法，所以这里使用C#的<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>（Extension Methods）对String类型做了一个扩展。</li>
<li>相对于LINQ Syntax，我个人更喜欢LINQ Extension Methods，接下来的代码也都会是这种风格。</li>
<li>不要以为词法分析都是这么离谱般简单！vczh的<a href="http://www.cnblogs.com/geniusvczh/p/3577561.html">词法分析教程</a>给出了一个完整编程语言的词法分析教程。</li>
</ul>


<h3>语法树生成</h3>

<p>得到了词素之后，接下来就是进行语法分析。不过由于Lisp类语言的程序即是语法树，所以语法分析可以直接跳过。</p>

<p>以下面的程序为例：</p>

<figure class='code'><figcaption><span>程序即语法树</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="c1">;</span>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">x</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="c1">; 换一个角度看的话：</span>
</span><span class='line'><span class="p">(</span>
</span><span class='line'>    <span class="nv">def</span>
</span><span class='line'>    <span class="nv">x</span>
</span><span class='line'>    <span class="p">(</span>
</span><span class='line'>        <span class="nv">if</span>
</span><span class='line'>        <span class="p">(</span>
</span><span class='line'>            <span class="nv">&gt;</span>
</span><span class='line'>            <span class="nv">a</span>
</span><span class='line'>            <span class="mi">1</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>        <span class="nv">a</span>
</span><span class='line'>        <span class="mi">1</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>更加直观的图片：</p>

<p><img src="http://i.imgur.com/NVolNQE.png" alt="抽象语法树" /></p>

<p>这使得<a href="http://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>（Abstract Syntax Tree）的构建变得极其简单（无需考虑操作符优先级等问题），我们使用<code>SExpression</code>类型定义iScheme的语法树（事实上<a href="http://en.wikipedia.org/wiki/S-expression">S Expression</a>也是Lisp表达式的名字）。</p>

<figure class='code'><figcaption><span>抽象语法树的定义</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SExpression</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">String</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">&gt;</span> <span class="n">Children</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">SExpression</span> <span class="n">Parent</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">SExpression</span><span class="p">(</span><span class="n">String</span> <span class="k">value</span><span class="p">,</span> <span class="n">SExpression</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">&gt;();</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">String</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;(&quot;</span> <span class="p">+</span> <span class="s">&quot; &quot;</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="n">Children</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后用下面的步骤构建语法树：</p>

<ol>
<li>碰到左括号，创建一个新的节点到当前节点（<code>current</code>），然后重设当前节点。</li>
<li>碰到右括号，回退到当前节点的父节点。</li>
<li>否则把为当前词素创建节点，添加到当前节点中。</li>
</ol>


<figure class='code'><figcaption><span>抽象语法树的构建过程</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">SExpression</span> <span class="nf">ParseAsIScheme</span><span class="p">(</span><span class="k">this</span> <span class="n">String</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SExpression</span> <span class="n">program</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SExpression</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="k">null</span><span class="p">);</span>
</span><span class='line'>    <span class="n">SExpression</span> <span class="n">current</span> <span class="p">=</span> <span class="n">program</span><span class="p">;</span>
</span><span class='line'>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">lex</span> <span class="k">in</span> <span class="n">Tokenize</span><span class="p">(</span><span class="n">code</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">lex</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SExpression</span> <span class="n">newNode</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SExpression</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">current</span><span class="p">);</span>
</span><span class='line'>            <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span>
</span><span class='line'>            <span class="n">current</span> <span class="p">=</span> <span class="n">newNode</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lex</span> <span class="p">==</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">current</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">SExpression</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="n">lex</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">current</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">program</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>注意</h4>

<ul>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb384054.aspx">自动属性</a>（Auto Property），从而避免重复编写样版代码（Boilerplate Code）。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/dd264739.aspx">命名参数</a>（Named Parameters）提高代码可读性：<code>new SExpression(value: "", parent: null)</code>比<code>new SExpression("", null)</code>可读。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>提高代码流畅性：<code>code.Tokenize().ParseAsIScheme</code>比<code>ParseAsIScheme(Tokenize(code))</code>流畅。</li>
<li>大多数编程语言的语法分析不会这么简单！如果打算实现一个类似C#的编程语言，你需要更强大的语法分析技术：

<ul>
<li>如果打算手写语法分析器，可以参考LL(k), Precedence Climbing和Top Down Operator Precedence。</li>
<li>如果打算生成语法分析器，可以参考ANTLR或Bison。</li>
</ul>
</li>
</ul>


<h3>作用域</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>决定程序的运行环境。iScheme使用嵌套作用域。</p>

<p>以下面的程序为例</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">def</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">1</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">def</span> <span class="nv">y</span> <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">def</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">4</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="nv">x</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="http://i.imgur.com/TzBY0vd.jpg" alt="作用域示例" /></p>

<p>利用C#提供的<code>Dictionary&lt;TKey, TValue&gt;</code>类型，我们可以很容易的实现iScheme的作用域<code>SScope</code>：</p>

<figure class='code'><figcaption><span>iScheme的作用域实现</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SScope</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">SScope</span> <span class="n">Parent</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;</span> <span class="n">variableTable</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">SScope</span><span class="p">(</span><span class="n">SScope</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">variableTable</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="n">SObject</span> <span class="nf">Find</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SScope</span> <span class="n">current</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">variableTable</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">current</span><span class="p">.</span><span class="n">variableTable</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">current</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="n">name</span> <span class="p">+</span> <span class="s">&quot; is not defined.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="n">SObject</span> <span class="nf">Define</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">SObject</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">variableTable</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类型实现</h3>

<p>iScheme的类型系统极其简单——只有数值，Bool，列表和函数，考虑到他们都是iScheme里面的值对象（Value Object），为了便于对它们进行统一处理，这里为它们设置一个统一的父类型<code>SObject</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SObject</span> <span class="p">{</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>数值类型</h4>

<p>iScheme的数值类型只是对.Net中<code>Int64</code>（即C#里的<code>long</code>）的简单封装：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SNumber</span> <span class="p">:</span> <span class="n">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Int64</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="k">public</span> <span class="nf">SNumber</span><span class="p">(</span><span class="n">Int64</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="k">value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">String</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="k">value</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">Int64</span><span class="p">(</span><span class="n">SNumber</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">number</span><span class="p">.</span><span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">SNumber</span><span class="p">(</span><span class="n">Int64</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">SNumber</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">SNumber</span> <span class="n">foo</span> <span class="p">=</span> <span class="m">30</span><span class="p">;</span>
</span><span class='line'><span class="n">SNumber</span> <span class="n">bar</span> <span class="p">=</span> <span class="m">40</span><span class="p">;</span>
</span><span class='line'><span class="n">SNumber</span> <span class="n">foobar</span> <span class="p">=</span> <span class="n">foo</span> <span class="p">*</span> <span class="n">bar</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而不必：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">SNumber</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SNumber</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="m">30</span><span class="p">);</span>
</span><span class='line'><span class="n">SNumber</span> <span class="n">bar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SNumber</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="m">40</span><span class="p">);</span>
</span><span class='line'><span class="n">SNumber</span> <span class="n">foobar</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SNumber</span><span class="p">(</span><span class="k">value</span><span class="p">:</span> <span class="n">foo</span><span class="p">.</span><span class="n">Value</span> <span class="p">*</span> <span class="n">bar</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了方便，这里也为SObject增加了<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>（尽管<code>Int64</code>可以被转换为<code>SNumber</code>且<code>SNumber</code>继承自<code>SObject</code>，但.Net无法直接把<code>Int64</code>转化为<code>SObject</code>）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">SObject</span><span class="p">(</span><span class="n">Int64</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">SNumber</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Bool类型</h4>

<p>由于Bool类型只有True和False，所以使用静态对象就足矣。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SBool</span> <span class="p">:</span> <span class="n">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SBool</span> <span class="n">False</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SBool</span><span class="p">();</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SBool</span> <span class="n">True</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SBool</span><span class="p">();</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">String</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">((</span><span class="n">Boolean</span><span class="p">)</span><span class="k">this</span><span class="p">).</span><span class="n">ToString</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">Boolean</span><span class="p">(</span><span class="n">SBool</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">value</span> <span class="p">==</span> <span class="n">SBool</span><span class="p">.</span><span class="n">True</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">SBool</span><span class="p">(</span><span class="n">Boolean</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">value</span> <span class="p">?</span> <span class="n">True</span> <span class="p">:</span> <span class="n">False</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里同样使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">SBool</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">a</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Do something...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而不用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">SBool</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">a</span> <span class="p">&gt;</span> <span class="m">1</span> <span class="p">?</span> <span class="n">SBool</span><span class="p">.</span><span class="n">True</span><span class="p">:</span> <span class="n">SBool</span><span class="p">.</span><span class="n">False</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">foo</span> <span class="p">==</span> <span class="n">SBool</span><span class="p">.</span><span class="n">True</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Do something...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样，为<code>SObject</code>增加<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">SObject</span><span class="p">(</span><span class="n">Boolean</span> <span class="k">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">SBool</span><span class="p">)</span><span class="k">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>列表类型</h4>

<p>iScheme使用.Net中的<code>IEnumberable&lt;T&gt;</code>实现列表类型<code>SList</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SList</span> <span class="p">:</span> <span class="n">SObject</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SObject</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SObject</span><span class="p">&gt;</span> <span class="n">values</span><span class="p">;</span>
</span><span class='line'>    <span class="k">public</span> <span class="nf">SList</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SObject</span><span class="p">&gt;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">values</span> <span class="p">=</span> <span class="n">values</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">String</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;(list &quot;</span> <span class="p">+</span> <span class="s">&quot; &quot;</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">values</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">SObject</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>实现<code>IEnumerable&lt;SObject&gt;</code>后，就可以直接使用LINQ的一系列扩展方法，十分方便。</p>

<h4>函数类型</h4>

<p>iScheme的函数类型（<code>SFunction</code>）由三部分组成：</p>

<ul>
<li>函数体：即对应的<code>SExpression</code>。</li>
<li>参数列表。</li>
<li>作用域：函数拥有自己的作用域</li>
</ul>


<figure class='code'><figcaption><span>SFunction的实现</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SFunction</span> <span class="p">:</span> <span class="n">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">SExpression</span> <span class="n">Body</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">String</span><span class="p">[]</span> <span class="n">Parameters</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">SScope</span> <span class="n">Scope</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">Boolean</span> <span class="n">IsPartial</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">ComputeFilledParameters</span><span class="p">().</span><span class="n">Length</span><span class="p">.</span><span class="n">InBetween</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="nf">SFunction</span><span class="p">(</span><span class="n">SExpression</span> <span class="n">body</span><span class="p">,</span> <span class="n">String</span><span class="p">[]</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Body</span> <span class="p">=</span> <span class="n">body</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parameters</span> <span class="p">=</span> <span class="n">parameters</span><span class="p">;</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Scope</span> <span class="p">=</span> <span class="n">scope</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="n">SObject</span> <span class="nf">Evaluate</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">String</span><span class="p">[]</span> <span class="n">filledParameters</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">ComputeFilledParameters</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">filledParameters</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">Body</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Scope</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">String</span> <span class="nf">ToString</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;(func ({0}) {1})&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="s">&quot; &quot;</span><span class="p">.</span><span class="n">Join</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">SObject</span> <span class="k">value</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">((</span><span class="k">value</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">FindInTop</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">p</span> <span class="p">+</span> <span class="s">&quot;:&quot;</span> <span class="p">+</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>            <span class="p">})),</span> <span class="k">this</span><span class="p">.</span><span class="n">Body</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span> <span class="n">String</span><span class="p">[]</span> <span class="nf">ComputeFilledParameters</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">Scope</span><span class="p">.</span><span class="n">FindInTop</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">!=</span> <span class="k">null</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h5>需要注意的几点</h5>

<ul>
<li>iScheme支持部分求值（Partial Evaluation），这意味着：</li>
</ul>


<figure class='code'><figcaption><span>部分求值</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">def</span> <span class="nv">mul</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">mul</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">12</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">mul</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a:3</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">((</span><span class="nf">mul</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">12</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，当<code>SFunction</code>的实际参数（Argument）数量小于其形式参数（Parameter）的数量时，它依然是一个函数，无法被求值。</p>

<p>这个功能有什么用呢？生成高阶函数。有了部分求值，我们就可以使用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">mul</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">mul3</span> <span class="p">(</span><span class="nf">mul</span> <span class="mi">3</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">mul3</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<p>而不用专门定义一个生成函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scm'><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">times</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="nv">x</span><span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="nf">def</span> <span class="nv">mul3</span> <span class="p">(</span><span class="nf">times</span> <span class="mi">3</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="p">(</span><span class="nf">mul3</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="nv">&gt;&gt;</span> <span class="mi">9</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>SFunction#ToString</code>可以将其自身还原为源代码——从而大大简化了iScheme的理解和测试。</li>
</ul>


<h3>内置操作</h3>

<p>iScheme的内置操作有四种：算术|逻辑|比较|列表操作。</p>

<p>我选择了表达力（Expressiveness）强的lambda方法表来定义内置操作：</p>

<p>首先在<code>SScope</code>中添加静态字段<code>builtinFunctions</code>，以及对应的访问属性<code>BuiltinFunctions</code>和操作方法<code>BuildIn</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SScope</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">[],</span> <span class="n">SScope</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;&gt;</span> <span class="n">builtinFunctions</span> <span class="p">=</span>
</span><span class='line'>        <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">[],</span> <span class="n">SScope</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;&gt;();</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">[],</span> <span class="n">SScope</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;&gt;</span> <span class="n">BuiltinFunctions</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">builtinFunctions</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// Dirty HACK for fluent API.</span>
</span><span class='line'>    <span class="k">public</span> <span class="n">SScope</span> <span class="nf">BuildIn</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">[],</span> <span class="n">SScope</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;</span> <span class="n">builtinFuntion</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SScope</span><span class="p">.</span><span class="n">builtinFunctions</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">builtinFuntion</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：</p>

<ol>
<li><code>Func&lt;T1, T2, TRESULT&gt;</code>是C#提供的委托类型，表示一个接受<code>T1</code>和<code>T2</code>，返回<code>TRESULT</code></li>
<li>这里有一个小HACK，使用实例方法（Instance Method）修改静态成员（Static Member），从而实现一套流畅的API（参见<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>）。</li>
</ol>


<p>接下来就可以这样定义内置操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">new</span> <span class="nf">SScope</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">addMethod</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="n">subMethod</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="n">mulMethod</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">divMethod</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>一目了然。</p>

<h4>断言（Assertion）扩展</h4>

<p>为了便于进行<a href="http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，我对<code>Boolean</code>类型做了一点点扩展。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">OrThrows</span><span class="p">(</span><span class="k">this</span> <span class="n">Boolean</span> <span class="n">condition</span><span class="p">,</span> <span class="n">String</span> <span class="n">message</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(!</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">message</span> <span class="p">??</span> <span class="s">&quot;WTF&quot;</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而可以写出流畅的断言：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Value must be less than 3.&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>而不用</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;Value must be less than 3.&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>算术操作</h4>

<p>iScheme算术操作包含<code>+ - * / %</code>五个操作，它们仅应用于数值类型（也就是<code>SNumber</code>）。</p>

<p>从加减法开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">obj</span> <span class="p">=&gt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Sum</span><span class="p">(</span><span class="n">n</span> <span class="p">=&gt;</span> <span class="n">n</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">obj</span> <span class="p">=&gt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;().</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="n">Int64</span> <span class="n">firstValue</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">-</span><span class="n">firstValue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">firstValue</span> <span class="p">-</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意到这里有一段重复逻辑负责转型求值（Cast then Evaluation），考虑到接下来还有不少地方要用这个逻辑，我把这段逻辑抽象成扩展方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">&gt;</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span>
</span><span class='line'><span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">SObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">expressions</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">).</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SObject</span><span class="p">&gt;</span> <span class="n">Evaluate</span><span class="p">(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">SExpression</span><span class="p">&gt;</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">expressions</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后加减法就可以如此定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">)))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="n">Int64</span> <span class="n">firstValue</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">-</span><span class="n">firstValue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">firstValue</span> <span class="p">-</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>乘法，除法和求模定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">Aggregate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">*</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="n">Int64</span> <span class="n">firstValue</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">firstValue</span> <span class="p">/</span> <span class="n">numbers</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Aggregate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">*</span> <span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;%&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">2</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Parameters count in mod should be 2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">numbers</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">%</span> <span class="n">numbers</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h4>逻辑操作</h4>

<p>iScheme逻辑操作包括<code>and</code>，<code>or</code>和<code>not</code>，即与，或和非。</p>

<p>需要注意的是iScheme逻辑操作是<a href="http://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a>（Short-circuit evaluation），也就是说：</p>

<ul>
<li><code>(and condA condB)</code>，如果<code>condA</code>为假，那么整个表达式为假，无需对<code>condB</code>求值。</li>
<li><code>(or condA condB)</code>，如果<code>condA</code>为真，那么整个表达式为真，无需对<code>condB</code>求值。</li>
</ul>


<p>此外和<code>+ - * /</code>一样，<code>and</code>和<code>or</code>也可以接收任意数量的参数。</p>

<p>需求明确了接下来就是实现，iScheme的逻辑操作实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;and&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">!</span><span class="n">args</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">arg</span> <span class="p">=&gt;</span> <span class="p">!(</span><span class="n">SBool</span><span class="p">)</span><span class="n">arg</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;or&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">args</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">arg</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">SBool</span><span class="p">)</span><span class="n">arg</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;not&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h4>比较操作</h4>

<p>iScheme的比较操作包括<code>= &lt; &gt; &gt;= &lt;=</code>，需要注意下面几点：</p>

<ul>
<li><code>=</code>是比较操作而非赋值操作。</li>
<li>同算术操作一样，它们应用于数值类型，并支持任意数量的参数。</li>
</ul>


<p><code>=</code>的实现如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Must have more than 1 argument in relation operation.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">SNumber</span> <span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="n">SNumber</span><span class="p">)</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">arg</span> <span class="k">in</span> <span class="n">args</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SNumber</span> <span class="n">next</span> <span class="p">=</span> <span class="p">(</span><span class="n">SNumber</span><span class="p">)</span><span class="n">arg</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">current</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以预见所有的比较操作都将使用这段逻辑，因此把这段比较逻辑抽象成一个扩展方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">SBool</span> <span class="nf">ChainRelation</span><span class="p">(</span><span class="k">this</span> <span class="n">SExpression</span><span class="p">[]</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">,</span> <span class="n">SNumber</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">&gt;</span> <span class="n">relation</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">expressions</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Must have more than 1 parameter in relation operation.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">SNumber</span> <span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="n">SNumber</span><span class="p">)</span><span class="n">expressions</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">expressions</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SNumber</span> <span class="n">next</span> <span class="p">=</span> <span class="p">(</span><span class="n">SNumber</span><span class="p">)</span><span class="n">obj</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">relation</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">current</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">SBool</span><span class="p">.</span><span class="n">False</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">SBool</span><span class="p">.</span><span class="n">True</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来就可以很方便的定义比较操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">ChainRelation</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">Int64</span><span class="p">)</span><span class="n">s1</span> <span class="p">==</span> <span class="p">(</span><span class="n">Int64</span><span class="p">)</span><span class="n">s2</span><span class="p">))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;&gt;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">ChainRelation</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">s1</span> <span class="p">&gt;</span> <span class="n">s2</span><span class="p">))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">ChainRelation</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">s1</span> <span class="p">&lt;</span> <span class="n">s2</span><span class="p">))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">ChainRelation</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">s1</span> <span class="p">&gt;=</span> <span class="n">s2</span><span class="p">))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">ChainRelation</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">s1</span> <span class="p">&lt;=</span> <span class="n">s2</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意<code>=</code>操作的实现里面有<code>Int64</code>强制转型——因为我们没有重载<code>SNumber#Equals</code>，所以无法直接通过<code>==</code>来比较两个<code>SNumber</code>。</p>

<h4>列表操作</h4>

<p>iScheme的列表操作包括<code>first</code>，<code>rest</code>，<code>empty?</code>和<code>append</code>，分别用来取列表的第一个元素，除第一个以外的部分，判断列表是否为空和拼接列表。</p>

<p><code>first</code>和<code>rest</code>操作如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SList</span> <span class="n">list</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">list</span> <span class="p">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">SList</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;&lt;first&gt; must apply to a list.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">First</span><span class="p">();</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;rest&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SList</span> <span class="n">list</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">list</span> <span class="p">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">SList</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;&lt;rest&gt; must apply to a list.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">SList</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">));</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>又发现相当的重复逻辑——判断参数是否是一个合法的列表，重复代码很邪恶，所以这里把这段逻辑抽象为扩展方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="n">SList</span> <span class="nf">RetrieveSList</span><span class="p">(</span><span class="k">this</span> <span class="n">SExpression</span><span class="p">[]</span> <span class="n">expressions</span><span class="p">,</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">String</span> <span class="n">operationName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SList</span> <span class="n">list</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">expressions</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">list</span> <span class="p">=</span> <span class="p">(</span><span class="n">expressions</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">SList</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;&lt;&quot;</span> <span class="p">+</span> <span class="n">operationName</span> <span class="p">+</span> <span class="s">&quot;&gt; must apply to a list&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了这个扩展方法，接下来的列表操作就很容易实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">RetrieveSList</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="s">&quot;first&quot;</span><span class="p">).</span><span class="n">First</span><span class="p">())</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;rest&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">SList</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">RetrieveSList</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="s">&quot;rest&quot;</span><span class="p">).</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;append&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SList</span> <span class="n">list0</span> <span class="p">=</span> <span class="k">null</span><span class="p">,</span> <span class="n">list1</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="m">2</span>
</span><span class='line'>        <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">list0</span> <span class="p">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">SList</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span>
</span><span class='line'>        <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="n">list1</span> <span class="p">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="k">as</span> <span class="n">SList</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Input must be two lists&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">SList</span><span class="p">(</span><span class="n">list0</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">list1</span><span class="p">));</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'><span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;empty?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">RetrieveSList</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="s">&quot;empty?&quot;</span><span class="p">).</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>测试</h4>

<p>iScheme的内置操作完成之后，就可以测试下初步成果了。</p>

<p>首先添加基于控制台的分析/求值（Parse/Evaluation）循环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">KeepInterpretingInConsole</span><span class="p">(</span><span class="k">this</span> <span class="n">SScope</span> <span class="n">scope</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">SScope</span><span class="p">,</span> <span class="n">SObject</span><span class="p">&gt;</span> <span class="n">evaluate</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Console</span><span class="p">.</span><span class="n">ForegroundColor</span> <span class="p">=</span> <span class="n">ConsoleColor</span><span class="p">.</span><span class="n">Gray</span><span class="p">;</span>
</span><span class='line'>            <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">code</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(!</span><span class="n">String</span><span class="p">.</span><span class="n">IsNullOrWhiteSpace</span><span class="p">(</span><span class="n">code</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">()))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Console</span><span class="p">.</span><span class="n">ForegroundColor</span> <span class="p">=</span> <span class="n">ConsoleColor</span><span class="p">.</span><span class="n">Green</span><span class="p">;</span>
</span><span class='line'>                <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span> <span class="p">+</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">scope</span><span class="p">));</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Console</span><span class="p">.</span><span class="n">ForegroundColor</span> <span class="p">=</span> <span class="n">ConsoleColor</span><span class="p">.</span><span class="n">Red</span><span class="p">;</span>
</span><span class='line'>            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;&gt;&gt; &quot;</span> <span class="p">+</span> <span class="n">ex</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在<code>SExpression#Evaluate</code>中补充调用代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">override</span> <span class="n">SObject</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Int64</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">Int64</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="k">out</span> <span class="n">number</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SExpression</span> <span class="n">first</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">node</span> <span class="p">=&gt;</span> <span class="n">node</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">[</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">](</span><span class="n">arguments</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;THIS IS JUST TEMPORARY!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后在<code>Main</code>中调用该解释/求值循环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">cmdArgs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">SScope</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">)))</span>
</span><span class='line'>        <span class="c1">// 省略若干内置函数</span>
</span><span class='line'>        <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;empty?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">RetrieveSList</span><span class="p">(</span><span class="s">&quot;empty?&quot;</span><span class="p">).</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">KeepInterpretingInConsole</span><span class="p">((</span><span class="n">code</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">code</span><span class="p">.</span><span class="n">ParseAsScheme</span><span class="p">().</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行程序，输入一些简单的表达式：</p>

<p><img src="http://i.imgur.com/FEVEVGW.jpg" alt="运行结果" /></p>

<p>看样子还不错 :&ndash;)</p>

<p>接下来开始实现iScheme的执行（Evaluation）逻辑。</p>

<h3>执行逻辑</h3>

<p>iScheme的执行就是把语句（SExpression）在作用域（SScope）转化成对象（SObject）并对作用域（SScope）产生作用的过程，如下图所示。</p>

<p><img src="http://i.imgur.com/2j4ztfF.png" alt="编程语言的实质" /></p>

<p>iScheme的执行逻辑就在<code>SExpression#Evaluate</code>里面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">SExpression</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">override</span> <span class="n">SObject</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// TODO: Todo your ass.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先明确输入和输出：</p>

<ol>
<li>处理字面量（Literals）：<code>3</code>；和具名量（Named Values）：<code>x</code></li>
<li>处理<code>if</code>：<code>(if (&lt; a 3) 3 a)</code></li>
<li>处理<code>def</code>：<code>(def pi 3.14)</code></li>
<li>处理<code>begin</code>：<code>(begin (def a 3) (* a a))</code></li>
<li>处理<code>func</code>：<code>(func (x) (* x x))</code></li>
<li>处理内置函数调用：<code>(+ 1 2 3 (first (list 1 2)))</code></li>
<li>处理自定义函数调用：<code>(map (func (x) (* x x)) (list 1 2 3))</code></li>
</ol>


<p>此外，情况1和2中的<code>SExpression</code>没有子节点，可以直接读取其<code>Value</code>进行求值，余下的情况需要读取其<code>Children</code>进行求值。</p>

<p>首先处理没有子节点的情况：</p>

<h4>处理字面量和具名量</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Int64</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">Int64</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="k">out</span> <span class="n">number</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来处理带有子节点的情况：</p>

<p>首先获得当前节点的第一个节点：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">SExpression</span> <span class="n">first</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后根据该节点的<code>Value</code>决定下一步操作：</p>

<h4>处理<code>if</code></h4>

<p><code>if</code>语句的处理方法很直接——根据判断条件（condition）的值判断执行哪条语句即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;if&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SBool</span> <span class="n">condition</span> <span class="p">=</span> <span class="p">(</span><span class="n">SBool</span><span class="p">)(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">condition</span> <span class="p">?</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理<code>def</code></h4>

<p>直接定义即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;def&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Define</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Value</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理<code>begin</code></h4>

<p>遍历语句，然后返回最后一条语句的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;begin&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SObject</span> <span class="n">result</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>    <span class="k">foreach</span> <span class="p">(</span><span class="n">SExpression</span> <span class="n">statement</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="p">=</span> <span class="n">statement</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理<code>func</code></h4>

<p>利用<code>SExpression</code>构建<code>SFunction</code>，然后返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;func&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SExpression</span> <span class="n">body</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
</span><span class='line'>    <span class="n">String</span><span class="p">[]</span> <span class="n">parameters</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Children</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Value</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="n">SScope</span> <span class="n">newScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">SFunction</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">newScope</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理<code>list</code></h4>

<p>首先把<code>list</code>里的元素依次求值，然后创建<code>SList</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;list&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">SList</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理内置操作</h4>

<p>首先得到参数的表达式，然后调用对应的内置函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">[</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">](</span><span class="n">arguments</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>处理自定义函数调用</h4>

<p>自定义函数调用有两种情况：</p>

<ol>
<li>非具名函数调用：<code>((func (x) (* x x)) 3)</code></li>
<li>具名函数调用：<code>(square 3)</code></li>
</ol>


<p>调用自定义函数时应使用新的作用域，所以为<code>SFunction</code>增加<code>Update</code>方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">SFunction</span> <span class="nf">Update</span><span class="p">(</span><span class="n">SObject</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">existingArguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">FindInTop</span><span class="p">(</span><span class="n">p</span><span class="p">)).</span><span class="n">Where</span><span class="p">(</span><span class="n">obj</span> <span class="p">=&gt;</span> <span class="n">obj</span> <span class="p">!=</span> <span class="k">null</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">newArguments</span> <span class="p">=</span> <span class="n">existingArguments</span><span class="p">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">arguments</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="n">SScope</span> <span class="n">newScope</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Scope</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">SpawnScopeWith</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">,</span> <span class="n">newArguments</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">SFunction</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Body</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Parameters</span><span class="p">,</span> <span class="n">newScope</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了便于创建自定义作用域，并判断函数的参数是否被赋值，为<code>SScope</code>增加<code>SpawnScopeWith</code>和<code>FindInTop</code>方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">SScope</span> <span class="nf">SpawnScopeWith</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">names</span><span class="p">,</span> <span class="n">SObject</span><span class="p">[]</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;=</span> <span class="n">values</span><span class="p">.</span><span class="n">Length</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Too many arguments.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">SScope</span> <span class="n">scope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">Int32</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">values</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">scope</span><span class="p">.</span><span class="n">variableTable</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">scope</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">public</span> <span class="n">SObject</span> <span class="nf">FindInTop</span><span class="p">(</span><span class="n">String</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">variableTable</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">variableTable</span><span class="p">[</span><span class="n">name</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是函数调用的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SFunction</span> <span class="n">function</span> <span class="p">=</span> <span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span> <span class="p">?</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">first</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">function</span><span class="p">.</span><span class="n">Update</span><span class="p">(</span><span class="n">arguments</span><span class="p">).</span><span class="n">Evaluate</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>完整的求值代码</h4>

<p>综上所述，求值代码如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">SObject</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Int64</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">Int64</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="k">out</span> <span class="n">number</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SExpression</span> <span class="n">first</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;if&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SBool</span> <span class="n">condition</span> <span class="p">=</span> <span class="p">(</span><span class="n">SBool</span><span class="p">)(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">condition</span> <span class="p">?</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;def&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Define</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Value</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;begin&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SObject</span> <span class="n">result</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>            <span class="k">foreach</span> <span class="p">(</span><span class="n">SExpression</span> <span class="n">statement</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">result</span> <span class="p">=</span> <span class="n">statement</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;func&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SExpression</span> <span class="n">body</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
</span><span class='line'>            <span class="n">String</span><span class="p">[]</span> <span class="n">parameters</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Children</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Value</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>            <span class="n">SScope</span> <span class="n">newScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nf">SFunction</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">newScope</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;list&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">new</span> <span class="nf">SList</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">[</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">](</span><span class="n">arguments</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SFunction</span> <span class="n">function</span> <span class="p">=</span> <span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span> <span class="p">?</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">first</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">function</span><span class="p">.</span><span class="n">Update</span><span class="p">(</span><span class="n">arguments</span><span class="p">).</span><span class="n">Evaluate</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>去除尾递归</h4>

<p>到了这里iScheme解释器就算完成了。但仔细观察求值过程还是有一个很大的问题，尾递归调用：</p>

<ul>
<li>处理<code>if</code>的尾递归调用。</li>
<li>处理函数调用中的尾递归调用。</li>
</ul>


<p>Alex Stepanov曾在<a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">Elements of Programming</a>中介绍了一种将严格尾递归调用（Strict tail-recursive call）转化为迭代的方法，细节恕不赘述，以阶乘为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// Recursive factorial.</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fact</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// First tranform to tail recursive version.</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fact</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span><span class="c1">// This is a strict tail-recursive call which can be omitted</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Then transform to iterative version.</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fact</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">*=</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>应用这种方法到<code>SExpression#Evaluate</code>，得到转换后的版本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="n">SObject</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="n">SScope</span> <span class="n">scope</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SExpression</span> <span class="n">current</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Int64</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">Int64</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> <span class="k">out</span> <span class="n">number</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SExpression</span> <span class="n">first</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;if&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">SBool</span> <span class="n">condition</span> <span class="p">=</span> <span class="p">(</span><span class="n">SBool</span><span class="p">)(</span><span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'>                <span class="n">current</span> <span class="p">=</span> <span class="n">condition</span> <span class="p">?</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">:</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;def&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="n">Define</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Value</span><span class="p">,</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Evaluate</span><span class="p">(</span><span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;begin&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">SObject</span> <span class="n">result</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>                <span class="k">foreach</span> <span class="p">(</span><span class="n">SExpression</span> <span class="n">statement</span> <span class="k">in</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="p">=</span> <span class="n">statement</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;func&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">SExpression</span> <span class="n">body</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">2</span><span class="p">];</span>
</span><span class='line'>                <span class="n">String</span><span class="p">[]</span> <span class="n">parameters</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Children</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Value</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>                <span class="n">SScope</span> <span class="n">newScope</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SScope</span><span class="p">(</span><span class="n">scope</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">new</span> <span class="nf">SFunction</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">newScope</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;list&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">new</span> <span class="nf">SList</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">exp</span> <span class="p">=&gt;</span> <span class="n">exp</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)));</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">SScope</span><span class="p">.</span><span class="n">BuiltinFunctions</span><span class="p">[</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">](</span><span class="n">arguments</span><span class="p">,</span> <span class="n">scope</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">SFunction</span> <span class="n">function</span> <span class="p">=</span> <span class="n">first</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="s">&quot;(&quot;</span> <span class="p">?</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">first</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">SFunction</span><span class="p">)</span><span class="n">scope</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">arguments</span> <span class="p">=</span> <span class="n">current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="m">1</span><span class="p">).</span><span class="n">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">)).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>                <span class="n">SFunction</span> <span class="n">newFunction</span> <span class="p">=</span> <span class="n">function</span><span class="p">.</span><span class="n">Update</span><span class="p">(</span><span class="n">arguments</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">newFunction</span><span class="p">.</span><span class="n">IsPartial</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">newFunction</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">();</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">current</span> <span class="p">=</span> <span class="n">newFunction</span><span class="p">.</span><span class="n">Body</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">scope</span> <span class="p">=</span> <span class="n">newFunction</span><span class="p">.</span><span class="n">Scope</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>一些演示</h4>

<p>基本的运算</p>

<p><img src="http://i.imgur.com/3417GE2.jpg" alt="基本的运算" /></p>

<p>高阶函数</p>

<p><img src="http://i.imgur.com/47a7jhf.jpg" alt="高阶函数" /></p>

<h2>回顾</h2>

<h3>小结</h3>

<p>除去注释（貌似没有注释-_-），iScheme的解释器的实现代码一共333行——包括空行，括号等元素。</p>

<p>在这300余行代码里，实现了函数式编程语言的大部分功能：算术|逻辑|运算，嵌套作用域，顺序语句，控制语句，递归，<a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>，<a href="http://zh.wikipedia.org/wiki/%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC">部分求值</a>。</p>

<p>与我两年之前实现的Scheme方言<a href="http://www.cnblogs.com/figure9/archive/2011/07/10/2102613.html">Lucida</a>相比，iScheme除了没有字符串类型，其它功能和Lucida相同，而代码量只是前者的八分之一，编写时间是前者的十分之一（Lucida用了两天，iScheme用了一个半小时），可扩展性和易读性均秒杀前者。这说明了：</p>

<ol>
<li>代码量不能说明问题。</li>
<li>不同开发者生产效率的差别会非常巨大。</li>
<li>这两年我还是学到了一点东西的。-_&ndash;</li>
</ol>


<h3>一些设计决策</h3>

<h4>使用扩展方法提高可读性</h4>

<p>例如，通过定义<code>OrThrows</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">OrThrows</span><span class="p">(</span><span class="k">this</span> <span class="n">Boolean</span> <span class="n">condition</span><span class="p">,</span> <span class="n">String</span> <span class="n">message</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(!</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">message</span> <span class="p">??</span> <span class="s">&quot;WTF&quot;</span><span class="p">);</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>写出流畅的断言：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">).</span><span class="n">OrThrows</span><span class="p">(</span><span class="s">&quot;Value must be less than 3.&quot;</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h4>声明式编程风格</h4>

<p>以<code>Main</code>函数为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">cmdArgs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">new</span> <span class="nf">SScope</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Evaluate</span><span class="p">&lt;</span><span class="n">SNumber</span><span class="p">&gt;(</span><span class="n">scope</span><span class="p">).</span><span class="n">Sum</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="n">s</span><span class="p">)))</span>
</span><span class='line'>        <span class="c1">// Other build</span>
</span><span class='line'>        <span class="p">.</span><span class="n">BuildIn</span><span class="p">(</span><span class="s">&quot;empty?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">args</span><span class="p">.</span><span class="n">RetrieveSList</span><span class="p">(</span><span class="s">&quot;empty?&quot;</span><span class="p">).</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">KeepInterpretingInConsole</span><span class="p">((</span><span class="n">code</span><span class="p">,</span> <span class="n">scope</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">code</span><span class="p">.</span><span class="n">ParseAsIScheme</span><span class="p">().</span><span class="n">Evaluate</span><span class="p">(</span><span class="n">scope</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>非常直观，而且</p>

<ul>
<li>如果需要添加新的操作，添加写一行<code>BuildIn</code>即可。</li>
<li>如果需要使用其它语法，替换解析函数<code>ParseAsIScheme</code>即可。</li>
<li>如果需要从文件读取代码，替换执行函数<code>KeepInterpretingInConsole</code>即可。</li>
</ul>


<h3>不足</h3>

<p>当然iScheme还是有很多不足：</p>

<p>语言特性方面：</p>

<ol>
<li>缺乏实用类型：没有<code>Double</code>和<code>String</code>这两个关键类型，更不用说复合类型（Compound Type）。</li>
<li>没有IO操作，更不要说网络通信。</li>
<li>效率低下：尽管去除尾递归挽回了一点效率，但iScheme的执行效率依然惨不忍睹。</li>
<li>错误信息：错误信息基本不可读，往往出错了都不知道从哪里找起。</li>
<li>不支持延续调用（Call with current continuation，即call/cc）。</li>
<li>没有并发。</li>
<li>各种bug：比如可以定义文本量，无法重载默认操作，空括号被识别等等。</li>
</ol>


<p>设计实现方面：</p>

<ol>
<li>使用了可变（Mutable）类型。</li>
<li>没有任何注释（因为觉得没有必要 &ndash;_-）。</li>
<li>糟糕的类型系统：Lisp类语言中的数据和程序可以不分彼此，而iScheme的实现中确把数据和程序分成了<code>SObject</code>和<code>SExpression</code>，现在我依然没有找到一个融合他们的好办法。</li>
</ol>


<p>这些就留到以后慢慢处理了 &ndash;_-（TODO YOUR ASS）</p>

<h2>延伸阅读</h2>

<h3>书籍</h3>

<ol>
<li>Compilers: Priciples, Techniques and Tools Principles: <a href="http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/">http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/</a></li>
<li>Language Implementation Patterns: <a href="http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/">http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/</a></li>
<li>*The Definitive ANTLR4 Reference: <a href="http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/">http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/</a></li>
<li>Engineering a compiler: <a href="http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/">http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/</a></li>
<li>Flex &amp; Bison: <a href="http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/">http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/</a></li>
<li>*Writing Compilers and Interpreters: <a href="http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/">http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/</a></li>
<li>Elements of Programming: <a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/</a></li>
</ol>


<p>注：带*号的没有中译本。</p>

<h3>文章</h3>

<p>大多和编译前端相关，自己没时间也没能力研究后端。-_&ndash;</p>

<p>为什么编译技术很重要？看看Steve Yegge（没错，就是被王垠黑过的Google高级技术工程师）是怎么说的（需要翻墙）。</p>

<p><a href="http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html">http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html</a></p>

<p>本文重点参考的Peter Norvig的两篇文章：</p>

<ol>
<li>How to write a lisp interpreter in Python: <a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a></li>
<li>An even better lisp interpreter in Python: <a href="http://norvig.com/lispy2.html">http://norvig.com/lispy2.html</a></li>
</ol>


<p>几种简单实用的语法分析技术：</p>

<ol>
<li>LL(k) Parsing：

<ul>
<li><a href="http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/">http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/">http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></li>
</ul>
</li>
<li>Top Down Operator Precendence：<a href="http://javascript.crockford.com/tdop/tdop.html">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li>Precendence Climbing Parsing：<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a></li>
</ol>


<h2>关于本文作者</h2>

<p>曾经的Windows/.Net/C#程序员，研究生毕业后糊里糊涂变成Linux/Java开发者。所谓一入Java深似海，现在无比怀念使用C#的岁月。</p>

<p>对解释器/编译器感兴趣，现在正在自学Coursera的<a href="https://class.coursera.org/compilers-004">Compiler课程</a>。</p>

<p>欢迎来信交流技术：lunageek#gmail#com</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读书籍]]></title>
    <link href="http://zh.lucida.me/blog/on-reading-books/"/>
    <updated>2014-03-15T13:05:35-07:00</updated>
    <id>http://zh.lucida.me/blog/on-reading-books</id>
    <content type="html"><![CDATA[<h2>摘要</h2>

<p>这篇文章从如何阅读书籍出发，简单讨论了如何选择书籍、是否阅读原版和阅读数量这几个常见问题，然后自己的阅读问题进行了分析和总结。</p>

<h2>注意</h2>

<ol>
<li>“如何阅读”指“What to read”而非“How to read”，Mortimer J. Adler的<a href="http://book.douban.com/subject/1013208/">怎样阅读一本书</a>对How to read有着精彩的描述。</li>
<li>“书籍”指非小说（Non-fiction）类书籍。</li>
</ol>


<h2>目标</h2>

<p>我是一个功利主义者（<a href="http://en.wikipedia.org/wiki/Utilitarianism">Utilitarianism</a>），因此我认为阅读的目标在于为自己创造实际价值，所以：</p>

<ol>
<li>我不会因为某本书看起来很有趣就去阅读（机会成本）。</li>
<li>也不会因为很多人推荐某本书就去阅读（从众）。</li>
<li>更不会因为某本书难就去阅读（追求智商优越感）</li>
</ol>


<p>一本书值得阅读，当且仅当：</p>

<ol>
<li>它可以直接为我创造价值。</li>
<li>它可以间接为我创造价值。</li>
</ol>


<p>我的阅读目标：</p>

<blockquote><p>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。</p></blockquote>

<!-- more -->


<h2>如何选择？</h2>

<h3>专业书籍</h3>

<blockquote><p>专业知识尽可能深入。</p></blockquote>

<p>我是一个软件开发者（Software Developer），因此这里的专业书籍均和软件开发有关。</p>

<p>这里介绍我自己用的两种方法：</p>

<h4>根据引用列表</h4>

<p>从一本经典书籍出发，深度优先遍历它的引用列表，通过书评和摘要了解这些引用书籍，再根据自己的实际情况决定自己的阅读次序。</p>

<p>这里以<a href="http://book.douban.com/subject/1477390/">代码大全</a>为例（为了方便和一致性，这里使用英文书名）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Code Complete：软件构建全程最佳实践指南。
</span><span class='line'>|
</span><span class='line'>|----How to Solve it：系统解决问题。
</span><span class='line'>|
</span><span class='line'>|----Conceptual Blockbusting：跳出思维的壁垒。
</span><span class='line'>|
</span><span class='line'>|----Mythical Man Month：软件工程不能做什么。
</span><span class='line'>|
</span><span class='line'>|----Programming Pearls：极简算法手册。
</span><span class='line'>     |
</span><span class='line'>     |----The Science of Programming：编写正确的程序。
</span><span class='line'>     |
</span><span class='line'>     |----Writing Efficient Programs：编写高效的程序。
</span><span class='line'>|
</span><span class='line'>|----Pragmatic Programmer：高效程序员的实践。
</span><span class='line'>|
</span><span class='line'>|----Refactoring：如何改进自己的代码。
</span><span class='line'>|
</span><span class='line'>|----Programming on Purposes：用正确的编程模式处理问题。
</span><span class='line'>|
</span><span class='line'>|----Software Tools：用合适的抽象封装复杂度。
</span><span class='line'>     |
</span><span class='line'>     |----The Practice of Programming：极简编程风格指南。
</span><span class='line'>          |
</span><span class='line'>          |---- Writing Solid Code：减少调试的时间。
</span><span class='line'>          |
</span><span class='line'>          |---- Elements of Programming Style：极简编程风格指南。</span></code></pre></td></tr></table></div></figure>


<p>可以发现，通过<a href="http://book.douban.com/subject/1477390/">代码大全</a>一本书，经过短短两层引用联系，几乎可以找到2004年以前所有软件开发的经典书籍。事实上，我阅读的80%以上的软件开发经典书籍，都源自于<a href="http://book.douban.com/subject/1477390/">代码大全</a>的引用列表。</p>

<p>这种方法的好处：</p>

<ul>
<li>简单直接：相对于从茫茫书海里找出10本经典书籍，找1本经典书籍再从它的引用列表里面找到20本经典书籍要容易的多。</li>
<li>质量保证：靠谱书籍的引用书籍的质量一般都很高。</li>
<li>发现一些被忽视的经典：相当一部分的书籍随着时间的流逝而淡出人们的视野，但这并不代表它们本身没有价值，例如：

<ul>
<li><a href="http://book.douban.com/subject/1989284/">Programming on Purposes</a></li>
<li><a href="http://book.douban.com/subject/1815459/">Software Tools</a></li>
<li><a href="http://book.douban.com/subject/2350559/">The Science of Programming</a></li>
<li><a href="http://book.douban.com/subject/1456967/">Writing Solid Code</a></li>
<li><a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a></li>
<li>等等&hellip; 这些书或者绝版，但它们都对我的软件开发理念产生了巨大影响。</li>
</ul>
</li>
<li>形成知识体系：引用书籍彼此具有天然的联系，这使得创建知识体系更加容易。</li>
</ul>


<p>我认为这种方法适用于任何需要严肃阅读的领域：</p>

<ol>
<li>锚点：找到一本经典书籍。</li>
<li>撒网：了解该书引用列表中的书籍。</li>
<li>收网：根据自己实际需要，精读相关书籍。</li>
</ol>


<h4>根据作者</h4>

<p>这里以计算机书籍为例（以下仅代表个人口味）：</p>

<ol>
<li>Richard Stevens：善。</li>
<li>Brian Kernighan：极善。</li>
<li>Deitel Series：翔。</li>
<li>Bruce Eckel：废话连篇。</li>
<li>Jon Bentley：善。</li>
<li>Andrew S Tanenbaum：大善。</li>
<li>Jeffrey D Ullman：善。</li>
<li>P.J. Plauger：大善。</li>
<li>Robert C Martin：善。</li>
<li>Bjarne Stroustrup：善，但略神叨（神侃世界观方法论有点顶不住）。</li>
<li>Martin Fowler：善，但略唠叨。</li>
<li>Ron Jeffries：翔（好吧我是故意来黑的，尼玛连个<a href="http://devgrind.com/2007/04/25/how-to-not-solve-a-sudoku/">Sudoku</a>都解不出来写毛程序）</li>
</ol>


<p>这种方法的问题在于需要一定阅读经验，但是它非常有效——以至于不用看内容就对书的质量有七八成把握。</p>

<h3>非本专业书籍</h3>

<blockquote><p>专业周边知识尽可能精炼。</p></blockquote>

<ol>
<li>对于专业周边知识，了解关键概念及指导思想即可。</li>
<li>不需要，也没有必要对专业周边知识进行深入了解。</li>
<li>&ldquo;Know what&rdquo; is enough, &ldquo;Know how&rdquo; is expensive.</li>
</ol>


<p>以我2年前编写手机应用，学习用户体验为例：</p>

<ol>
<li>分别在现实中（身边有几个很不错的交互设计师）和线上（Quora和知乎）进行提问和搜索，得到一个书单。</li>
<li>按照下面的原则过滤书单：

<ul>
<li>去掉教科书和大部头。</li>
<li>去掉包含大量原理或论证的书籍。</li>
<li>保留结论型书籍。</li>
<li>保留指南型书籍。</li>
</ul>
</li>
<li>总结出书单，迅速的阅读并找到关键点。

<ul>
<li><a href="http://book.douban.com/subject/3323633/">给大家看的设计书</a>：CRAP原则，字体与配色。</li>
<li><a href="http://book.douban.com/subject/4606471/">设计心理学</a>：心智模型，心智摩擦，最小惊讶。</li>
<li><a href="http://book.douban.com/subject/1493316/">交互设计之路</a>：为什么需要交互，交互有哪些坑。</li>
<li><a href="http://book.douban.com/subject/4254166/">Tapworthy</a>：具有实际操作性的移动平台交互设计指南。</li>
</ul>
</li>
</ol>


<p>了解设计的人可能认为上面的书单过于初级——没错，它们都是结论型或指南型书籍，没有原理，也没有论证——但这正是对于我这样的非专业者所需要的书籍：我不需要知道这些知识是怎么来的，知道怎么用足矣。</p>

<p>此外，受价值驱动，而非兴趣——大多数情况下兴趣只是把自己脱离当前困境的接口。</p>

<h3>学习型书籍</h3>

<p>学习型书籍是一种元（Meta）方法书籍：这类书籍用于提升学习能力，换句话说，就是缩短吸收知识所需要的时间。</p>

<p>这类书籍我只读过下面的几本，效果有但不明显：</p>

<ul>
<li><a href="http://book.douban.com/subject/2345548/">学习之道</a>：冥想，体会。</li>
<li><a href="http://book.douban.com/subject/1013208/">如何阅读一本书</a>：检视阅读，主题阅读。</li>
<li><a href="http://www.scotthyoung.com/learnmorestudyless/">Learn more, study less</a>：建立知识体系及联系。</li>
</ul>


<p>需要注意的是，不要陷入到寻求最优学习方法的误区——Best is the worthest enemy of better。</p>

<h2>阅读原版？</h2>

<h3>如何在翻译版和原版做选择？</h3>

<ol>
<li>优先选择翻译版。计算机书籍这种描述精确知识的书籍更是如此。</li>
<li>此外，如果阅读中出现难以理解的问题，不要下意识的把其归咎于翻译问题——多数情况是理解问题。</li>
</ol>


<h3>为什么还有那么多人阅读原版？</h3>

<ol>
<li>因为翻译版还没出版。</li>
<li>知识的价值有其时效性。</li>
<li>逼格。</li>
</ol>


<h2>越多越好？</h2>

<p>我经常逛豆瓣，豆瓣有一个很有意思的现象就是人们喜欢去比较自己每年读书的数量，或者是截图炫耀自己读过几千本书云云。</p>

<p>我在这里酸一下：书的数量并没有什么参考价值，就好比无法用盖一栋大楼的砖数评价这栋大楼的质量；换个说法，Effort不等于Progress。</p>

<blockquote><p>关键在于读过书的质量，吸收的程度，以及创造的价值。</p></blockquote>

<p>此外，盲目追求读书的数量会带来另一个问题——浅尝辄止。本应花在专业书籍上的时间被分配到其它无关紧要的事情上，导致该学好的没学好，没必要的学了一滩但用不上。</p>

<h2>总结</h2>

<ol>
<li>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。

<ul>
<li>按照引用列表和作者深入阅读专业书籍。</li>
<li>利用结论型/指南型书籍精炼阅读专业周边书籍。</li>
<li>不断强化自己的按需学习能力。</li>
</ul>
</li>
<li>不一定非要阅读原版。</li>
<li>读书并非多多益善。</li>
<li>读书之前回答下面几个问题：

<ul>
<li>这本书能给自己带来什么改变？</li>
<li>自己是否需要这种改变？</li>
<li>如果均为Yes，继续；如果有一个No，砍掉。</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络上瘾及其解决方法]]></title>
    <link href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/"/>
    <updated>2014-03-09T10:14:28-07:00</updated>
    <id>http://zh.lucida.me/blog/on-suppressing-the-internet-addiction</id>
    <content type="html"><![CDATA[<h2>症状</h2>

<h3>起床后</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人，大概20分钟。</p>

<h3>工作中</h3>

<p>大概每隔半小时刷一下微博或论坛，点进去看两分钟再切回来。</p>

<h3>睡觉前</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人->草榴（-_-），大概30分钟。</p>

<h2>原因</h2>

<h3>智能手机带来的极其便利的信息可访问性</h3>

<p>平板和智能手机使互联网的可访问性（accessibility）提升了至少两个数量级——三年前我的NOKIA E51只能在WIFI环境下浏览简单的文字信息，而现在我的iPhone5可以无时无刻的阅读/观看互联网上几乎所有的信息，得益于4G，即便是包含大量图片甚至视频的信息也可以轻松阅读。</p>

<h3>碎片化时间不知如何处理</h3>

<p>无论是工作还是学习，都会有疲倦或无聊的时刻，大概10分钟左右。</p>

<p>微博这种碎片化信息的出现正好填补了碎片化时间。但比较恶心的是这种东西会上瘾——慢慢的它会占据越来越多的时间：清晨，睡眠甚至路上和正常阅读的时间。</p>

<h3>长时间从事同一种工作带来的无聊感</h3>

<p>无论多么有激情有兴趣，长时间从事同一种工作总会无聊的，低智力门槛的社交网络就成了一个打发时间的好选择。</p>

<p>然后时间就都耗里面了。-_&ndash;</p>

<!-- more -->


<h2>现实 V.S. 虚拟</h2>

<p>人是社会性动物，社会性动物通过与其他对象建立联系来确定自己的存在感，也就是交流（Communication），现实和虚拟中都是如此。交流包括一对一交流和一对多交流：现实中，一对一交流通过谈话/电话/信件，一对多交流通过电视/广播；虚拟中，一对一交流通过IM（Instant Messenger），一对多交流通过微博/论坛/博客。</p>

<h3>一对一交流：</h3>

<ol>
<li>现实中，一对一交流通过谈话/电话/信件，一对一交流通过IM（Instant Messenger）。</li>
<li>现实的一对一交流大多无状态——双方的交流同时开始，同时结束。虚拟的一对一交流大多有状态——双方的交流可以从某一方开始，然后若干小时后另一方看到消息回复，然后如此继续。</li>
<li>现实中的一对一交流需要考虑对方的状态——也就是交流需要建立在双方都有时间的基础上；虚拟的一对一交流无需考虑对方的状态，有意交流的一方可以随时给对方发送信息。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>任何人都可以与你交流，无论你愿意与否。</li>
<li>你可以与任何人交流，无论是否值得。</li>
<li>可能会陷入一种等待交流的焦虑中。</li>
</ol>


<h3>一对多交流：</h3>

<ol>
<li>现实的一对多交流需要大量人力物力（广播/电视/报纸），虚拟的一对多交流几乎零成本（微博/博客/社交网络）。</li>
<li>现实的一对多交流需要信息审核/证伪，虚拟的一对多交流几乎没有信息审核。</li>
<li>现实的一对多交流中接收方是完全被动的，虚拟的一对多交流接收方和广播方之间可以有交互。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>没有审核带来的大量低质量无意义信息（通常会以一种很有趣或是令人热血沸腾的形式出现）。</li>
<li><a href="http://book.douban.com/subject/1012611/">乌合之众</a>，最热门的信息不是最有价值的，而是吵的最响（或是争议最多）的。</li>
<li>与广播方（例如名人）的交流会带来成就感，也会使自己陷入等待回复的焦虑中。</li>
<li>可能会陷入一种不断查看新信息（尽管这些信息毫无意义）的焦虑中。</li>
</ol>


<h2>解决方法</h2>

<p>为此在豆瓣阅读买了一本<a href="http://book.douban.com/subject/24383461/">网络素养</a>，原版：<a href="http://www.amazon.com/Net-Smart-How-Thrive-Online/dp/0262526131/">Net Smart: How to thrive online</a>。</p>

<p><img src="http://img5.douban.com/lpic/s26842036.jpg" title="网络素养" alt="网络素养" /></p>

<p><img src="http://ecx.images-amazon.com/images/I/41LRFD-SVlL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_SX385_SY500_CR,0,0,385,500_SH20_OU02_.jpg" title="Net Smart" alt="Net Smart" /></p>

<p>这本书废话极多，关键的两点：控制注意力，鉴别垃圾信息。</p>

<h3>控制注意力</h3>

<ul>
<li>下意识的控制注意力，可以通过关注自己的呼吸来调节。</li>
<li>即便忽略几条微博几条信息，也不会对生活造成多大影响。</li>
<li>此外可以使用冥想提升自己的集中力（Focus）。</li>
<li>番茄工作法（没看明白要点，25分钟休息一次是什么原理，如果这样岂不是更不靠谱）。</li>
</ul>


<h3>鉴别垃圾信息</h3>

<ul>
<li>冷静面对夸张的标题，此类信息一般有意断章取义，或是掩盖上下文。</li>
<li>恰当的使用三点式验证争议信息：使用三个不同可信来源验证信息的有效性。</li>
<li>选取可信/有效/有价值的信息来源，屏蔽哗众取宠/断章取义的信息源。</li>
</ul>


<h3>集中时间处理社交网络</h3>

<ul>
<li>在固定的时间段（例：12:40 &ndash; 13:10, 20:20 &ndash; 21:00）处理社交网络信息，而非随时随地的查看状态。</li>
<li>如有特别需求，可以编写Crawler来发送Reminder邮件，替代人工轮询。</li>
</ul>


<h2>用不上瘾的行为填充碎片化时间</h2>

<p>碎片化时间可以进行其它益智或体育活动，包括但不限于：</p>

<ul>
<li>拆解/还原九连环。</li>
<li>单手还原魔方。</li>
<li>背诵单词。</li>
<li>绘画。</li>
<li>乒乓。</li>
<li>桌球。</li>
</ul>


<h2>尝试其它活动</h2>

<p>为了得到新鲜感，包括但不限于：</p>

<ul>
<li>学习自己感兴趣但不了解的技术（例如ANTLR）或学科（例如经济/心理学）。</li>
<li>尝试集体运动（例如攀岩，射箭）。</li>
<li>尝试旅行（例如在周末去荷兰、芬兰或瑞典进行两日游）。</li>
</ul>

]]></content>
  </entry>
  
</feed>
