
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="google-site-verification" content="xcnfIp24QN30miBMIDuuCCQF5IKPlu9_-U0785KdzLc" />
  <title>深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行） - Lucida</title>
  <meta name="author" content="Lucida">

  
  <meta name="description" content="本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。">
  <meta name="keywords" content="Programming, Java, Lambda">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Lucida" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Lucida</a></h1>
  
    <h2>Life Love Tech</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.duckduckgo.com/" method="get">
  <fieldset role="search">
    <input type="hidden" name="sites" value="zh.lucida.me" />
    <input class="search" type="text" name="q" results="0" placeholder="Search&hellip;"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">博文列表</a></li>
  <li><a href="http://en.lucida.me">English</a></li>
  <li><a href="/about">关于</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行）</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-12T22:23:36-08:00" pubdate data-updated="true">Dec 12<span>th</span>, 2014</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://zh.lucida.me">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<p>本文是深入理解Java 8 Lambda系列的第二篇，主要介绍Java 8针对新增语言特性而新增的类库（例如Streams API、Collectors和并行）。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of the Lambda: Libraries Edition</a>一文的翻译。</p>

<h2><a name="about">关于</a></h2>

<p>Java SE 8增加了新的语言特性（例如lambda表达式和默认方法），为此Java SE 8的类库也进行了很多改进，本文简要介绍了这些改进。在阅读本文前，你应该先阅读<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">深入浅出Java 8 Lambda（语言篇）</a>，以便对Java SE 8的新增特性有一个全面了解。</p>

<h2><a name="background">背景（Background）</a></h2>

<p>自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而<a href="https://jcp.org/en/jsr/detail?id=355">JSR 355</a>（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API：</p>

<!-- more -->


<ul>
<li>为现有的接口（例如<code>Collection</code>，<code>List</code>和<code>Stream</code>）增加扩展方法；</li>
<li>在类库中增加新的<em>流</em>（stream，即<code>java.util.stream.Stream</code>）抽象以便进行聚集（aggregation）操作；</li>
<li>改造现有的类型使之可以提供流视图（stream view）；</li>
<li>改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如<code>ArrayList</code>和<code>HashMap</code>（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。</li>
</ul>


<p>除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。除此之外，我们还需要在将并行变的<em>容易</em>（easier）和将并行变的<em>不可见</em>（invisible）之间做出抉择，我们选择了一个折中的路线：提供<em>显式</em>（explicit）但<em>非侵入</em>（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题）</p>

<h2><a name="interal_vs_external_iteration">内部迭代和外部迭代（Internal  vs external iteration）</a></h2>

<p>集合类库主要依赖于<em>外部迭代</em>（external iteration）。<code>Collection</code>实现<code>Iterable</code>接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Shape</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">shapes</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">shape</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子演示了外部迭代：for-each循环调用<code>shapes</code>的<code>iterator()</code>方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：</p>

<ul>
<li>Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。</li>
</ul>


<p>尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。</p>

<p>我们可以使用<em>内部迭代</em>（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。</p>

<p>下面是前例的内部迭代代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">shapes</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>

<p>外部迭代同时承担了<em>做什么</em>（把形状设为红色）和<em>怎么做</em>（得到<code>Iterator</code>实例然后依次遍历）两项职责，而内部迭代只负责<em>做什么</em>，而把<em>怎么做</em>留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。</p>

<h2><a name="stream">流（Stream）</a></h2>

<p><em>流</em>是Java SE 8类库中新增的关键抽象，它被定义于<code>java.util.stream</code>（这个包里有若干流类型：<code>Stream&lt;T&gt;</code>代表对象引用流，此外还有一系列特化（specialization）流，比如<code>IntStream</code>代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。</p>

<p>流的操作可以被组合成<em>流水线</em>（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>      <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>      <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">RED</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流视图（stream view），接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>

<p>如果我们想把蓝色的形状提取到新的<code>List</code>里，则可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                         <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                         <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>collect()</code>操作会把其接收的元素聚集（aggregate）到一起（这里是<code>List</code>），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到<code>List</code>中。（如需更多<code>collect()</code>方法的细节，请阅读<a href="#collectors">Collectors</a>一节）</p>

<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Set</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="n">hasBlueShape</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getContainingBox</span><span class="o">())</span>
</span><span class='line'>                              <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>

<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。</p>

<h2><a name="stream_vs_collection">流和集合（Streams vs Collections）</a></h2>

<p>集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同：</p>

<ul>
<li>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到；</li>
<li>天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改；</li>
<li>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；</li>
<li>无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举<a href="http://en.wikipedia.org/wiki/Perfect_number">完美数</a>这个操作可以被表达为在所有整数上进行过滤）。集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）；</li>
</ul>


<p>从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（<code>Collection</code>拥有<code>stream()</code>和<code>parallelStream()</code>方法），也可以通过流产生一个集合（使用前例的<code>collect()</code>方法）。<code>Collection</code>以外的类型也可以作为<code>stream</code>的数据源，比如JDK中的<code>BufferedReader</code>、<code>Random</code>和<code>BitSet</code>已经被改造可以用做流的数据源，<code>Arrays.stream()</code>则产生给定数组的流视图。事实上，任何可以用<code>Iterator</code>描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。</p>

<h3><a name="laziness">惰性（Laziness）</a></h3>

<p>过滤和映射这样的操作既可以被<em>急性求值</em>（以<code>filter</code>为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被<em>惰性求值</em>（用<code>Stream</code>代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</p>

<p>对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像<code>sum()</code>这样生成值的操作和<code>forEach()</code>这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。</p>

<p>以下面的流水线为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的过滤操作和映射操作是惰性的，这意味着在调用<code>sum()</code>之前，我们不会从数据源提取任何元素。在<code>sum</code>操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。</p>

<p>大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（<code>forEach</code>，<code>toArray</code>和<code>collect</code>等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让<code>filter</code>和<code>map</code>返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如<code>forEach()</code>）都是急性操作。绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。</p>

<p>在使用这种<em>数据源—惰性操作—惰性操作—急性操作</em>流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。</p>

<p>对于<code>anyMatch(Predicate)</code>和<code>findFirst()</code>这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Optional</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;</span> <span class="n">firstBlue</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>                                  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span><span class="o">()</span> <span class="o">==</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                                  <span class="o">.</span><span class="na">findFirst</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于过滤这一步是惰性的，<code>findFirst</code>在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。<code>findFirst()</code>方法返回<code>Optional</code>对象，因为集合中有可能不存在满足条件的元素。<code>Optional</code>是一种用于描述可缺失值的类型。</p>

<p>在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。</p>

<h3><a name="parallelism">并行（Parallelism）</a></h3>

<p>流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过<code>parallel()</code>方法被转化为并行流）</p>

<p>尽管并行是显式的，但它并不需要成为侵入式的。利用<code>parallelStream()</code>，我们可以轻松的把之前重量求和的代码并行化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
</span><span class='line'>                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getColor</span> <span class="o">=</span> <span class="n">BLUE</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">getWeight</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。</p>

<p>因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出<code>ConcurrentModificationException</code>）我们把这个条件称为无干扰性（non-interference）。</p>

<p>我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义：</p>

<ol>
<li>不要干扰数据源；</li>
<li>不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。</li>
</ol>


<p>只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如<code>ArrayList</code>）也是一样。</p>

<h2><a name="examples">实例（Examples）</a></h2>

<p>下面的代码源自JDK中的<code>Class</code>类型（<code>getEnclosingMethod</code>方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getEnclosingClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Class</span><span class="o">&lt;</span> <span class="o">?</span> <span class="o">&gt;[]</span> <span class="n">candidateParamClasses</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">candidateParamClasses</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">parameterClasses</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">boolean</span> <span class="n">matches</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">candidateParamClasses</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">candidateParamClasses</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">parameterClasses</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">matches</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>          <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">matches</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// finally, check return type</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">returnType</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">method</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">throw</span> <span class="k">new</span> <span class="nf">InternalError</span><span class="o">(</span><span class="s">&quot;Enclosing method not found&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用<code>Arrays.stream</code>将它转化为<code>Stream</code>，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用<code>findFirst</code>得到<code>Optional&lt;Method&gt;</code>，最后利用<code>orElseThrow</code>返回目标值或者抛出异常。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getEnclosingClass</span><span class="o">().</span><span class="na">getDeclaredMethods</span><span class="o">())</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">enclosingInfo</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">(),</span> <span class="n">parameterClasses</span><span class="o">))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">getReturnType</span><span class="o">(),</span> <span class="n">returnType</span><span class="o">))</span>
</span><span class='line'>             <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
</span><span class='line'>             <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="s">&quot;Enclosing method not found&quot;</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。</p>

<p>流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。</p>

<p>假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;</span> <span class="n">favs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Album</span> <span class="n">album</span> <span class="o">:</span> <span class="n">albums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="n">hasFavorite</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Track</span> <span class="n">track</span> <span class="o">:</span> <span class="n">album</span><span class="o">.</span><span class="na">tracks</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">track</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">hasFavorite</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">hasFavorite</span><span class="o">)</span>
</span><span class='line'>    <span class="n">favs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">album</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">favs</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Album</span> <span class="n">a1</span><span class="o">,</span> <span class="n">Album</span> <span class="n">a2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">a1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用<code>anyMatch</code>）；按名字排序；以及把满足条件的专辑放在一个<code>List</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Album</span><span class="o">&gt;</span> <span class="n">sortedFavs</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">albums</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">tracks</span><span class="o">.</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">name</span><span class="o">))</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Compartor.comparing</code>方法接收一个函数（该函数返回一个实现了<code>Comparable</code>接口的排序键值），然后返回一个利用该键值进行排序的<code>Comparator</code>（请参考下面的<a href="#comparator_factories">比较器工厂</a>一节）。</p>

<h3><a name="collectors">收集器（Collectors）</a></h3>

<p>在之前的例子中，我们利用<code>collect()</code>方法把流中的元素聚合到<code>List</code>或<code>Set</code>中。<code>collect()</code>接收一个类型为<code>Collector</code>的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。<code>Collectors</code>类包含了大量常用收集器的工厂方法，<code>toList()</code>和<code>toSet()</code>就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。</p>

<p><code>Collector</code>的类型由其输入类型和输出类型决定。以<code>toList()</code>收集器为例，它的输入类型为<code>T</code>，输出类型为<code>List&lt;T&gt;</code>，<code>toMap</code>是另外一个较为复杂的<code>Collector</code>，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。<code>toMap</code>的输入类型是<code>T</code>，输出类型是<code>Map&lt;K, V&gt;</code>，其中<code>K</code>和<code>V</code>分别是前面两个函数所生成的键类型和值类型。（复杂版本的<code>toMap</code>收集器则允许你指定目标<code>Map</code>的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Album</span><span class="o">&gt;</span> <span class="n">albumsByCatalogNumber</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">albums</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">getCatalogNumber</span><span class="o">(),</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>groupingBy</code>是一个与<code>toMap</code>相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的<code>Collector</code>：它以<code>Track</code>作为输入，以<code>Map&lt;Artist, List&lt;Track&gt;&gt;</code>作为输出。<code>groupingBy</code>收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成<code>Map</code>，该<code>Map</code>的键是分类函数的返回结果，值是该分类下的元素列表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;</span> <span class="n">favsByArtist</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的<code>groupingBy</code>收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用<em>其它</em>收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的<code>groupingBy</code>使用<code>toList()</code>作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到<code>Set</code>而非<code>List</code>中，我们可以使用<code>toSet</code>收集器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;</span> <span class="n">favsByArtist</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="o">)</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">,</span>
</span><span class='line'>                                         <span class="n">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级<code>Map</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">Artist</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Track</span><span class="o">&gt;&gt;&gt;</span> <span class="n">byArtistAndRating</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">artist</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">groupingBy</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">rating</span><span class="o">)));</span>
</span></code></pre></td></tr></table></div></figure>


<p>在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用<code>Stream.flatMap()</code>得到一个歌曲流，然后用<code>Pattern.splitAsStream</code>把每首歌曲的标题打散成词流；接下来我们用<code>groupingBy</code>和<code>String.toUpperCase</code>对这些词进行不区分大小写的分组，最后使用<code>counting()</code>收集器计算每个词出现的次数（从而无需创建中间集合）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">&quot;\\s+&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">wordFreq</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">tracks</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>          <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">pattern</span><span class="o">.</span><span class="na">splitAsStream</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">name</span><span class="o">))</span> <span class="c1">// Stream&lt;String&gt;</span>
</span><span class='line'>          <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">groupingBy</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">(),</span>
</span><span class='line'>                              <span class="n">counting</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>flatMap</code>接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的<code>flatMap</code>会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。</p>

<p><code>Collectors</code>类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义<code>Collector</code>。</p>

<h2><a name="parallelism_under_the_hood">并行的实质（Parallelism under the hood）</a></h2>

<p>Java SE 7引入了<a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Fork/Join</a>模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。</p>

<p>为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步：</p>

<ul>
<li>把问题分解为子问题；</li>
<li>串行解决子问题从而得到部分结果（partial result）；</li>
<li>合并部分结果合为最终结果。</li>
</ul>


<p>这也是Fork/Join的实现原理。</p>

<p>为了能够并行化任意流上的所有操作，我们把流抽象为<code>Spliterator</code>，<code>Spliterator</code>是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像<code>Iterator</code>允许你跳过一个元素然后保留剩下的元素，<code>Spliterator</code>允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的<code>Spliterator</code>中，而剩下的数据则会被保存在原来的<code>Spliterator</code>里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。</p>

<p>上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。</p>

<p>大多数用户无需去实现<code>Spliterator</code>接口，因为集合上的<code>stream()</code>方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现<code>Spliterator</code>接口。<code>Spliterator</code>接口的API如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Element access</span>
</span><span class='line'>  <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Decomposition</span>
</span><span class='line'>  <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">//Optional metadata</span>
</span><span class='line'>  <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
</span><span class='line'>  <span class="n">Comparator</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">getComparator</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>集合库中的基础接口<code>Collection</code>和<code>Iterable</code>都实现了正确但相对低效的<code>spliterator()</code>实现，但派生接口（例如<code>Set</code>）和具体实现类（例如<code>ArrayList</code>）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在<code>split()</code>方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。</p>

<h3><a name="encounter_order">出现顺序（Encounter order）</a></h3>

<p>多数数据结构（例如列表，数组和I/O通道）都拥有<em>自然出现顺序</em>（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如<code>HashSet</code>）则没有一个明确定义的出现顺序（这也是<code>HashSet</code>的<code>Iterator</code>实现中不保证元素出现顺序的原因）。</p>

<p>是否具有明确定义的出现顺序是<code>Spliterator</code>检查的特性之一（这个特性也被流使用）。除了少数例外（比如<code>Stream.forEach()</code>和<code>Stream.findAny()</code>），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
</span><span class='line'>                           <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Person:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
</span><span class='line'>                           <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码中名字出现的顺序必须要和流中的<code>Person</code>出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是<code>HashSet</code>，那么上面代码中名字就可以以任意顺序出现。</p>

<h2><a name="streams_lambdas_in_jdk">JDK中的流和lambda（Streams and lambdas in JDK）</a></h2>

<p><code>Stream</code>在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用<code>Stream</code>。我们为<code>Collection</code>提供了<code>stream()</code>和<code>parallelStream()</code>，以便把集合转化为流；此外数组可以通过<code>Arrays.stream()</code>被转化为流。</p>

<p>除此之外，<code>Stream</code>中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如<code>Stream.of()</code>，<code>Stream.generate</code>以及<code>IntStream.range</code>。其它的常用类型也提供了流相关的方法，例如<code>String.chars</code>，<code>BufferedReader.lines</code>，<code>Pattern.splitAsStream</code>，<code>Random.ints</code>和<code>BitSet.stream</code>。</p>

<p>最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现<code>Stream</code>至少需要一个<code>Iterator</code>，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过<code>Spliterator</code>提供一个更加高效的实现（就像JDK中所有的集合一样）。</p>

<h3><a name="comparator_factories">比较器工厂（Comparator factories）</a></h3>

<p>我们在<code>Comparator</code>接口中新增了若干用于生成比较器的实用方法：</p>

<p>静态方法<code>Comparator.comparing()</code>接收一个函数（该函数返回一个实现<code>Comparable</code>接口的比较键值），返回一个<code>Comparator</code>，它的实现十分简洁：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">U</span><span class="o">&gt;&gt;</span> <span class="n">Compartor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">comparing</span><span class="o">(</span>
</span><span class='line'>    <span class="n">Function</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">keyExtractor</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c1</span><span class="o">).</span><span class="na">compareTo</span><span class="o">(</span><span class="n">keyExtractor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">c2</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们把这种方法称为<em>高阶函数</em>——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="o">...</span>
</span><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()));</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码比“过去的代码”（一般要定义一个实现<code>Comparator</code>接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，<code>Comparator</code>拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">()).</span><span class="na">reversed</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>与之类似，默认方法<code>thenComparing</code>允许你去改进一个已有的<code>Comparator</code>：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">comparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getLastName</span><span class="o">())</span>
</span><span class='line'>                                 <span class="o">.</span><span class="na">thenComparing</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">());</span>
</span><span class='line'><span class="n">people</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a name="mutative_collection_operation">可变的集合操作（Mutative  collection operation）</a></h3>

<p>集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如<code>Collection</code>，<code>List</code>和<code>Map</code>）提供了一些新的方法，比如<code>Iterable.forEach(Consumer)</code>，<code>Collection.removeAll(Predicate)</code>，<code>List.replaceAll(UnaryOperator)</code>，<code>List.sort(Comparator)</code>和<code>Map.computeIfAbsent()</code>。除此之外，<code>ConcurrentMap</code>中的一些非原子方法（例如<code>replace</code>和<code>putIfAbsent</code>）被提升到<code>Map</code>之中。</p>

<h2><a name="summary">小结（Summary）</a></h2>

<p>引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。<code>Stream</code>抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Lucida</span></span>

      








  


<time datetime="2014-12-12T22:23:36-08:00" pubdate data-updated="true">Dec 12<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/essay/'>Essay</a>, <a class='category' href='/blog/categories/java/'>Java</a>, <a class='category' href='/blog/categories/lambda/'>Lambda</a>, <a class='category' href='/blog/categories/programming/'>Programming</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/" data-via="" data-counturl="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/lucida-pinyin-converter/" title="Previous Post: 从2000毫秒到10毫秒——Lucida拼音库的设计与实现">&laquo; 从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>关于</h1>
  <img src="http://imgur.com/nZXZVhG.png" width="128px" height="128px">
  <p>学生生涯在<a href="http://www.dlut.edu.cn" target="_blank">大工</a>和<a href="http://www.buaa.edu.cn" target="_blank">北航</a>度过；</p>
  <p>现在就职于<a href="http://www.google.co.uk/about/jobs/locations/london/" target="_blank">Google London</a>；</p>
  <p><a href="http://www.windowsphone.com/zh-cn/store/publishers?publisherId=LucSoft&amp;appId=3e4f73b2-c70e-40dd-b3b8-1d2135e9af56" target="_blank">LucSoft</a>和<a href="http://www.windowsphone.com/zh-cn/store/publishers?publisherId=IdaSoft&amp;appId=7f06890c-60d6-4ec7-880d-24a9dd24a283" target="_blank">IdaSoft</a>的创建者，其下包含<a href="http://www.windowsphone.com/zh-cn/store/app/%E4%B8%AD%E6%96%87%E6%8B%A8%E5%8F%B7%E5%8A%A9%E6%89%8B/3e4f73b2-c70e-40dd-b3b8-1d2135e9af56" target="_blank">拨号助手</a>和<a href="http://www.windowsphone.com/zh-cn/store/app/%E9%87%91%E5%BA%B8%E5%85%A8%E9%9B%86/7f06890c-60d6-4ec7-880d-24a9dd24a283" target="_blank">金庸全集</a>等热门应用；</p>
  <p><a href="http://book.douban.com/people/figure9/" target="_blank">读过的书</a>和<a href="http://book.douban.com/people/figure9/reviews" target="_blank">书评</a>；</p>  
  <p><a href="http://www.weibo.com/pegong" target="_blank">新浪微博</a>；</p>
  <p>本站所有内容均属个人观点，和本人雇主及其他团体无关。</p>
</section><section>
  <h1>最近的博文</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/java-8-lambdas-insideout-library-features/">深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行）</a>
      </li>
    
      <li class="post">
        <a href="/blog/lucida-pinyin-converter/">从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a>
      </li>
    
      <li class="post">
        <a href="/blog/lean-technical-resume/">精益技术简历之道——改善技术简历的47条原则</a>
      </li>
    
      <li class="post">
        <a href="/blog/java-8-lambdas-insideout-language-features/">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a>
      </li>
    
      <li class="post">
        <a href="/blog/top-code-offline-browser/">Top Coder算法题目浏览器</a>
      </li>
    
      <li class="post">
        <a href="/blog/sublime-text-complete-guide/">Sublime Text 全程指南</a>
      </li>
    
      <li class="post">
        <a href="/blog/design-of-design-1-horror-vacui/">设计中的设计——1. Horror Vacui</a>
      </li>
    
      <li class="post">
        <a href="/blog/after-germany-screwed-brazil/">我们都爱黑巴西——德国神虐巴西之后</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>分类</h1>
    <ul id="category-list"><li><a href='/blog/categories/algorithm'>Algorithm (2)</a></li><li><a href='/blog/categories/bullshit'>Bullshit (2)</a></li><li><a href='/blog/categories/csharp'>CSharp (1)</a></li><li><a href='/blog/categories/design'>Design (2)</a></li><li><a href='/blog/categories/essay'>Essay (22)</a></li><li><a href='/blog/categories/interpreter'>Interpreter (1)</a></li><li><a href='/blog/categories/java'>Java (2)</a></li><li><a href='/blog/categories/lambda'>Lambda (2)</a></li><li><a href='/blog/categories/learning'>Learning (3)</a></li><li><a href='/blog/categories/life'>Life (4)</a></li><li><a href='/blog/categories/movie'>Movie (1)</a></li><li><a href='/blog/categories/optimization'>Optimization (1)</a></li><li><a href='/blog/categories/programming'>Programming (12)</a></li><li><a href='/blog/categories/reading'>Reading (1)</a></li><li><a href='/blog/categories/resume'>Resume (1)</a></li><li><a href='/blog/categories/retrospection'>Retrospection (12)</a></li><li><a href='/blog/categories/sport'>Sport (2)</a></li><li><a href='/blog/categories/technology'>Technology (8)</a></li><li><a href='/blog/categories/tools'>Tools (2)</a></li></ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Lucida -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'lucida';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/';
        var disqus_url = 'http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
