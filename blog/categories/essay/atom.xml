<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Essay | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/essay/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-06-06T15:46:13-07:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计中的设计——0. Prologue]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-0-prologue/"/>
    <updated>2014-06-06T15:06:06-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-0-prologue</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<em>设计</em>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<p>此外，副标题里使用<strong>Prologue</strong>，主要是因为我接下来提到的产品（设计）大多没有中文名——为了一致，我决定在这一系列所有文章的副标题中统一使用英文。</p>

<p>最后，这一系列博文和原研哉的<a href="http://book.douban.com/subject/1336111/">設計中的設計</a>无关，尽管它们名字相同。</p>

<h2>为什么要写这个系列？</h2>

<p>作为一个码农，按理说我应该和设计绝缘——设计是美工的事情嘛，码农负责写好代码就成。事实上我之前也一直这么认为。</p>

<!-- more -->


<p>但在三年前我这个看法被动摇了——2011年是国内移动互联网井喷的一年，随着iPhone及其模仿者的大行其道，曾经的手机王者Nokia被迅速的淘汰出市场；随着手机应用开发门槛的降低（从Symbian到iOS或Android），各种手机应用喷涌而出。</p>

<p>在这段时间我编写了一些手机应用，并通过QQ群，邮件列表以及论坛等渠道直接与用户交流，在这个过程中，我悲观的发现用户的思维模式和我（开发者）的思维模式完全不同，我认为理所当然的东西他们认为不可理喻，反之亦然。</p>

<p>在那段时间里我一度绝望的认为所有的用户都是神经病、弱智或是某些代谢产物，后来在Microsoft ATC实习时结识了几个设计师朋友（<a href="http://weibo.com/u/3848053360">@Xing</a>和<a href="http://weibo.com/u/2104950751">@Yan</a>），我向他们大吐苦水，他们则非常腹黑的讲了一个笑话：</p>

<blockquote><p>丈夫驾车出门。妻子在家听广播，听到一则报道，妻子连忙拿起电话。</p>

<p>妻子：老公啊，我刚听广播上说，高速公路上有一辆车在逆行，你千万要小心。</p>

<p>老公：哪是一辆啊，我看有好几百辆车都在逆行。</p></blockquote>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/hei.png" alt="黑" /></p>

<p>被善意的黑出翔之后，我认为我不能这样一直逆行下去——于是我开始天天死皮赖脸的向他们请教：从设计的原则，到设计的书籍，再到用户的心理，我强迫自己跳出码农的思维模式，像正常人一样思考。</p>

<p>感谢他们的指导，尽管我无法成为像他们一样专业的优秀设计师，但我形成了一个大体的设计观：比如一个好设计应该是什么样子，而一个烂设计又应该是什么样子。</p>

<p>在这个设计观的指引下，接下来我编写的手机应用都获得了不错的评价（几乎全五星），在做私活时也总能做出令客户满意的产品。</p>

<h2>优秀的产品&amp;杰出的设计</h2>

<p>在朋友的推荐下，最近把《道德经》看了一遍，我认为《道德经》里面的一段文字可以套用在产品和设计上：</p>

<blockquote><p>太上，不知有之；</p>

<p>其次，亲而誉之；</p>

<p>其次，畏之；</p>

<p>其次，侮之；</p>

<p>信不足焉，有不信焉。</p>

<p>—— 《道德经》 十七章</p></blockquote>

<p>把上面的文字应用到产品和设计：</p>

<ul>
<li>优秀的设计使用户专注于产品本身，而忽略设计的存在。（例如Google（搜索引擎）和iPad）</li>
<li>不错的设计使用户感到舒适，用户会称赞它的设计。（例如iPod Classic，<a href="http://www.parrot.com/zik/uk/">Parrot Zik</a>和Amazon Kindle）</li>
<li>马虎的设计使用户感到不适，用户很难掌握产品的功能。（例如早期版本的Microsoft Office，vim编辑器和JavaScript语言）</li>
<li>糟糕的设计会毁掉一个产品，用户会把产品和产品的设计骂出翔。（例如Nokia的Symbian触屏手机和绝大多数Linux桌面系统）</li>
</ul>


<p>需要注意，我在上面列举的产品都具有强大的功能——它们有的成功，有的失败，区别就在于设计。</p>

<h2>The Inmates are Running the Asylum</h2>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/inmates_asylum.jpg" alt="The Inmates are Running the Asylum" /></p>

<p><a href="http://www.amazon.com/The-Inmates-Are-Running-Asylum/dp/0672326140/">The Inmates are Running the Asylum</a>的全名是：The Inmates Are Running the Asylum : Why High Tech Products Drive Us Crazy and How to Restore the Sanity，直译成中文是：疯子开精神病院（为什么高科技产品总让我们抓狂以及如何打破这个窘境），可能是这个书名太惊悚，所以它的中文书名被分别译为<a href="http://book.douban.com/subject/1237849/">软件创新之路</a>（第一版）和<a href="http://book.douban.com/subject/1493316/">交互设计之路</a>（第二版）。</p>

<p>在这本书中，VB的创造者Alan Cooper创造性的把所有程序员黑了一遍——让程序员创造面向用户的软件，等价于让一群疯子开精神病院——因为能成为程序员的人思维本身就不正常：</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/ynm3000.png" alt="要你命3000" /></p>

<p>这是<a href="http://movie.douban.com/subject/1307739/">达文西</a>发明的要你命3000。</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/crazy_app.jpg" alt="要你命3000000000" /></p>

<p>这是程序员发明的要你命3000000000。</p>

<p>当然这本书不只是为了黑程序员，作者花了大量篇幅解释为什么现在的产品随着科技含量的提高反而愈发不好用，并提出了<a href="http://en.wikipedia.org/wiki/Interaction_design#Goal-oriented_design">认知摩擦（Cognitive friction）</a>、<a href="http://www.slideshare.net/PublishingTechnology/dancing-bears-pubtech">跳舞的熊（Dancing bear）</a>以及逻辑人（Homo logicus）等令人耳目一新的概念。总而言之，<a href="http://en.wikipedia.org/wiki/Interaction_design">交互设计（Interaction Design）</a>对于软件开发必不可少。</p>

<p>如果你是一个想做出好产品的程序员（码农），那么这本书值得一读——它会打破你现有的观念，让你意识到优秀的产品需要设计。就像我的朋友讲的那个笑话，它会让你意识到<strong>是你在逆行，而不是你面前的几百辆车在逆行。</strong></p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三月小结（暨TARQIE——一种量化成长的方法（下））]]></title>
    <link href="http://zh.lucida.me/blog/summary-of-march-2014/"/>
    <updated>2014-04-06T15:24:33-07:00</updated>
    <id>http://zh.lucida.me/blog/summary-of-march-2014</id>
    <content type="html"><![CDATA[<h2>目标实际完成情况</h2>

<h3>Tarqie-J</h3>

<ol>
<li>目标

<ul>
<li>高效完成Q1 OKR。 &ndash;> 1.0

<ul>
<li>搞定，超出Manager和Mentor的预期。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>成功迁移124个Test。 &ndash;> 1.0

<ul>
<li>搞定，并且构建了持续测试环境。</li>
</ul>
</li>
<li>为这些Test配置一个可稳定运行的环境。 &ndash;> 0.8

<ul>
<li>基本搞定，但仍存在少量（每天1~2次）的不稳定状况。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>恬着脸皮向不同的同事请教。 &ndash;> 1.0

<ul>
<li>达成——基本每个同事都被我骚扰了一遍 &ndash;_&ndash;</li>
</ul>
</li>
<li>理解当前Test的架构和流程。 &ndash;> 1.0

<ul>
<li>重建测试框架的过程中了解</li>
</ul>
</li>
<li>阅读The Art Of Unit Test，Guice Book和GuiceBerry Manual，了解如何用Guice写良好的Test。 &ndash;> 0.7

<ul>
<li>部分完成，阅读Google Guice Book，了解了Guice运作机制。</li>
</ul>
</li>
<li>阅读Java Best Practices和Effective Java。 &ndash;> 0.8

<ul>
<li>部分完成，重新阅读了JBP，但Effective Java只看了一多半。</li>
</ul>
</li>
<li>阅读Java Performance，了解JVM。 &ndash;> 0.7

<ul>
<li>部分完成，阅读了国产的<a href="http://book.douban.com/subject/24722612/">《深入理解Java虚拟机》</a>，了解Java内存管理/回收，字节码生成等内容。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>每周与mentor交流，进行进度控制/难点求助。 &ndash;> 0.6

<ul>
<li>由于mentor结婚度蜜月所以没有达成。</li>
</ul>
</li>
<li>Test的数量不断增加。 &ndash;> 1.0

<ul>
<li>达成——事实上全部搞定。</li>
</ul>
</li>
<li>CL中review的数量持续降低。 &ndash;> 1.0

<ul>
<li>搞定，成功的从每次提交代码20余个review降至小于6个。</li>
</ul>
</li>
<li>逐步理解项目代码背后的机理。 &ndash;> 0.6

<ul>
<li>部分搞定，对项目测试框架已经相当了解了（毕竟自己重新搭建了整个框架），但对整个项目的各个模块，交互流程还是一头雾水。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.85</p>

<!-- more -->


<h3>Tarqie-L</h3>

<ol>
<li>目标

<ul>
<li>提高精力，理解Python。 &ndash;> 0.8

<ul>
<li>精力小有提高，至于Python——实现机制不太了解，但Python语法和编程风格我现在有足够自信——毕竟写了一个程序解析合法的Python然后生成同等语义的Google风格的Python，再加上身边有一个Python Readability Reviewer，说自己现在达到中级Python开发者的水准应该不为过。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>精力提高（自然醒，不赖床）。 &ndash;> 0.6

<ul>
<li>自然醒但依然赖床——-_&ndash;</li>
</ul>
</li>
<li>熟悉Python及其实现。 &ndash;> 0.8

<ul>
<li>部分搞定，见上文。</li>
</ul>
</li>
<li>理解4个开源项目的架构。 &ndash;> 1.0

<ul>
<li>搞定，见下文。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>早睡早起（11:30 PM ~ 8:30 AM）+每天运动20分钟。 &ndash;> 0.7

<ul>
<li>早睡早起没做到，运动的频率两周一次。</li>
</ul>
</li>
<li>阅读相关技术书籍（Python源码剖析，开源项目架构等）。 &ndash;> 0.6

<ul>
<li>部分完成，Python源码剖析只读了第一章，但开源项目架构每周一篇。</li>
</ul>
</li>
<li>增强学习能力（阅读《Study Less, Learn More》） &ndash;> 1.0

<ul>
<li>完成。</li>
</ul>
</li>
<li>控制手淫频率至两周一次。 &ndash;> 1.0 &ndash;_&ndash;

<ul>
<li>完成。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>早睡早起+运动不间断。 &ndash;> 0.5

<ul>
<li>搞定一半。两天运动一次。</li>
</ul>
</li>
<li>学习能力增强（+系统学习能力）。 &ndash;> 1.0

<ul>
<li>部分做到，但很难验证——不过用十天搞出了另外一个家伙搞了5个月的东西应该能说明部分问题。</li>
</ul>
</li>
<li>逐步理解Python各个部分的实现（对象，语句，元组，列表，字典，控制流，异常，自定义类型，列表理解，生成器，模块，从源码了解其机制）。 &ndash;> 1.0

<ul>
<li>没有阅读代码，但完成了一个Python Formatter——把Python代码转换成AST再转换回等语义的<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>代码。</li>
</ul>
</li>
<li>每周理解1个开源项目的架构。 &ndash;> 1.0

<ul>
<li>完成——阅读了<a href="http://aosabook.org/en/bash.html">Bash</a>, <a href="http://aosabook.org/en/selenium.html">Selenium WebDriver</a>, <a href="http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">Chrome</a>和<a href="http://aosabook.org/en/posa/parsing-xml-at-the-speed-of-light.html">puginxml</a>。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.8</p>

<h3>成就</h3>

<h4>工作</h4>

<ol>
<li>构建新的测试环境并迁移原有的测试用例。

<ul>
<li>各种神坑，Team/MailList/Group/ReadTheFuckingSource。</li>
<li>manager一度问我是否需要support——想了想还是撑下来了，还好搞定了。</li>
<li>神奇的发现自己第一次实习时做的也是migration，尼玛难道是轮回？</li>
</ul>
</li>
<li>利用业余时间构建了pyfmt——基于AST的代码格式化工具，生成符合<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>的等语义代码。

<ul>
<li>速度是公司工具的6倍到50倍不等（已验证）。</li>
<li>速度是<a href="https://github.com/hhatto/autopep8">autopep8</a>的3倍到30倍（已验证）。</li>
<li>生成的代码质量基本等同（待验证）。</li>
<li>代码量是<a href="https://github.com/hhatto/autopep8">autopep8</a>的二分之一。</li>
<li>不依赖任何第三方库。</li>
<li>不使用任何正则表达式——Never send a regex to do a parser&rsquo;s job.</li>
</ul>
</li>
</ol>


<h4>生活</h4>

<ol>
<li>重新实现了自己两年前写的Lucida。

<ul>
<li>重新设计类型系统，进行尾递归优化。然后完成<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">《90分钟实现一门编程语言——极简解释器教程》</a>，写作之余想通了之前很多迷惑的地方。</li>
<li>功能基本等同，代码量是前一版的八分之一，运行速度是前一版的270倍（倒不是这一版效率有多高，主要是前一版写的太挫了）</li>
</ul>
</li>
<li><a href="http://zh.lucida.me/blog/on-reading-books/">《如何阅读书籍》</a>和<a href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/">《网络上瘾及其解决方法》</a>两篇议论型博客。</li>
<li>完整的完成一个引体向上。</li>
</ol>


<h3>阅读列表</h3>

<ul>
<li><a href="http://book.douban.com/subject/3814402/">The Quick Python Book</a></li>
<li><a href="http://book.douban.com/subject/25710862/">Getting Started with Google Guava</a></li>
<li><a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a></li>
<li><a href="http://book.douban.com/subject/24383461/">网络素养</a></li>
<li><a href="http://book.douban.com/subject/25783654/">如何高效学习</a></li>
<li><a href="http://book.douban.com/subject/3009235/">Google Guice</a></li>
<li><a href="http://aosabook.org/en/index.html">The Architecture of Open Source Applications</a></li>
</ul>


<h3>一些体会</h3>

<ol>
<li>慢读慎写——读书不是靠页数，代码不是拼行数。</li>
<li>精益求精——严肃认真对待自己的任何一个项目/作品，每一行代码，每一个细节都应有其意义。</li>
<li>Don&rsquo;t <a href="http://en.wikipedia.org/wiki/Satisfice">satisfice</a>—— 在时间充裕的情况下，尽力寻找最优解，而不是找到一个答案就满足。</li>
<li>Have a mentor/coach——无论学习什么，身边要有一个大师级人物，不要盲目相信自学能力——坑大多都是自己挖出来的。</li>
<li>在合适的抽象层工作（Working at a proper abstraction layer），包括下面几点：

<ul>
<li>找到与目标最契合的层次：

<ul>
<li>如果层级过高就会造成性能损失和功能缺失。</li>
<li>如果层次过低就会变成重造轮子。</li>
</ul>
</li>
<li>总是在同一个层次工作——以避免上下文切换。</li>
<li>将复杂度封装到各自对应的层次——以避免进行交互——<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li>
</ul>
</li>
</ol>


<h3>发现的问题</h3>

<ol>
<li>3月目标制定的过于宏大——尽管完成度不错，但代价也很大——工作时间从每天8小时增加到10小时，到了后期的阅读时间几乎被缩减到零，接下来会相应的缩小计划目标。</li>
<li>除了工作就是学习，导致略抑郁——尽管做出的东西带来了一点成就感。总之接下来需要更多的娱乐。</li>
<li>猛然反应过来所谓的TARQIE其实就是OKR（<a href="http://en.wikipedia.org/wiki/OKR">Objective-Key-Results</a>）——所以接下来直接使用<a href="http://en.wikipedia.org/wiki/OKR">OKR</a>制定计划，更加简洁。</li>
</ol>


<h3>4月计划</h3>

<h3>OKR-J</h3>

<ul>
<li>目标

<ol>
<li>完整迁移测试到原项目中。</li>
<li>稳定+推广pyfmt。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>成功迁移124个Test到原项目。</li>
<li>将测试的不稳定性控制在每天3次以下。</li>
<li>pyfmt通过Python Readability。</li>
<li>pyfmt有10个以上的用户。</li>
<li>pyfmt从experimental进入devtools（略激进，但值得一试）。</li>
</ol>
</li>
</ul>


<h3>OKR-L</h3>

<ul>
<li>目标

<ol>
<li>正常作息，提高精力。</li>
<li>结合pyfmt，深度理解Python。</li>
<li>加深对Java &amp; JVM的理解。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>理解Python各个部分的实现，从源码了解其机制。</li>
<li>阅读并理解两个以上的开源项目架构。</li>
<li>完成<a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a>，阅读<a href="http://www.amazon.co.uk/Java-Performance-Addison-Wesley-Charlie-Hunt/dp/0137142528/">《Java Performance》</a>至50%。</li>
<li>迁移测试的同时完成<a href="http://www.amazon.co.uk/Effective-Unit-Testing-guide-developers/dp/1935182579/">Effective Unit Testing: A guide for Java developers</a>的阅读。</li>
<li>早睡<em>晚</em>起（8:40 ~ 23:50）</li>
<li>控制手淫频率至两周一次。</li>
<li>至少两天一次20分钟的运动。</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[90分钟实现一门编程语言——极简解释器教程]]></title>
    <link href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/"/>
    <updated>2014-03-23T12:08:35-07:00</updated>
    <id>http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>解释器, C#, Scheme, 函数式编程</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/</a></p>

<h2>关于</h2>

<p>本文介绍了如何使用C#实现一个简化Scheme——iScheme及其解释器。</p>

<p>如果你对下面的内容感兴趣：</p>

<ul>
<li>实现基本的词法分析，语法分析并生成抽象语法树。</li>
<li>实现嵌套作用域和函数调用。</li>
<li>解释器的基本原理。</li>
<li>以及一些C#编程技巧。</li>
</ul>


<p>那么请继续阅读。</p>

<p>如果你对以下内容感兴趣：</p>

<ul>
<li>高级的词法/语法分析技术。</li>
<li>类型推导/分析。</li>
<li>目标代码优化。</li>
</ul>


<p>本文则过于初级，你可以跳过本文，但欢迎指出本文的错误 :&ndash;)</p>

<!-- more -->


<h2>代码样例</h2>

<p>```csharp 代码示例
public static int Add(int a, int b) {</p>

<pre><code>return a + b;
</code></pre>

<p>}</p>

<blockquote><blockquote><p>Add(3, 4)
7</p>

<p>Add(5, 5)
10
```</p></blockquote></blockquote>

<p>这段代码定义了<code>Add</code>函数，接下来的<code>&gt;&gt;</code>符号表示对<code>Add(3, 4)</code>进行求值，再下一行的<code>&gt;&gt; 7</code>表示上一行的求值结果，不同的求值用换行分开。可以把这里的<code>&gt;&gt;</code>理解成控制台提示符（即Terminal中的PS）。</p>

<h2>什么是解释器</h2>

<p><img src="http://i.imgur.com/C8lxHfr.jpg" alt="解释器图示" /></p>

<p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>（Interpreter）是一种程序，能够读入程序并直接输出结果，如上图。相对于<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>（Compiler），<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>并不会生成目标机器代码，而是直接运行源程序，简单来说：</p>

<blockquote><p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>是运行程序的程序。</p></blockquote>

<p>计算器就是一个典型的解释器，我们把数学公式（源程序）给它，它通过运行它内部的"解释器"给我们答案。</p>

<p><img src="http://i.imgur.com/FC1nqko.jpg" alt="CASIO 计算器" /></p>

<h2>iScheme编程语言</h2>

<p>iScheme是什么？</p>

<ul>
<li>Scheme语言的一个极简子集。</li>
<li>虽然小，但变量，算术|比较|逻辑运算，列表，函数和递归这些编程语言元素一应俱全。</li>
<li>非常非常慢——可以说它只是为演示本文的概念而存在。</li>
</ul>


<p>OK，那么Scheme是什么？</p>

<ul>
<li>一种函数式程序设计语言。</li>
<li>一种Lisp方言。</li>
<li>麻省理工学院程序设计入门课程使用的语言（参见<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">MIT 6.001</a>和《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造与解释</a>》）。</li>
</ul>


<p><img src="http://i.imgur.com/66TdRMD.jpg" alt="计算机程序的构造与解释" /></p>

<ul>
<li>使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>（Polish Notation）。</li>
<li>更多的介绍参见<a href="http://zh.wikipedia.org/wiki/Scheme">Scheme编程语言</a>。</li>
</ul>


<p>以计算阶乘为例：</p>

<p>```csharp C#版阶乘
public static int Factorial(int n) {</p>

<pre><code>if (n == 1) {
    return 1;
} else {
    return n * Factorial(n - 1);
}
</code></pre>

<p>}
```</p>

<p>```scm iScheme版阶乘
(def factorial (lambda (n) (</p>

<pre><code>if (= n 1)
   1
   (* n (factorial (- n 1))))))
</code></pre>

<p>```</p>

<h3>数值类型</h3>

<p>由于iScheme只是一个用于演示的语言，所以目前只提供对整数的支持。iScheme使用C#的<code>Int64</code>类型作为其内部的数值表示方法。</p>

<h3>定义变量</h3>

<p><code>``scm iScheme使用</code>def`关键字定义变量</p>

<blockquote><blockquote><p>(def a 3)
3</p>

<p>a
3
```</p></blockquote></blockquote>

<h3>算术|逻辑|比较操作</h3>

<p>与常见的编程语言（C#, Java, C++, C）不同，Scheme使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>，即前缀表示法。例如：</p>

<p>```csharp C#中的算术|逻辑|比较操作
// Arithmetic ops
a + b * c
a / (b + c + d)
// Logical ops
(cond1 &amp;&amp; cond2) || cond3
// Comparing ops
a == b
1 &lt; a &amp;&amp; a &lt; 3</p>

<p>```</p>

<p><code>scm 对应的iScheme代码
; Arithmetic ops
(+ a (* b c))
(/ a (+ b c d))
; Logical ops
(or (and cond1 cond2) cond3)
; Comparing ops
(= a b)
(&lt; 1 a 3)
</code></p>

<p>需要注意的几点：</p>

<ol>
<li>iScheme中的操作符可以接受不止两个参数——这在一定程度上控制了括号的数量。</li>
<li>iScheme逻辑操作使用<code>and</code>, <code>or</code>和<code>not</code>代替了常见的<code>&amp;&amp;</code>, <code>||</code>和<code>!</code>——这在一定程度上增强了程序的可读性。</li>
</ol>


<h3>顺序语句</h3>

<p>iScheme使用<code>begin</code>关键字标识顺序语句，并以最后一条语句的值作为返回结果。以求两个数的平均值为例：</p>

<p><code>csharp C#的顺序语句
int a = 3;
int b = 5;
int c = (a + b) / 2;
</code></p>

<p>```scm iScheme的顺序语句
(def c (begin</p>

<pre><code>(def a 3)
(def b 5)
(/ (+ a b) 2)))
</code></pre>

<p>```</p>

<h3>控制流操作</h3>

<p>iScheme中的控制流操作只包含<code>if</code>。</p>

<p>```scm if语句示例</p>

<blockquote><blockquote><p>(define a (if (> 3 2) 1 2))
1</p>

<p>a
1
```</p></blockquote></blockquote>

<h3>列表类型</h3>

<p>iScheme使用<code>list</code>关键字定义列表，并提供<code>first</code>关键字获取列表的第一个元素；提供<code>rest</code>关键字获取列表除第一个元素外的元素。</p>

<p>```scm iScheme的列表示例</p>

<blockquote><blockquote><p>(define alist (list 1 2 3 4))
(list 1 2 3 4)</p>

<p>(first alist)
1</p>

<p>(rest alist)
(2 3 4)
```</p></blockquote></blockquote>

<h3>定义函数</h3>

<p>iScheme使用<code>func</code>关键字定义函数：</p>

<p>```scm iScheme的函数定义
(def square (func (x) (* x x)))</p>

<p>(def sum_square (func (a b) (+ (square a) (square b))))
```</p>

<p>```csharp 对应的C#代码
public static int Square (int x) {</p>

<pre><code>return x * x;
</code></pre>

<p>}</p>

<p>public static int SumSquare(int a, int b) {</p>

<pre><code>return Square(a) + Square(b);
</code></pre>

<p>}
```</p>

<h3>递归</h3>

<p>由于iScheme中没有<code>for</code>或<code>while</code>这种命令式语言（Imperative Programming Language）的循环结构，递归成了重复操作的唯一选择。</p>

<p>以计算最大公约数为例：</p>

<p>```scm iScheme计算最大公约数
(def gcd (func (a b)</p>

<pre><code>(if (= b 0)
    a
    (func (b (% a b))))))
</code></pre>

<p>```</p>

<p>```csharp 对应的C#代码
public static int GCD (int a, int b) {</p>

<pre><code>if (b == 0) {
    return a;
} else {
    return GCD(b, a % b);
}
</code></pre>

<p>}
```</p>

<h3>高阶函数</h3>

<p>和Scheme一样，函数在iScheme中是头等对象，这意味着：</p>

<ul>
<li>可以定义一个变量为函数。</li>
<li>函数可以接受一个函数作为参数。</li>
<li>函数返回一个函数。</li>
</ul>


<p>```scm iScheme的高阶函数示例
; Defines a multiply function.
(def mul (func (a b) (* a b)))
; Defines a list map function.
(def map (func (f alist)</p>

<pre><code>(if (empty? alist)
    (list )
    (append (list (f (first alist))) (map f (rest alist)))
    )))
</code></pre>

<p>; Doubles a list using map and mul.</p>

<blockquote><blockquote><p>(map (mul 2) (list 1 2 3))
(list 2 4 6)
```</p></blockquote></blockquote>

<h3>小结</h3>

<p>对iScheme的介绍就到这里——事实上这就是iScheme的所有元素，会不会太简单了？ &ndash;_&ndash;</p>

<p>接下来进入正题——从头开始构造iScheme的解释程序。</p>

<h2>解释器构造</h2>

<p>iScheme解释器主要分为两部分，解析（Parse）和求值（Evaluation）：</p>

<ul>
<li>解析（Parse）：解析源程序，并生成解释器可以理解的中间（Intermediate）结构。这部分包含词法分析，语法分析，语义分析，生成语法树。</li>
<li>求值（Evaluation）：执行解析阶段得到的中介结构然后得到运行结果。这部分包含作用域，类型系统设计和语法树遍历。</li>
</ul>


<h3>词法分析</h3>

<p>词法分析负责把源程序解析成一个个词法单元（Lex），以便之后的处理。</p>

<p>iScheme的词法分析极其简单——由于iScheme的词法元素只包含括号，空白，数字和变量名，因此C#自带的<code>String#Split</code>就足够。</p>

<p>```csharp iScheme的词法分析及测试
public static String[] Tokenize(String text) {</p>

<pre><code>String[] tokens = text.Replace("(", " ( ").Replace(")", " ) ").Split(" \t\r\n".ToArray(), StringSplitOptions.RemoveEmptyEntries);
return tokens;
</code></pre>

<p>}</p>

<p>// Extends String.Join for a smooth API.
public static String Join(this String separator, IEnumerable<Object> values) {</p>

<pre><code>return String.Join(separator, values);
</code></pre>

<p>}</p>

<p>// Displays the lexes in a readable form.
public static String PrettyPrint(String[] lexes) {</p>

<pre><code>return "[" + ", ".Join(lexes.Select(s =&gt; "'" + s + "'") + "]";
</code></pre>

<p>}</p>

<p>// Some tests</p>

<blockquote><blockquote><p>PrettyPrint(Tokenize(&ldquo;a&rdquo;))
[&lsquo;a&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(def a 3)&rdquo;))
[&lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(begin (def a 3) (<em> a a))&rdquo;))
[&lsquo;begin&rsquo;, &lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;, &lsquo;(&rsquo;, &lsquo;</em>&rsquo;, &lsquo;a&rsquo;, &lsquo;a&rsquo;, &lsquo;)&rsquo;, &lsquo;)&rsquo;]
```</p></blockquote></blockquote>

<h4>注意</h4>

<ul>
<li>个人不喜欢<code>String.Join</code>这个静态方法，所以这里使用C#的<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>（Extension Methods）对String类型做了一个扩展。</li>
<li>相对于LINQ Syntax，我个人更喜欢LINQ Extension Methods，接下来的代码也都会是这种风格。</li>
<li>不要以为词法分析都是这么离谱般简单！vczh的<a href="http://www.cnblogs.com/geniusvczh/p/3577561.html">词法分析教程</a>给出了一个完整编程语言的词法分析教程。</li>
</ul>


<h3>语法树生成</h3>

<p>得到了词素之后，接下来就是进行语法分析。不过由于Lisp类语言的程序即是语法树，所以语法分析可以直接跳过。</p>

<p>以下面的程序为例：</p>

<p>```scm 程序即语法树
;
(def x (if (> a 1) a 1))
; 换一个角度看的话：
(</p>

<pre><code>def
x
(
    if
    (
        &gt;
        a
        1
    )
    a
    1
)
</code></pre>

<p>)
```</p>

<p>更加直观的图片：</p>

<p><img src="http://i.imgur.com/NVolNQE.png" alt="抽象语法树" /></p>

<p>这使得<a href="http://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>（Abstract Syntax Tree）的构建变得极其简单（无需考虑操作符优先级等问题），我们使用<code>SExpression</code>类型定义iScheme的语法树（事实上<a href="http://en.wikipedia.org/wiki/S-expression">S Expression</a>也是Lisp表达式的名字）。</p>

<p>```csharp 抽象语法树的定义
public class SExpression {</p>

<pre><code>public String Value { get; private set; }
public List&lt;SExpression&gt; Children { get; private set; }
public SExpression Parent { get; private set; }

public SExpression(String value, SExpression parent) {
    this.Value = value;
    this.Children = new List&lt;SExpression&gt;();
    this.Parent = parent;
}

public override String ToString() {
    if (this.Value == "(") {
        return "(" + " ".Join(Children) + ")";
    } else {
        return this.Value;
    }
}
</code></pre>

<p>}
```</p>

<p>然后用下面的步骤构建语法树：</p>

<ol>
<li>碰到左括号，创建一个新的节点到当前节点（<code>current</code>），然后重设当前节点。</li>
<li>碰到右括号，回退到当前节点的父节点。</li>
<li>否则把为当前词素创建节点，添加到当前节点中。</li>
</ol>


<p>```csharp 抽象语法树的构建过程
public static SExpression ParseAsIScheme(this String code) {</p>

<pre><code>SExpression program = new SExpression(value: "", parent: null);
SExpression current = program;
foreach (var lex in Tokenize(code)) {
    if (lex == "(") {
        SExpression newNode = new SExpression(value: "(", parent: current);
        current.Children.Add(newNode);
        current = newNode;
    } else if (lex == ")") {
        current = current.Parent;
    } else {
        current.Children.Add(new SExpression(value: lex, parent: current));
    }
}
return program.Children[0];
</code></pre>

<p>}
```</p>

<h4>注意</h4>

<ul>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb384054.aspx">自动属性</a>（Auto Property），从而避免重复编写样版代码（Boilerplate Code）。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/dd264739.aspx">命名参数</a>（Named Parameters）提高代码可读性：<code>new SExpression(value: "", parent: null)</code>比<code>new SExpression("", null)</code>可读。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>提高代码流畅性：<code>code.Tokenize().ParseAsIScheme</code>比<code>ParseAsIScheme(Tokenize(code))</code>流畅。</li>
<li>大多数编程语言的语法分析不会这么简单！如果打算实现一个类似C#的编程语言，你需要更强大的语法分析技术：

<ul>
<li>如果打算手写语法分析器，可以参考LL(k), Precedence Climbing和Top Down Operator Precedence。</li>
<li>如果打算生成语法分析器，可以参考ANTLR或Bison。</li>
</ul>
</li>
</ul>


<h3>作用域</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>决定程序的运行环境。iScheme使用嵌套作用域。</p>

<p>以下面的程序为例</p>

<p>```scm</p>

<blockquote><blockquote><p>(def x 1)
1</p>

<p>(def y (begin (def x 2) (* x x)))
4</p>

<p>x
1
```</p></blockquote></blockquote>

<p><img src="http://i.imgur.com/TzBY0vd.jpg" alt="作用域示例" /></p>

<p>利用C#提供的<code>Dictionary&lt;TKey, TValue&gt;</code>类型，我们可以很容易的实现iScheme的作用域<code>SScope</code>：</p>

<p>```csharp iScheme的作用域实现
public class SScope {</p>

<pre><code>public SScope Parent { get; private set; }
private Dictionary&lt;String, SObject&gt; variableTable;

public SScope(SScope parent) {
    this.Parent = parent;
    this.variableTable = new Dictionary&lt;String, SObject&gt;();
}

public SObject Find(String name) {
    SScope current = this;
    while (current != null) {
        if (current.variableTable.ContainsKey(name)) {
            return current.variableTable[name];
        }
        current = current.Parent;
    }
    throw new Exception(name + " is not defined.");
}

public SObject Define(String name, SObject value) {
    this.variableTable.Add(name, value);
    return value;
}
</code></pre>

<p>}
```</p>

<h3>类型实现</h3>

<p>iScheme的类型系统极其简单——只有数值，Bool，列表和函数，考虑到他们都是iScheme里面的值对象（Value Object），为了便于对它们进行统一处理，这里为它们设置一个统一的父类型<code>SObject</code>：</p>

<p><code>csharp
public class SObject { }
</code></p>

<h4>数值类型</h4>

<p>iScheme的数值类型只是对.Net中<code>Int64</code>（即C#里的<code>long</code>）的简单封装：</p>

<p>```csharp
public class SNumber : SObject {</p>

<pre><code>private readonly Int64 value;
public SNumber(Int64 value) {
    this.value = value;
}
public override String ToString() {
    return this.value.ToString();
}
public static implicit operator Int64(SNumber number) {
    return number.value;
}
public static implicit operator SNumber(Int64 value) {
    return new SNumber(value);
}
</code></pre>

<p>}
```</p>

<p>注意这里使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p><code>csharp
SNumber foo = 30;
SNumber bar = 40;
SNumber foobar = foo * bar;
</code></p>

<p>而不必：</p>

<p><code>csharp
SNumber foo = new SNumber(value: 30);
SNumber bar = new SNumber(value: 40);
SNumber foobar = new SNumber(value: foo.Value * bar.Value);
</code></p>

<p>为了方便，这里也为SObject增加了<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>（尽管<code>Int64</code>可以被转换为<code>SNumber</code>且<code>SNumber</code>继承自<code>SObject</code>，但.Net无法直接把<code>Int64</code>转化为<code>SObject</code>）：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Int64 value) {
    return (SNumber)value;
}
</code></pre>

<p>}
```</p>

<h4>Bool类型</h4>

<p>由于Bool类型只有True和False，所以使用静态对象就足矣。</p>

<p>```csharp
public class SBool : SObject {</p>

<pre><code>public static readonly SBool False = new SBool();
public static readonly SBool True = new SBool();
public override String ToString() {
    return ((Boolean)this).ToString();
}
public static implicit operator Boolean(SBool value) {
    return value == SBool.True;
}
public static implicit operator SBool(Boolean value) {
    return value ? True : False;
}
</code></pre>

<p>}
```</p>

<p>这里同样使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p>```csharp
SBool foo = a > 1;
if (foo) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>而不用</p>

<p>```csharp
SBool foo = a > 1 ? SBool.True: SBool.False;
if (foo == SBool.True) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>同样，为<code>SObject</code>增加<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Boolean value) {
    return (SBool)value;
}
</code></pre>

<p>}
```</p>

<h4>列表类型</h4>

<p>iScheme使用.Net中的<code>IEnumberable&lt;T&gt;</code>实现列表类型<code>SList</code>：</p>

<p>```csharp
public class SList : SObject, IEnumerable<SObject> {</p>

<pre><code>private readonly IEnumerable&lt;SObject&gt; values;
public SList(IEnumerable&lt;SObject&gt; values) {
    this.values = values;
}
public override String ToString() {
    return "(list " + " ".Join(this.values) + ")";
}
public IEnumerator&lt;SObject&gt; GetEnumerator() {
    return this.values.GetEnumerator();
}
IEnumerator IEnumerable.GetEnumerator() {
    return this.values.GetEnumerator();
}
</code></pre>

<p>}
```</p>

<p>实现<code>IEnumerable&lt;SObject&gt;</code>后，就可以直接使用LINQ的一系列扩展方法，十分方便。</p>

<h4>函数类型</h4>

<p>iScheme的函数类型（<code>SFunction</code>）由三部分组成：</p>

<ul>
<li>函数体：即对应的<code>SExpression</code>。</li>
<li>参数列表。</li>
<li>作用域：函数拥有自己的作用域</li>
</ul>


<p>```csharp SFunction的实现
public class SFunction : SObject {</p>

<pre><code>public SExpression Body { get; private set; }
public String[] Parameters { get; private set; }
public SScope Scope { get; private set; }
public Boolean IsPartial {
    get {
        return this.ComputeFilledParameters().Length.InBetween(1, this.Parameters.Length);
    }
}

public SFunction(SExpression body, String[] parameters, SScope scope) {
    this.Body = body;
    this.Parameters = parameters;
    this.Scope = scope;
}

public SObject Evaluate() {
    String[] filledParameters = this.ComputeFilledParameters();
    if (filledParameters.Length &lt; Parameters.Length) {
        return this;
    } else {
        return this.Body.Evaluate(this.Scope);
    }
}

public override String ToString() {
    return String.Format("(func ({0}) {1})",
        " ".Join(this.Parameters.Select(p =&gt; {
            SObject value = null;
            if ((value = this.Scope.FindInTop(p)) != null) {
                return p + ":" + value;
            }
            return p;
        })), this.Body);
}

private String[] ComputeFilledParameters() {
    return this.Parameters.Where(p =&gt; Scope.FindInTop(p) != null).ToArray();
}
</code></pre>

<p>}
```</p>

<h5>需要注意的几点</h5>

<ul>
<li>iScheme支持部分求值（Partial Evaluation），这意味着：</li>
</ul>


<p>```scm 部分求值</p>

<blockquote><blockquote><p>(def mul (func (a b) (<em> a b)))
(func (a b) (</em> a b))</p>

<p>(mul 3 4)
12</p>

<p>(mul 3)
(func (a:3 b) (* a b))</p>

<p>((mul 3) 4)
12
```</p></blockquote></blockquote>

<p>也就是说，当<code>SFunction</code>的实际参数（Argument）数量小于其形式参数（Parameter）的数量时，它依然是一个函数，无法被求值。</p>

<p>这个功能有什么用呢？生成高阶函数。有了部分求值，我们就可以使用</p>

<p>```scm
(def mul (func (a b) (* a b)))
(def mul3 (mul 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<p>而不用专门定义一个生成函数：</p>

<p>```scm
(def times (func (n) (func (n x) (* n x)) ) )
(def mul3 (times 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<ul>
<li><code>SFunction#ToString</code>可以将其自身还原为源代码——从而大大简化了iScheme的理解和测试。</li>
</ul>


<h3>内置操作</h3>

<p>iScheme的内置操作有四种：算术|逻辑|比较|列表操作。</p>

<p>我选择了表达力（Expressiveness）强的lambda方法表来定义内置操作：</p>

<p>首先在<code>SScope</code>中添加静态字段<code>builtinFunctions</code>，以及对应的访问属性<code>BuiltinFunctions</code>和操作方法<code>BuildIn</code>。</p>

<p>```csharp
public class SScope {</p>

<pre><code>private static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; builtinFunctions =
    new Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt;();
public static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; BuiltinFunctions {
    get { return builtinFunctions; }
}
// Dirty HACK for fluent API.
public SScope BuildIn(String name, Func&lt;SExpression[], SScope, SObject&gt; builtinFuntion) {
    SScope.builtinFunctions.Add(name, builtinFuntion);
    return this;
}
</code></pre>

<p>}
```</p>

<p>注意：</p>

<ol>
<li><code>Func&lt;T1, T2, TRESULT&gt;</code>是C#提供的委托类型，表示一个接受<code>T1</code>和<code>T2</code>，返回<code>TRESULT</code></li>
<li>这里有一个小HACK，使用实例方法（Instance Method）修改静态成员（Static Member），从而实现一套流畅的API（参见<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>）。</li>
</ol>


<p>接下来就可以这样定义内置操作：</p>

<p>```csharp
new SScope(parent: null)</p>

<pre><code>.BuildIn("+", addMethod)
.BuildIn("-", subMethod)
.BuildIn("*", mulMethod)
.BuildIn("/", divMethod);
</code></pre>

<p>```</p>

<p>一目了然。</p>

<h4>断言（Assertion）扩展</h4>

<p>为了便于进行<a href="http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，我对<code>Boolean</code>类型做了一点点扩展。</p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>从而可以写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<p>而不用</p>

<p>```csharp
if (a &lt; 3) {</p>

<pre><code>    throw new Exception("Value must be less than 3.");
</code></pre>

<p>}
```</p>

<h4>算术操作</h4>

<p>iScheme算术操作包含<code>+ - * / %</code>五个操作，它们仅应用于数值类型（也就是<code>SNumber</code>）。</p>

<p>从加减法开始：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;();
return numbers.Sum(n =&gt; n);
</code></pre>

<p>})
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;().ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>注意到这里有一段重复逻辑负责转型求值（Cast then Evaluation），考虑到接下来还有不少地方要用这个逻辑，我把这段逻辑抽象成扩展方法：</p>

<p>```csharp
public static IEnumerable<T> Evaluate<T>(this IEnumerable<SExpression> expressions, SScope scope)
where T : SObject {</p>

<pre><code>return expressions.Evaluate(scope).Cast&lt;T&gt;();
</code></pre>

<p>}
public static IEnumerable<SObject> Evaluate(this IEnumerable<SExpression> expressions, SScope scope) {</p>

<pre><code>return expressions.Select(exp =&gt; exp.Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>然后加减法就可以如此定义：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => (args.Evaluate<SNumber>(scope).Sum(s => s)))
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>乘法，除法和求模定义如下：</p>

<p>```csharp
.BuildIn(&ldquo;*&rdquo;, (args, scope) => args.Evaluate<SNumber>(scope).Aggregate((a, b) => a * b))
.BuildIn(&ldquo;/&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
return firstValue / numbers.Skip(1).Aggregate((a, b) =&gt; a * b);
</code></pre>

<p>})
.BuildIn(&ldquo;%&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 2).OrThrows("Parameters count in mod should be 2");
var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
return numbers[0] % numbers[1];
</code></pre>

<p>})
```</p>

<h4>逻辑操作</h4>

<p>iScheme逻辑操作包括<code>and</code>，<code>or</code>和<code>not</code>，即与，或和非。</p>

<p>需要注意的是iScheme逻辑操作是<a href="http://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a>（Short-circuit evaluation），也就是说：</p>

<ul>
<li><code>(and condA condB)</code>，如果<code>condA</code>为假，那么整个表达式为假，无需对<code>condB</code>求值。</li>
<li><code>(or condA condB)</code>，如果<code>condA</code>为真，那么整个表达式为真，无需对<code>condB</code>求值。</li>
</ul>


<p>此外和<code>+ - * /</code>一样，<code>and</code>和<code>or</code>也可以接收任意数量的参数。</p>

<p>需求明确了接下来就是实现，iScheme的逻辑操作实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;and&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return !args.Any(arg =&gt; !(SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;or&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return args.Any(arg =&gt; (SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;not&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 1).OrThrows();
return args[0].Evaluate(scope);
</code></pre>

<p>})
```</p>

<h4>比较操作</h4>

<p>iScheme的比较操作包括<code>= &lt; &gt; &gt;= &lt;=</code>，需要注意下面几点：</p>

<ul>
<li><code>=</code>是比较操作而非赋值操作。</li>
<li>同算术操作一样，它们应用于数值类型，并支持任意数量的参数。</li>
</ul>


<p><code>=</code>的实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;=&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 1).OrThrows("Must have more than 1 argument in relation operation.");
SNumber current = (SNumber)args[0].Evaluate(scope);
foreach (var arg in args.Skip(1)) {
    SNumber next = (SNumber)arg.Evaluate(scope);
    if (current == next) {
        current = next;
    } else {
        return false;
    }
}
return true;
</code></pre>

<p>})
```</p>

<p>可以预见所有的比较操作都将使用这段逻辑，因此把这段比较逻辑抽象成一个扩展方法：</p>

<p>```csharp
public static SBool ChainRelation(this SExpression[] expressions, SScope scope, Func&lt;SNumber, SNumber, Boolean> relation) {</p>

<pre><code>(expressions.Length &gt; 1).OrThrows("Must have more than 1 parameter in relation operation.");
SNumber current = (SNumber)expressions[0].Evaluate(scope);
foreach (var obj in expressions.Skip(1)) {
    SNumber next = (SNumber)obj.Evaluate(scope);
    if (relation(current, next)) {
        current = next;
    } else {
        return SBool.False;
    }
}
return SBool.True;
</code></pre>

<p>}
```</p>

<p>接下来就可以很方便的定义比较操作：</p>

<p><code>csharp
.BuildIn("=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; (Int64)s1 == (Int64)s2))
.BuildIn("&gt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt; s2))
.BuildIn("&lt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt; s2))
.BuildIn("&gt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt;= s2))
.BuildIn("&lt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt;= s2))
</code></p>

<p>注意<code>=</code>操作的实现里面有<code>Int64</code>强制转型——因为我们没有重载<code>SNumber#Equals</code>，所以无法直接通过<code>==</code>来比较两个<code>SNumber</code>。</p>

<h4>列表操作</h4>

<p>iScheme的列表操作包括<code>first</code>，<code>rest</code>，<code>empty?</code>和<code>append</code>，分别用来取列表的第一个元素，除第一个以外的部分，判断列表是否为空和拼接列表。</p>

<p><code>first</code>和<code>rest</code>操作如下：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;first&gt; must apply to a list.");
return list.First();
</code></pre>

<p>})
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;rest&gt; must apply to a list.");
return new SList(list.Skip(1));
</code></pre>

<p>})
```</p>

<p>又发现相当的重复逻辑——判断参数是否是一个合法的列表，重复代码很邪恶，所以这里把这段逻辑抽象为扩展方法：</p>

<p>```csharp
public static SList RetrieveSList(this SExpression[] expressions, SScope scope, String operationName) {</p>

<pre><code>SList list = null;
(expressions.Length == 1 &amp;&amp; (list = (expressions[0].Evaluate(scope) as SList)) != null)
    .OrThrows("&lt;" + operationName + "&gt; must apply to a list");
return list;
</code></pre>

<p>}
```</p>

<p>有了这个扩展方法，接下来的列表操作就很容易实现：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;first&rdquo;).First())
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => new SList(args.RetrieveSList(scope, &ldquo;rest&rdquo;).Skip(1)))
.BuildIn(&ldquo;append&rdquo;, (args, scope) => {</p>

<pre><code>SList list0 = null, list1 = null;
(args.Length == 2
    &amp;&amp; (list0 = (args[0].Evaluate(scope) as SList)) != null
    &amp;&amp; (list1 = (args[1].Evaluate(scope) as SList)) != null).OrThrows("Input must be two lists");
return new SList(list0.Concat(list1));
</code></pre>

<p>})
.BuildIn(&ldquo;empty?&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;empty?&rdquo;).Count() == 0)
```</p>

<h4>测试</h4>

<p>iScheme的内置操作完成之后，就可以测试下初步成果了。</p>

<p>首先添加基于控制台的分析/求值（Parse/Evaluation）循环：</p>

<p>```csharp
public static void KeepInterpretingInConsole(this SScope scope, Func&lt;String, SScope, SObject> evaluate) {</p>

<pre><code>while (true) {
    try {
        Console.ForegroundColor = ConsoleColor.Gray;
        Console.Write("&gt;&gt; ");
        String code;
        if (!String.IsNullOrWhiteSpace(code = Console.ReadLine())) {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("&gt;&gt; " + evaluate(code, scope));
        }
    } catch (Exception ex) {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("&gt;&gt; " + ex.Message);
    }
}
</code></pre>

<p>}
```</p>

<p>然后在<code>SExpression#Evaluate</code>中补充调用代码：</p>

<p>```csharp
public override SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    }
} else {
    SExpression first = this.Children[0];
    if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    }
}
throw new Exception("THIS IS JUST TEMPORARY!");
</code></pre>

<p>}
```</p>

<p>最后在<code>Main</code>中调用该解释/求值循环：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // 省略若干内置函数
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>运行程序，输入一些简单的表达式：</p>

<p><img src="http://i.imgur.com/FEVEVGW.jpg" alt="运行结果" /></p>

<p>看样子还不错 :&ndash;)</p>

<p>接下来开始实现iScheme的执行（Evaluation）逻辑。</p>

<h3>执行逻辑</h3>

<p>iScheme的执行就是把语句（SExpression）在作用域（SScope）转化成对象（SObject）并对作用域（SScope）产生作用的过程，如下图所示。</p>

<p><img src="http://i.imgur.com/2j4ztfF.png" alt="编程语言的实质" /></p>

<p>iScheme的执行逻辑就在<code>SExpression#Evaluate</code>里面：</p>

<p>```csharp
public class SExpression {</p>

<pre><code>// ...
public override SObject Evaluate(SScope scope) {
    // TODO: Todo your ass.
}
</code></pre>

<p>}
```</p>

<p>首先明确输入和输出：</p>

<ol>
<li>处理字面量（Literals）：<code>3</code>；和具名量（Named Values）：<code>x</code></li>
<li>处理<code>if</code>：<code>(if (&lt; a 3) 3 a)</code></li>
<li>处理<code>def</code>：<code>(def pi 3.14)</code></li>
<li>处理<code>begin</code>：<code>(begin (def a 3) (* a a))</code></li>
<li>处理<code>func</code>：<code>(func (x) (* x x))</code></li>
<li>处理内置函数调用：<code>(+ 1 2 3 (first (list 1 2)))</code></li>
<li>处理自定义函数调用：<code>(map (func (x) (* x x)) (list 1 2 3))</code></li>
</ol>


<p>此外，情况1和2中的<code>SExpression</code>没有子节点，可以直接读取其<code>Value</code>进行求值，余下的情况需要读取其<code>Children</code>进行求值。</p>

<p>首先处理没有子节点的情况：</p>

<h4>处理字面量和具名量</h4>

<p>```csharp
if (this.Children.Count == 0) {</p>

<pre><code>Int64 number;
if (Int64.TryParse(this.Value, out number)) {
    return number;
} else {
    return scope.Find(this.Value);
}
</code></pre>

<p>}
```</p>

<p>接下来处理带有子节点的情况：</p>

<p>首先获得当前节点的第一个节点：</p>

<p><code>csharp
SExpression first = this.Children[0];
</code></p>

<p>然后根据该节点的<code>Value</code>决定下一步操作：</p>

<h4>处理<code>if</code></h4>

<p><code>if</code>语句的处理方法很直接——根据判断条件（condition）的值判断执行哪条语句即可：</p>

<p>```csharp
if (first.Value == &ldquo;if&rdquo;) {</p>

<pre><code>SBool condition = (SBool)(this.Children[1].Evaluate(scope));
return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
</code></pre>

<p>}
```</p>

<h4>处理<code>def</code></h4>

<p>直接定义即可：</p>

<p>```csharp
else if (first.Value == &ldquo;def&rdquo;) {</p>

<pre><code>return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
</code></pre>

<p>}
```</p>

<h4>处理<code>begin</code></h4>

<p>遍历语句，然后返回最后一条语句的值：</p>

<p>```csharp
else if (first.Value == &ldquo;begin&rdquo;) {</p>

<pre><code>SObject result = null;
foreach (SExpression statement in this.Children.Skip(1)) {
    result = statement.Evaluate(scope);
}
return result;
</code></pre>

<p>}
```</p>

<h4>处理<code>func</code></h4>

<p>利用<code>SExpression</code>构建<code>SFunction</code>，然后返回：</p>

<p>```csharp
else if (first.Value == &ldquo;func&rdquo;) {</p>

<pre><code>SExpression body = this.Children[2];
String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
SScope newScope = new SScope(scope);
return new SFunction(body, parameters, newScope);
</code></pre>

<p>}
```</p>

<h4>处理<code>list</code></h4>

<p>首先把<code>list</code>里的元素依次求值，然后创建<code>SList</code>：</p>

<p>```csharp
else if (first.Value == &ldquo;list&rdquo;) {</p>

<pre><code>return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
</code></pre>

<p>}
```</p>

<h4>处理内置操作</h4>

<p>首先得到参数的表达式，然后调用对应的内置函数：</p>

<p>```csharp
else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {</p>

<pre><code>var arguments = this.Children.Skip(1).ToArray();
return SScope.BuiltinFunctions[first.Value](arguments, scope);
</code></pre>

<p>}
```</p>

<h4>处理自定义函数调用</h4>

<p>自定义函数调用有两种情况：</p>

<ol>
<li>非具名函数调用：<code>((func (x) (* x x)) 3)</code></li>
<li>具名函数调用：<code>(square 3)</code></li>
</ol>


<p>调用自定义函数时应使用新的作用域，所以为<code>SFunction</code>增加<code>Update</code>方法：</p>

<p>```csharp
public SFunction Update(SObject[] arguments) {</p>

<pre><code>var existingArguments = this.Parameters.Select(p =&gt; this.Scope.FindInTop(p)).Where(obj =&gt; obj != null);
var newArguments = existingArguments.Concat(arguments).ToArray();
SScope newScope = this.Scope.Parent.SpawnScopeWith(this.Parameters, newArguments);
return new SFunction(this.Body, this.Parameters, newScope);
</code></pre>

<p>}
```</p>

<p>为了便于创建自定义作用域，并判断函数的参数是否被赋值，为<code>SScope</code>增加<code>SpawnScopeWith</code>和<code>FindInTop</code>方法：</p>

<p>```csharp
public SScope SpawnScopeWith(String[] names, SObject[] values) {</p>

<pre><code>(names.Length &gt;= values.Length).OrThrows("Too many arguments.");
SScope scope = new SScope(this);
for (Int32 i = 0; i &lt; values.Length; i++) {
    scope.variableTable.Add(names[i], values[i]);
}
return scope;
</code></pre>

<p>}
public SObject FindInTop(String name) {</p>

<pre><code>if (variableTable.ContainsKey(name)) {
    return variableTable[name];
}
return null;
</code></pre>

<p>}
```</p>

<p>下面是函数调用的实现：</p>

<p>```csharp
else {</p>

<pre><code>SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
return function.Update(arguments).Evaluate();
</code></pre>

<p>}
```</p>

<h4>完整的求值代码</h4>

<p>综上所述，求值代码如下</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    } else {
        return scope.Find(this.Value);
    }
} else {
    SExpression first = this.Children[0];
    if (first.Value == "if") {
        SBool condition = (SBool)(this.Children[1].Evaluate(scope));
        return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
    } else if (first.Value == "def") {
        return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
    } else if (first.Value == "begin") {
        SObject result = null;
        foreach (SExpression statement in this.Children.Skip(1)) {
            result = statement.Evaluate(scope);
        }
        return result;
    } else if (first.Value == "func") {
        SExpression body = this.Children[2];
        String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
        SScope newScope = new SScope(scope);
        return new SFunction(body, parameters, newScope);
    } else if (first.Value == "list") {
        return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
    } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    } else {
        SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
        var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
        return function.Update(arguments).Evaluate();
    }
}
</code></pre>

<p>}
```</p>

<h4>去除尾递归</h4>

<p>到了这里iScheme解释器就算完成了。但仔细观察求值过程还是有一个很大的问题，尾递归调用：</p>

<ul>
<li>处理<code>if</code>的尾递归调用。</li>
<li>处理函数调用中的尾递归调用。</li>
</ul>


<p>Alex Stepanov曾在<a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">Elements of Programming</a>中介绍了一种将严格尾递归调用（Strict tail-recursive call）转化为迭代的方法，细节恕不赘述，以阶乘为例：</p>

<p>```c
// Recursive factorial.
int fact (int n) {</p>

<pre><code>if (n == 1)
    return result;
return n * fact(n - 1);
</code></pre>

<p>}
// First tranform to tail recursive version.
int fact (int n, int result) {</p>

<pre><code>if (n == 1)
    return result;
else {
    result *= n;
    n -= 1;
    return fact(n, result);// This is a strict tail-recursive call which can be omitted
}
</code></pre>

<p>}
// Then transform to iterative version.
int fact (int n, int result) {</p>

<pre><code>while (true) {
    if (n == 1)
        return result;
    else {
        result *= n;
        n -= 1;
    }
}
</code></pre>

<p>}
```</p>

<p>应用这种方法到<code>SExpression#Evaluate</code>，得到转换后的版本：</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>SExpression current = this;
while (true) {
    if (current.Children.Count == 0) {
        Int64 number;
        if (Int64.TryParse(current.Value, out number)) {
            return number;
        } else {
            return scope.Find(current.Value);
        }
    } else {
        SExpression first = current.Children[0];
        if (first.Value == "if") {
            SBool condition = (SBool)(current.Children[1].Evaluate(scope));
            current = condition ? current.Children[2] : current.Children[3];
        } else if (first.Value == "def") {
            return scope.Define(current.Children[1].Value, current.Children[2].Evaluate(new SScope(scope)));
        } else if (first.Value == "begin") {
            SObject result = null;
            foreach (SExpression statement in current.Children.Skip(1)) {
                result = statement.Evaluate(scope);
            }
            return result;
        } else if (first.Value == "func") {
            SExpression body = current.Children[2];
            String[] parameters = current.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
            SScope newScope = new SScope(scope);
            return new SFunction(body, parameters, newScope);
        } else if (first.Value == "list") {
            return new SList(current.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
        } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
            var arguments = current.Children.Skip(1).ToArray();
            return SScope.BuiltinFunctions[first.Value](arguments, scope);
        } else {
            SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
            var arguments = current.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
            SFunction newFunction = function.Update(arguments);
            if (newFunction.IsPartial) {
                return newFunction.Evaluate();
            } else {
                current = newFunction.Body;
                scope = newFunction.Scope;
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h4>一些演示</h4>

<p>基本的运算</p>

<p><img src="http://i.imgur.com/3417GE2.jpg" alt="基本的运算" /></p>

<p>高阶函数</p>

<p><img src="http://i.imgur.com/47a7jhf.jpg" alt="高阶函数" /></p>

<h2>回顾</h2>

<h3>小结</h3>

<p>除去注释（貌似没有注释-_-），iScheme的解释器的实现代码一共333行——包括空行，括号等元素。</p>

<p>在这300余行代码里，实现了函数式编程语言的大部分功能：算术|逻辑|运算，嵌套作用域，顺序语句，控制语句，递归，<a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>，<a href="http://zh.wikipedia.org/wiki/%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC">部分求值</a>。</p>

<p>与我两年之前实现的Scheme方言<a href="http://www.cnblogs.com/figure9/archive/2011/07/10/2102613.html">Lucida</a>相比，iScheme除了没有字符串类型，其它功能和Lucida相同，而代码量只是前者的八分之一，编写时间是前者的十分之一（Lucida用了两天，iScheme用了一个半小时），可扩展性和易读性均秒杀前者。这说明了：</p>

<ol>
<li>代码量不能说明问题。</li>
<li>不同开发者生产效率的差别会非常巨大。</li>
<li>这两年我还是学到了一点东西的。-_&ndash;</li>
</ol>


<h3>一些设计决策</h3>

<h4>使用扩展方法提高可读性</h4>

<p>例如，通过定义<code>OrThrows</code></p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<h4>声明式编程风格</h4>

<p>以<code>Main</code>函数为例：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // Other build
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsIScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>非常直观，而且</p>

<ul>
<li>如果需要添加新的操作，添加写一行<code>BuildIn</code>即可。</li>
<li>如果需要使用其它语法，替换解析函数<code>ParseAsIScheme</code>即可。</li>
<li>如果需要从文件读取代码，替换执行函数<code>KeepInterpretingInConsole</code>即可。</li>
</ul>


<h3>不足</h3>

<p>当然iScheme还是有很多不足：</p>

<p>语言特性方面：</p>

<ol>
<li>缺乏实用类型：没有<code>Double</code>和<code>String</code>这两个关键类型，更不用说复合类型（Compound Type）。</li>
<li>没有IO操作，更不要说网络通信。</li>
<li>效率低下：尽管去除尾递归挽回了一点效率，但iScheme的执行效率依然惨不忍睹。</li>
<li>错误信息：错误信息基本不可读，往往出错了都不知道从哪里找起。</li>
<li>不支持延续调用（Call with current continuation，即call/cc）。</li>
<li>没有并发。</li>
<li>各种bug：比如可以定义文本量，无法重载默认操作，空括号被识别等等。</li>
</ol>


<p>设计实现方面：</p>

<ol>
<li>使用了可变（Mutable）类型。</li>
<li>没有任何注释（因为觉得没有必要 &ndash;_-）。</li>
<li>糟糕的类型系统：Lisp类语言中的数据和程序可以不分彼此，而iScheme的实现中确把数据和程序分成了<code>SObject</code>和<code>SExpression</code>，现在我依然没有找到一个融合他们的好办法。</li>
</ol>


<p>这些就留到以后慢慢处理了 &ndash;_-（TODO YOUR ASS）</p>

<h2>延伸阅读</h2>

<h3>书籍</h3>

<ol>
<li>Compilers: Priciples, Techniques and Tools Principles: <a href="http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/">http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/</a></li>
<li>Language Implementation Patterns: <a href="http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/">http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/</a></li>
<li>*The Definitive ANTLR4 Reference: <a href="http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/">http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/</a></li>
<li>Engineering a compiler: <a href="http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/">http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/</a></li>
<li>Flex &amp; Bison: <a href="http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/">http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/</a></li>
<li>*Writing Compilers and Interpreters: <a href="http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/">http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/</a></li>
<li>Elements of Programming: <a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/</a></li>
</ol>


<p>注：带*号的没有中译本。</p>

<h3>文章</h3>

<p>大多和编译前端相关，自己没时间也没能力研究后端。-_&ndash;</p>

<p>为什么编译技术很重要？看看Steve Yegge（没错，就是被王垠黑过的Google高级技术工程师）是怎么说的（需要翻墙）。</p>

<p><a href="http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html">http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html</a></p>

<p>本文重点参考的Peter Norvig的两篇文章：</p>

<ol>
<li>How to write a lisp interpreter in Python: <a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a></li>
<li>An even better lisp interpreter in Python: <a href="http://norvig.com/lispy2.html">http://norvig.com/lispy2.html</a></li>
</ol>


<p>几种简单实用的语法分析技术：</p>

<ol>
<li>LL(k) Parsing：

<ul>
<li><a href="http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/">http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/">http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></li>
</ul>
</li>
<li>Top Down Operator Precendence：<a href="http://javascript.crockford.com/tdop/tdop.html">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li>Precendence Climbing Parsing：<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a></li>
</ol>


<h2>关于本文作者</h2>

<p>曾经的Windows/.Net/C#程序员，研究生毕业后糊里糊涂变成Linux/Java开发者。所谓一入Java深似海，现在无比怀念使用C#的岁月。</p>

<p>对解释器/编译器感兴趣，现在正在自学Coursera的<a href="https://class.coursera.org/compilers-004">Compiler课程</a>。</p>

<p>欢迎来信交流技术：lunageek#gmail#com</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读书籍]]></title>
    <link href="http://zh.lucida.me/blog/on-reading-books/"/>
    <updated>2014-03-15T13:05:35-07:00</updated>
    <id>http://zh.lucida.me/blog/on-reading-books</id>
    <content type="html"><![CDATA[<h2>摘要</h2>

<p>这篇文章从如何阅读书籍出发，简单讨论了如何选择书籍、是否阅读原版和阅读数量这几个常见问题，然后自己的阅读问题进行了分析和总结。</p>

<h2>注意</h2>

<ol>
<li>“如何阅读”指“What to read”而非“How to read”，Mortimer J. Adler的<a href="http://book.douban.com/subject/1013208/">怎样阅读一本书</a>对How to read有着精彩的描述。</li>
<li>“书籍”指非小说（Non-fiction）类书籍。</li>
</ol>


<h2>目标</h2>

<p>我是一个功利主义者（<a href="http://en.wikipedia.org/wiki/Utilitarianism">Utilitarianism</a>），因此我认为阅读的目标在于为自己创造实际价值，所以：</p>

<ol>
<li>我不会因为某本书看起来很有趣就去阅读（机会成本）。</li>
<li>也不会因为很多人推荐某本书就去阅读（从众）。</li>
<li>更不会因为某本书难就去阅读（追求智商优越感）</li>
</ol>


<p>一本书值得阅读，当且仅当：</p>

<ol>
<li>它可以直接为我创造价值。</li>
<li>它可以间接为我创造价值。</li>
</ol>


<p>我的阅读目标：</p>

<blockquote><p>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。</p></blockquote>

<!-- more -->


<h2>如何选择？</h2>

<h3>专业书籍</h3>

<blockquote><p>专业知识尽可能深入。</p></blockquote>

<p>我是一个软件开发者（Software Developer），因此这里的专业书籍均和软件开发有关。</p>

<p>这里介绍我自己用的两种方法：</p>

<h4>根据引用列表</h4>

<p>从一本经典书籍出发，深度优先遍历它的引用列表，通过书评和摘要了解这些引用书籍，再根据自己的实际情况决定自己的阅读次序。</p>

<p>这里以<a href="http://book.douban.com/subject/1477390/">代码大全</a>为例（为了方便和一致性，这里使用英文书名）：</p>

<p>```
Code Complete：软件构建全程最佳实践指南。
|
|&mdash;&mdash;How to Solve it：系统解决问题。
|
|&mdash;&mdash;Conceptual Blockbusting：跳出思维的壁垒。
|
|&mdash;&mdash;Mythical Man Month：软件工程不能做什么。
|
|&mdash;&mdash;Programming Pearls：极简算法手册。</p>

<pre><code> |
 |----The Science of Programming：编写正确的程序。
 |
 |----Writing Efficient Programs：编写高效的程序。
</code></pre>

<p>|
|&mdash;&mdash;Pragmatic Programmer：高效程序员的实践。
|
|&mdash;&mdash;Refactoring：如何改进自己的代码。
|
|&mdash;&mdash;Programming on Purposes：用正确的编程模式处理问题。
|
|&mdash;&mdash;Software Tools：用合适的抽象封装复杂度。</p>

<pre><code> |
 |----The Practice of Programming：极简编程风格指南。
      |
      |---- Writing Solid Code：减少调试的时间。
      |
      |---- Elements of Programming Style：极简编程风格指南。
</code></pre>

<p>```</p>

<p>可以发现，通过<a href="http://book.douban.com/subject/1477390/">代码大全</a>一本书，经过短短两层引用联系，几乎可以找到2004年以前所有软件开发的经典书籍。事实上，我阅读的80%以上的软件开发经典书籍，都源自于<a href="http://book.douban.com/subject/1477390/">代码大全</a>的引用列表。</p>

<p>这种方法的好处：</p>

<ul>
<li>简单直接：相对于从茫茫书海里找出10本经典书籍，找1本经典书籍再从它的引用列表里面找到20本经典书籍要容易的多。</li>
<li>质量保证：靠谱书籍的引用书籍的质量一般都很高。</li>
<li>发现一些被忽视的经典：相当一部分的书籍随着时间的流逝而淡出人们的视野，但这并不代表它们本身没有价值，例如：

<ul>
<li><a href="http://book.douban.com/subject/1989284/">Programming on Purposes</a></li>
<li><a href="http://book.douban.com/subject/1815459/">Software Tools</a></li>
<li><a href="http://book.douban.com/subject/2350559/">The Science of Programming</a></li>
<li><a href="http://book.douban.com/subject/1456967/">Writing Solid Code</a></li>
<li><a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a></li>
<li>等等&hellip; 这些书或者绝版，但它们都对我的软件开发理念产生了巨大影响。</li>
</ul>
</li>
<li>形成知识体系：引用书籍彼此具有天然的联系，这使得创建知识体系更加容易。</li>
</ul>


<p>我认为这种方法适用于任何需要严肃阅读的领域：</p>

<ol>
<li>锚点：找到一本经典书籍。</li>
<li>撒网：了解该书引用列表中的书籍。</li>
<li>收网：根据自己实际需要，精读相关书籍。</li>
</ol>


<h4>根据作者</h4>

<p>这里以计算机书籍为例（以下仅代表个人口味）：</p>

<ol>
<li>Richard Stevens：善。</li>
<li>Brian Kernighan：极善。</li>
<li>Deitel Series：翔。</li>
<li>Bruce Eckel：废话连篇。</li>
<li>Jon Bentley：善。</li>
<li>Andrew S Tanenbaum：大善。</li>
<li>Jeffrey D Ullman：善。</li>
<li>P.J. Plauger：大善。</li>
<li>Robert C Martin：善。</li>
<li>Bjarne Stroustrup：善，但略神叨（神侃世界观方法论有点顶不住）。</li>
<li>Martin Fowler：善，但略唠叨。</li>
<li>Ron Jeffries：翔（好吧我是故意来黑的，尼玛连个<a href="http://devgrind.com/2007/04/25/how-to-not-solve-a-sudoku/">Sudoku</a>都解不出来写毛程序）</li>
</ol>


<p>这种方法的问题在于需要一定阅读经验，但是它非常有效——以至于不用看内容就对书的质量有七八成把握。</p>

<h3>非本专业书籍</h3>

<blockquote><p>专业周边知识尽可能精炼。</p></blockquote>

<ol>
<li>对于专业周边知识，了解关键概念及指导思想即可。</li>
<li>不需要，也没有必要对专业周边知识进行深入了解。</li>
<li>&ldquo;Know what&rdquo; is enough, &ldquo;Know how&rdquo; is expensive.</li>
</ol>


<p>以我2年前编写手机应用，学习用户体验为例：</p>

<ol>
<li>分别在现实中（身边有几个很不错的交互设计师）和线上（Quora和知乎）进行提问和搜索，得到一个书单。</li>
<li>按照下面的原则过滤书单：

<ul>
<li>去掉教科书和大部头。</li>
<li>去掉包含大量原理或论证的书籍。</li>
<li>保留结论型书籍。</li>
<li>保留指南型书籍。</li>
</ul>
</li>
<li>总结出书单，迅速的阅读并找到关键点。

<ul>
<li><a href="http://book.douban.com/subject/3323633/">给大家看的设计书</a>：CRAP原则，字体与配色。</li>
<li><a href="http://book.douban.com/subject/4606471/">设计心理学</a>：心智模型，心智摩擦，最小惊讶。</li>
<li><a href="http://book.douban.com/subject/1493316/">交互设计之路</a>：为什么需要交互，交互有哪些坑。</li>
<li><a href="http://book.douban.com/subject/4254166/">Tapworthy</a>：具有实际操作性的移动平台交互设计指南。</li>
</ul>
</li>
</ol>


<p>了解设计的人可能认为上面的书单过于初级——没错，它们都是结论型或指南型书籍，没有原理，也没有论证——但这正是对于我这样的非专业者所需要的书籍：我不需要知道这些知识是怎么来的，知道怎么用足矣。</p>

<p>此外，受价值驱动，而非兴趣——大多数情况下兴趣只是把自己脱离当前困境的接口。</p>

<h3>学习型书籍</h3>

<p>学习型书籍是一种元（Meta）方法书籍：这类书籍用于提升学习能力，换句话说，就是缩短吸收知识所需要的时间。</p>

<p>这类书籍我只读过下面的几本，效果有但不明显：</p>

<ul>
<li><a href="http://book.douban.com/subject/2345548/">学习之道</a>：冥想，体会。</li>
<li><a href="http://book.douban.com/subject/1013208/">如何阅读一本书</a>：检视阅读，主题阅读。</li>
<li><a href="http://www.scotthyoung.com/learnmorestudyless/">Learn more, study less</a>：建立知识体系及联系。</li>
</ul>


<p>需要注意的是，不要陷入到寻求最优学习方法的误区——Best is the worthest enemy of better。</p>

<h2>阅读原版？</h2>

<h3>如何在翻译版和原版做选择？</h3>

<ol>
<li>优先选择翻译版。计算机书籍这种描述精确知识的书籍更是如此。</li>
<li>此外，如果阅读中出现难以理解的问题，不要下意识的把其归咎于翻译问题——多数情况是理解问题。</li>
</ol>


<h3>为什么还有那么多人阅读原版？</h3>

<ol>
<li>因为翻译版还没出版。</li>
<li>知识的价值有其时效性。</li>
<li>逼格。</li>
</ol>


<h2>越多越好？</h2>

<p>我经常逛豆瓣，豆瓣有一个很有意思的现象就是人们喜欢去比较自己每年读书的数量，或者是截图炫耀自己读过几千本书云云。</p>

<p>我在这里酸一下：书的数量并没有什么参考价值，就好比无法用盖一栋大楼的砖数评价这栋大楼的质量；换个说法，Effort不等于Progress。</p>

<blockquote><p>关键在于读过书的质量，吸收的程度，以及创造的价值。</p></blockquote>

<p>此外，盲目追求读书的数量会带来另一个问题——浅尝辄止。本应花在专业书籍上的时间被分配到其它无关紧要的事情上，导致该学好的没学好，没必要的学了一滩但用不上。</p>

<h2>总结</h2>

<ol>
<li>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。

<ul>
<li>按照引用列表和作者深入阅读专业书籍。</li>
<li>利用结论型/指南型书籍精炼阅读专业周边书籍。</li>
<li>不断强化自己的按需学习能力。</li>
</ul>
</li>
<li>不一定非要阅读原版。</li>
<li>读书并非多多益善。</li>
<li>读书之前回答下面几个问题：

<ul>
<li>这本书能给自己带来什么改变？</li>
<li>自己是否需要这种改变？</li>
<li>如果均为Yes，继续；如果有一个No，砍掉。</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络上瘾及其解决方法]]></title>
    <link href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/"/>
    <updated>2014-03-09T10:14:28-07:00</updated>
    <id>http://zh.lucida.me/blog/on-suppressing-the-internet-addiction</id>
    <content type="html"><![CDATA[<h2>症状</h2>

<h3>起床后</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人，大概20分钟。</p>

<h3>工作中</h3>

<p>大概每隔半小时刷一下微博或论坛，点进去看两分钟再切回来。</p>

<h3>睡觉前</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人->草榴（-_-），大概30分钟。</p>

<h2>原因</h2>

<h3>智能手机带来的极其便利的信息可访问性</h3>

<p>平板和智能手机使互联网的可访问性（accessibility）提升了至少两个数量级——三年前我的NOKIA E51只能在WIFI环境下浏览简单的文字信息，而现在我的iPhone5可以无时无刻的阅读/观看互联网上几乎所有的信息，得益于4G，即便是包含大量图片甚至视频的信息也可以轻松阅读。</p>

<h3>碎片化时间不知如何处理</h3>

<p>无论是工作还是学习，都会有疲倦或无聊的时刻，大概10分钟左右。</p>

<p>微博这种碎片化信息的出现正好填补了碎片化时间。但比较恶心的是这种东西会上瘾——慢慢的它会占据越来越多的时间：清晨，睡眠甚至路上和正常阅读的时间。</p>

<h3>长时间从事同一种工作带来的无聊感</h3>

<p>无论多么有激情有兴趣，长时间从事同一种工作总会无聊的，低智力门槛的社交网络就成了一个打发时间的好选择。</p>

<p>然后时间就都耗里面了。-_&ndash;</p>

<!-- more -->


<h2>现实 V.S. 虚拟</h2>

<p>人是社会性动物，社会性动物通过与其他对象建立联系来确定自己的存在感，也就是交流（Communication），现实和虚拟中都是如此。交流包括一对一交流和一对多交流：现实中，一对一交流通过谈话/电话/信件，一对多交流通过电视/广播；虚拟中，一对一交流通过IM（Instant Messenger），一对多交流通过微博/论坛/博客。</p>

<h3>一对一交流：</h3>

<ol>
<li>现实中，一对一交流通过谈话/电话/信件，一对一交流通过IM（Instant Messenger）。</li>
<li>现实的一对一交流大多无状态——双方的交流同时开始，同时结束。虚拟的一对一交流大多有状态——双方的交流可以从某一方开始，然后若干小时后另一方看到消息回复，然后如此继续。</li>
<li>现实中的一对一交流需要考虑对方的状态——也就是交流需要建立在双方都有时间的基础上；虚拟的一对一交流无需考虑对方的状态，有意交流的一方可以随时给对方发送信息。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>任何人都可以与你交流，无论你愿意与否。</li>
<li>你可以与任何人交流，无论是否值得。</li>
<li>可能会陷入一种等待交流的焦虑中。</li>
</ol>


<h3>一对多交流：</h3>

<ol>
<li>现实的一对多交流需要大量人力物力（广播/电视/报纸），虚拟的一对多交流几乎零成本（微博/博客/社交网络）。</li>
<li>现实的一对多交流需要信息审核/证伪，虚拟的一对多交流几乎没有信息审核。</li>
<li>现实的一对多交流中接收方是完全被动的，虚拟的一对多交流接收方和广播方之间可以有交互。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>没有审核带来的大量低质量无意义信息（通常会以一种很有趣或是令人热血沸腾的形式出现）。</li>
<li><a href="http://book.douban.com/subject/1012611/">乌合之众</a>，最热门的信息不是最有价值的，而是吵的最响（或是争议最多）的。</li>
<li>与广播方（例如名人）的交流会带来成就感，也会使自己陷入等待回复的焦虑中。</li>
<li>可能会陷入一种不断查看新信息（尽管这些信息毫无意义）的焦虑中。</li>
</ol>


<h2>解决方法</h2>

<p>为此在豆瓣阅读买了一本<a href="http://book.douban.com/subject/24383461/">网络素养</a>，原版：<a href="http://www.amazon.com/Net-Smart-How-Thrive-Online/dp/0262526131/">Net Smart: How to thrive online</a>。</p>

<p><img src="http://img5.douban.com/lpic/s26842036.jpg" title="网络素养" alt="网络素养" /></p>

<p><img src="http://ecx.images-amazon.com/images/I/41LRFD-SVlL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_SX385_SY500_CR,0,0,385,500_SH20_OU02_.jpg" title="Net Smart" alt="Net Smart" /></p>

<p>这本书废话极多，关键的两点：控制注意力，鉴别垃圾信息。</p>

<h3>控制注意力</h3>

<ul>
<li>下意识的控制注意力，可以通过关注自己的呼吸来调节。</li>
<li>即便忽略几条微博几条信息，也不会对生活造成多大影响。</li>
<li>此外可以使用冥想提升自己的集中力（Focus）。</li>
<li>番茄工作法（没看明白要点，25分钟休息一次是什么原理，如果这样岂不是更不靠谱）。</li>
</ul>


<h3>鉴别垃圾信息</h3>

<ul>
<li>冷静面对夸张的标题，此类信息一般有意断章取义，或是掩盖上下文。</li>
<li>恰当的使用三点式验证争议信息：使用三个不同可信来源验证信息的有效性。</li>
<li>选取可信/有效/有价值的信息来源，屏蔽哗众取宠/断章取义的信息源。</li>
</ul>


<h3>集中时间处理社交网络</h3>

<ul>
<li>在固定的时间段（例：12:40 &ndash; 13:10, 20:20 &ndash; 21:00）处理社交网络信息，而非随时随地的查看状态。</li>
<li>如有特别需求，可以编写Crawler来发送Reminder邮件，替代人工轮询。</li>
</ul>


<h2>用不上瘾的行为填充碎片化时间</h2>

<p>碎片化时间可以进行其它益智或体育活动，包括但不限于：</p>

<ul>
<li>拆解/还原九连环。</li>
<li>单手还原魔方。</li>
<li>背诵单词。</li>
<li>绘画。</li>
<li>乒乓。</li>
<li>桌球。</li>
</ul>


<h2>尝试其它活动</h2>

<p>为了得到新鲜感，包括但不限于：</p>

<ul>
<li>学习自己感兴趣但不了解的技术（例如ANTLR）或学科（例如经济/心理学）。</li>
<li>尝试集体运动（例如攀岩，射箭）。</li>
<li>尝试旅行（例如在周末去荷兰、芬兰或瑞典进行两日游）。</li>
</ul>

]]></content>
  </entry>
  
</feed>
