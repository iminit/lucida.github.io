<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-12-26T17:25:33-08:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/"/>
    <updated>2014-12-12T22:23:36-08:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<p>本文是深入理解Java 8 Lambda系列的第二篇，主要介绍Java 8针对新增语言特性而新增的类库（例如Streams API、Collectors和并行）。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of the Lambda: Libraries Edition</a>一文的翻译。</p>

<h2><a name="about">关于</a></h2>

<p>Java SE 8增加了新的语言特性（例如lambda表达式和默认方法），为此Java SE 8的类库也进行了很多改进，本文简要介绍了这些改进。在阅读本文前，你应该先阅读<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">深入浅出Java 8 Lambda（语言篇）</a>，以便对Java SE 8的新增特性有一个全面了解。</p>

<h2><a name="background">背景（Background）</a></h2>

<p>自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而<a href="https://jcp.org/en/jsr/detail?id=355">JSR 355</a>（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API：</p>

<!-- more -->


<ul>
<li>为现有的接口（例如<code>Collection</code>，<code>List</code>和<code>Stream</code>）增加扩展方法；</li>
<li>在类库中增加新的<em>流</em>（stream，即<code>java.util.stream.Stream</code>）抽象以便进行聚集（aggregation）操作；</li>
<li>改造现有的类型使之可以提供流视图（stream view）；</li>
<li>改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如<code>ArrayList</code>和<code>HashMap</code>（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。</li>
</ul>


<p>除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。除此之外，我们还需要在将并行变的<em>容易</em>（easier）和将并行变的<em>不可见</em>（invisible）之间做出抉择，我们选择了一个折中的路线：提供<em>显式</em>（explicit）但<em>非侵入</em>（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题）</p>

<h2><a name="interal_vs_external_iteration">内部迭代和外部迭代（Internal  vs external iteration）</a></h2>

<p>集合类库主要依赖于<em>外部迭代</em>（external iteration）。<code>Collection</code>实现<code>Iterable</code>接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：</p>

<p><code>java
for (Shape shape : shapes) {
  shape.setColor(RED);
}
</code></p>

<p>这个例子演示了外部迭代：for-each循环调用<code>shapes</code>的<code>iterator()</code>方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：</p>

<ul>
<li>Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。</li>
</ul>


<p>尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。</p>

<p>我们可以使用<em>内部迭代</em>（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。</p>

<p>下面是前例的内部迭代代码：</p>

<p><code>java
shapes.forEach(s -&gt; s.setColor(RED));
</code></p>

<p>尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>

<p>外部迭代同时承担了<em>做什么</em>（把形状设为红色）和<em>怎么做</em>（得到<code>Iterator</code>实例然后依次遍历）两项职责，而内部迭代只负责<em>做什么</em>，而把<em>怎么做</em>留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。</p>

<h2><a name="stream">流（Stream）</a></h2>

<p><em>流</em>是Java SE 8类库中新增的关键抽象，它被定义于<code>java.util.stream</code>（这个包里有若干流类型：<code>Stream&lt;T&gt;</code>代表对象引用流，此外还有一系列特化（specialization）流，比如<code>IntStream</code>代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。</p>

<p>流的操作可以被组合成<em>流水线</em>（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色：</p>

<p>```java
shapes.stream()</p>

<pre><code>  .filter(s -&gt; s.getColor() == BLUE)
  .forEach(s -&gt; s.setColor(RED));
</code></pre>

<p>```</p>

<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流视图（stream view），接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>

<p>如果我们想把蓝色的形状提取到新的<code>List</code>里，则可以：</p>

<p>```java
List<Shape> blue = shapes.stream()</p>

<pre><code>                     .filter(s -&gt; s.getColor() == BLUE)
                     .collect(Collectors.toList());
</code></pre>

<p>```</p>

<p><code>collect()</code>操作会把其接收的元素聚集（aggregate）到一起（这里是<code>List</code>），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到<code>List</code>中。（如需更多<code>collect()</code>方法的细节，请阅读<a href="#collectors">Collectors</a>一节）</p>

<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>

<p>```java
Set<Box> hasBlueShape = shapes.stream()</p>

<pre><code>                          .filter(s -&gt; s.getColor() == BLUE)
                          .map(s -&gt; s.getContainingBox())
                          .collect(Collectors.toSet());
</code></pre>

<p>```</p>

<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>

<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>

<p>```java
int sum = shapes.stream()</p>

<pre><code>            .filter(s -&gt; s.getColor() == BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。</p>

<h2><a name="stream_vs_collection">流和集合（Streams vs Collections）</a></h2>

<p>集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同：</p>

<ul>
<li>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到；</li>
<li>天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改；</li>
<li>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；</li>
<li>无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举<a href="http://en.wikipedia.org/wiki/Perfect_number">完美数</a>这个操作可以被表达为在所有整数上进行过滤）。集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）；</li>
</ul>


<p>从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（<code>Collection</code>拥有<code>stream()</code>和<code>parallelStream()</code>方法），也可以通过流产生一个集合（使用前例的<code>collect()</code>方法）。<code>Collection</code>以外的类型也可以作为<code>stream</code>的数据源，比如JDK中的<code>BufferedReader</code>、<code>Random</code>和<code>BitSet</code>已经被改造可以用做流的数据源，<code>Arrays.stream()</code>则产生给定数组的流视图。事实上，任何可以用<code>Iterator</code>描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。</p>

<h3><a name="laziness">惰性（Laziness）</a></h3>

<p>过滤和映射这样的操作既可以被<em>急性求值</em>（以<code>filter</code>为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被<em>惰性求值</em>（用<code>Stream</code>代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</p>

<p>对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像<code>sum()</code>这样生成值的操作和<code>forEach()</code>这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。</p>

<p>以下面的流水线为例：</p>

<p>```java
int sum = shapes.stream()</p>

<pre><code>            .filter(s -&gt; s.getColor() == BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>这里的过滤操作和映射操作是惰性的，这意味着在调用<code>sum()</code>之前，我们不会从数据源提取任何元素。在<code>sum</code>操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。</p>

<p>大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（<code>forEach</code>，<code>toArray</code>和<code>collect</code>等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让<code>filter</code>和<code>map</code>返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如<code>forEach()</code>）都是急性操作。绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。</p>

<p>在使用这种<em>数据源—惰性操作—惰性操作—急性操作</em>流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。</p>

<p>对于<code>anyMatch(Predicate)</code>和<code>findFirst()</code>这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例：</p>

<p>```java
Optional<Shape> firstBlue = shapes.stream()</p>

<pre><code>                              .filter(s -&gt; s.getColor() == BLUE)
                              .findFirst();
</code></pre>

<p>```</p>

<p>由于过滤这一步是惰性的，<code>findFirst</code>在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。<code>findFirst()</code>方法返回<code>Optional</code>对象，因为集合中有可能不存在满足条件的元素。<code>Optional</code>是一种用于描述可缺失值的类型。</p>

<p>在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。</p>

<h3><a name="parallelism">并行（Parallelism）</a></h3>

<p>流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过<code>parallel()</code>方法被转化为并行流）</p>

<p>尽管并行是显式的，但它并不需要成为侵入式的。利用<code>parallelStream()</code>，我们可以轻松的把之前重量求和的代码并行化：</p>

<p>```java
int sum = shapes.parallelStream()</p>

<pre><code>            .filter(s -&gt; s.getColor = BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。</p>

<p>因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出<code>ConcurrentModificationException</code>）我们把这个条件称为无干扰性（non-interference）。</p>

<p>我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义：</p>

<ol>
<li>不要干扰数据源；</li>
<li>不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。</li>
</ol>


<p>只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如<code>ArrayList</code>）也是一样。</p>

<h2><a name="examples">实例（Examples）</a></h2>

<p>下面的代码源自JDK中的<code>Class</code>类型（<code>getEnclosingMethod</code>方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配：</p>

<p>```java
for (Method method : enclosingInfo.getEnclosingClass().getDeclaredMethods()) {
  if (method.getName().equals(enclosingInfo.getName())) {</p>

<pre><code>Class&lt; ? &gt;[] candidateParamClasses = method.getParameterTypes();
if (candidateParamClasses.length == parameterClasses.length) {
  boolean matches = true;
  for (int i = 0; i &lt; candidateParamClasses.length; i += 1) {
    if (!candidateParamClasses[i].equals(parameterClasses[i])) {
      matches = false;
      break;
    }
  }

  if (matches) { // finally, check return type
    if (method.getReturnType().equals(returnType)) {
      return method;
    }
  }
}
</code></pre>

<p>  }
}
throw new InternalError(&ldquo;Enclosing method not found&rdquo;);
```</p>

<p>通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用<code>Arrays.stream</code>将它转化为<code>Stream</code>，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用<code>findFirst</code>得到<code>Optional&lt;Method&gt;</code>，最后利用<code>orElseThrow</code>返回目标值或者抛出异常。</p>

<p>```java
return Arrays.stream(enclosingInfo.getEnclosingClass().getDeclaredMethods())</p>

<pre><code>         .filter(m -&gt; Objects.equal(m.getName(), enclosingInfo.getName()))
         .filter(m -&gt; Arrays.equal(m.getParameterTypes(), parameterClasses))
         .filter(m -&gt; Objects.equals(m.getReturnType(), returnType))
         .findFirst()
         .orElseThrow(() -&gt; new InternalError("Enclosing method not found"));
</code></pre>

<p>```</p>

<p>相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。</p>

<p>流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。</p>

<p>假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写：</p>

<p>```java
List<Album> favs = new ArrayList&lt;>();
for (Album album : albums) {
  boolean hasFavorite = false;
  for (Track track : album.tracks) {</p>

<pre><code>if (track.rating &gt;= 4) {
  hasFavorite = true;
  break;
}
</code></pre>

<p>  }
  if (hasFavorite)</p>

<pre><code>favs.add(album);
</code></pre>

<p>}
Collections.sort(favs, new Comparator<Album>() {
  public int compare(Album a1, Album a2) {</p>

<pre><code>return a1.name.compareTo(a2.name);
</code></pre>

<p>  }
});
```</p>

<p>我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用<code>anyMatch</code>）；按名字排序；以及把满足条件的专辑放在一个<code>List</code>中：</p>

<p>```java
List<Album> sortedFavs =</p>

<pre><code>albums.stream()
      .filter(a -&gt; a.tracks.anyMatch(t -&gt; (t.rating &gt;= 4)))
      .sorted(Comparator.comparing(a -&gt; a.name))
      .collect(Collectors.toList());
</code></pre>

<p>```</p>

<p><code>Compartor.comparing</code>方法接收一个函数（该函数返回一个实现了<code>Comparable</code>接口的排序键值），然后返回一个利用该键值进行排序的<code>Comparator</code>（请参考下面的<a href="#comparator_factories">比较器工厂</a>一节）。</p>

<h3><a name="collectors">收集器（Collectors）</a></h3>

<p>在之前的例子中，我们利用<code>collect()</code>方法把流中的元素聚合到<code>List</code>或<code>Set</code>中。<code>collect()</code>接收一个类型为<code>Collector</code>的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。<code>Collectors</code>类包含了大量常用收集器的工厂方法，<code>toList()</code>和<code>toSet()</code>就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。</p>

<p><code>Collector</code>的类型由其输入类型和输出类型决定。以<code>toList()</code>收集器为例，它的输入类型为<code>T</code>，输出类型为<code>List&lt;T&gt;</code>，<code>toMap</code>是另外一个较为复杂的<code>Collector</code>，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。<code>toMap</code>的输入类型是<code>T</code>，输出类型是<code>Map&lt;K, V&gt;</code>，其中<code>K</code>和<code>V</code>分别是前面两个函数所生成的键类型和值类型。（复杂版本的<code>toMap</code>收集器则允许你指定目标<code>Map</code>的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引：</p>

<p>```java
Map&lt;Integer, Album> albumsByCatalogNumber =</p>

<pre><code>albums.stream()
      .collect(Collectors.toMap(a -&gt; a.getCatalogNumber(), a -&gt; a));
</code></pre>

<p>```</p>

<p><code>groupingBy</code>是一个与<code>toMap</code>相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的<code>Collector</code>：它以<code>Track</code>作为输入，以<code>Map&lt;Artist, List&lt;Track&gt;&gt;</code>作为输出。<code>groupingBy</code>收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成<code>Map</code>，该<code>Map</code>的键是分类函数的返回结果，值是该分类下的元素列表。</p>

<p>```java
Map&lt;Artist, List<Track>> favsByArtist =</p>

<pre><code>tracks.stream()
      .filter(t -&gt; t.rating &gt;= 4)
      .collect(Collectors.groupingBy(t -&gt; t.artist));
</code></pre>

<p>```</p>

<p>收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的<code>groupingBy</code>收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用<em>其它</em>收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的<code>groupingBy</code>使用<code>toList()</code>作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到<code>Set</code>而非<code>List</code>中，我们可以使用<code>toSet</code>收集器：</p>

<p>```java
Map&lt;Artist, Set<Track>> favsByArtist =</p>

<pre><code>tracks.stream()
      .filter(t -&gt; t.rating &gt;= 4)
      .collect(Collectors.groupingBy(t -&gt; t.artist,
                                     Collectors.toSet()));
</code></pre>

<p>```</p>

<p>如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级<code>Map</code>：</p>

<p>```java
Map&lt;Artist, Map&lt;Integer, List<Track>>> byArtistAndRating =</p>

<pre><code>tracks.stream()
      .collect(groupingBy(t -&gt; t.artist,
                          groupingBy(t -&gt; t.rating)));
</code></pre>

<p>```</p>

<p>在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用<code>Stream.flatMap()</code>得到一个歌曲流，然后用<code>Pattern.splitAsStream</code>把每首歌曲的标题打散成词流；接下来我们用<code>groupingBy</code>和<code>String.toUpperCase</code>对这些词进行不区分大小写的分组，最后使用<code>counting()</code>收集器计算每个词出现的次数（从而无需创建中间集合）。</p>

<p>```java
Pattern pattern = Pattern.compile(&ldquo;\s+&rdquo;);
Map&lt;String, Integer> wordFreq =</p>

<pre><code>tracks.stream()
      .flatMap(t -&gt; pattern.splitAsStream(t.name)) // Stream&lt;String&gt;
      .collect(groupingBy(s -&gt; s.toUpperCase(),
                          counting()));
</code></pre>

<p>```</p>

<p><code>flatMap</code>接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的<code>flatMap</code>会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。</p>

<p><code>Collectors</code>类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义<code>Collector</code>。</p>

<h2><a name="parallelism_under_the_hood">并行的实质（Parallelism under the hood）</a></h2>

<p>Java SE 7引入了<a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Fork/Join</a>模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。</p>

<p>为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步：</p>

<ul>
<li>把问题分解为子问题；</li>
<li>串行解决子问题从而得到部分结果（partial result）；</li>
<li>合并部分结果合为最终结果。</li>
</ul>


<p>这也是Fork/Join的实现原理。</p>

<p>为了能够并行化任意流上的所有操作，我们把流抽象为<code>Spliterator</code>，<code>Spliterator</code>是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像<code>Iterator</code>允许你跳过一个元素然后保留剩下的元素，<code>Spliterator</code>允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的<code>Spliterator</code>中，而剩下的数据则会被保存在原来的<code>Spliterator</code>里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。</p>

<p>上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。</p>

<p>大多数用户无需去实现<code>Spliterator</code>接口，因为集合上的<code>stream()</code>方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现<code>Spliterator</code>接口。<code>Spliterator</code>接口的API如下所示：</p>

<p>```java
public interface Spliterator<T> {
  // Element access
  boolean tryAdvance(Consumer&lt; ? super T> action);
  void forEachRemaining(Consumer&lt; ? super T> action);</p>

<p>  // Decomposition
  Spliterator<T> trySplit();</p>

<p>  //Optional metadata
  long estimateSize();
  int characteristics();
  Comparator&lt; ? super T> getComparator();
}
```</p>

<p>集合库中的基础接口<code>Collection</code>和<code>Iterable</code>都实现了正确但相对低效的<code>spliterator()</code>实现，但派生接口（例如<code>Set</code>）和具体实现类（例如<code>ArrayList</code>）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在<code>split()</code>方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。</p>

<h3><a name="encounter_order">出现顺序（Encounter order）</a></h3>

<p>多数数据结构（例如列表，数组和I/O通道）都拥有<em>自然出现顺序</em>（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如<code>HashSet</code>）则没有一个明确定义的出现顺序（这也是<code>HashSet</code>的<code>Iterator</code>实现中不保证元素出现顺序的原因）。</p>

<p>是否具有明确定义的出现顺序是<code>Spliterator</code>检查的特性之一（这个特性也被流使用）。除了少数例外（比如<code>Stream.forEach()</code>和<code>Stream.findAny()</code>），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线：</p>

<p>```java
List<String> names = people.parallelStream()</p>

<pre><code>                       .map(Person::getName)
                       .collect(toList());
</code></pre>

<p>```</p>

<p>代码中名字出现的顺序必须要和流中的<code>Person</code>出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是<code>HashSet</code>，那么上面代码中名字就可以以任意顺序出现。</p>

<h2><a name="streams_lambdas_in_jdk">JDK中的流和lambda（Streams and lambdas in JDK）</a></h2>

<p><code>Stream</code>在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用<code>Stream</code>。我们为<code>Collection</code>提供了<code>stream()</code>和<code>parallelStream()</code>，以便把集合转化为流；此外数组可以通过<code>Arrays.stream()</code>被转化为流。</p>

<p>除此之外，<code>Stream</code>中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如<code>Stream.of()</code>，<code>Stream.generate</code>以及<code>IntStream.range</code>。其它的常用类型也提供了流相关的方法，例如<code>String.chars</code>，<code>BufferedReader.lines</code>，<code>Pattern.splitAsStream</code>，<code>Random.ints</code>和<code>BitSet.stream</code>。</p>

<p>最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现<code>Stream</code>至少需要一个<code>Iterator</code>，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过<code>Spliterator</code>提供一个更加高效的实现（就像JDK中所有的集合一样）。</p>

<h3><a name="comparator_factories">比较器工厂（Comparator factories）</a></h3>

<p>我们在<code>Comparator</code>接口中新增了若干用于生成比较器的实用方法：</p>

<p>静态方法<code>Comparator.comparing()</code>接收一个函数（该函数返回一个实现<code>Comparable</code>接口的比较键值），返回一个<code>Comparator</code>，它的实现十分简洁：</p>

<p>```java
public static &lt;T, U extends Comparable&lt; ? super U>> Compartor<T> comparing(</p>

<pre><code>Function&lt; ? super T, ? extends U&gt; keyExtractor) {
</code></pre>

<p>  return (c1, c2) &ndash;> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
}
```</p>

<p>我们把这种方法称为<em>高阶函数</em>——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码：</p>

<p><code>java
List&lt;Person&gt; people = ...
people.sort(comparing(p -&gt; p.getLastName()));
</code></p>

<p>这段代码比“过去的代码”（一般要定义一个实现<code>Comparator</code>接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，<code>Comparator</code>拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可：</p>

<p><code>java
people.sort(comparing(p -&gt; p.getLastName()).reversed());
</code></p>

<p>与之类似，默认方法<code>thenComparing</code>允许你去改进一个已有的<code>Comparator</code>：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序：</p>

<p>```java
Comparator<Person> c = Comparator.comparing(p &ndash;> p.getLastName())</p>

<pre><code>                             .thenComparing(p -&gt; p.getFirstName());
</code></pre>

<p>people.sort&copy;;
```</p>

<h3><a name="mutative_collection_operation">可变的集合操作（Mutative  collection operation）</a></h3>

<p>集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如<code>Collection</code>，<code>List</code>和<code>Map</code>）提供了一些新的方法，比如<code>Iterable.forEach(Consumer)</code>，<code>Collection.removeAll(Predicate)</code>，<code>List.replaceAll(UnaryOperator)</code>，<code>List.sort(Comparator)</code>和<code>Map.computeIfAbsent()</code>。除此之外，<code>ConcurrentMap</code>中的一些非原子方法（例如<code>replace</code>和<code>putIfAbsent</code>）被提升到<code>Map</code>之中。</p>

<h2><a name="summary">小结（Summary）</a></h2>

<p>引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。<code>Stream</code>抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/"/>
    <updated>2014-10-23T23:54:02-07:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li>深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<h2>关于</h2>

<p>本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>一文的翻译，那么问题来了：</p>

<h3>为什么要写（翻译）这个系列？</h3>

<!-- more -->


<ol>
<li>工作之后，我开始大量使用Java</li>
<li>公司将会在不久的未来使用Java 8</li>
<li>作为资质平庸的开发者，我需要打一点提前量，以免到时拙计</li>
<li>为了学习Java 8（主要是其中的lambda及相关库），我先后阅读了Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>，<a href="http://www.amazon.com/Cay-S.-Horstmann/e/B000AQ1QDY/">Cay Horstmann</a>（<a href="http://www.amazon.com/Core-Volume-I--Fundamentals-Edition-Series/dp/0137081898/">Core Java</a>的作者）的<a href="http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/">Java 8 for the Really Impatient</a>和Richard Warburton的<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a></li>
<li>但我感到并没有多大收获，Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>涉及了lambda表达式的每一个概念，但都是点到辄止；后两本书（尤其是<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>）花了大量篇幅介绍Java lambda及其类库，但实质内容不多，读完了还是没有对Java lambda产生一个清晰的认识</li>
<li>关键在于这些文章和书都没有解决我对Java lambda的困惑，比如：

<ul>
<li>Java 8中的lambda为什么要设计成这样？（为什么要一个lambda对应一个接口？而不是Structural Typing？）</li>
<li>lambda和匿名类型的关系是什么？lambda是匿名对象的语法糖吗？</li>
<li>Java 8是如何对lambda进行类型推导的？它的类型推导做到了什么程度？</li>
<li>Java 8为什么要引入默认方法？</li>
<li>Java编译器如何处理lambda？</li>
<li>等等……</li>
</ul>
</li>
<li>之后我在Google搜索这些问题，然后就找到<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的三篇关于Java lambda的文章（<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>，<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of Lambda libraries version</a>和<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">Translation of lambda</a>），读完之后上面的问题都得到了解决</li>
<li>为了加深理解，我决定翻译这一系列文章</li>
</ol>


<h3>警告（Caveats）</h3>

<p>如果你不知道什么是函数式编程，或者不了解<code>map</code>，<code>filter</code>，<code>reduce</code>这些常用的高阶函数，那么你不适合阅读本文，请先学习函数式编程基础（比如<a href="http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/">这本书</a>）。</p>

<hr />

<h1><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a> by <a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a></h1>

<blockquote><p>The high-level goal of Project Lambda is to enable programming patterns that require modeling code as data to be convenient and idiomatic in Java.</p></blockquote>

<h2>关于</h2>

<p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>

<ul>
<li>lambda表达式（又被成为“闭包”或“匿名方法”）</li>
<li>方法引用和构造方法引用</li>
<li>扩展的目标类型和类型推导</li>
<li>接口中的默认方法和静态方法</li>
</ul>


<h2>1. 背景</h2>

<p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>

<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：</p>

<p><code>java
public interface ActionListener {
  void actionPerformed(ActionEvent e);
}
</code></p>

<p>这里并不需要专门定义一个类来实现<code>ActionListener</code>接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</p>

<p>```
button.addActionListener(new ActionListener) {
  public void actionPerformed(ActionEvent e) {</p>

<pre><code>ui.dazzle(e.getModifiers());
</code></pre>

<p>  }
}
```</p>

<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>

<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的<a href="http://blogs.oracle.com/jrose/entry/better_closures">选择</a>，因为：</p>

<ol>
<li>语法过于冗余</li>
<li>匿名类中的<code>this</code>和变量名容易使人产生误解</li>
<li>类型载入和实例创建语义不够灵活</li>
<li>无法捕获非<code>final</code>的局部变量</li>
<li>无法对控制流进行抽象</li>
</ol>


<p>上面的多数问题均在Java SE 8中得以解决：</p>

<ul>
<li>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2</li>
<li>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3</li>
<li>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰</li>
</ul>


<p>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>

<h2>2. 函数式接口（Functional interfaces）</h2>

<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>

<ul>
<li>接口是Java类型系统的一部分</li>
<li>接口天然就拥有其运行时表示（Runtime representation）</li>
<li>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）</li>
</ul>


<p>上面提到的<code>ActionListener</code>接口只有一个方法，大多数回调接口都拥有这个特征：比如<code>Runnable</code>接口和<code>Comparator</code>接口。我们把这些只拥有一个方法的接口称为<em>函数式接口</em>。（之前它们被称为<em>SAM类型</em>，即<em>单抽象方法类型</em>（Single Abstract Method））</p>

<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个<code>Object</code>已经提供的方法，比如<code>toString()</code>，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过<code>@FunctionalInterface</code>注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>

<p>实现函数式类型的另一种方式是引入一个全新的<em>结构化</em>函数类型，我们也称其为“箭头”类型。例如，一个接收<code>String</code>和<code>Object</code>并返回<code>int</code>的函数类型可以被表示为<code>(String, Object) -&gt; int</code>。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>

<ul>
<li>它会为Java类型系统引入额外的复杂度，并带来<a href="http://en.wikipedia.org/wiki/Structural_type_system">结构类型（Structural Type）</a>和<a href="http://en.wikipedia.org/wiki/Nominal_type_system">指名类型（Nominal Type）</a>的混用。（Java几乎全部使用指名类型）</li>
<li>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型</li>
<li>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后</li>
<li>每个函数类型很难拥有其运行时表示，这意味着开发者会受到<a href="http://en.wikipedia.org/wiki/Type_erasure">类型擦除（erasure）</a>的困扰和局限。比如说，我们无法对方法<code>m(T-&gt;U)</code>和<code>m(X-&gt;Y)</code>进行重载（Overload）</li>
</ul>


<p>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：</p>

<ul>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html">java.security.PrivilegedAction</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html">java.util.Comparator</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html">java.io.FileFilter</a></li>
<li><a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html">java.beans.PropertyChangeListener</a></li>
</ul>


<p>除此之外，Java SE 8中增加了一个新的包：<code>java.util.function</code>，它里面包含了常用的函数式接口，例如：</p>

<ul>
<li><code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code></li>
<li><code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象，不返回值</li>
<li><code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象，返回<code>R</code>对象</li>
<li><code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂），不接收值</li>
<li><code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象，返回<code>T</code>对象</li>
<li><code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象，返回<code>T</code>对象</li>
</ul>


<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>。（我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如<code>BiFunction&lt;T, U, R&gt;</code>，它接收<code>T</code>对象和<code>U</code>对象，返回<code>R</code>对象。</p>

<h2>3. lambda表达式（lambda expressions）</h2>

<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作。</p>

<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>

<p>下面是一些lambda表达式：</p>

<p><code>
(int x, int y) -&gt; x + y
() -&gt; 42
(String s) -&gt; { System.out.println(s); }
</code></p>

<p>第一个lambda表达式接收<code>x</code>和<code>y</code>这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数'42'；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>

<p>lambda表达式的语法由参数列表、箭头符号<code>-&gt;</code>和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——

<ul>
<li><code>return</code>语句会把控制权交给匿名方法的调用者</li>
<li><code>break</code>和<code>continue</code>只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li>
</ul>
</li>
</ul>


<p>表达式函数体适合小型lambda表达式，它消除了<code>return</code>关键字，使得语法更加简洁。</p>

<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<p>下面是一些出现在语句中的lambda表达式：</p>

<p>```
FileFilter java = (File f) &ndash;> f.getName().endsWith(&ldquo;*.java&rdquo;);</p>

<p>String user = doPrivileged(() &ndash;> System.getProperty(&ldquo;user.name&rdquo;));</p>

<p>new Thread(() &ndash;> {
  connectToService();
  sendNotification();
}).start();
```</p>

<h2>4. 目标类型（Target typing）</h2>

<p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是<code>ActionListener</code>：</p>

<p><code>
ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());
</code></p>

<p>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>

<p>```
Callable<String> c = () &ndash;> &ldquo;done&rdquo;;</p>

<p>PrivilegedAction<String> a = () &ndash;> &ldquo;done&rdquo;;
```</p>

<p>第一个lambda表达式<code>() -&gt; "done"</code>是<code>Callable</code>的实例，而第二个lambda表达式则是<code>PrivilegedAction</code>的实例。</p>

<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导，这个<strong>被期待的类型</strong>被称为<em>目标类型</em>。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>

<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型<code>T</code>：</p>

<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li>
<li>lambda表达式的返回值和<code>T</code>的方法返回值相兼容（Compatible）</li>
<li>lambda表达式内所抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li>
</ul>


<p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>

<p><code>
Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);
</code></p>

<p>在上面的例子里，编译器可以推导出<code>s1</code>和<code>s2</code>的类型是<code>String</code>。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>

<p>```
FileFilter java = f &ndash;> f.getName().endsWith(&ldquo;.java&rdquo;);</p>

<p>button.addActionListener(e &ndash;> ui.dazzle(e.getModifiers()));
```</p>

<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>

<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：</p>

<p>```
List<String> ls = Collections.emptyList();
List<Integer> li = Collections.emptyList();</p>

<p>Map&lt;String, Integer> m1 = new HashMap&lt;>();
Map&lt;Integer, String> m2 = new HashMap&lt;>();
```</p>

<h2>5. 目标类型的上下文（Contexts for target typing）</h2>

<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>

<ul>
<li>变量声明</li>
<li>赋值</li>
<li>返回语句</li>
<li>数组初始化器</li>
<li>方法和构造方法的参数</li>
<li>lambda表达式函数体</li>
<li>条件表达式（<code>? :</code>）</li>
<li>转型（Cast）表达式</li>
</ul>


<p>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>

<p>```
Comparator<String> c;
c = (String s1, String s2) &ndash;> s1.compareToIgnoreCase(s2);</p>

<p>public Runnable toDoLater() {
  return () &ndash;> {</p>

<pre><code>System.out.println("later");
</code></pre>

<p>  }
}
```</p>

<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：</p>

<p>```
filterFiles(new FileFilter[] {</p>

<pre><code>          f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith("q")
        });
</code></pre>

<p>```</p>

<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>

<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有<strong>显式类型</strong>（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有<strong>隐式类型</strong>（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>

<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。</p>

<p><code>
List&lt;Person&gt; ps = ...
Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());
</code></p>

<p>在上面的代码中，<code>ps</code>的类型是<code>List&lt;Person&gt;</code>，所以<code>ps.stream()</code>的返回类型是<code>Stream&lt;Person&gt;</code>。<code>map()</code>方法接收一个类型为<code>Function&lt;T, R&gt;</code>的函数式接口，这里<code>T</code>的类型即是<code>Stream</code>元素的类型，也就是<code>Person</code>，而<code>R</code>的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导<code>R</code>的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回<code>String</code>，因此<code>R</code>的类型是<code>String</code>，因而<code>map()</code>返回<code>Stream&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>

<ul>
<li>使用显式lambda表达式（为参数<code>p</code>提供显式类型）以提供额外的类型信息</li>
<li>把lambda表达式转型为<code>Function&lt;Person, String&gt;</code></li>
<li>为泛型参数<code>R</code>提供一个实际类型。（<code>.&lt;String&gt;map(p -&gt; p.getName())</code>）</li>
</ul>


<p>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>

<p><code>
Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; { System.out.println("hi"); };
</code></p>

<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>

<p><code>
Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42);
</code></p>

<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>

<p><code>
// Object o = () -&gt; { System.out.println("hi"); }; 这段代码是非法的
Object o = (Runnable) () -&gt; { System.out.println("hi"); };
</code></p>

<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>

<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>

<p>```
List<String> ls = Collections.checkedList(new ArrayList&lt;>(), String.class);</p>

<p>Set<Integer> si = flag ? Collections.singleton(23) : Collections.emptySet();
```</p>

<h2>6. 词法作用域（Lexical scoping）</h2>

<p>在内部类中使用变量名（以及<code>this</code>）非常容易出错。内部类中通过继承得到的成员（包括来自<code>Object</code>的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的<code>this</code>引用会指向内部类自己而非外部类。</p>

<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，'this'关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>

<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把<code>"Hello, world!"</code>打印两遍：</p>

<p>```
public class Hello {
  Runnable r1 = () &ndash;> { System.out.println(this); }
  Runnable r2 = () &ndash;> { System.out.println(toString()); }</p>

<p>  public String toString() {  return &ldquo;Hello, world&rdquo;; }</p>

<p>  public static void main(String&hellip; args) {</p>

<pre><code>new Hello().r1.run();
new Hello().r2.run();
</code></pre>

<p>  }
}
```</p>

<p>与之相类似的内部类实现则会打印出类似<code>Hello$1@5b89a773</code>和<code>Hello$2@537a7706</code>之类的字符串，这往往会使开发者大吃一惊。</p>

<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如<code>for</code>循环和<code>catch</code>从句）一致。</p>

<p><strong>个人补充</strong>：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>

<p><code>
int i = 0;
int sum = 0;
for (int i = 1; i &lt; 10; i += 1) { //这里会出现编译错误，因为i已经在for循环外部声明过了
  sum += i;
}
</code></p>

<h2>7. 变量捕获（Variable capture）</h2>

<p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合<em>有效只读</em>（Effectively final）的局部变量。</p>

<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上<code>final</code>后也不会导致编译错误的局部变量就是有效只读变量。</p>

<p><code>
Callable&lt;String&gt; helloCallable(String name) {
  String hello = "Hello";
  return () -&gt; (hello + ", " + name);
}
</code></p>

<p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段的引用和未限定方法的调用在本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其它情况下，lambda对象不会保留任何对<code>this</code>的引用。</p>

<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>

<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>

<p><code>
int sum = 0;
list.forEach(e -&gt; { sum += e.size(); });
</code></p>

<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对<em>值</em>封闭，对<em>变量</em>开放。</p>

<p><strong>个人补充</strong>：lambda表达式对<em>值</em>封闭，对<em>变量</em>开放的原文是：lambda expressions close over <em>values</em>, not <em>variables</em>，我在这里增加一个例子以说明这个特性：</p>

<p>```
int sum = 0;
list.forEach(e &ndash;> { sum += e.size(); }); // Illegal, close over values</p>

<p>List<Integer> aList = new List&lt;>();
list.forEach(e &ndash;> { aList.add(e); }); // Legal, open over variables
```</p>

<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。<code>java.util.stream</code>包提供了各种通用的和专用的规约操作（例如<code>sum</code>、<code>min</code>和<code>max</code>），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替<code>forEach</code>：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .sum();
</code></pre>

<p>```</p>

<p><code>sum()</code>等价于下面的规约操作：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .reduce(0 , (x, y) -&gt; x + y);
</code></pre>

<p>```</p>

<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>

<p><code>
0 + list[0] + list[1] + list[2] + ...
</code></p>

<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>

<h2>8. 方法引用（Method references）</h2>

<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在<em>已有的</em>方法上实现同样的特性。</p>

<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>

<p>以下面的代码为例，假设我们要按照<code>name</code>或<code>age</code>为<code>Person</code>数组进行排序：</p>

<p>```
class Person {
  private final String name;
  private final int age;</p>

<p>  public int getAge() { return age; }
  public String getName() {return name; }
  &hellip;
}</p>

<p>Person[] people = &hellip;
Comparator<Person> byName = Comparator.comparing(p &ndash;> p.getName());
Arrays.sort(people, byName);
```</p>

<p>在这里我们可以用方法引用代替lambda表达式：</p>

<p><code>
Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);
</code></p>

<p>这里的<code>Person::getName</code>可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>

<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>

<p><code>
Consumer&lt;Integer&gt; b1 = System::exit;    // void exit(int status)
Consumer&lt;String[]&gt; b2 = Arrays:sort;    // void sort(Object[] a)
Consumer&lt;String&gt; b3 = MyProgram::main;  // void main(String... args)
Runnable r = Myprogram::mapToInt        // void main(String... args)
</code></p>

<h2>9. 方法引用的种类（Kinds of method references）</h2>

<p>方法引用有很多种，它们的语法如下：</p>

<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>


<p>对于静态方法引用，我们需要在类名和方法名之间加入<code>::</code>分隔符，例如<code>Integer::sum</code>。</p>

<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>

<p><code>
Set&lt;String&gt; knownNames = ...
Predicate&lt;String&gt; isKnown = knownNames::contains;
</code></p>

<p>这里的隐式lambda表达式（也就是实例方法引用）会从<code>knownNames</code>中捕获<code>String</code>对象，而它的方法体则会通过<code>Set.contains</code>使用该<code>String</code>对象。</p>

<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>

<p><code>
Callable&lt;Path&gt; c = ...
Privileged&lt;Path&gt; a = c::call;
</code></p>

<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>

<p><code>
Function&lt;String, String&gt; upperfier = String::toUpperCase;
</code></p>

<p>这里的隐式lambda表达式（即<code>String::toUpperCase</code>实例方法引用）有一个<code>String</code>参数，这个参数会被<code>toUpperCase</code>方法使用。</p>

<p>如果类型的实例方法是泛型的，那么我们就需要在<code>::</code>分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>

<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>

<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在<code>::</code>分隔符之前提供参数类型信息。</p>

<p>和静态方法引用类似，构造方法也可以通过<code>new</code>关键字被直接引用：</p>

<p><code>
SocketImplFactory factory = MySocketImpl::new;
</code></p>

<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>

<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照"菱形"构造方法调用时的方式进行推导。</p>

<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收<code>int</code>参数的数组构造方法。参考下面的代码：</p>

<p><code>
IntFunction&lt;int[]&gt; arrayMaker = int[]::new;
int[] array = arrayMaker.apply(10) // 创建数组 int[10]
</code></p>

<h2>10. 默认方法和静态接口方法（Default and static interface methods）</h2>

<p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把<em>代码即数据</em>（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>

<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。<em>默认方法</em>（之前被称为<em>虚拟扩展方法</em>或<em>守护方法</em>）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>

<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如<code>removeAll</code>方法应该被泛化为接收一个函数式接口<code>Predicate</code>，但这个新的方法应该被放在哪里呢？我们无法直接在<code>Collection</code>接口上新增方法——不然就会破坏现有的<code>Collection</code>实现。我们倒是可以在<code>Collections</code>工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>

<p><em>默认方法</em>利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是<em>抽象的</em>或是<em>默认的</em>。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>

<p>下面的例子展示了如何向<code>Iterator</code>接口增加默认方法<code>skip</code>：</p>

<p>```
interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();</p>

<p>  default void skip(int i) {</p>

<pre><code>for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next();
</code></pre>

<p>  }
}
```</p>

<p>根据上面的<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会自动继承<code>skip</code>方法。在使用者的眼里，<code>skip</code>不过是接口新增的一个虚拟方法。在没有覆盖<code>skip</code>方法的<code>Iterator</code>子类实例上调用<code>skip</code>会执行<code>skip</code>的默认实现：调用<code>hasNext</code>和<code>next</code>若干次。子类可以通过覆盖<code>skip</code>来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>

<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>

<p>除了默认方法，Java SE 8还在允许在接口中定义<em>静态</em>方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如<code>Collections</code>）。比如，我们一般需要使用静态辅助方法生成实现<code>Comparator</code>的比较器，在Java SE 8中我们可以直接把该静态方法定义在<code>Comparator</code>接口中：</p>

<p>```
public static &lt;T, U extends Comparable&lt;? super U>></p>

<pre><code>Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) {
</code></pre>

<p>  return (c1, c2) &ndash;> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
}
```</p>

<h2>11. 继承默认方法（Inheritance of default methods）</h2>

<p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>

<ul>
<li>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。</li>
<li>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。</li>
</ul>


<p>为了演示第二条规则，我们假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法。在下面的<code>implement</code>从句中，<code>List</code>中的方法声明会优先于<code>Queue</code>中的方法声明：</p>

<p><code>
class LinkedList&lt;E&gt; implements List&lt;E&gt;, Queue&lt;E&gt; { ... }
</code></p>

<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>

<p><code>
interface Robot implements Artist, Gun {
  default void draw() { Artist.super.draw(); }
}
</code></p>

<p><code>super</code>前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>

<p>最后，接口在<code>inherits</code>和<code>extends</code>从句中的声明顺序和它们被实现的顺序无关。</p>

<h2>12. 融会贯通（Putting it together）</h2>

<p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>

<p>比如说下面的代码：</p>

<p>```
List<Person> people = &hellip;
Collections.sort(people, new Comparator<Person>() {
  public int compare(Person x, Person y) {</p>

<pre><code>return x.getLastName().compareTo(y.getLastName());
</code></pre>

<p>  }
})
```</p>

<p>冗余代码实在太多了！</p>

<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>

<p>```
Collections.sort(people,</p>

<pre><code>             (Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName()));
</code></pre>

<p>```</p>

<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助<code>Comparator</code>里的<code>comparing</code>方法实现比较操作：</p>

<p><code>
Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName()));
</code></p>

<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>

<p><code>
Collections.sort(people, comparing(p -&gt; p.getLastName()));
</code></p>

<p>我们注意到这里的lambda表达式实际上是<code>getLastName</code>的代理（forwarder），于是我们可以用方法引用代替它：</p>

<p><code>
Collections.sort(people, comparing(Person::getLastName));
</code></p>

<p>最后，使用<code>Collections.sort</code>这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现<code>List</code>接口的数据结构提供特定（specialized）的高效实现，而且由于<code>Collections.sort</code>方法不属于<code>List</code>接口，用户在阅读<code>List</code>接口的文档时不会察觉在另外的<code>Collections</code>类中还有一个针对<code>List</code>接口的排序（<code>sort()</code>）方法。</p>

<p>默认方法可以有效的解决这个问题，我们为<code>List</code>增加默认方法<code>sort()</code>，然后就可以这样调用：</p>

<p><code>
people.sort(comparing(Person::getLastName));;
</code></p>

<p>此外，如果我们为<code>Comparator</code>接口增加一个默认方法<code>reversed()</code>（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>

<p><code>
people.sort(comparing(Person::getLastName).reversed());;
</code></p>

<h2>13. 小结（Summary）</h2>

<p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>

<p>未完待续——</p>

<p>下篇：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
</feed>
