<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technology | Lucida]]></title>
  <link href="http://lucida.github.io/blog/categories/technology/atom.xml" rel="self"/>
  <link href="http://lucida.github.io/"/>
  <updated>2014-04-13T02:10:05+01:00</updated>
  <id>http://lucida.github.io/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习&使用技术的四种层次]]></title>
    <link href="http://lucida.github.io/blog/levels-on-learning-and-using-technologies/"/>
    <updated>2014-04-13T01:53:21+01:00</updated>
    <id>http://lucida.github.io/blog/levels-on-learning-and-using-technologies</id>
    <content type="html"><![CDATA[<h1>学习&amp;使用技术的四种层次</h1>

<h2>关键字</h2>

<p>技术，生活，反思。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/</a></p>

<h2>关于</h2>

<p>Bjarne Stroustrup在他的新书《<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A tour of C++</a>》</p>

<p><img src="http://i.imgur.com/VlQ7ROA.jpg" alt="A tour of C++" style="max-height: 370px;"/></p>

<p>里面举了一个旅行的例子来比喻初学编程语言：</p>

<blockquote><p>&hellip;as an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions what to see next&hellip;</p>

<p>&hellip;you do not know the city after such a tour. You do not understand all you have seen and heard. You do not know how to navigate the formal and informal rules that govern life in the city&hellip;</p>

<p>&hellip;to really know a city, you have to live in it, often for years.</p></blockquote>

<p>简而言之，编程语言是City，而开发者则是Traveller——这是一个很有意思的比喻，在这篇文章里，我试图<strong>延续</strong>这个类比（Analogy）——把这个类比放大到初学，掌握，了解以至精通一门技术的层面。</p>

<p>不过需要注意：我自己并没有精通哪一门技术——所以这篇文章的内容是值得怀疑（susceptible）的，但它可以作为一个不错的参考。</p>

<h2>0. Stranger（陌生人）</h2>

<p>使用一项技术最初的层次就是听说过没用过——就像我们之中的大多数人都听过南极，听过北极，知道南极有企鹅，北极有北极熊，但是却从来没有去过南极或北极。</p>

<p>Stranger具有以下的特征：</p>

<ul>
<li>知道这项技术的名字。</li>
<li>知道这项技术的一些术语。</li>
<li>知道这项技术的一些关键人物的名字。</li>
<li>了解少量技术的细节，但没有使用这项技术的实际经验。</li>
</ul>


<p>以我本人和RoR来打个比方：</p>

<ul>
<li>知道RoR是Ruby on Rails。</li>
<li>知道Rails，Gem和Rake的存在。</li>
<li>知道DHH也知道松本行弘。</li>
<li>看过<a href="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/">The Ruby Programming Language</a>，还使用一个基于RoR的博客框架<a href="http://octopress.org/">Octopress</a>写博客。</li>
<li>但从来没有使用RoR去搭建网站。</li>
</ul>


<p>所以我是一个RoR的Stranger。</p>

<p>对于新技术，绝大多数人都是Stranger——但是就我对国内技术社区的观察，相当数量的Stranger意识不到自己还是Stranger——认为知道一点术语一些人名就算了解一门技术，甚至把它写在简历上（Familiar with XXX）或是开始与别人进行讨论（当然都是毫无意义的讨论）。</p>

<h2>1. Tourist（旅行者）</h2>

<p>当开发者真正开始用一项技术作出了可以用的东西：</p>

<ul>
<li>面向用户的产品（End-User-Oriented Product），比如一个手机应用，或是一个浏览器插件。</li>
<li>或是面向程序员的工具（Programmer-Oriented Tools），比如一个页面抓取框架，或一个简单的Parser Generator。</li>
<li>注意教科书范例（Textbook examples）和Hello world不属于可以用的东西——这些只是Dead Code——被执行一两次，然后被遗忘。</li>
</ul>


<p>这时这个开发者就进入到了Tourist阶段：</p>

<ul>
<li>了解这项技术的基本元素。</li>
<li>使用这项技术做出了实用的产品或工具。</li>
<li>了解对这项技术的部分细节。</li>
</ul>


<p>根据的学习目的的不同，Tourist又可以分为Salesman和Sightseer。</p>

<h3>1.1. Salesman（旅行商）</h3>

<p><img src="http://i.imgur.com/k5oucJ5.jpg" alt="Salesman" style="max-height: 370px;"/></p>

<p>Salesman是具有明确目的的Tourist——他们学习技术的目标是为了完成某一项业务，就像旅行商去某地出差是为了卖商品而非观光一样。</p>

<p>绝大多数职业开发者在开发生涯中都会扮演Salesman这个角色——接到一个任务，涉及到某项不熟悉的技术，需要在限定时间内完成。</p>

<h3>1.2. Sightseer（观光者）</h3>

<p><img src="http://i.imgur.com/RpYoDXc.gif" alt="Sightseer" style="max-height: 370px;"/></p>

<p>和Salesman相反，Sightseer学习技术的目标是为了拓展视野，增加见识，而非完成某项特定业务。</p>

<p>具有主动学习精神的开发者在业余时会时常扮演Sightseer角色——找到自己认为有价值的新技术或是基础知识进行系统学习，从而拓宽视野，提高水平。</p>

<h2>2. Resident（居住者）</h2>

<p>如果一个旅行者在一个地方待了半年以上，那么他/她就会变得原来越像当地人。随着Tourist对某项技术的日益精进，他/她会逐渐演变成这项技术的Resident：</p>

<ul>
<li>熟悉这项技术的基本元素。</li>
<li>熟悉这项技术的生态系统（Ecology）：既包括开发工具（编辑器，命令行工具，集成开发环境等），也包括开发社区（讨论组，邮件列表等）。</li>
<li>了解这项技术能做什么，不能做什么。</li>
<li>了解这项技术有那些坑，如何绕过这些坑，以及识别这些坑带来的问题。</li>
<li>对某些领域有深入的研究——但并不受限于特定领域。</li>
<li>使用这项技术做出了有相当价值的产品或工具。</li>
</ul>


<p>同Tourist一样，根据使用技术的目标不同，Resident可以分为Worker和Craftsman：</p>

<h2>2.1. Worker（工人）</h2>

<p><img src="http://i.imgur.com/jGNNrQp.jpg" alt="Worker" style="max-height: 370px;"/></p>

<p>技术是Worker的谋生手段，一个优秀的Worker应具备以下特征：</p>

<ul>
<li>对于给定问题，知道如何给出经济有效的解决方案。</li>
<li>以团队合作为主，了解团队合作的价值，能够推动团队项目健康前进。</li>
<li>追求按时交付。</li>
</ul>


<h3>2.2. Craftsman（工匠）</h3>

<p><img src="http://i.imgur.com/9RRUjmb.jpg" alt="Craftsman" style="max-height: 370px;"/></p>

<p>同Worker不同，技术并非Craftsman的谋生手段，而是某种“副业”——用来提升声望，修炼开发水平。</p>

<p>一个优秀的Craftman往往具备以下特点：</p>

<ul>
<li>对于给定问题，知道如何给出优雅的解决方案。</li>
<li>以单兵作战为主，主要靠个人推进项目，但也能进行一定程度的团队合作。</li>
<li>追求极致美感。</li>
</ul>


<h2>3. Architect（架构者）</h2>

<p>有想法且有能力的人在一个地方待久了都会有将这个地方变的更好的冲动——一种方式是从源头出发，推翻旧制度建立新社会，也就是革命；另一种方式则是保留现有的制度，对其进行温和但持续的改进，也就是改良。</p>

<p>技术也是如此，任何技术都跟不上开发者成长的脚步，当这种差距到达一定程度时，就会有卓越的开发者站出来，创造出新的技术，他们就是Architect：</p>

<ul>
<li>熟悉多项互相关联的技术，并了解他们的优势和不足。</li>
<li>具备强大的领导能力，深厚的基础和大量实际开发经验。</li>
<li>能够带动整个技术的生态系统发展。</li>
<li>好吧，我编不下去了（尼玛我要都知道我还至于是IT苦屌么 &ndash;_-）</li>
</ul>


<p>如果你看过<a href="http://movie.douban.com/subject/1304141/">Matrix 2: Reloaded</a></p>

<p><img src="http://i.imgur.com/EDyNv4F.jpg" alt="Matrix 2: Reloaded" style="max-height: 370px;"/></p>

<p>就会知道Architect这个词放在这里再好不过。</p>

<p>根据目标不同，Architect分为Reformist和Revolutionist。</p>

<h3>3.1. Reformist（改良者）</h3>

<p><img src="http://i.imgur.com/xp2SzWu.jpg" alt="Reformist" style="max-height: 370px;"/></p>

<p>改良者的目标：<strong>把现有技术变的更好</strong>。（<strong>Makes</strong> existing technology better）</p>

<p>例如：</p>

<ul>
<li>GoF总结<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Pattern</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/John_Resig">John Resig</a>创造<a href="http://en.wikipedia.org/wiki/Jquery">jQuery</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>为C#引入<a href="http://en.wikipedia.org/wiki/LINQ">LINQ</a>。</li>
</ul>


<h3>3.2. Revolutionist（革命者）</h3>

<p><img src="http://i.imgur.com/cpmjDCC.jpg" alt="Revolutionist" style="max-height: 370px;"/></p>

<p>革命者的目标：<strong>用更好的技术取代现有技术</strong>。（<strong>Replaces</strong> existing technology with better one）</p>

<p>例如：</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Alan_kay">Alan Kay</a>把细胞的概念引入软件开发]进而创造出<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的核心概念。</li>
<li><a href="http://en.wikipedia.org/wiki/Donald_Knuth">Don Knuth</a>对计算机算法（<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>）以及计算机排版（TEX）的贡献。</li>
<li>iPhone于2010年之前的任何手机（iPhone4除外）。</li>
</ul>


<h2>小结</h2>

<p>这篇文章利用<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>里的隐喻，把学习/使用技术分成了四个层次七个头衔：Stranger，Tourist（Salesman，Sightseer），Resident（Worker，Craftsman），Architect（Reformist，Revolutionist），然后给出了各个头衔所应具备的特征和能力。</p>

<h3>关于同类文章</h3>

<p>之前也有类似的文章，例如<a href="http://blog.itpub.net/6517/viewspace-611506/">程序员的十层境界</a>和<a href="http://blog.csdn.net/happydeer/article/details/8107560">开发者的八种境界</a></p>

<p>这些文章的共同点：</p>

<ol>
<li>看似很牛逼但回想一下啥都没说。</li>
<li>不会给人带来什么价值。</li>
<li>没有一个鉴别的标准。</li>
<li>没有指导性，也没有使用价值。</li>
</ol>


<h3>本文的应用场景</h3>

<h4>考察状态</h4>

<p>以我自己对编程语言的掌握为例：</p>

<ul>
<li>C/C++: Stranger.</li>
<li>Python: Craftsman.</li>
<li>Java: Worker.</li>
<li>C#: Craftsman.</li>
<li>JavaScript: Sightseer.</li>
<li>Scheme: Sightseer</li>
</ul>


<p>将上面的列表转置：</p>

<ul>
<li>Stranger: C/C++</li>
<li>Sightseer: JavaScript, Scheme</li>
<li>Worker: Java</li>
<li>Craftsman: C#, Python</li>
</ul>


<p>结合这些头衔的定义，一目了然。</p>

<h4>制定计划</h4>

<p>运用本文的词汇，可以进行非常精炼的计划制定：</p>

<ul>
<li>例如 Make a thoroughly <strong>sightseeing</strong> of <strong>C++</strong>；</li>
<li>或是 Become a proficient <strong>worker</strong> on <strong>IntelliJ</strong>；</li>
<li>抑或 Take a short <strong>tour</strong> of <strong>Sublime Text</strong>。</li>
</ul>


<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三月小结（暨TARQIE——一种量化成长的方法（下））]]></title>
    <link href="http://lucida.github.io/blog/summary-of-march-2014/"/>
    <updated>2014-04-06T23:24:33+01:00</updated>
    <id>http://lucida.github.io/blog/summary-of-march-2014</id>
    <content type="html"><![CDATA[<h1>三月小结（暨TARQIE——一种量化成长的方法（下））</h1>

<h2>目标实际完成情况</h2>

<h3>Tarqie-J</h3>

<ol>
<li>目标

<ul>
<li>高效完成Q1 OKR。 &ndash;> 1.0

<ul>
<li>搞定，超出Manager和Mentor的预期。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>成功迁移124个Test。 &ndash;> 1.0

<ul>
<li>搞定，并且构建了持续测试环境。</li>
</ul>
</li>
<li>为这些Test配置一个可稳定运行的环境。 &ndash;> 0.8

<ul>
<li>基本搞定，但仍存在少量（每天1~2次）的不稳定状况。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>恬着脸皮向不同的同事请教。 &ndash;> 1.0

<ul>
<li>达成——基本每个同事都被我骚扰了一遍 &ndash;_&ndash;</li>
</ul>
</li>
<li>理解当前Test的架构和流程。 &ndash;> 1.0

<ul>
<li>重建测试框架的过程中了解</li>
</ul>
</li>
<li>阅读The Art Of Unit Test，Guice Book和GuiceBerry Manual，了解如何用Guice写良好的Test。 &ndash;> 0.7

<ul>
<li>部分完成，阅读Google Guice Book，了解了Guice运作机制。</li>
</ul>
</li>
<li>阅读Java Best Practices和Effective Java。 &ndash;> 0.8

<ul>
<li>部分完成，重新阅读了JBP，但Effective Java只看了一多半。</li>
</ul>
</li>
<li>阅读Java Performance，了解JVM。 &ndash;> 0.7

<ul>
<li>部分完成，阅读了国产的<a href="http://book.douban.com/subject/24722612/">《深入理解Java虚拟机》</a>，了解Java内存管理/回收，字节码生成等内容。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>每周与mentor交流，进行进度控制/难点求助。 &ndash;> 0.6

<ul>
<li>由于mentor结婚度蜜月所以没有达成。</li>
</ul>
</li>
<li>Test的数量不断增加。 &ndash;> 1.0

<ul>
<li>达成——事实上全部搞定。</li>
</ul>
</li>
<li>CL中review的数量持续降低。 &ndash;> 1.0

<ul>
<li>搞定，成功的从每次提交代码20余个review降至小于6个。</li>
</ul>
</li>
<li>逐步理解项目代码背后的机理。 &ndash;> 0.6

<ul>
<li>部分搞定，对项目测试框架已经相当了解了（毕竟自己重新搭建了整个框架），但对整个项目的各个模块，交互流程还是一头雾水。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.85</p>

<h3>Tarqie-L</h3>

<ol>
<li>目标

<ul>
<li>提高精力，理解Python。 &ndash;> 0.8

<ul>
<li>精力小有提高，至于Python——实现机制不太了解，但Python语法和编程风格我现在有足够自信——毕竟写了一个程序解析合法的Python然后生成同等语义的Google风格的Python，再加上身边有一个Python Readability Reviewer，说自己现在达到中级Python开发者的水准应该不为过。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>精力提高（自然醒，不赖床）。 &ndash;> 0.6

<ul>
<li>自然醒但依然赖床——-_&ndash;</li>
</ul>
</li>
<li>熟悉Python及其实现。 &ndash;> 0.8

<ul>
<li>部分搞定，见上文。</li>
</ul>
</li>
<li>理解4个开源项目的架构。 &ndash;> 1.0

<ul>
<li>搞定，见下文。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>早睡早起（11:30 PM ~ 8:30 AM）+每天运动20分钟。 &ndash;> 0.7

<ul>
<li>早睡早起没做到，运动的频率两周一次。</li>
</ul>
</li>
<li>阅读相关技术书籍（Python源码剖析，开源项目架构等）。 &ndash;> 0.6

<ul>
<li>部分完成，Python源码剖析只读了第一章，但开源项目架构每周一篇。</li>
</ul>
</li>
<li>增强学习能力（阅读《Study Less, Learn More》） &ndash;> 1.0

<ul>
<li>完成。</li>
</ul>
</li>
<li>控制手淫频率至两周一次。 &ndash;> 1.0 &ndash;_&ndash;

<ul>
<li>完成。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>早睡早起+运动不间断。 &ndash;> 0.5

<ul>
<li>搞定一半。两天运动一次。</li>
</ul>
</li>
<li>学习能力增强（+系统学习能力）。 &ndash;> 1.0

<ul>
<li>部分做到，但很难验证——不过用十天搞出了另外一个家伙搞了5个月的东西应该能说明部分问题。</li>
</ul>
</li>
<li>逐步理解Python各个部分的实现（对象，语句，元组，列表，字典，控制流，异常，自定义类型，列表理解，生成器，模块，从源码了解其机制）。 &ndash;> 1.0

<ul>
<li>没有阅读代码，但完成了一个Python Formatter——把Python代码转换成AST再转换回等语义的<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>代码。</li>
</ul>
</li>
<li>每周理解1个开源项目的架构。 &ndash;> 1.0

<ul>
<li>完成——阅读了<a href="http://aosabook.org/en/bash.html">Bash</a>, <a href="http://aosabook.org/en/selenium.html">Selenium WebDriver</a>, <a href="http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">Chrome</a>和<a href="http://aosabook.org/en/posa/parsing-xml-at-the-speed-of-light.html">puginxml</a>。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.8</p>

<h3>成就</h3>

<h4>工作</h4>

<ol>
<li>构建新的测试环境并迁移原有的测试用例。

<ul>
<li>各种神坑，Team/MailList/Group/ReadTheFuckingSource。</li>
<li>manager一度问我是否需要support——想了想还是撑下来了，还好搞定了。</li>
<li>神奇的发现自己第一次实习时做的也是migration，尼玛难道是轮回？</li>
</ul>
</li>
<li>利用业余时间构建了pyfmt——基于AST的代码格式化工具，生成符合<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>的等语义代码。

<ul>
<li>速度是公司工具的6倍到50倍不等（已验证）。</li>
<li>速度是<a href="https://github.com/hhatto/autopep8">autopep8</a>的3倍到30倍（已验证）。</li>
<li>生成的代码质量基本等同（待验证）。</li>
<li>代码量是<a href="https://github.com/hhatto/autopep8">autopep8</a>的二分之一。</li>
<li>不依赖任何第三方库。</li>
<li>不使用任何正则表达式——Never send a regex to do a parser&rsquo;s job.</li>
</ul>
</li>
</ol>


<h4>生活</h4>

<ol>
<li>重新实现了自己两年前写的Lucida。

<ul>
<li>重新设计类型系统，进行尾递归优化。然后完成<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">《90分钟实现一门编程语言——极简解释器教程》</a>，写作之余想通了之前很多迷惑的地方。</li>
<li>功能基本等同，代码量是前一版的八分之一，运行速度是前一版的270倍（倒不是这一版效率有多高，主要是前一版写的太挫了）</li>
</ul>
</li>
<li><a href="http://zh.lucida.me/blog/on-reading-books/">《如何阅读书籍》</a>和<a href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/">《网络上瘾及其解决方法》</a>两篇议论型博客。</li>
<li>完整的完成一个引体向上。</li>
</ol>


<h3>阅读列表</h3>

<ul>
<li><a href="http://book.douban.com/subject/3814402/">The Quick Python Book</a></li>
<li><a href="http://book.douban.com/subject/25710862/">Getting Started with Google Guava</a></li>
<li><a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a></li>
<li><a href="http://book.douban.com/subject/24383461/">网络素养</a></li>
<li><a href="http://book.douban.com/subject/25783654/">如何高效学习</a></li>
<li><a href="http://book.douban.com/subject/3009235/">Google Guice</a></li>
<li><a href="http://aosabook.org/en/index.html">The Architecture of Open Source Applications</a></li>
</ul>


<h3>一些体会</h3>

<ol>
<li>慢读慎写——读书不是靠页数，代码不是拼行数。</li>
<li>精益求精——严肃认真对待自己的任何一个项目/作品，每一行代码，每一个细节都应有其意义。</li>
<li>Don&rsquo;t <a href="http://en.wikipedia.org/wiki/Satisfice">satisfice</a>—— 在时间充裕的情况下，尽力寻找最优解，而不是找到一个答案就满足。</li>
<li>Have a mentor/coach——无论学习什么，身边要有一个大师级人物，不要盲目相信自学能力——坑大多都是自己挖出来的。</li>
<li>在合适的抽象层工作（Working at a proper abstraction layer），包括下面几点：

<ul>
<li>找到与目标最契合的层次：

<ul>
<li>如果层级过高就会造成性能损失和功能缺失。</li>
<li>如果层次过低就会变成重造轮子。</li>
</ul>
</li>
<li>总是在同一个层次工作——以避免上下文切换。</li>
<li>将复杂度封装到各自对应的层次——以避免进行交互——<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li>
</ul>
</li>
</ol>


<h3>发现的问题</h3>

<ol>
<li>3月目标制定的过于宏大——尽管完成度不错，但代价也很大——工作时间从每天8小时增加到10小时，到了后期的阅读时间几乎被缩减到零，接下来会相应的缩小计划目标。</li>
<li>除了工作就是学习，导致略抑郁——尽管做出的东西带来了一点成就感。总之接下来需要更多的娱乐。</li>
<li>猛然反应过来所谓的TARQIE其实就是OKR（<a href="http://en.wikipedia.org/wiki/OKR">Objective-Key-Results</a>）——所以接下来直接使用<a href="http://en.wikipedia.org/wiki/OKR">OKR</a>制定计划，更加简洁。</li>
</ol>


<h3>4月计划</h3>

<h3>OKR-J</h3>

<ul>
<li>目标

<ol>
<li>完整迁移测试到原项目中。</li>
<li>稳定+推广pyfmt。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>成功迁移124个Test到原项目。</li>
<li>将测试的不稳定性控制在每天3次以下。</li>
<li>pyfmt通过Python Readability。</li>
<li>pyfmt有10个以上的用户。</li>
<li>pyfmt从experimental进入devtools（略激进，但值得一试）。</li>
</ol>
</li>
</ul>


<h3>OKR-L</h3>

<ul>
<li>目标

<ol>
<li>正常作息，提高精力。</li>
<li>结合pyfmt，深度理解Python。</li>
<li>加深对Java &amp; JVM的理解。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>理解Python各个部分的实现，从源码了解其机制。</li>
<li>阅读并理解两个以上的开源项目架构。</li>
<li>完成<a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a>，阅读<a href="http://www.amazon.co.uk/Java-Performance-Addison-Wesley-Charlie-Hunt/dp/0137142528/">《Java Performance》</a>至50%。</li>
<li>迁移测试的同时完成<a href="http://www.amazon.co.uk/Effective-Unit-Testing-guide-developers/dp/1935182579/">Effective Unit Testing: A guide for Java developers</a>的阅读。</li>
<li>早睡<em>晚</em>起（8:40 ~ 23:50）</li>
<li>控制手淫频率至两周一次。</li>
<li>至少两天一次20分钟的运动。</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[90分钟实现一门编程语言——极简解释器教程]]></title>
    <link href="http://lucida.github.io/blog/how-to-implement-an-interpreter-in-csharp/"/>
    <updated>2014-03-23T19:08:35+00:00</updated>
    <id>http://lucida.github.io/blog/how-to-implement-an-interpreter-in-csharp</id>
    <content type="html"><![CDATA[<h1>90分钟实现一门编程语言——极简解释器教程</h1>

<h2>关键字</h2>

<p>解释器, C#, Scheme, 函数式编程</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/</a></p>

<h2>关于</h2>

<p>本文介绍了如何使用C#实现一个简化Scheme——iScheme及其解释器。</p>

<p>如果你对下面的内容感兴趣：</p>

<ul>
<li>实现基本的词法分析，语法分析并生成抽象语法树。</li>
<li>实现嵌套作用域和函数调用。</li>
<li>解释器的基本原理。</li>
<li>以及一些C#编程技巧。</li>
</ul>


<p>那么请继续阅读。</p>

<p>如果你对以下内容感兴趣：</p>

<ul>
<li>高级的词法/语法分析技术。</li>
<li>类型推导/分析。</li>
<li>目标代码优化。</li>
</ul>


<p>本文则过于初级，你可以跳过本文，但欢迎指出本文的错误 :&ndash;)</p>

<h2>代码样例</h2>

<p>```csharp 代码示例
public static int Add(int a, int b) {</p>

<pre><code>return a + b;
</code></pre>

<p>}</p>

<blockquote><blockquote><p>Add(3, 4)
7</p>

<p>Add(5, 5)
10
```</p></blockquote></blockquote>

<p>这段代码定义了<code>Add</code>函数，接下来的<code>&gt;&gt;</code>符号表示对<code>Add(3, 4)</code>进行求值，再下一行的<code>&gt;&gt; 7</code>表示上一行的求值结果，不同的求值用换行分开。可以把这里的<code>&gt;&gt;</code>理解成控制台提示符（即Terminal中的PS）。</p>

<h2>什么是解释器</h2>

<p><img src="http://i.imgur.com/C8lxHfr.jpg" alt="解释器图示" /></p>

<p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>（Interpreter）是一种程序，能够读入程序并直接输出结果，如上图。相对于<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>（Compiler），<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>并不会生成目标机器代码，而是直接运行源程序，简单来说：</p>

<blockquote><p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>是运行程序的程序。</p></blockquote>

<p>计算器就是一个典型的解释器，我们把数学公式（源程序）给它，它通过运行它内部的"解释器"给我们答案。</p>

<p><img src="http://i.imgur.com/FC1nqko.jpg" alt="CASIO 计算器" /></p>

<h2>iScheme编程语言</h2>

<p>iScheme是什么？</p>

<ul>
<li>Scheme语言的一个极简子集。</li>
<li>虽然小，但变量，算术|比较|逻辑运算，列表，函数和递归这些编程语言元素一应俱全。</li>
<li>非常非常慢——可以说它只是为演示本文的概念而存在。</li>
</ul>


<p>OK，那么Scheme是什么？</p>

<ul>
<li>一种函数式程序设计语言。</li>
<li>一种Lisp方言。</li>
<li>麻省理工学院程序设计入门课程使用的语言（参见<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">MIT 6.001</a>和《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造与解释</a>》）。</li>
</ul>


<p><img src="http://i.imgur.com/66TdRMD.jpg" alt="计算机程序的构造与解释" /></p>

<ul>
<li>使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>（Polish Notation）。</li>
<li>更多的介绍参见<a href="http://zh.wikipedia.org/wiki/Scheme">Scheme编程语言</a>。</li>
</ul>


<p>以计算阶乘为例：</p>

<p>```csharp C#版阶乘
public static int Factorial(int n) {</p>

<pre><code>if (n == 1) {
    return 1;
} else {
    return n * Factorial(n - 1);
}
</code></pre>

<p>}
```</p>

<p>```scm iScheme版阶乘
(def factorial (lambda (n) (</p>

<pre><code>if (= n 1)
   1
   (* n (factorial (- n 1))))))
</code></pre>

<p>```</p>

<h3>数值类型</h3>

<p>由于iScheme只是一个用于演示的语言，所以目前只提供对整数的支持。iScheme使用C#的<code>Int64</code>类型作为其内部的数值表示方法。</p>

<h3>定义变量</h3>

<p><code>``scm iScheme使用</code>def`关键字定义变量</p>

<blockquote><blockquote><p>(def a 3)
3</p>

<p>a
3
```</p></blockquote></blockquote>

<h3>算术|逻辑|比较操作</h3>

<p>与常见的编程语言（C#, Java, C++, C）不同，Scheme使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>，即前缀表示法。例如：</p>

<p>```csharp C#中的算术|逻辑|比较操作
// Arithmetic ops
a + b * c
a / (b + c + d)
// Logical ops
(cond1 &amp;&amp; cond2) || cond3
// Comparing ops
a == b
1 &lt; a &amp;&amp; a &lt; 3</p>

<p>```</p>

<p><code>scm 对应的iScheme代码
; Arithmetic ops
(+ a (* b c))
(/ a (+ b c d))
; Logical ops
(or (and cond1 cond2) cond3)
; Comparing ops
(= a b)
(&lt; 1 a 3)
</code></p>

<p>需要注意的几点：</p>

<ol>
<li>iScheme中的操作符可以接受不止两个参数——这在一定程度上控制了括号的数量。</li>
<li>iScheme逻辑操作使用<code>and</code>, <code>or</code>和<code>not</code>代替了常见的<code>&amp;&amp;</code>, <code>||</code>和<code>!</code>——这在一定程度上增强了程序的可读性。</li>
</ol>


<h3>顺序语句</h3>

<p>iScheme使用<code>begin</code>关键字标识顺序语句，并以最后一条语句的值作为返回结果。以求两个数的平均值为例：</p>

<p><code>csharp C#的顺序语句
int a = 3;
int b = 5;
int c = (a + b) / 2;
</code></p>

<p>```scm iScheme的顺序语句
(def c (begin</p>

<pre><code>(def a 3)
(def b 5)
(/ (+ a b) 2)))
</code></pre>

<p>```</p>

<h3>控制流操作</h3>

<p>iScheme中的控制流操作只包含<code>if</code>。</p>

<p>```scm if语句示例</p>

<blockquote><blockquote><p>(define a (if (> 3 2) 1 2))
1</p>

<p>a
1
```</p></blockquote></blockquote>

<h3>列表类型</h3>

<p>iScheme使用<code>list</code>关键字定义列表，并提供<code>first</code>关键字获取列表的第一个元素；提供<code>rest</code>关键字获取列表除第一个元素外的元素。</p>

<p>```scm iScheme的列表示例</p>

<blockquote><blockquote><p>(define alist (list 1 2 3 4))
(list 1 2 3 4)</p>

<p>(first alist)
1</p>

<p>(rest alist)
(2 3 4)
```</p></blockquote></blockquote>

<h3>定义函数</h3>

<p>iScheme使用<code>func</code>关键字定义函数：</p>

<p>```scm iScheme的函数定义
(def square (func (x) (* x x)))</p>

<p>(def sum_square (func (a b) (+ (square a) (square b))))
```</p>

<p>```csharp 对应的C#代码
public static int Square (int x) {</p>

<pre><code>return x * x;
</code></pre>

<p>}</p>

<p>public static int SumSquare(int a, int b) {</p>

<pre><code>return Square(a) + Square(b);
</code></pre>

<p>}
```</p>

<h3>递归</h3>

<p>由于iScheme中没有<code>for</code>或<code>while</code>这种命令式语言（Imperative Programming Language）的循环结构，递归成了重复操作的唯一选择。</p>

<p>以计算最大公约数为例：</p>

<p>```scm iScheme计算最大公约数
(def gcd (func (a b)</p>

<pre><code>(if (= b 0)
    a
    (func (b (% a b))))))
</code></pre>

<p>```</p>

<p>```csharp 对应的C#代码
public static int GCD (int a, int b) {</p>

<pre><code>if (b == 0) {
    return a;
} else {
    return GCD(b, a % b);
}
</code></pre>

<p>}
```</p>

<h3>高阶函数</h3>

<p>和Scheme一样，函数在iScheme中是头等对象，这意味着：</p>

<ul>
<li>可以定义一个变量为函数。</li>
<li>函数可以接受一个函数作为参数。</li>
<li>函数返回一个函数。</li>
</ul>


<p>```scm iScheme的高阶函数示例
; Defines a multiply function.
(def mul (func (a b) (* a b)))
; Defines a list map function.
(def map (func (f alist)</p>

<pre><code>(if (empty? alist)
    (list )
    (append (list (f (first alist))) (map f (rest alist)))
    )))
</code></pre>

<p>; Doubles a list using map and mul.</p>

<blockquote><blockquote><p>(map (mul 2) (list 1 2 3))
(list 2 4 6)
```</p></blockquote></blockquote>

<h3>小结</h3>

<p>对iScheme的介绍就到这里——事实上这就是iScheme的所有元素，会不会太简单了？ &ndash;_&ndash;</p>

<p>接下来进入正题——从头开始构造iScheme的解释程序。</p>

<h2>解释器构造</h2>

<p>iScheme解释器主要分为两部分，解析（Parse）和求值（Evaluation）：</p>

<ul>
<li>解析（Parse）：解析源程序，并生成解释器可以理解的中间（Intermediate）结构。这部分包含词法分析，语法分析，语义分析，生成语法树。</li>
<li>求值（Evaluation）：执行解析阶段得到的中介结构然后得到运行结果。这部分包含作用域，类型系统设计和语法树遍历。</li>
</ul>


<h3>词法分析</h3>

<p>词法分析负责把源程序解析成一个个词法单元（Lex），以便之后的处理。</p>

<p>iScheme的词法分析极其简单——由于iScheme的词法元素只包含括号，空白，数字和变量名，因此C#自带的<code>String#Split</code>就足够。</p>

<p>```csharp iScheme的词法分析及测试
public static String[] Tokenize(String text) {</p>

<pre><code>String[] tokens = text.Replace("(", " ( ").Replace(")", " ) ").Split(" \t\r\n".ToArray(), StringSplitOptions.RemoveEmptyEntries);
return tokens;
</code></pre>

<p>}</p>

<p>// Extends String.Join for a smooth API.
public static String Join(this String separator, IEnumerable<Object> values) {</p>

<pre><code>return String.Join(separator, values);
</code></pre>

<p>}</p>

<p>// Displays the lexes in a readable form.
public static String PrettyPrint(String[] lexes) {</p>

<pre><code>return "[" + ", ".Join(lexes.Select(s =&gt; "'" + s + "'") + "]";
</code></pre>

<p>}</p>

<p>// Some tests</p>

<blockquote><blockquote><p>PrettyPrint(Tokenize(&ldquo;a&rdquo;))
[&lsquo;a&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(def a 3)&rdquo;))
[&lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(begin (def a 3) (<em> a a))&rdquo;))
[&lsquo;begin&rsquo;, &lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;, &lsquo;(&rsquo;, &lsquo;</em>&rsquo;, &lsquo;a&rsquo;, &lsquo;a&rsquo;, &lsquo;)&rsquo;, &lsquo;)&rsquo;]
```</p></blockquote></blockquote>

<h4>注意</h4>

<ul>
<li>个人不喜欢<code>String.Join</code>这个静态方法，所以这里使用C#的<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>（Extension Methods）对String类型做了一个扩展。</li>
<li>相对于LINQ Syntax，我个人更喜欢LINQ Extension Methods，接下来的代码也都会是这种风格。</li>
<li>不要以为词法分析都是这么离谱般简单！vczh的<a href="http://www.cnblogs.com/geniusvczh/p/3577561.html">词法分析教程</a>给出了一个完整编程语言的词法分析教程。</li>
</ul>


<h3>语法树生成</h3>

<p>得到了词素之后，接下来就是进行语法分析。不过由于Lisp类语言的程序即是语法树，所以语法分析可以直接跳过。</p>

<p>以下面的程序为例：</p>

<p>```scm 程序即语法树
;
(def x (if (> a 1) a 1))
; 换一个角度看的话：
(</p>

<pre><code>def
x
(
    if
    (
        &gt;
        a
        1
    )
    a
    1
)
</code></pre>

<p>)
```</p>

<p>更加直观的图片：</p>

<p><img src="http://i.imgur.com/NVolNQE.png" alt="抽象语法树" /></p>

<p>这使得<a href="http://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>（Abstract Syntax Tree）的构建变得极其简单（无需考虑操作符优先级等问题），我们使用<code>SExpression</code>类型定义iScheme的语法树（事实上<a href="http://en.wikipedia.org/wiki/S-expression">S Expression</a>也是Lisp表达式的名字）。</p>

<p>```csharp 抽象语法树的定义
public class SExpression {</p>

<pre><code>public String Value { get; private set; }
public List&lt;SExpression&gt; Children { get; private set; }
public SExpression Parent { get; private set; }

public SExpression(String value, SExpression parent) {
    this.Value = value;
    this.Children = new List&lt;SExpression&gt;();
    this.Parent = parent;
}

public override String ToString() {
    if (this.Value == "(") {
        return "(" + " ".Join(Children) + ")";
    } else {
        return this.Value;
    }
}
</code></pre>

<p>}
```</p>

<p>然后用下面的步骤构建语法树：</p>

<ol>
<li>碰到左括号，创建一个新的节点到当前节点（<code>current</code>），然后重设当前节点。</li>
<li>碰到右括号，回退到当前节点的父节点。</li>
<li>否则把为当前词素创建节点，添加到当前节点中。</li>
</ol>


<p>```csharp 抽象语法树的构建过程
public static SExpression ParseAsIScheme(this String code) {</p>

<pre><code>SExpression program = new SExpression(value: "", parent: null);
SExpression current = program;
foreach (var lex in Tokenize(code)) {
    if (lex == "(") {
        SExpression newNode = new SExpression(value: "(", parent: current);
        current.Children.Add(newNode);
        current = newNode;
    } else if (lex == ")") {
        current = current.Parent;
    } else {
        current.Children.Add(new SExpression(value: lex, parent: current));
    }
}
return program.Children[0];
</code></pre>

<p>}
```</p>

<h4>注意</h4>

<ul>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb384054.aspx">自动属性</a>（Auto Property），从而避免重复编写样版代码（Boilerplate Code）。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/dd264739.aspx">命名参数</a>（Named Parameters）提高代码可读性：<code>new SExpression(value: "", parent: null)</code>比<code>new SExpression("", null)</code>可读。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>提高代码流畅性：<code>code.Tokenize().ParseAsIScheme</code>比<code>ParseAsIScheme(Tokenize(code))</code>流畅。</li>
<li>大多数编程语言的语法分析不会这么简单！如果打算实现一个类似C#的编程语言，你需要更强大的语法分析技术：

<ul>
<li>如果打算手写语法分析器，可以参考LL(k), Precedence Climbing和Top Down Operator Precedence。</li>
<li>如果打算生成语法分析器，可以参考ANTLR或Bison。</li>
</ul>
</li>
</ul>


<h3>作用域</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>决定程序的运行环境。iScheme使用嵌套作用域。</p>

<p>以下面的程序为例</p>

<p>```scm</p>

<blockquote><blockquote><p>(def x 1)
1</p>

<p>(def y (begin (def x 2) (* x x)))
4</p>

<p>x
1
```</p></blockquote></blockquote>

<p><img src="http://i.imgur.com/TzBY0vd.jpg" alt="作用域示例" /></p>

<p>利用C#提供的<code>Dictionary&lt;TKey, TValue&gt;</code>类型，我们可以很容易的实现iScheme的作用域<code>SScope</code>：</p>

<p>```csharp iScheme的作用域实现
public class SScope {</p>

<pre><code>public SScope Parent { get; private set; }
private Dictionary&lt;String, SObject&gt; variableTable;

public SScope(SScope parent) {
    this.Parent = parent;
    this.variableTable = new Dictionary&lt;String, SObject&gt;();
}

public SObject Find(String name) {
    SScope current = this;
    while (current != null) {
        if (current.variableTable.ContainsKey(name)) {
            return current.variableTable[name];
        }
        current = current.Parent;
    }
    throw new Exception(name + " is not defined.");
}

public SObject Define(String name, SObject value) {
    this.variableTable.Add(name, value);
    return value;
}
</code></pre>

<p>}
```</p>

<h3>类型实现</h3>

<p>iScheme的类型系统极其简单——只有数值，Bool，列表和函数，考虑到他们都是iScheme里面的值对象（Value Object），为了便于对它们进行统一处理，这里为它们设置一个统一的父类型<code>SObject</code>：</p>

<p><code>csharp
public class SObject { }
</code></p>

<h4>数值类型</h4>

<p>iScheme的数值类型只是对.Net中<code>Int64</code>（即C#里的<code>long</code>）的简单封装：</p>

<p>```csharp
public class SNumber : SObject {</p>

<pre><code>private readonly Int64 value;
public SNumber(Int64 value) {
    this.value = value;
}
public override String ToString() {
    return this.value.ToString();
}
public static implicit operator Int64(SNumber number) {
    return number.value;
}
public static implicit operator SNumber(Int64 value) {
    return new SNumber(value);
}
</code></pre>

<p>}
```</p>

<p>注意这里使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p><code>csharp
SNumber foo = 30;
SNumber bar = 40;
SNumber foobar = foo * bar;
</code></p>

<p>而不必：</p>

<p><code>csharp
SNumber foo = new SNumber(value: 30);
SNumber bar = new SNumber(value: 40);
SNumber foobar = new SNumber(value: foo.Value * bar.Value);
</code></p>

<p>为了方便，这里也为SObject增加了<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>（尽管<code>Int64</code>可以被转换为<code>SNumber</code>且<code>SNumber</code>继承自<code>SObject</code>，但.Net无法直接把<code>Int64</code>转化为<code>SObject</code>）：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Int64 value) {
    return (SNumber)value;
}
</code></pre>

<p>}
```</p>

<h4>Bool类型</h4>

<p>由于Bool类型只有True和False，所以使用静态对象就足矣。</p>

<p>```csharp
public class SBool : SObject {</p>

<pre><code>public static readonly SBool False = new SBool();
public static readonly SBool True = new SBool();
public override String ToString() {
    return ((Boolean)this).ToString();
}
public static implicit operator Boolean(SBool value) {
    return value == SBool.True;
}
public static implicit operator SBool(Boolean value) {
    return value ? True : False;
}
</code></pre>

<p>}
```</p>

<p>这里同样使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p>```csharp
SBool foo = a > 1;
if (foo) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>而不用</p>

<p>```csharp
SBool foo = a > 1 ? SBool.True: SBool.False;
if (foo == SBool.True) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>同样，为<code>SObject</code>增加<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Boolean value) {
    return (SBool)value;
}
</code></pre>

<p>}
```</p>

<h4>列表类型</h4>

<p>iScheme使用.Net中的<code>IEnumberable&lt;T&gt;</code>实现列表类型<code>SList</code>：</p>

<p>```csharp
public class SList : SObject, IEnumerable<SObject> {</p>

<pre><code>private readonly IEnumerable&lt;SObject&gt; values;
public SList(IEnumerable&lt;SObject&gt; values) {
    this.values = values;
}
public override String ToString() {
    return "(list " + " ".Join(this.values) + ")";
}
public IEnumerator&lt;SObject&gt; GetEnumerator() {
    return this.values.GetEnumerator();
}
IEnumerator IEnumerable.GetEnumerator() {
    return this.values.GetEnumerator();
}
</code></pre>

<p>}
```</p>

<p>实现<code>IEnumerable&lt;SObject&gt;</code>后，就可以直接使用LINQ的一系列扩展方法，十分方便。</p>

<h4>函数类型</h4>

<p>iScheme的函数类型（<code>SFunction</code>）由三部分组成：</p>

<ul>
<li>函数体：即对应的<code>SExpression</code>。</li>
<li>参数列表。</li>
<li>作用域：函数拥有自己的作用域</li>
</ul>


<p>```csharp SFunction的实现
public class SFunction : SObject {</p>

<pre><code>public SExpression Body { get; private set; }
public String[] Parameters { get; private set; }
public SScope Scope { get; private set; }
public Boolean IsPartial {
    get {
        return this.ComputeFilledParameters().Length.InBetween(1, this.Parameters.Length);
    }
}

public SFunction(SExpression body, String[] parameters, SScope scope) {
    this.Body = body;
    this.Parameters = parameters;
    this.Scope = scope;
}

public SObject Evaluate() {
    String[] filledParameters = this.ComputeFilledParameters();
    if (filledParameters.Length &lt; Parameters.Length) {
        return this;
    } else {
        return this.Body.Evaluate(this.Scope);
    }
}

public override String ToString() {
    return String.Format("(func ({0}) {1})",
        " ".Join(this.Parameters.Select(p =&gt; {
            SObject value = null;
            if ((value = this.Scope.FindInTop(p)) != null) {
                return p + ":" + value;
            }
            return p;
        })), this.Body);
}

private String[] ComputeFilledParameters() {
    return this.Parameters.Where(p =&gt; Scope.FindInTop(p) != null).ToArray();
}
</code></pre>

<p>}
```</p>

<h5>需要注意的几点</h5>

<ul>
<li>iScheme支持部分求值（Partial Evaluation），这意味着：</li>
</ul>


<p>```scm 部分求值</p>

<blockquote><blockquote><p>(def mul (func (a b) (<em> a b)))
(func (a b) (</em> a b))</p>

<p>(mul 3 4)
12</p>

<p>(mul 3)
(func (a:3 b) (* a b))</p>

<p>((mul 3) 4)
12
```</p></blockquote></blockquote>

<p>也就是说，当<code>SFunction</code>的实际参数（Argument）数量小于其形式参数（Parameter）的数量时，它依然是一个函数，无法被求值。</p>

<p>这个功能有什么用呢？生成高阶函数。有了部分求值，我们就可以使用</p>

<p>```scm
(def mul (func (a b) (* a b)))
(def mul3 (mul 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<p>而不用专门定义一个生成函数：</p>

<p>```scm
(def times (func (n) (func (n x) (* n x)) ) )
(def mul3 (times 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<ul>
<li><code>SFunction#ToString</code>可以将其自身还原为源代码——从而大大简化了iScheme的理解和测试。</li>
</ul>


<h3>内置操作</h3>

<p>iScheme的内置操作有四种：算术|逻辑|比较|列表操作。</p>

<p>我选择了表达力（Expressiveness）强的lambda方法表来定义内置操作：</p>

<p>首先在<code>SScope</code>中添加静态字段<code>builtinFunctions</code>，以及对应的访问属性<code>BuiltinFunctions</code>和操作方法<code>BuildIn</code>。</p>

<p>```csharp
public class SScope {</p>

<pre><code>private static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; builtinFunctions =
    new Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt;();
public static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; BuiltinFunctions {
    get { return builtinFunctions; }
}
// Dirty HACK for fluent API.
public SScope BuildIn(String name, Func&lt;SExpression[], SScope, SObject&gt; builtinFuntion) {
    SScope.builtinFunctions.Add(name, builtinFuntion);
    return this;
}
</code></pre>

<p>}
```</p>

<p>注意：</p>

<ol>
<li><code>Func&lt;T1, T2, TRESULT&gt;</code>是C#提供的委托类型，表示一个接受<code>T1</code>和<code>T2</code>，返回<code>TRESULT</code></li>
<li>这里有一个小HACK，使用实例方法（Instance Method）修改静态成员（Static Member），从而实现一套流畅的API（参见<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>）。</li>
</ol>


<p>接下来就可以这样定义内置操作：</p>

<p>```csharp
new SScope(parent: null)</p>

<pre><code>.BuildIn("+", addMethod)
.BuildIn("-", subMethod)
.BuildIn("*", mulMethod)
.BuildIn("/", divMethod);
</code></pre>

<p>```</p>

<p>一目了然。</p>

<h4>断言（Assertion）扩展</h4>

<p>为了便于进行<a href="http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，我对<code>Boolean</code>类型做了一点点扩展。</p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>从而可以写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<p>而不用</p>

<p>```csharp
if (a &lt; 3) {</p>

<pre><code>    throw new Exception("Value must be less than 3.");
</code></pre>

<p>}
```</p>

<h4>算术操作</h4>

<p>iScheme算术操作包含<code>+ - * / %</code>五个操作，它们仅应用于数值类型（也就是<code>SNumber</code>）。</p>

<p>从加减法开始：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;();
return numbers.Sum(n =&gt; n);
</code></pre>

<p>})
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;().ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>注意到这里有一段重复逻辑负责转型求值（Cast then Evaluation），考虑到接下来还有不少地方要用这个逻辑，我把这段逻辑抽象成扩展方法：</p>

<p>```csharp
public static IEnumerable<T> Evaluate<T>(this IEnumerable<SExpression> expressions, SScope scope)
where T : SObject {</p>

<pre><code>return expressions.Evaluate(scope).Cast&lt;T&gt;();
</code></pre>

<p>}
public static IEnumerable<SObject> Evaluate(this IEnumerable<SExpression> expressions, SScope scope) {</p>

<pre><code>return expressions.Select(exp =&gt; exp.Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>然后加减法就可以如此定义：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => (args.Evaluate<SNumber>(scope).Sum(s => s)))
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>乘法，除法和求模定义如下：</p>

<p>```csharp
.BuildIn(&ldquo;*&rdquo;, (args, scope) => args.Evaluate<SNumber>(scope).Aggregate((a, b) => a * b))
.BuildIn(&ldquo;/&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
return firstValue / numbers.Skip(1).Aggregate((a, b) =&gt; a * b);
</code></pre>

<p>})
.BuildIn(&ldquo;%&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 2).OrThrows("Parameters count in mod should be 2");
var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
return numbers[0] % numbers[1];
</code></pre>

<p>})
```</p>

<h4>逻辑操作</h4>

<p>iScheme逻辑操作包括<code>and</code>，<code>or</code>和<code>not</code>，即与，或和非。</p>

<p>需要注意的是iScheme逻辑操作是<a href="http://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a>（Short-circuit evaluation），也就是说：</p>

<ul>
<li><code>(and condA condB)</code>，如果<code>condA</code>为假，那么整个表达式为假，无需对<code>condB</code>求值。</li>
<li><code>(or condA condB)</code>，如果<code>condA</code>为真，那么整个表达式为真，无需对<code>condB</code>求值。</li>
</ul>


<p>此外和<code>+ - * /</code>一样，<code>and</code>和<code>or</code>也可以接收任意数量的参数。</p>

<p>需求明确了接下来就是实现，iScheme的逻辑操作实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;and&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return !args.Any(arg =&gt; !(SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;or&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return args.Any(arg =&gt; (SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;not&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 1).OrThrows();
return args[0].Evaluate(scope);
</code></pre>

<p>})
```</p>

<h4>比较操作</h4>

<p>iScheme的比较操作包括<code>= &lt; &gt; &gt;= &lt;=</code>，需要注意下面几点：</p>

<ul>
<li><code>=</code>是比较操作而非赋值操作。</li>
<li>同算术操作一样，它们应用于数值类型，并支持任意数量的参数。</li>
</ul>


<p><code>=</code>的实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;=&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 1).OrThrows("Must have more than 1 argument in relation operation.");
SNumber current = (SNumber)args[0].Evaluate(scope);
foreach (var arg in args.Skip(1)) {
    SNumber next = (SNumber)arg.Evaluate(scope);
    if (current == next) {
        current = next;
    } else {
        return false;
    }
}
return true;
</code></pre>

<p>})
```</p>

<p>可以预见所有的比较操作都将使用这段逻辑，因此把这段比较逻辑抽象成一个扩展方法：</p>

<p>```csharp
public static SBool ChainRelation(this SExpression[] expressions, SScope scope, Func&lt;SNumber, SNumber, Boolean> relation) {</p>

<pre><code>(expressions.Length &gt; 1).OrThrows("Must have more than 1 parameter in relation operation.");
SNumber current = (SNumber)expressions[0].Evaluate(scope);
foreach (var obj in expressions.Skip(1)) {
    SNumber next = (SNumber)obj.Evaluate(scope);
    if (relation(current, next)) {
        current = next;
    } else {
        return SBool.False;
    }
}
return SBool.True;
</code></pre>

<p>}
```</p>

<p>接下来就可以很方便的定义比较操作：</p>

<p><code>csharp
.BuildIn("=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; (Int64)s1 == (Int64)s2))
.BuildIn("&gt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt; s2))
.BuildIn("&lt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt; s2))
.BuildIn("&gt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt;= s2))
.BuildIn("&lt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt;= s2))
</code></p>

<p>注意<code>=</code>操作的实现里面有<code>Int64</code>强制转型——因为我们没有重载<code>SNumber#Equals</code>，所以无法直接通过<code>==</code>来比较两个<code>SNumber</code>。</p>

<h4>列表操作</h4>

<p>iScheme的列表操作包括<code>first</code>，<code>rest</code>，<code>empty?</code>和<code>append</code>，分别用来取列表的第一个元素，除第一个以外的部分，判断列表是否为空和拼接列表。</p>

<p><code>first</code>和<code>rest</code>操作如下：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;first&gt; must apply to a list.");
return list.First();
</code></pre>

<p>})
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;rest&gt; must apply to a list.");
return new SList(list.Skip(1));
</code></pre>

<p>})
```</p>

<p>又发现相当的重复逻辑——判断参数是否是一个合法的列表，重复代码很邪恶，所以这里把这段逻辑抽象为扩展方法：</p>

<p>```csharp
public static SList RetrieveSList(this SExpression[] expressions, SScope scope, String operationName) {</p>

<pre><code>SList list = null;
(expressions.Length == 1 &amp;&amp; (list = (expressions[0].Evaluate(scope) as SList)) != null)
    .OrThrows("&lt;" + operationName + "&gt; must apply to a list");
return list;
</code></pre>

<p>}
```</p>

<p>有了这个扩展方法，接下来的列表操作就很容易实现：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;first&rdquo;).First())
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => new SList(args.RetrieveSList(scope, &ldquo;rest&rdquo;).Skip(1)))
.BuildIn(&ldquo;append&rdquo;, (args, scope) => {</p>

<pre><code>SList list0 = null, list1 = null;
(args.Length == 2
    &amp;&amp; (list0 = (args[0].Evaluate(scope) as SList)) != null
    &amp;&amp; (list1 = (args[1].Evaluate(scope) as SList)) != null).OrThrows("Input must be two lists");
return new SList(list0.Concat(list1));
</code></pre>

<p>})
.BuildIn(&ldquo;empty?&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;empty?&rdquo;).Count() == 0)
```</p>

<h4>测试</h4>

<p>iScheme的内置操作完成之后，就可以测试下初步成果了。</p>

<p>首先添加基于控制台的分析/求值（Parse/Evaluation）循环：</p>

<p>```csharp
public static void KeepInterpretingInConsole(this SScope scope, Func&lt;String, SScope, SObject> evaluate) {</p>

<pre><code>while (true) {
    try {
        Console.ForegroundColor = ConsoleColor.Gray;
        Console.Write("&gt;&gt; ");
        String code;
        if (!String.IsNullOrWhiteSpace(code = Console.ReadLine())) {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("&gt;&gt; " + evaluate(code, scope));
        }
    } catch (Exception ex) {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("&gt;&gt; " + ex.Message);
    }
}
</code></pre>

<p>}
```</p>

<p>然后在<code>SExpression#Evaluate</code>中补充调用代码：</p>

<p>```csharp
public override SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    }
} else {
    SExpression first = this.Children[0];
    if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    }
}
throw new Exception("THIS IS JUST TEMPORARY!");
</code></pre>

<p>}
```</p>

<p>最后在<code>Main</code>中调用该解释/求值循环：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // 省略若干内置函数
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>运行程序，输入一些简单的表达式：</p>

<p><img src="http://i.imgur.com/FEVEVGW.jpg" alt="运行结果" /></p>

<p>看样子还不错 :&ndash;)</p>

<p>接下来开始实现iScheme的执行（Evaluation）逻辑。</p>

<h3>执行逻辑</h3>

<p>iScheme的执行就是把语句（SExpression）在作用域（SScope）转化成对象（SObject）并对作用域（SScope）产生作用的过程，如下图所示。</p>

<p><img src="http://i.imgur.com/2j4ztfF.png" alt="编程语言的实质" /></p>

<p>iScheme的执行逻辑就在<code>SExpression#Evaluate</code>里面：</p>

<p>```csharp
public class SExpression {</p>

<pre><code>// ...
public override SObject Evaluate(SScope scope) {
    // TODO: Todo your ass.
}
</code></pre>

<p>}
```</p>

<p>首先明确输入和输出：</p>

<ol>
<li>处理字面量（Literals）：<code>3</code>；和具名量（Named Values）：<code>x</code></li>
<li>处理<code>if</code>：<code>(if (&lt; a 3) 3 a)</code></li>
<li>处理<code>def</code>：<code>(def pi 3.14)</code></li>
<li>处理<code>begin</code>：<code>(begin (def a 3) (* a a))</code></li>
<li>处理<code>func</code>：<code>(func (x) (* x x))</code></li>
<li>处理内置函数调用：<code>(+ 1 2 3 (first (list 1 2)))</code></li>
<li>处理自定义函数调用：<code>(map (func (x) (* x x)) (list 1 2 3))</code></li>
</ol>


<p>此外，情况1和2中的<code>SExpression</code>没有子节点，可以直接读取其<code>Value</code>进行求值，余下的情况需要读取其<code>Children</code>进行求值。</p>

<p>首先处理没有子节点的情况：</p>

<h4>处理字面量和具名量</h4>

<p>```csharp
if (this.Children.Count == 0) {</p>

<pre><code>Int64 number;
if (Int64.TryParse(this.Value, out number)) {
    return number;
} else {
    return scope.Find(this.Value);
}
</code></pre>

<p>}
```</p>

<p>接下来处理带有子节点的情况：</p>

<p>首先获得当前节点的第一个节点：</p>

<p><code>csharp
SExpression first = this.Children[0];
</code></p>

<p>然后根据该节点的<code>Value</code>决定下一步操作：</p>

<h4>处理<code>if</code></h4>

<p><code>if</code>语句的处理方法很直接——根据判断条件（condition）的值判断执行哪条语句即可：</p>

<p>```csharp
if (first.Value == &ldquo;if&rdquo;) {</p>

<pre><code>SBool condition = (SBool)(this.Children[1].Evaluate(scope));
return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
</code></pre>

<p>}
```</p>

<h4>处理<code>def</code></h4>

<p>直接定义即可：</p>

<p>```csharp
else if (first.Value == &ldquo;def&rdquo;) {</p>

<pre><code>return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
</code></pre>

<p>}
```</p>

<h4>处理<code>begin</code></h4>

<p>遍历语句，然后返回最后一条语句的值：</p>

<p>```csharp
else if (first.Value == &ldquo;begin&rdquo;) {</p>

<pre><code>SObject result = null;
foreach (SExpression statement in this.Children.Skip(1)) {
    result = statement.Evaluate(scope);
}
return result;
</code></pre>

<p>}
```</p>

<h4>处理<code>func</code></h4>

<p>利用<code>SExpression</code>构建<code>SFunction</code>，然后返回：</p>

<p>```csharp
else if (first.Value == &ldquo;func&rdquo;) {</p>

<pre><code>SExpression body = this.Children[2];
String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
SScope newScope = new SScope(scope);
return new SFunction(body, parameters, newScope);
</code></pre>

<p>}
```</p>

<h4>处理<code>list</code></h4>

<p>首先把获得<code>list</code>里元素的值，然后创建<code>SList</code>：</p>

<p>```csharp
else if (first.Value == &ldquo;list&rdquo;) {</p>

<pre><code>return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
</code></pre>

<p>}
```</p>

<h4>处理内置操作</h4>

<p>首先对参数求值，然后调用对应的内置函数：</p>

<p>```csharp
else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {</p>

<pre><code>var arguments = this.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
return SScope.BuiltinFunctions[first.Value](arguments, scope);
</code></pre>

<p>}
```</p>

<h4>处理自定义函数调用</h4>

<p>自定义函数调用有两种情况：</p>

<ol>
<li>非具名函数调用：<code>((func (x) (* x x)) 3)</code></li>
<li>具名函数调用：<code>(square 3)</code></li>
</ol>


<p>调用自定义函数时应使用新的作用域，所以为<code>SFunction</code>增加<code>Update</code>方法：</p>

<p>```csharp
public SFunction Update(SObject[] arguments) {</p>

<pre><code>var existingArguments = this.Parameters.Select(p =&gt; this.Scope.FindInTop(p)).Where(obj =&gt; obj != null);
var newArguments = existingArguments.Concat(arguments).ToArray();
SScope newScope = this.Scope.Parent.SpawnScopeWith(this.Parameters, newArguments);
return new SFunction(this.Body, this.Parameters, newScope);
</code></pre>

<p>}
```</p>

<p>为了便于创建自定义作用域，并判断函数的参数是否被赋值，为<code>SScope</code>增加<code>SpawnScopeWith</code>和<code>FindInTop</code>方法：</p>

<p>```csharp
public SScope SpawnScopeWith(String[] names, SObject[] values) {</p>

<pre><code>(names.Length &gt;= values.Length).OrThrows("Too many arguments.");
SScope scope = new SScope(this);
for (Int32 i = 0; i &lt; values.Length; i++) {
    scope.variableTable.Add(names[i], values[i]);
}
return scope;
</code></pre>

<p>}
public SObject FindInTop(String name) {</p>

<pre><code>if (variableTable.ContainsKey(name)) {
    return variableTable[name];
}
return null;
</code></pre>

<p>}
```</p>

<p>下面是函数调用的实现：</p>

<p>```csharp
else {</p>

<pre><code>SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
return function.Update(arguments).Evaluate();
</code></pre>

<p>}
```</p>

<h4>完整的求值代码</h4>

<p>综上所述，求值代码如下</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    } else {
        return scope.Find(this.Value);
    }
} else {
    SExpression first = this.Children[0];
    if (first.Value == "if") {
        SBool condition = (SBool)(this.Children[1].Evaluate(scope));
        return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
    } else if (first.Value == "def") {
        return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
    } else if (first.Value == "begin") {
        SObject result = null;
        foreach (SExpression statement in this.Children.Skip(1)) {
            result = statement.Evaluate(scope);
        }
        return result;
    } else if (first.Value == "func") {
        SExpression body = this.Children[2];
        String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
        SScope newScope = new SScope(scope);
        return new SFunction(body, parameters, newScope);
    } else if (first.Value == "list") {
        return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
    } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    } else {
        SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
        var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
        return function.Update(arguments).Evaluate();
    }
}
</code></pre>

<p>}
```</p>

<h4>去除尾递归</h4>

<p>到了这里iScheme解释器就算完成了。但仔细观察求值过程还是有一个很大的问题，尾递归调用：</p>

<ul>
<li>处理<code>if</code>的尾递归调用。</li>
<li>处理函数调用中的尾递归调用。</li>
</ul>


<p>Alex Stepanov曾在<a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">Elements of Programming</a>中介绍了一种将严格尾递归调用（Strict tail-recursive call）转化为迭代的方法，细节恕不赘述，以阶乘为例：</p>

<p>```c
// Recursive factorial.
int fact (int n) {</p>

<pre><code>if (n == 1)
    return result;
return n * fact(n - 1);
</code></pre>

<p>}
// First tranform to tail recursive version.
int fact (int n, int result) {</p>

<pre><code>if (n == 1)
    return result;
else {
    n -= 1;
    result *= 1;
    return fact(n, result);// This is a strict tail-recursive call which can be omitted
}
</code></pre>

<p>}
// Then transform to iterative version.
int fact (int n, int result) {</p>

<pre><code>while (true) {
    if (n == 1)
        return result;
    else {
        n -= 1;
        result *= 1;
    }
}
</code></pre>

<p>}
```</p>

<p>应用这种方法到<code>SExpression#Evaluate</code>，得到转换后的版本：</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>SExpression current = this;
while (true) {
    if (current.Children.Count == 0) {
        Int64 number;
        if (Int64.TryParse(current.Value, out number)) {
            return number;
        } else {
            return scope.Find(current.Value);
        }
    } else {
        SExpression first = current.Children[0];
        if (first.Value == "if") {
            SBool condition = (SBool)(current.Children[1].Evaluate(scope));
            current = condition ? current.Children[2] : current.Children[3];
        } else if (first.Value == "def") {
            return scope.Define(current.Children[1].Value, current.Children[2].Evaluate(new SScope(scope)));
        } else if (first.Value == "begin") {
            SObject result = null;
            foreach (SExpression statement in current.Children.Skip(1)) {
                result = statement.Evaluate(scope);
            }
            return result;
        } else if (first.Value == "func") {
            SExpression body = current.Children[2];
            String[] parameters = current.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
            SScope newScope = new SScope(scope);
            return new SFunction(body, parameters, newScope);
        } else if (first.Value == "list") {
            return new SList(current.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
        } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
            var arguments = current.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
            return SScope.BuiltinFunctions[first.Value](arguments, scope);
        } else {
            SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
            var arguments = current.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
            SFunction newFunction = function.Update(arguments);
            if (newFunction.IsPartial) {
                return newFunction.Evaluate();
            } else {
                current = newFunction.Body;
                scope = newFunction.Scope;
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h4>一些演示</h4>

<p>基本的运算</p>

<p><img src="http://i.imgur.com/3417GE2.jpg" alt="基本的运算" /></p>

<p>高阶函数</p>

<p><img src="http://i.imgur.com/47a7jhf.jpg" alt="高阶函数" /></p>

<h2>回顾</h2>

<h3>小结</h3>

<p>除去注释（貌似没有注释-_-），iScheme的解释器的实现代码一共333行——包括空行，括号等元素。</p>

<p>在这300余行代码里，实现了函数式编程语言的大部分功能：算术|逻辑|运算，嵌套作用域，顺序语句，控制语句，递归，<a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>，<a href="http://zh.wikipedia.org/wiki/%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC">部分求值</a>。</p>

<p>与我两年之前实现的Scheme方言<a href="http://www.cnblogs.com/figure9/archive/2011/07/10/2102613.html">Lucida</a>相比，iScheme除了没有字符串类型，其它功能和Lucida相同，而代码量只是前者的八分之一，编写时间是前者的十分之一（Lucida用了两天，iScheme用了一个半小时），可扩展性和易读性均秒杀前者。这说明了：</p>

<ol>
<li>代码量不能说明问题。</li>
<li>不同开发者生产效率的差别会非常巨大。</li>
<li>这两年我还是学到了一点东西的。-_&ndash;</li>
</ol>


<h3>一些设计决策</h3>

<h4>使用扩展方法提高可读性</h4>

<p>例如，通过定义<code>OrThrows</code></p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<h4>声明式编程风格</h4>

<p>以<code>Main</code>函数为例：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // Other build
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsIScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>非常直观，而且</p>

<ul>
<li>如果需要添加新的操作，添加写一行<code>BuildIn</code>即可。</li>
<li>如果需要使用其它语法，替换解析函数<code>ParseAsIScheme</code>即可。</li>
<li>如果需要从文件读取代码，替换执行函数<code>KeepInterpretingInConsole</code>即可。</li>
</ul>


<h3>不足</h3>

<p>当然iScheme还是有很多不足：</p>

<p>语言特性方面：</p>

<ol>
<li>缺乏实用类型：没有<code>Double</code>和<code>String</code>这两个关键类型，更不用说复合类型（Compound Type）。</li>
<li>没有IO操作，更不要说网络通信。</li>
<li>效率低下：尽管去除尾递归挽回了一点效率，但iScheme的执行效率依然惨不忍睹。</li>
<li>错误信息：错误信息基本不可读，往往出错了都不知道从哪里找起。</li>
<li>不支持延续调用（Call with current continuation，即call/cc）。</li>
<li>没有并发。</li>
<li>各种bug：比如可以定义文本量，无法重载默认操作，空括号被识别等等。</li>
</ol>


<p>设计实现方面：</p>

<ol>
<li>使用了可变（Mutable）类型。</li>
<li>没有任何注释（因为觉得没有必要 &ndash;_-）。</li>
<li>糟糕的类型系统：Lisp类语言中的数据和程序可以不分彼此，而iScheme的实现中确把数据和程序分成了<code>SObject</code>和<code>SExpression</code>，现在我依然没有找到一个融合他们的好办法。</li>
</ol>


<p>这些就留到以后慢慢处理了 &ndash;_-（TODO YOUR ASS）</p>

<h2>延伸阅读</h2>

<h3>书籍</h3>

<ol>
<li>Compilers: Priciples, Techniques and Tools Principles: <a href="http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/">http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/</a></li>
<li>Language Implementation Patterns: <a href="http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/">http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/</a></li>
<li>*The Definitive ANTLR4 Reference: <a href="http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/">http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/</a></li>
<li>Engineering a compiler: <a href="http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/">http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/</a></li>
<li>Flex &amp; Bison: <a href="http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/">http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/</a></li>
<li>*Writing Compilers and Interpreters: <a href="http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/">http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/</a></li>
<li>Elements of Programming: <a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/</a></li>
</ol>


<p>注：带*号的没有中译本。</p>

<h3>文章</h3>

<p>大多和编译前端相关，自己没时间也没能力研究后端。-_&ndash;</p>

<p>为什么编译技术很重要？看看Steve Yegge（没错，就是被王垠黑过的Google高级技术工程师）是怎么说的（需要翻墙）。</p>

<p><a href="http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html">http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html</a></p>

<p>本文重点参考的Peter Norvig的两篇文章：</p>

<ol>
<li>How to write a lisp interpreter in Python: <a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a></li>
<li>An even better lisp interpreter in Python: <a href="http://norvig.com/lispy2.html">http://norvig.com/lispy2.html</a></li>
</ol>


<p>几种简单实用的语法分析技术：</p>

<ol>
<li>LL(k) Parsing：

<ul>
<li><a href="http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/">http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/">http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></li>
</ul>
</li>
<li>Top Down Operator Precendence：<a href="http://javascript.crockford.com/tdop/tdop.html">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li>Precendence Climbing Parsing：<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a></li>
</ol>


<h2>关于本文作者</h2>

<p>曾经的Windows/.Net/C#程序员，研究生毕业后糊里糊涂变成Linux/Java开发者。所谓一入Java深似海，现在无比怀念使用C#的岁月。</p>

<p>对解释器/编译器感兴趣，现在正在自学Coursera的<a href="https://class.coursera.org/compilers-004">Compiler课程</a>。</p>

<p>欢迎来信交流技术：lunageek#gmail#com</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一篇博文]]></title>
    <link href="http://lucida.github.io/blog/my-first-article/"/>
    <updated>2014-01-05T17:03:00+00:00</updated>
    <id>http://lucida.github.io/blog/my-first-article</id>
    <content type="html"><![CDATA[<h2>为什么要使用Octopress</h2>

<p>之前用过不少博客，其中最长的一个<a href="http://www.cnblogs.com/figure9/">博客园博客</a>用了五年，写了不少文章，也不乏不少关注者，但我始终觉得不太爽：</p>

<ul>
<li>博客园上的文章水平太低：

<ul>
<li>倒不是装x，我并不否认博客园在国内的程序社区的地位，但这仅限于国内，一个首页上充满python入门教程或是常用排序算法的站点更适合初学者。</li>
<li>所以可以理解一些用户在"成名"之后反而选择离开。</li>
</ul>
</li>
<li>提供的编辑器不好用，尤其是代码样式难看的一B。</li>
<li>缺乏对站点的控制，尽管有一些主题但可塑性不强，自己想放一些脚本进去也不方便。</li>
<li>缺乏Mobile Readability，无论在我的iPhone 5还是Nexus 5上，精心设计的文章排版都会变成翔。</li>
</ul>


<p>直到前天和<a href="http://contributors.rubyonrails.org/contributors/oscar-del-ben/commits">Oscar</a>打桌球，我提到一直打算做一个独立博客，但由于不清楚uk这边申请域名和空间的流程而一直拖到现在，Oscar很疑惑的说如果只是一个静态博客那么用Github做host不就成了么。</p>

<p>于是这个周末做了下调研，最后目标锁定在<a href="http://octopress.org/">Octopress</a>。</p>

<h3>免费的空间</h3>

<p>Octopress是一个静态博客生成系统，使用<a href="http://jekyllrb.com/">Jekyll</a>生成静态站点，而Jekyll是Github默认的<a href="http://pages.github.com">pages</a>生成系统，因此Octopress生成的静态站点可以很方便的部署到Github Pages上。而Github提供了免费的空间，因此申请空间这步就轻松的跳过了。</p>

<h3>接近完美的样式</h3>

<p>Octopress默认的样式已经很不错，尤其是在<code>code</code>的展现和对<strong>Markdown</strong>的支持上，除此之外对<code>Markdown</code>做了一系列扩展，使得排版更加精致。
下面的代码效果令我十分满意：</p>

<p>``` java Hello world in java
package org.java.fun;</p>

<p>public class Sample{</p>

<pre><code>public static void main(String[] args) {
    System.out.println("Hello world!"); 
}
</code></pre>

<p>}
```</p>

<h3>Mobile Readablity</h3>

<p>无论是在iPad Air，还是在iPhone 5和NEXUS 5上面，Octopress的表现都堪称完美。</p>

<h3>新技术的训练</h3>

<p>很惭愧的承认自己并没有用过git，也没有用过Markdown。以至于Basia在得知我没用过git时十分惊讶</p>

<blockquote><p>How could a programmer never use git before?</p></blockquote>

<p>使用Octopress写博客可以强制自己使用git，此外如果想要对站点做一点tweak，还需要html5+css3+js+ror这一系列web开发前后端的知识，考虑到自己有做full stack developer的打算，用这个博客练手不失为一个好办法。</p>

<h2>接下来会写些什么</h2>

<ul>
<li>读过的书</li>
<li>写的代码</li>
<li>以及在london的生活感受</li>
</ul>

]]></content>
  </entry>
  
</feed>
