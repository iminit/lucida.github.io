<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Technology | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/technology/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-11-01T22:07:20-07:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[精益技术简历之道——改善技术简历的47条原则]]></title>
    <link href="http://zh.lucida.me/blog/lean-technical-resume/"/>
    <updated>2014-11-01T21:08:43-07:00</updated>
    <id>http://zh.lucida.me/blog/lean-technical-resume</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>这篇文章围绕着技术简历这个话题，从版式、个人信息、技术能力、项目经历和教育背景等方面出发，给出了编写高质量技术简历所应遵循的47条原则。它们既有益于求职者编写高质量的简历，也有助于招聘者筛选合格的求职者。</p>

<h2>为什么要编写这篇文章？</h2>

<p>技术简历既是技术人员求职必不可少的一环，也是找工作的第一步，其重要性不言而喻。然而关于如何编写技术简历的靠谱教程却少之又少，以至于求职者无法编写出合格的简历，而招聘者无法从简历中看出求职者的真实水平。</p>

<p>一些人可能会反对：如何编写技术简历还不简单，网上到处都是嘛！找一个教程，套一个模板，简历不就出来了嘛！</p>

<ul>
<li><a href="http://jingyan.baidu.com/article/363872ecf0fa656e4ba16f80.html">求职简历怎么写</a>，</li>
<li><a href="http://bbs.yingjiesheng.com/thread-180175-1-1.html">资深HR告诉你到底怎么写一份好的简历</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4a388a6d01008cza.html">技术人员的简历编写技巧</a></li>
<li><a href="http://wenku.baidu.com/view/98f781d528ea81c758f57876.html">精美简历模板集合</a></li>
<li><a href="http://wenku.baidu.com/link?url=ocsWDBteInQGBzY562PWrz7_ZRZHF9BkzonuRAYmFCFGFCmMjXLPB3wSMxuQOFmbzx8FnuhJXogWHVmS8ViYt2nfkY_Xj3RT7ifLZH2WoZe">IT求职简历模板</a></li>
</ul>


<p>上面的教程和模板是我在谷歌和百度搜索“如何编写技术简历”和“技术简历模板”得到的结果，它们的共性是<strong>完全不适用于技术领域</strong>：这些教程和模板会指导你写出一篇屁话连连空话连篇看似出彩但毫无实质内容的嘴遁简历，是的，它们可能适用于一些国有企业，但对于追求实际的外企和民企完全不适用。</p>

<p>技术领域追求<strong>简练、客观、实际和成就</strong>，而不是<strong>冗余、主观、抽象和过程</strong>。如果求职者使用上面的教程或模板编写技术简历，那么结果注定会非常糟糕；如果招聘者使用上面的教程来甄别求职者，那么注定会招进一群光说不做的饭桶。我不是在开玩笑——尽管算上实习我只工作了三年，但我已经见证过很多优秀的童鞋因为简历被公司拒之门外，也见证过招聘者/HR因为不懂甄别简历，搞进来一群莫名其妙的家伙来面试，既浪费时间，又浪费资源。</p>

<p>所以我决定写一篇如何编写技术简历的文章，也就是<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>：</p>

<ol>
<li>为技术人员提供一个靠谱使用的技术简历编写教程</li>
<li>为招聘人员提供一个便捷高效的技术简历甄别教程</li>
</ol>


<p>结合国外书籍/文章和我自己的经验，我总结出47项编写高质量技术简历的原则，<strong>这些原则既可以作为求职者编写技术简历的准则，也可以作为招聘人员筛选技术简历的标准。</strong></p>

<p>此外，随着越来越多的人开始海外求职，我特别针对英文简历编写了9项原则，以帮助国人编写合格的英文技术简历。</p>

<p>注：本文标题中的的“精益”（Lean）源于精益创业（<a href="http://theleanstartup.com/">the Learn Startup</a>）。</p>

<h2>注意</h2>

<p>为了完成这篇文章，我从我的微博关注者中征集了一系列简历（感谢你们的信任！）。下文有可能会出现你们简历中的部分内容（当然我会进行改动以便保护你们的隐私），如果觉得不妥，请与我联系，我会将其删除。</p>

<p>下面进入正文。</p>

<!-- more -->


<hr />

<h2>精益技术简历原则</h2>

<h3>关于</h3>

<p>为了使本文更加严谨有序，我在组织简历原则时参考了编程书籍中著名的Effective系列（例如<a href="http://book.douban.com/subject/1842426/">Effective C++</a>和<a href="http://book.douban.com/subject/3360807/">Effective Java</a>）以及<a href="http://book.douban.com/subject/3267575/">Framework Design Guidelines</a>的行文风格：</p>

<ul>
<li>“使用……”、“对……进行……”、“按照……”这些原则属于必须遵循的原则</li>
<li>“不要使用……”、“不要……”、“避免……”这些原则属于必须避免的原则</li>
<li>“考虑……”、“不必……”、“谨慎……”这些原则属于我个人建议的原则，你可以去违反它们，但我个人不推荐这样做</li>
</ul>


<p>为了便于阅读和理解，我将这些原则按照进行了分类：</p>

<ul>
<li><strong>排版</strong>分类中的原则介绍了如何写出美观的简历</li>
<li>一般来说一封简历都会包含<strong>个人信息</strong>、<strong>技术能力</strong>、<strong>项目经验</strong>、<strong>教育背景</strong>和<strong>个人爱好</strong>，所以我将简历内容相关的原则按照这些分类进行了组织</li>
<li><strong>英文简历</strong>分类介绍了如何改善你的英文简历</li>
<li>未被分组的原则被归类到<strong>其他</strong></li>
</ul>


<h3><a name="sec1">版式</a></h3>

<p>版式（排版和样式）并不是简历内容的一部分，但却会对简历给人的第一印象造成很大影响——“字如其人”，简历版式可以反映其作者是否严谨是否认真。如果版式过于糟糕，那么简历很可能会被直接筛掉。</p>

<h4><a name="rule1">1. 使用对齐</a></h4>

<p>对齐（Alignment）是良好排版的第一要素——对齐不仅使简历层次分明，也会给人有力的感觉，例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="未对齐的简历" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="对齐的简历" /></p>

<h4><a name="rule2">2. 不必使用居中</a></h4>

<p>居中会破坏对齐，减弱整体的层次感，所以我不建议在简历中使用居中。例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="居中标题" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="非居中标题" /></p>

<p>是的，这条原则里使用的图片来自<a href="#rule1">原则 1. 使用对齐</a>，请牢记：<strong>左/右对齐优于居中对齐。</strong></p>

<h4><a name="rule3">3. 谨慎使用<strong>粗体</strong></a></h4>

<p>粗体是一个很强大的工具，它可以有效的去引导简历阅读者的视线，并突出重要的内容。但我在阅读简历的时候发现不少人对粗体使用不当——滥用，用错，甚至是全文使用粗体，这使得简历完全无法被正常阅读。</p>

<p>粗体适用于去突出<strong>成就</strong>（Achievements），例如：</p>

<ul>
<li>量化的成就：将页面加载速度提升<strong>50%</strong></li>
<li>良好的成绩：GPA <strong>4.0/4.0</strong></li>
<li>奖项：ICPC/ACM比赛中获得XX赛区<strong>一等奖</strong></li>
<li>他人的推荐语：<strong>“XX是我见过的最优秀的实习生”</strong></li>
</ul>


<p>在其它场景下，我不推荐使用粗体，此外注意不要过多使用粗体——<strong>粗体是为了突出成就，不是为了突出技术关键字</strong>，<strong>太多的粗体会导致什么也突出不出来。</strong></p>

<h4><a name="rule4">4. 避免不必要的折行</a></h4>

<p>折行（Wrap）指当一行内容过长时会自动进入下一行。我不是说不可以折行（那就成了古龙小说了 :&ndash;/），而是说不要使用不必要的折行，比如说：</p>

<p><img src="http://i.imgur.com/oWHWfnO.png" alt="不必要的折行" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/RHoQFdQ.png" alt="去掉折行" /></p>

<p>不必要的折行会降低简历的密度，破坏简历的层次感，而且会给人没话说有意占行数的感觉。请务必避免这样的折行。</p>

<h4><a name="rule5">5. 使用制表符辅助对齐</a></h4>

<p>为了进行对齐，我们往往需要添加一些空白符。在这里请使用制表符（tab）而非空格（space），因为：</p>

<ol>
<li>空格往往不会带来严格的对齐（因为简历字体往往不是等宽的）</li>
<li>制表符在打印版本下的表现更佳</li>
</ol>


<h3><a name="sec2">个人信息</a></h3>

<p>个人信息部分决定了简历阅读者对简历的第一印象，请务必在这部分内容多下功夫。</p>

<h4><a name="rule6">6. 不要使用不必要的条目名称</a></h4>

<p>条目名称（Column name）这个词很拗口，我举一个例子：“姓名：张大锤”和“电话：135-9112-7890”里的“姓名”和“电话”就是条目名称。</p>

<p>绝大多数的条目名称都是不必要的——“张大锤”一看就是一个名字，“135-9112-7890”一看就是一个手机号码。这种条目信息会让简历变得拖沓啰嗦，请务必删除它们。</p>

<p>此外，请牢记<strong>“个人简历”是简历上最大的废话</strong>——这当然是一封简历，不用你提醒。可笑的是很多所谓的“500强简历模板”还把“个人简历”作为简历抬头（Header）。</p>

<h4><a name="rule7">7. 使用分隔符增强电话号码的可读性</a></h4>

<p>请使用“-”和“()”格式化你的电话号码，例如：把<strong>8618601007070</strong> 改为 <strong>(+86) 186-0100-7070</strong>，以便简历阅读者能够正确便捷的拨打你的号码，此外这样的号码也显得更加专业。</p>

<h4><a name="rule8">8. 使用可以点击的链接</a></h4>

<ul>
<li>使用<a href="http://zh.lucida.me">http://zh.lucida.me</a>而非http<nolink>://zh.lucida.me</li>
<li>使用<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#109;&#x79;&#109;&#97;&#x69;&#x6c;&#64;&#103;&#x67;&#x67;&#46;&#x63;&#x6f;&#109;">&#109;&#121;&#x6d;&#x61;&#105;&#x6c;&#64;&#x67;&#103;&#x67;&#x2e;&#x63;&#x6f;&#109;</a>而非mymail<nolink>@ggg.com</li>
</ul>


<p>这样简历阅读者就可以直接点击，而不是费力的把链接复制粘贴到某个输入栏中。</p>

<h4><a name="rule9">9. 不要使用照片</a></h4>

<p>照片不会对你的简历产生任何正面价值，而且它会破坏简历的结构，请不要在简历中使用照片。</p>

<h4><a name="rule10">10. 不要写无关个人信息</a></h4>

<p>是的，你是在写技术简历，而不是在写入党申请或征婚启事之类的东西，所以请不要在简历中出现下面这些信息：</p>

<ul>
<li>性别</li>
<li>生日</li>
<li>星座</li>
<li>籍贯</li>
<li>通信地址</li>
<li>民族</li>
<li>政治面貌（WTF!!??）</li>
<li>身高/体重</li>
</ul>


<p>理想的个人信息应该包括姓名、联系方式（电邮地址和手机号码），如果你有不错的技术博客也可以把它放在上面。</p>

<h4><a name="rule11">11. 使用客观事实而非主观描述</a></h4>

<p>我经常在简历里面看到诸如“我是一个热爱编程的开发者”或是“我精力充沛，热爱学习，能够长时间从事编程工作”之类的个人评价，总之就是把雇主希望看到的性格特点堆在一起，有时感动的我都想哭。</p>

<p>但感动归感动，这些感人肺腑的个人评价我向来直接无视——<strong>我为什么要相信你呢？</strong>引用<a href="https://lkml.org/lkml/2000/8/25/132">Linus的话</a>，<strong>Talk is cheap, show me the code</strong>。如果要说明你是一个热爱编程的开发者，那么请出你的Github页面或优秀的个人作品；如果要说明你热爱学习，请给出你读过的书或写过的书评。总之，使用客观事实，而非主观描述。</p>

<h4><a name="rule12">12. 考虑提供他人的评价</a></h4>

<p>这条原则是上一条原则的扩充——找你的导师、老板或者同事为你写一个评语，相对于主观描述，他人的评价往往更加可信。如果你的评价者是业内权威，那么效果就会更好。</p>

<h4><a name="rule13">13. 不必写求职目标</a></h4>

<p>我读过的很多简历都有“Objective”（求职目标）这一栏，一般求职者会在这里写他所期待的职位。我个人非常不喜欢求职目标这一栏，因为求职目标给我一种海投简历的感觉。如果走的是内部推荐，或者使用目标公司的求职页面，请去掉求职目标，你应该已经了解投递职位，不需要在简历里面重复。</p>

<h3><a name="sec3">技术能力</a></h3>

<p>技术能力是技术简历里面重要的一环，一般来说简历阅读者会通过这部分内容了解你的技能集（Skill set），从而构成对你的第一技术印象。</p>

<h4><a name="rule14">14. 不要堆砌技术名词</a></h4>

<p>技术简历中一个常见误区是堆砌技术名词，一些求职者认为在简历上写的技术越多越好，于是把自己会的、用过的、见过的甚至没见过的技术都堆在一起，比如：</p>

<p>Technical Skills</p>

<ul>
<li>Programming Language: HTML, CSS, PHP, JavaScript, SQL, Haskell, Perl, Python, C, C++, Java, Ruby, Prolog, .NET, C#, Assembly, REXX, Verilog, R, Visual Basic, MATLAB, jQuery, Angular, SASS</li>
<li>Operating System: Unix/Linux, Mac, MS-DOS, Windows 7/8, Windows Server 2003/2008/2012, z/VM</li>
<li>Software: Adobe Creative Cloud Dreamweaver, Photoshop, InDesign, Audition. WordPress, OmniUpdate, Google Analytics, Eclipse, NetBeans, LaTex, Microsoft Office Suite, Microsoft Excel, Project, Visio, Visual Studio</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>是的，一个人可以同时掌握甚至精通多种编程语言，但一般来说这种可能性很小。当我看到这样的技术描述，我会迅速的跳转到简历的项目经验环节，如果我无法在项目经验里找到对应的技术，我会直接把这个简历筛掉。（我把它叫做“未声明引用”（Undeclared reference）：你说你精通C++，但你却没有C++的项目经验，你确定不是在逗我？）</p>

<p>所以，不要堆砌技术名词，技术简历并非多多益善，熟悉什么技术就写什么技术，然后在项目经验里面给出你熟悉该技术的证据（evidence），这样会使你的简历更有说服力。</p>

<h4><a name="rule15">15. 对技术进行分类</a></h4>

<p>技术能力部分的另一个常见问题是缺乏分类或者分类错误，比如：</p>

<p><code>
编程语言：C++, C#, Visual Studio, Shell, Python, Eclipse, Java
</code></p>

<p><img src="http://i.imgur.com/PpAXta9.jpg" alt="分类不清" /></p>

<p>这样的简历也会被直接扔进废纸篓——连编程语言和编程环境都分不清，招你作甚。</p>

<p>正确分类后就清楚了很多：</p>

<p><code>
编程语言：C++, C#, Java, Python, Shell
开发环境：Visual Studio, Eclipse
</code></p>

<h4><a name="rule16">16. 使用正确的技术名称</a></h4>

<p>这个原则非常简单（甚至有点弱智）——正确拼写技术名称，并使用正确的大小写。我在这里摘取了一些我见过的技术名词错误：</p>

<ul>
<li>Andoid &ndash;> Android</li>
<li>IOS, ios &ndash;> iOS</li>
<li>javascript &ndash;> JavaScript</li>
<li>coffescript &ndash;> CoffeeScript</li>
<li>intelij &ndash;> IntelliJ</li>
<li>Dikjstra &ndash;> Dijkstra</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="别字错误" /></p>

<p>请严格检查此类错误——这类错误会大大降低你的简历的专业性，并给人非常不好的印象</p>

<h4><a name="rule17">17. 不要写电脑能力</a></h4>

<p>技术简历需要展现你的技术能力（Technical Skills），而不是电脑能力（Computer Skills），这两个概念比较拗口，所以我在这里举几个例子：</p>

<ul>
<li>技术能力包括：编程（C++/Java/Python），开发环境（Visual Studio/IntelliJ/Eclipse），测试（JUnit/TestNG/mockito/truth），用户体验（Axure/Expression Blend）等等。</li>
<li>电脑能力包括：日常办公（Word/Excel/PowerPoint/Office），图形界面操作系统（Windows 7/8）的使用，浏览器（IE/Chrome/Safari）的使用等等。</li>
</ul>


<p>电脑能力不但会稀释你的简历含金量，还会给人极不专业的感觉。不要在技术简历里面出现任何电脑能力——据说某公司甚至定了一个规矩，<strong>只要在技术简历里面看到Office字样就直接滤掉</strong>（靠谱！）。</p>

<h4><a name="rule18">18. 按照熟悉程度对技术能力进行排序</a></h4>

<p>这个原则十分简单——使用合适的词汇描述你的技术能力，并按照熟悉程度排序，例如：</p>

<p><code>
编程语言：C++, C#, Java, Python, JavaScript
</code></p>

<p>就不如</p>

<p><code>
编程语言：熟悉C++、C#和Java，了解Python和JavaScript
</code></p>

<p>另一种方式是使用比较符：</p>

<p><code>
编程语言：C++ = C# &gt; Java &gt; Python = JavaScript
</code></p>

<p>注意：没有必要在技术能力后面加上使用时间，比如：</p>

<p><code>
技术名称     熟练程度     使用时间
C++           精通         8年
Java          熟悉         5年
</code></p>

<p>时间没有意义——搞技术的都明白技术的使用时间和技术的熟练程度没有任何关系（谁知道这货是不是用了1个月C++然后在后面的95个月不断重复第一个月的东西？），只可惜有些HR永远都不懂这个道理，也不肯懂。</p>

<h4><a name="rule19">19. 不要写过于特定的技术</a></h4>

<p>什么叫做过于特定（Specific）的技术呢？举个例子：</p>

<p><code>
熟悉单例（Singleton）模式
</code></p>

<p><img src="http://i.imgur.com/gQwjJhC.png" alt="捂脸" /></p>

<p>且不说单例是不是一个好模式，单例模式有什么好熟悉的？这种东西也配写到简历上吗？至少在我看来，“熟悉单例模式”就跟“熟悉for循环”、“精通if语句”一般可笑。</p>

<h4><a name="rule20">20. 谨慎使用精通</a></h4>

<p>精通和Proficient是非常Strong的词汇，在简历上写精通类词汇也许会帮你得到面试机会，但你要面对难度更高的面试——招聘者会通过更高难度的问题来确认你真的是精通，而不是在嘴遁。</p>

<p>但如果你真的精通某项技术，那就自信的写上精通，然后用项目经历和面试中的表现说服招聘者，这样往往有助于你拿到Strong Offer。</p>

<h4><a name="rule21">21. 使用项目经验印证技术能力</a></h4>

<p>这条原则在<a href="#rule13">原则13 不要堆砌技术名词</a>也有提到——你的技术能力应该在你的项目经历中得到<strong>全部</strong>体现，技术能力展现你的技能集（Skills Set），而项目经验为其提供证据（Evidence）。打个比方，如果你提到你熟悉C++，那么你就需要在项目经验中提到C++，否则我认为你在说谎或者忘记把C++的项目经验写在简历上，说谎和健忘，两者都不是好事。</p>

<h3><a name="sec4">项目经历</a></h3>

<p>项目经历是简历阅读者进一步了解求职者技术能力的重要依据，良好的项目经历应当清晰，简洁，既印证前面提到的技术能力，也反映出求职者应对复杂度（Handle complexity）的能力。</p>

<h4><a name="rule22">22. 按照时间对项目经历排序</a></h4>

<p>一般来说，项目经历应该按照时间倒序排序——最新的项目经历放在最前。此外，考虑去掉过于久远（比如说，七八年前）的项目经历，因为你很有可能已经忘了七八年前做过的东西了。</p>

<p>另外一种排序方式是按照项目的重要程度排序——最重要的项目放在最前，但我个人不推荐这种方式，因为往往最重要的项目都在最近，如果你最重要的项目在很多年，那么很有可能你这些年毫无长进。</p>

<h4><a name="rule23">23. 不要列出过多的项目</a></h4>

<p>我经常看到非常长的简历：三四页纸，两三千字，十余个项目，恨不得把他/她做过的东西全都铺上去。而事实证明写出这样简历的人水平都不怎么样——至少就我的个人经验而言。</p>

<p>项目经历不是自传，不用把你全部的经历铺上去，也不要写过多的项目经历——三个项目是一个不错的选择，五个就有点多，十个就会没人看。要知道三个优秀的项目远胜十个一般的项目。</p>

<p>所以问题来了，什么是优秀的项目呢？就技术项目而言，我的评估标准是复杂度（Complexity）和影响力（Impact）：一个项目，如果复杂度和影响力都有那是最好，如果只有一个也不错，如果都没有那就呵呵。我会在<a href="#rule25">原则25 强调影响力和复杂度</a>中进一步说明。</p>

<h4><a name="rule24">24. 强调成果而非过程</a></h4>

<p>我在我之前的<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">关于锤子手机和锤子手机发布会</a>提到过：</p>

<blockquote><p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress。</p></blockquote>

<p>技术简历也是如此，不要在项目经历中过度强调你有多努力。“连续高强度工作三个月”和“在深夜重构了XX项目中的代码”并不是一个好的项目描述：如果你“连续高强度工作三个月”却无法说明你的工作成果，“在深夜重构了XX项目中的代码”却无法说明重构后代码改进了多少，那我认为你的“努力”毫无意义。</p>

<p>强调你的项目成果（Achievements）而非过程，“将网站访问量提升300%”、“将响应时间从1.5s减少到0.1s以内”都是不错的成果。</p>

<h4><a name="rule25">25. 使用量化结果而非抽象描述</a></h4>

<p>我经常在简历上看到“改善了代码的质量”、“提升了启动速度”和“大大增加了网站访问量”之类的描述，我的第一反应就是：</p>

<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p><strong>用个数字你会死啊！！！看新闻联播看多了吧亲！！！！</strong></p>

<p>接下来的反应是：</p>

<ul>
<li>“改善了代码的质量”——改善了多少？你是如何评估的？圈复杂度？测试覆盖度？Bug的数量？ ？？？</li>
<li>“提升了启动速度”——提升了多少？用户的反馈如何？是否在可接受的范围内？ ？？？</li>
<li>“大大增加了网站访问量”——“大大”是什么？访问量增加了多少？访问量原来是多少？ ？？？</li>
</ul>


<p>如果我找不到上面问题的答案，我会直接无视这些抽象描述——还是那句话，我为什么要相信你的一面之词？而且你连话都说不清。</p>

<h4><a name="rule26">26. 强调影响力和复杂度</a></h4>

<blockquote><p>&ldquo;Controlling complexity is the essence of computer programming.&rdquo;</p>

<p>Brian Kernighan</p></blockquote>

<p>控制复杂度使程序设计的根本（essense），所以绝大多数IT公司在招聘时都会把应对复杂度（Handle complexity）放在职位描述里面——你如果能把难题搞定，那么简单题也不在话下。如果你做过的项目足够复杂，那么就证明你能扛得住复杂度，是个好<del>备胎</del>备选（Candidate）。</p>

<p>那么什么样的项目经历称得上复杂呢？我在这里给出一个不严谨的分类，仅供参考：</p>

<ul>
<li>编程复杂度：操作系统，编译器/解释器，图形学编程，网络协议设计与实现等</li>
<li>算法复杂度：算法竞赛奖项等（不好意思我不熟悉算法所以给不出啥例子 &ndash;_-）</li>
<li>设计复杂度：大型网站，企业级应用，分布式应用等</li>
</ul>


<p>衡量项目的另一个重要依据是影响力（Impact），有的软件项目可能不那么复杂，但是它具有相当大的影响力，例如jQuery、RoR和JUnit：</p>

<blockquote><p>&ldquo;Never in the field of software development have so many owed so much to so few lines of code (JUnit).&rdquo;</p>

<p>Martin Fowler</p></blockquote>

<p>如果你的项目并不复杂，那么请强调它的影响力，用户量超过十万的手机应用和被广泛应用的类库都是很好的项目，尽管它们可能并不复杂。</p>

<p>如果一个项目既没有复杂度，也没有影响力，那么直接删掉它——不要犹豫，它不会为你的简历提供任何价值。</p>

<h3><a name="sec5">教育背景</a></h3>

<p>教育背景是简历的另一项重要内容，它对于应届生尤其重要——因为应届生往往没有太多的工作经历。</p>

<h4><a name="rule27">27. 不要写大学之前的教育经历</a></h4>

<p>我不明白为什么很多人把高中甚至初中都写在简历里——也许你的高中/初中很出色，不过那么多年前的事情就不用再提了吧 &ndash;_&ndash;||</p>

<h4><a name="rule28">28. 不要写课程列表</a></h4>

<p>我在简历的教育背景部分发现的另一个奇怪的现象是课程列表（Courseworks）：求职者把大学专业课程一水排开，放在简历里面，颇是壮观：</p>

<p>专业课程：</p>

<ul>
<li>计算机科学导论，C语言及程序设计，计算机组成原理，数据结构，算法设计，离散数学，操作系统原理，编译原理，计算机网络，数据库系统原理，面向对象编程，软件工程，图像处理技术，人工智能及其应用，网络工程</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>更加令人啼笑皆非的是把<strong>所有</strong>的大学课程放在一起：</p>

<p>大学课程：</p>

<ul>
<li>高等数学，线性代数，大学物理，概率与数理统计，毛泽东思想概论，思想道德修养，邓小平理论，马列政治经济学原理……</li>
</ul>


<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p>每当看到这样的简历我都在想我是该筛掉你呢还是筛掉你呢还是筛掉你呢？</p>

<p><strong>不要写课程列表</strong>，除非你有想特别强调的特殊专业课，而且你在该课上有突出表现（比如“编译原理（实现了带下标检查的扩展C编译器）”就不错）。</p>

<h4><a name="rule29">29. 考虑使用成绩或排名</a></h4>

<p>如果你的大学成绩或排名还不错，那么请把它放在教育背景中，例如：</p>

<p><code>
2009 ~ 2013    学士    大连理工大学    软件工程    GPA: 3.8/4.0，排名：3/153
</code></p>

<p>就不错。</p>

<p>但如果你的成绩一般（80%一下）或排名一般（前20%开外），那么就不要提它们（我就是这么做的，-_&ndash;#）</p>

<h4><a name="rule30">30. 考虑使用导师（老师）的评语</a></h4>

<p>这条原则和<a href="#rule12">原则12. 考虑提供他人的评价</a>相类似，与其说你在学校多么努力，不如让你的专业课老师（导师）给你一个评价。</p>

<p>注意：不要使用辅导员的评价，是的，辅导员在大学很重要，但辅导员对学生的评价往往没有<strong>专业</strong>参考价值。</p>

<h4><a name="rule31">31. 考虑使用学业相关的奖项</a></h4>

<p>请把在校期间的<strong>重要奖项</strong>放在教育背景中，比如“一等奖学金”，“数学建模大赛一等奖”就不错。</p>

<p>我在阅读简历时见到过很多学霸——学校里面获得的奖项接近一页纸之多。这是个好事，不过放太多奖无益于突出重点，所以请参考<a href="#rule23">原则 23. 不要列出过多的项目</a>：精选3到5个最有说服力的奖项，然后把它们放在教育背景中。</p>

<h3><a name="sec6">个人爱好</a></h3>

<p>个人爱好对技术简历往往毫无价值，所以这里的原则只有一条——</p>

<h4><a name="rule32">32. 避免写个人爱好</a></h4>

<p>除非你在个人爱好上取得了相当的成就，否则不要写个人爱好。每个人都喜欢音乐，都喜欢看书，也都喜欢技术，这种<del>屁话</del>套话还是留到入职邮件再说也不迟。</p>

<h3><a name="sec7">英文简历</a></h3>

<p>海外求职需要英文简历，而英文简历需要专业的英语——阅读你简历的人很有可能只懂英文，如果你的英文太糟糕那么他/她很可能会无视你的技术而直接把你筛掉。</p>

<h4><a name="rule33">33. 不要出现拼写错误</a></h4>

<p>请打开拼写检查——要知道简历里面的拼写错误是致命的。我在这里给出一些常见的拼写错误：</p>

<ul>
<li>explaination &ndash;> explanation</li>
<li>convenence &ndash;> convenience</li>
<li>seperate &ndash;> separate</li>
<li>Febuary &ndash;> February</li>
<li>embarass &ndash;> embarrass</li>
<li>consience &ndash;> conscience</li>
<li>mispell &ndash;> misspell</li>
<li>enginner &ndash;> engineer</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="金馆长" /></p>

<p>更多的拼写错误请参考<a href="http://grammar.yourdictionary.com/spelling-and-word-lists/misspelled.html">这里</a>。</p>

<h4><a name="rule34">34. 不要使用全角字符</a></h4>

<p>务必不要在英文简历中使用全角字符：</p>

<ol>
<li>全角字符会影响英文排版，使其变的很难看</li>
<li>对方的机器上可能没有对应的字库，因而无法显示全角字符</li>
</ol>


<p>我个人推荐在英文简历中只使用ASCII字符集里的字符。</p>

<h4><a name="rule35">35. 使用正确的词汇</a></h4>

<p><img src="http://i.imgur.com/SJF8N2m.jpg" alt="神翻译" /></p>

<p>国人英文简历的一大通病是用词不当，下面是我阅读英文技术简历时所发现的最常见的三个错误：</p>

<ol>
<li>“<strong>实现</strong>了xx功能”：使用<strong>Implement</strong>，而不是<strong>Achieve</strong></li>
<li>“软件工程师”：使用<strong>Software Developer</strong>或<strong>Software Engineer</strong>，而不是<strong>Software Programmer</strong></li>
<li>“我对xxx<strong>感兴趣</strong>”：使用<strong>I am interested in &hellip;</strong>，而不是<strong>I am interesting in</strong>，详见<a href="http://www.learnersdictionary.com/qa/what-is-the-difference-between-interested-and-interesting">这里</a></li>
</ol>


<p>用词不当会影响简历阅读者的理解，为其带来相当负面的印象。为了减少这类错误，你应该去阅读更多的专业英文著作，或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule36">36. 使用简洁的句子</a></h4>

<p>受中式思维的影响，我们的英文往往很冗余（Verbose），我举两个简单的例子</p>

<ul>
<li>“during the development period”应该是“during the development”：因为“development”本身已经包含“过程（period）”的意思。</li>
<li>“implemented xxx successfully”应当是“implemented xxx”：既然使用了过去式，那么你已经把它实现（implement）了，那自然就是“成功”实现。如果想要强调“成功”，那么可以用“accomplished xxx”。</li>
</ul>


<p>这里水一句：一般来说中国人对这种英语完全不敏感，反而很亲切（因为更接近中式思维），那为什么我对这种英语特别在意呢？因为我有几个伦敦同事特别在意英语的纯正性，初到伦敦时，无论是吃饭、聊天还是提交代码，他们都会无时无刻的纠正我的语法错误和发音错误（我想我已经被他们纠正几千多次了-_&ndash;#），所以我现在对此类中式英语异常敏感。</p>

<p>此外在简历里面我们有时可以忽略主语（Subject），例如：</p>

<p>```
Project A:</p>

<pre><code>I implemented the communication module.
I wrote tests for the communication module.
I deployed the module into our system.
</code></pre>

<p>```</p>

<p>可以这么写</p>

<p>```
Project A:</p>

<pre><code>Implemented the communication module.
Wrote tests for the communication module.
Deployed the module into our system.
</code></pre>

<p>```</p>

<p>这样不但更加简洁，而且用动词开头会让句子显得更加有力，给人以自信的感觉。</p>

<p>为了使简历中的英文句子更加简洁，你应该去阅读更多的英文写作书籍（例如<a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>和<a href="http://www.amazon.com/Writing-Well-30th-Anniversary-Edition/dp/0060891548/">On writing well</a>），或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule37">37. 避免中式英语</a></h4>

<p>这个原则实际上是<a href="#rule35">原则35. 使用正确的词汇</a>和<a href="#rule36">原则36. 使用简洁的句子</a>的扩展，因为这两个原则都属于中式英语的范畴。</p>

<p>中式英语的源头在于用中式思维将中文逐字转化成英语，尽管我们不会搞出这样的错误：</p>

<p><img src="http://i.imgur.com/PfkAXV7.jpg" alt="神翻译" /></p>

<p>但是小错是难免的，我已经不止三次的听到有人使用"red color"这个神奇的短语了。（red本身就是颜色，所以完全不需要后面的color）如果你打算根除中式英语，你有两种途径：</p>

<ol>
<li>找几个腹黑伦敦同事。-_&ndash;#</li>
<li>阅读<a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a></li>
</ol>


<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p>这是我读过最好的（貌似也是唯一的）讲中式英语的书籍。</p>

<p>当然，如果你只是把简历改的不那么中式，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule38">38. 使用一致的时态</a></h4>

<p>这个原则很简单——使用一致的时态：</p>

<ul>
<li>对于个人评价：使用现代式。</li>
<li>对于项目经历：使用过去式。</li>
</ul>


<p>之所以把这么简单的原则提出来，是因为我都过的英文简历几乎都违反了这个原则——它们或者在个人评价里“I was a passionate programmer”（嗯，你过去很激情那么现在呢？），或者在项目经历里“Implement xxx”（一直实现到现在不容易啊童鞋！）。</p>

<h4><a name="rule39">39. 考虑提供缩写词的解释</a></h4>

<p>不是所有人都了解你的工作或研究，所以对于<strong>不常用</strong>和<strong>有歧义</strong>的首字母缩写词（Acronym），请提供全称。</p>

<p>注意我说的是<strong>不常用</strong>和<strong>有歧义</strong>的缩写词，你无需告诉简历阅读者HTML的全称是HyperText Markup Language，也无需说明MVC是Model View Controller，但你可能需要说明AST是Abstract Syntax Tree，DSL是Domain Specific Language（而不是Digital Subscriber Line）。</p>

<h4><a name="rule40">40. 使用Bullets组织长段</a></h4>

<p>如果一段项目过长，请使用Bullets而不是“Firstly&hellip;, secondly&hellip;, finally&hellip;”，例如：</p>

<p>Firstly, I collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java. Secondly, I developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos. Finally, I improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</p>

<p>即便是一个English native speaker，看到这样的大长段也会发怵，这里可以利用Bullets改善可读性：</p>

<ol>
<li>Collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java.</li>
<li>Developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos.</li>
<li>Improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</li>
</ol>


<h4><a name="rule41">41. 打下良好的英文基础</a></h4>

<p>归根到底，写好英文简历需要良好的英文基础，所以我在这里推荐几本不错的英语基础书籍：</p>

<p><img src="http://img3.douban.com/lpic/s1446975.jpg" alt="Practical English Usage" /></p>

<p><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a>：简洁，精炼，学习英文语法和口语的必备书籍。</p>

<p><img src="http://img5.douban.com/lpic/s11442466.jpg" alt="Collins Pocket English Thesaurus" /></p>

<p><a href="http://www.amazon.com/Collins-Pocket-English-Thesaurus-Dictionaries/dp/0007450567/">Collins Pocket English Thesaurus</a>：个人无责任推荐——每天看一点，这本书不会提升你的词汇量（Total Vocabulary），但会提升你的有效词汇量（Effective Vocabulary）。</p>

<p><img src="http://img5.douban.com/lpic/s4228916.jpg" alt="Elements of Style" /></p>

<p><a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>：英语写作第一书。无论是写作，还是编程，都能从本书受益良多。</p>

<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a>：可能是目前唯一一本讲述中式英语的书籍，尽管书中的例子有点政治化，但不妨碍本书是一本好书。</p>

<p>这篇文章的主题并非英语学习，如果你对英语学习有兴趣可以去Google和<del>逼乎</del>知乎搜索更相关的答案。</p>

<p>当然，如果你只是想得到一个不错的英文简历，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h3><a name="sec8">其它</a></h3>

<p>剩下的是一些通用原则。</p>

<h4><a name="rule42">42. 考虑使用超链接</a></h4>

<p>这项原则是<em>原则8. 使用可以点击的链接</em>的扩充——超链接适用于简历全文，而不只适用于个人信息里的个人主页和邮箱地址：</p>

<ul>
<li>如果你的作品/项目有介绍链接，请提供它</li>
<li>如果你的作品/项目有在线演示，请提供它</li>
<li>如果你的作品/项目有用户反馈，请提供它</li>
</ul>


<p>使用超链接时要注意一点：使用隐式超链接而非显式超链接，例如使用<a href="http://www.google.com">Google</a>而非<a href="http://www.google.com">http://www.google.com</a>。因为显式超链接往往很长而且不可读，还会破坏打印版简历的效果。</p>

<h4><a name="rule43">43. 考虑提供一个“加强版”简历</a></h4>

<p>这项原则是<a href="#rule42">原则42. 考虑使用超链接</a>的补充，简历受限于篇幅（一般是一页）和格式（一般是PDF），无法提供更多丰富多彩的内容。但你可以用超链接关联一个外部“加强版”简历。</p>

<p>一个典型例子是<a href="http://iconmoon.com/about/">JJ Ying</a>的在线“简历”（使用Parallax效果），这种“加强版”简历往往会使简历阅读者眼前一亮，从而大大增加你的简历通过率。</p>

<h4><a name="rule44">44. 考虑提供开发社区账号</a></h4>

<p>如果你有非常活跃的开发社区（例如<a href="http://stackoverflow.com/">Stack Overflow</a>，<a href="https://github.com/">GitHub</a>和<a href="http://www.reddit.com/r/programming/">Reddit Programming</a>等开发社区）账号，那么请在简历中提供它们。</p>

<p>注意我说的开发社区账号，而不是社交网络账号：提供<a href="http://www.renren.com/">人人</a>、<a href="http://www.weibo.com/">微博</a>或<a href="https://www.facebook.com/">Facebook</a>账号不会对简历有任何帮助。</p>

<h4><a name="rule45">45. 持续更新简历</a></h4>

<p>优秀的简历应该是<del>与时俱进</del>持续更新的。从现在开始，定一个周期（一个月或三个月），然后以这个周期持续更新简历，这样你可以：</p>

<ol>
<li>随时拥有最新的简历，而不是在求职时挖空心思编写</li>
<li>形成一个成长记录，以便自我改善</li>
<li>时刻提醒自己持续学习，如果你发现这个周期的简历同上个周期变化不大，你就要好好反思下了</li>
</ol>


<p>以我自己为例，我维护着一个Markdown简历，每两个月一更新，通过更新记录/当前简历/下一步计划，我可以更有效的指导我的学习和工作。</p>

<h4><a name="rule46">46. 不断提升个人能力</a></h4>

<blockquote><p>“没有声音，再好的戏也出不来”
某广告语</p></blockquote>

<p>简历原则有助于展示（Demostrate）实力，而不是放大（Amplify）实力——打个比方，你的实力有100分，低劣的简历会让你看起来只有50分，而良好的简历则会展现出你100分，但不要指望简历会把你变成200分——我承认有些人可以通过说谎/造假/吹牛达到这个效果，但我不推荐这种透支信用的做法。</p>

<p>所以，优秀简历的根本是强大的实力，多学习，多做有影响力/复杂度（参考<a href="#rule26">原则26. 强调影响力和复杂度</a>）的项目，而不是在马上找工作的时候挖空心思编项目堆技能。没有声音，再好的戏也出不来。</p>

<h4><a name="rule47">47. 考虑征求他人意见</a></h4>

<blockquote><p>“当局者迷，旁观者清”</p></blockquote>

<p>在投递简历前，最好去征求他人意见——外人往往可以看出你简历的不足，指出低级错误，给出不错的建议。</p>

<p>当然你也可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h2>总结</h2>

<p>在这里我把精益技术简历的47条原则整理在一起，以便阅读整理：</p>

<h3><a href="#sec1">版式</a></h3>

<ol>
<li><a href="#rule1">原则1：使用对齐</a></li>
<li><a href="#rule2">原则2：不必使用居中</a></li>
<li><a href="#rule3">原则3：谨慎使用<strong>粗体</strong></a></li>
<li><a href="#rule4">原则4：避免不必要的折行</a></li>
<li><a href="#rule5">原则5：使用制表符辅助对齐</a></li>
</ol>


<h3><a href="#sec2">个人信息</a></h3>

<ol>
<li><a href="#rule6">原则6：不要使用不必要的条目名称</a></li>
<li><a href="#rule7">原则7：使用分隔符增强电话号码的可读性</a></li>
<li><a href="#rule8">原则8：使用可以点击的链接</a></li>
<li><a href="#rule9">原则9：不要使用照片</a></li>
<li><a href="#rule10">原则10：不要写无关个人信息</a></li>
<li><a href="#rule11">原则11：使用客观事实而非主观描述</a></li>
<li><a href="#rule12">原则12：考虑提供他人的评价</a></li>
<li><a href="#rule13">原则13：不必写求职目标</a></li>
</ol>


<h3><a href="#sec3">技术能力</a></h3>

<ol>
<li><a href="#rule14">原则14：不要堆砌技术名词</a></li>
<li><a href="#rule15">原则15：对技术进行分类</a></li>
<li><a href="#rule16">原则16：使用正确的技术名称</a></li>
<li><a href="#rule17">原则17：不要写电脑能力</a></li>
<li><a href="#rule18">原则18：按照熟悉程度对技术能力进行排序</a></li>
<li><a href="#rule19">原则19：不要写过于特定的技术</a></li>
<li><a href="#rule20">原则20：谨慎使用精通</a></li>
<li><a href="#rule21">原则21：使用项目经验印证技术能力</a></li>
</ol>


<h3><a href="#sec4">项目经历</a></h3>

<ol>
<li><a href="#rule22">原则22：按照时间对项目经历排序</a></li>
<li><a href="#rule23">原则23：不要列出过多的项目</a></li>
<li><a href="#rule24">原则24：强调成果而非过程</a></li>
<li><a href="#rule25">原则25：使用量化结果而非抽象描述</a></li>
<li><a href="#rule26">原则26：强调影响力和复杂度</a></li>
</ol>


<h3><a href="#sec5">教育背景</a></h3>

<ol>
<li><a href="#rule27">原则27：不要写大学之前的教育经历</a></li>
<li><a href="#rule28">原则28：不要写课程列表</a></li>
<li><a href="#rule29">原则29：考虑使用成绩或排名</a></li>
<li><a href="#rule30">原则30：考虑使用导师（老师）的评语</a></li>
<li><a href="#rule31">原则31：考虑使用学业相关的奖项</a></li>
</ol>


<h3><a href="#sec6">个人爱好</a></h3>

<ol>
<li><a href="#rule32">原则32：避免写个人爱好</a></li>
</ol>


<h3><a href="#sec7">英文简历</a></h3>

<ol>
<li><a href="#rule33">原则33：不要出现拼写错误</a></li>
<li><a href="#rule34">原则34：不要使用全角字符</a></li>
<li><a href="#rule35">原则35：使用正确的词汇</a></li>
<li><a href="#rule36">原则36：使用简洁的句子</a></li>
<li><a href="#rule37">原则37：避免中式英语</a></li>
<li><a href="#rule38">原则38：使用一致的时态</a></li>
<li><a href="#rule39">原则39：考虑提供缩写词的解释</a></li>
<li><a href="#rule40">原则40：使用Bullets组织长段</a></li>
<li><a href="#rule41">原则41：打下良好的英文基础</a></li>
</ol>


<h3><a href="#sec8">其它</a></h3>

<ol>
<li><a href="#rule42">原则42：考虑使用超链接</a></li>
<li><a href="#rule43">原则43：考虑提供一个“加强版”简历</a></li>
<li><a href="#rule44">原则44：考虑提供开发社区账号</a></li>
<li><a href="#rule45">原则45：持续更新简历</a></li>
<li><a href="#rule46">原则46：不断提升个人能力</a></li>
<li><a href="#rule47">原则47：考虑征求他人意见</a></li>
</ol>


<h2>参考</h2>

<p>书籍：</p>

<ol>
<li><a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X/">Cracking the Coding Interview: 150 Programming Questions and Solutions</a></li>
<li><a href="http://www.amazon.com/The-Google-Resume-Prepare-Microsoft/dp/0470927623/">The Google Resume: How to Prepare for a Career and Land a Job at Apple, Microsoft, Google, or any Top Tech Company</a></li>
<li><a href="http://www.amazon.com/Land-Tech-Love-Pragmatic-Life/dp/1934356263/">Land the Tech Job You Love</a></li>
<li><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a></li>
<li><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a></li>
</ol>


<p>链接：</p>

<ol>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></li>
<li><a href="http://www.weibo.com/p/1001603769729557894059">英文简历咨询服务</a>：再次谢谢关注者的简历！</li>
</ol>


<hr />

<p>以上。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[来自苹果的编程语言——Swift简介]]></title>
    <link href="http://zh.lucida.me/blog/an-introduction-to-swift/"/>
    <updated>2014-06-02T18:22:19-07:00</updated>
    <id>http://zh.lucida.me/blog/an-introduction-to-swift</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>这篇文章简要介绍了苹果于<a href="https://developer.apple.com/wwdc/">WWDC 2014</a>发布的编程语言——Swift。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>

<h2>前言</h2>

<p>在这里我认为有必要提一下<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，Swift编程环境的大部分概念都源自于<a href="http://worrydream.com/">Bret</a>这个演讲。</p>

<p>接下来进入正题。</p>

<h2>Swift是什么？</h2>

<p>Swift是苹果于WWDC 2014发布的编程语言，这里引用<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>的原话：</p>

<blockquote><p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>

<p>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible and more fun.</p>

<p>Swift&rsquo;s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to imagine how software development works.</p>

<p>Swift is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</p></blockquote>

<p>简单的说：</p>

<ol>
<li>Swift用来写iOS和OS X程序。（估计也不会支持其它屌丝系统）</li>
<li>Swift吸取了C和Objective-C的优点，且更加强大易用。</li>
<li>Swift可以使用现有的Cocoa和Cocoa Touch框架。</li>
<li>Swift兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</li>
</ol>


<h2>Swift语言概览</h2>

<!-- more -->


<h3>基本概念</h3>

<p>注：这一节的代码源自<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>中的<em>A Swift Tour</em>。</p>

<h4>Hello, world</h4>

<p>类似于脚本语言，下面的代码即是一个完整的Swift程序。</p>

<p><code>csharp
println("Hello, world")
</code></p>

<h4>变量与常量</h4>

<p>Swift使用<code>var</code>声明变量，<code>let</code>声明常量。</p>

<p><code>csharp
var myVariable = 42
myVariable = 50
let myConstant = 42
</code></p>

<h4>类型推导</h4>

<p>Swift支持类型推导（Type Inference），所以上面的代码不需指定类型，如果需要指定类型：</p>

<p><code>csharp
let explicitDouble : Double = 70
</code></p>

<p>Swift不支持隐式类型转换（Implicitly casting），所以下面的代码需要显式类型转换（Explicitly casting）：</p>

<p><code>csharp
let label = "The width is "
let width = 94
let labelWidth = label + String(width)
</code></p>

<h4>字符串格式化</h4>

<p>Swift使用<code>\(item)</code>的形式进行字符串格式化：</p>

<p><code>csharp
let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></p>

<h3>数组和字典</h3>

<p>Swift使用<code>[]</code>操作符声明数组（array）和字典（dictionary）：</p>

<p>```csharp
var shoppingList = [&ldquo;catfish&rdquo;, &ldquo;water&rdquo;, &ldquo;tulips&rdquo;, &ldquo;blue paint&rdquo;]
shoppingList[1] = &ldquo;bottle of water&rdquo;</p>

<p>var occupations = [</p>

<pre><code>"Malcolm": "Captain",
"Kaylee": "Mechanic",
</code></pre>

<p>]
occupations[&ldquo;Jayne&rdquo;] = &ldquo;Public Relations&rdquo;
```</p>

<p>一般使用初始化器（initializer）语法创建空数组和空字典：</p>

<p><code>csharp
let emptyArray = String[]()
let emptyDictionary = Dictionary&lt;String, Float&gt;()
</code></p>

<p>如果类型信息已知，则可以使用<code>[]</code>声明空数组，使用<code>[:]</code>声明空字典。</p>

<h3>控制流</h3>

<h4>概览</h4>

<p>Swift的条件语句包含<code>if</code>和<code>switch</code>，循环语句包含<code>for-in</code>、<code>for</code>、<code>while</code>和<code>do-while</code>，循环/判断条件不需要括号，但循环/判断体（body）必需括号：</p>

<p>```csharp
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {</p>

<pre><code>if score &gt; 50 {
    teamScore += 3
} else {
    teamScore += 1
}
</code></pre>

<p>}
```</p>

<h4>可空类型</h4>

<p>结合<code>if</code>和<code>let</code>，可以方便的处理可空变量（nullable variable）。对于空值，需要在类型声明后添加<code>?</code>显式标明该类型可空。</p>

<p>```csharp
var optionalString: String? = &ldquo;Hello&rdquo;
optionalString == nil</p>

<p>var optionalName: String? = &ldquo;John Appleseed&rdquo;
var gretting = &ldquo;Hello!&rdquo;
if let name = optionalName {</p>

<pre><code>gretting = "Hello, \(name)"
</code></pre>

<p>}
```</p>

<h4>灵活的switch</h4>

<p>Swift中的<code>switch</code>支持各种各样的比较操作：</p>

<p>```csharp
let vegetable = &ldquo;red pepper&rdquo;
switch vegetable {
case &ldquo;celery&rdquo;:</p>

<pre><code>let vegetableComment = "Add some raisins and make ants on a log."
</code></pre>

<p>case &ldquo;cucumber&rdquo;, &ldquo;watercress&rdquo;:</p>

<pre><code>let vegetableComment = "That would make a good tea sandwich."
</code></pre>

<p>case let x where x.hasSuffix(&ldquo;pepper&rdquo;):</p>

<pre><code>let vegetableComment = "Is it a spicy \(x)?"
</code></pre>

<p>default:</p>

<pre><code>let vegetableComment = "Everything tastes good in soup."
</code></pre>

<p>}
```</p>

<h4>其它循环</h4>

<p><code>for-in</code>除了遍历数组也可以用来遍历字典：</p>

<p>```csharp
let interestingNumbers = [</p>

<pre><code>"Prime": [2, 3, 5, 7, 11, 13],
"Fibonacci": [1, 1, 2, 3, 5, 8],
"Square": [1, 4, 9, 16, 25],
</code></pre>

<p>]
var largest = 0
for (kind, numbers) in interestingNumbers {</p>

<pre><code>for number in numbers {
    if number &gt; largest {
        largest = number
    }
}
</code></pre>

<p>}
largest
```</p>

<p><code>while</code>循环和<code>do-while</code>循环：</p>

<p>```csharp
var n = 2
while n &lt; 100 {</p>

<pre><code>n = n * 2
</code></pre>

<p>}
n</p>

<p>var m = 2
do {</p>

<pre><code>m = m * 2
</code></pre>

<p>} while m &lt; 100
m
```</p>

<p>Swift支持传统的<code>for</code>循环，此外也可以通过结合<code>..</code>（生成一个区间）和<code>for-in</code>实现同样的逻辑。</p>

<p>```csharp
var firstForLoop = 0
for i in 0..3 {</p>

<pre><code>firstForLoop += i
</code></pre>

<p>}
firstForLoop</p>

<p>var secondForLoop = 0
for var i = 0; i &lt; 3; ++i {</p>

<pre><code>secondForLoop += 1
</code></pre>

<p>}
secondForLoop
```</p>

<p>注意：Swift除了<code>..</code>还有<code>...</code>：<code>..</code>生成前闭后开的区间，而<code>...</code>生成前闭后闭的区间。</p>

<h3>函数和闭包</h3>

<h4>函数</h4>

<p>Swift使用<code>func</code>关键字声明函数：</p>

<p>```csharp
func greet(name: String, day: String) &ndash;> String {</p>

<pre><code>return "Hello \(name), today is \(day)."
</code></pre>

<p>}
greet(&ldquo;Bob&rdquo;, &ldquo;Tuesday&rdquo;)
```</p>

<p>通过元组（Tuple）返回多个值：</p>

<p>```csharp
func getGasPrices() &ndash;> (Double, Double, Double) {</p>

<pre><code>return (3.59, 3.69, 3.79)
</code></pre>

<p>}
getGasPrices()
```</p>

<p>支持带有变长参数的函数：</p>

<p>```csharp
func sumOf(numbers: Int&hellip;) &ndash;> Int {</p>

<pre><code>var sum = 0
for number in numbers {
    sum += number
}
return sum
</code></pre>

<p>}
sumOf()
sumOf(42, 597, 12)
```</p>

<p>函数也可以嵌套函数：</p>

<p>```csharp
func returnFifteen() &ndash;> Int {</p>

<pre><code>var y = 10
func add() {
    y += 5
}
add()
return y
</code></pre>

<p>}
returnFifteen()
```</p>

<p>作为头等对象，函数既可以作为返回值，也可以作为参数传递：</p>

<p>```csharp
func makeIncrementer() &ndash;> (Int &ndash;> Int) {</p>

<pre><code>func addOne(number: Int) -&gt; Int {
    return 1 + number
}
return addOne
</code></pre>

<p>}
var increment = makeIncrementer()
increment(7)
```</p>

<p>```csharp
func hasAnyMatches(list: Int[], condition: Int &ndash;> Bool) &ndash;> Bool {</p>

<pre><code>for item in list {
    if condition(item) {
        return true
    }
}
return false
</code></pre>

<p>}
func lessThanTen(number: Int) &ndash;> Bool {</p>

<pre><code>return number &lt; 10
</code></pre>

<p>}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
```</p>

<h4>闭包</h4>

<p>本质来说，函数是特殊的闭包，Swift中可以利用<code>{}</code>声明匿名闭包：</p>

<p>```csharp
numbers.map({</p>

<pre><code>(number: Int) -&gt; Int in
let result = 3 * number
return result
})
</code></pre>

<p>```</p>

<p>当闭包的类型已知时，可以使用下面的简化写法：</p>

<p><code>csharp
numbers.map({ number in 3 * number })
</code></p>

<p>此外还可以通过参数的位置来使用参数，当函数最后一个参数是闭包时，可以使用下面的语法：</p>

<p><code>csharp
sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }
</code></p>

<h3>类和对象</h3>

<h4>创建和使用类</h4>

<p>Swift使用<code>class</code>创建一个类，类可以包含字段和方法：</p>

<p>```csharp
class Shape {</p>

<pre><code>var numberOfSides = 0
func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}
```</p>

<p>创建<code>Shape</code>类的实例，并调用其字段和方法。</p>

<p><code>csharp
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></p>

<p>通过<code>init</code>构建对象，既可以使用<code>self</code>显式引用成员字段（<code>name</code>），也可以隐式引用（<code>numberOfSides</code>）。</p>

<p>```csharp
class NamedShape {</p>

<pre><code>var numberOfSides: Int = 0
var name: String

init(name: String) {
    self.name = name
}

func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}
```</p>

<p>使用<code>deinit</code>进行清理工作。</p>

<h4>继承和多态</h4>

<p>Swift支持继承和多态（<code>override</code>父类方法）：</p>

<p>```csharp
class Square: NamedShape {</p>

<pre><code>var sideLength: Double

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 4
}

func area() -&gt; Double {
    return sideLength * sideLength
}

override func simpleDescription() -&gt; String {
    return "A square with sides of length \(sideLength)."
}
</code></pre>

<p>}
let test = Square(sideLength: 5.2, name: &ldquo;my test square&rdquo;)
test.area()
test.simpleDescription()
```</p>

<p>注意：如果这里的<code>simpleDescription</code>方法没有被标识为<code>override</code>，则会引发编译错误。</p>

<h4>属性</h4>

<p>为了简化代码，Swift引入了属性（property），见下面的<code>perimeter</code>字段：</p>

<p>```csharp
class EquilateralTriangle: NamedShape {</p>

<pre><code>var sideLength: Double = 0.0

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 3
}

var perimeter: Double {
get {
    return 3.0 * sideLength
}
set {
    sideLength = newValue / 3.0
}
}

override func simpleDescription() -&gt; String {
    return "An equilateral triagle with sides of length \(sideLength)."
}
</code></pre>

<p>}
var triangle = EquilateralTriangle(sideLength: 3.1, name: &ldquo;a triangle&rdquo;)
triangle.perimeter
triangle.perimeter = 9.9
triangle.sideLength
```</p>

<p>注意：赋值器（setter）中，接收的值被自动命名为<code>newValue</code>。</p>

<h4>willSet和didSet</h4>

<p><code>EquilateralTriangle</code>的构造器进行了如下操作：</p>

<ol>
<li>为子类型的属性赋值。</li>
<li>调用父类型的构造器。</li>
<li>修改父类型的属性。</li>
</ol>


<p>如果不需要计算属性的值，但需要在赋值前后进行一些操作的话，使用<code>willSet</code>和<code>didSet</code>：</p>

<p>```csharp
class TriangleAndSquare {</p>

<pre><code>var triangle: EquilateralTriangle {
willSet {
    square.sideLength = newValue.sideLength
}
}
var square: Square {
willSet {
    triangle.sideLength = newValue.sideLength
}
}
init(size: Double, name: String) {
    square = Square(sideLength: size, name: name)
    triangle = EquilateralTriangle(sideLength: size, name: name)
}
</code></pre>

<p>}
var triangleAndSquare = TriangleAndSquare(size: 10, name: &ldquo;another test shape&rdquo;)
triangleAndSquare.square.sideLength
triangleAndSquare.square = Square(sideLength: 50, name: &ldquo;larger square&rdquo;)
triangleAndSquare.triangle.sideLength
```</p>

<p>从而保证<code>triangle</code>和<code>square</code>拥有相等的<code>sideLength</code>。</p>

<h4>调用方法</h4>

<p>Swift中，函数的参数名称只能在函数内部使用，但方法的参数名称除了在内部使用外还可以在外部使用（第一个参数除外），例如：</p>

<p>```csharp
class Counter {</p>

<pre><code>var count: Int = 0
func incrementBy(amount: Int, numberOfTimes times: Int) {
    count += amount * times
}
</code></pre>

<p>}
var counter = Counter()
counter.incrementBy(2, numberOfTimes: 7)
```</p>

<p>注意Swift支持为方法参数取别名：在上面的代码里，<code>numberOfTimes</code>面向外部，<code>times</code>面向内部。</p>

<h4>?的另一种用途</h4>

<p>使用可空值时，<code>?</code>可以出现在方法、属性或下标前面。如果<code>?</code>前的值为<code>nil</code>，那么<code>?</code>后面的表达式会被忽略，而原表达式直接返回<code>nil</code>，例如：</p>

<p><code>csharp
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional
square")
let sideLength = optionalSquare?.sideLength
</code>
当<code>optionalSquare</code>为<code>nil</code>时，<code>sideLength</code>属性调用会被忽略。</p>

<h3>枚举和结构</h3>

<h4>枚举</h4>

<p>使用<code>enum</code>创建枚举——注意Swift的枚举可以关联方法：</p>

<p>```csharp
enum Rank: Int {</p>

<pre><code>case Ace = 1
case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
case Jack, Queen, King
    func simpleDescription() -&gt; String {
    switch self {
        case .Ace:
            return "ace"
        case .Jack:
            return "jack"
        case .Queen:
            return "queen"
        case .King:
            return "king"
        default:
            return String(self.toRaw())
    }
}
</code></pre>

<p>}
let ace = Rank.Ace
let aceRawValue = ace.toRaw()
```</p>

<p>使用<code>toRaw</code>和<code>fromRaw</code>在原始（raw）数值和枚举值之间进行转换：
```csharp
if let convertedRank = Rank.fromRaw(3) {</p>

<pre><code>let threeDescription = convertedRank.simpleDescription()
</code></pre>

<p>}
```</p>

<p>注意枚举中的成员值（member value）是实际的值（actual value），和原始值（raw value）没有必然关联。</p>

<p>一些情况下枚举不存在有意义的原始值，这时可以直接忽略原始值：</p>

<p>```csharp
enum Suit {</p>

<pre><code>case Spades, Hearts, Diamonds, Clubs
    func simpleDescription() -&gt; String {
    switch self {
        case .Spades:
            return "spades"
        case .Hearts:
            return "hearts"
        case .Diamonds:
            return "diamonds"
        case .Clubs:
            return "clubs"
    }
}
</code></pre>

<p>}
let hearts = Suit.Hearts
let heartsDescription = hearts.simpleDescription()
```</p>

<p>除了可以关联方法，枚举还支持在其成员上关联值，同一枚举的不同成员可以有不同的关联的值：</p>

<p>```csharp
enum ServerResponse {</p>

<pre><code>case Result(String, String)
case Error(String)
</code></pre>

<p>}</p>

<p>let success = ServerResponse.Result(&ldquo;6:00 am&rdquo;, &ldquo;8:09 pm&rdquo;)
let failure = ServerResponse.Error(&ldquo;Out of cheese.&rdquo;)</p>

<p>switch success {</p>

<pre><code>case let .Result(sunrise, sunset):
    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
case let .Error(error):
    let serverResponse = "Failure... \(error)"
</code></pre>

<p>}
```</p>

<h4>结构</h4>

<p>Swift使用<code>struct</code>关键字创建结构。结构支持构造器和方法这些类的特性。结构和类的最大区别在于：结构的实例按值传递（passed by value），而类的实例按引用传递（passed by reference）。</p>

<p>```csharp
struct Card {</p>

<pre><code>var rank: Rank
var suit: Suit
func simpleDescription() -&gt; String {
    return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
}
</code></pre>

<p>}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
```</p>

<h3>协议（protocol）和扩展（extension）</h3>

<h4>协议</h4>

<p>Swift使用<code>protocol</code>定义协议：</p>

<p>```csharp
protocol ExampleProtocol {</p>

<pre><code>var simpleDescription: String { get }
mutating func adjust()
</code></pre>

<p>}
```</p>

<p>类型、枚举和结构都可以实现（adopt）协议：</p>

<p>```csharp
class SimpleClass: ExampleProtocol {</p>

<pre><code>var simpleDescription: String = "A very simple class."
var anotherProperty: Int = 69105
func adjust() {
    simpleDescription += " Now 100% adjusted."
}
</code></pre>

<p>}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription</p>

<p>struct SimpleStructure: ExampleProtocol {</p>

<pre><code>var simpleDescription: String = "A simple structure"
mutating func adjust() {
    simpleDescription += " (adjusted)"
}
</code></pre>

<p>}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
```</p>

<h4>扩展</h4>

<p>扩展用于在已有的类型上增加新的功能（比如新的方法或属性），Swift使用<code>extension</code>声明扩展：</p>

<p>```csharp
extension Int: ExampleProtocol {</p>

<pre><code>var simpleDescription: String {
    return "The number \(self)"
}
mutating func adjust() {
    self += 42
}
</code></pre>

<p>}
7.simpleDescription
```</p>

<h3>泛型（generics）</h3>

<p>Swift使用<code>&lt;&gt;</code>来声明泛型函数或泛型类型：</p>

<p>```csharp
func repeat<ItemType>(item: ItemType, times: Int) &ndash;> ItemType[] {</p>

<pre><code>var result = ItemType[]()
for i in 0..times {
    result += item
}
return result
</code></pre>

<p>}
repeat(&ldquo;knock&rdquo;, 4)
```</p>

<p>Swift也支持在类、枚举和结构中使用泛型：</p>

<p>```csharp
// Reimplement the Swift standard library&rsquo;s optional type
enum OptionalValue<T> {</p>

<pre><code>case None
case Some(T)
</code></pre>

<p>}
var possibleInteger: OptionalValue<Int> = .None
possibleInteger = .Some(100)
```</p>

<p>有时需要对泛型做一些需求（requirements），比如需求某个泛型类型实现某个接口或继承自某个特定类型、两个泛型类型属于同一个类型等等，Swift通过<code>where</code>描述这些需求：</p>

<p>```csharp
func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element> (lhs: T, rhs: U) &ndash;> Bool {</p>

<pre><code>for lhsItem in lhs {
    for rhsItem in rhs {
        if lhsItem == rhsItem {
            return true
        }
    }
}
return false
</code></pre>

<p>}
anyCommonElements([1, 2, 3], [3])
```</p>

<p>Swift语言概览就到这里，有兴趣的朋友请进一步阅读<a href="">The Swift Programming Language</a>。</p>

<p>接下来聊聊个人对Swift的一些感受。</p>

<h2>个人感受</h2>

<p><strong>注意</strong>：下面的感受纯属个人意见，仅供参考。</p>

<h3>大杂烩</h3>

<p>尽管我接触Swift不足两小时，但很容易看出Swift吸收了大量其它编程语言中的元素，这些元素包括但不限于：</p>

<ol>
<li>属性（Property）、可空值（Nullable type）语法和泛型（Generic Type）语法源自C#。</li>
<li>格式风格与Go相仿（没有句末的分号，判断条件不需要括号）。</li>
<li>Python风格的当前实例引用语法（使用<code>self</code>）和列表字典声明语法。</li>
<li>Haskell风格的区间声明语法（比如<code>1..3</code>，<code>1...3</code>）。</li>
<li>协议和扩展源自Objective-C（自家产品随便用）。</li>
<li>枚举类型很像Java（可以拥有成员或方法）。</li>
<li><code>class</code>和<code>struct</code>的概念和C#极其相似。</li>
</ol>


<p>注意这里不是说Swift是抄袭——实际上编程语言能玩的花样基本就这些，况且Swift选的都是在我看来相当不错的特性。</p>

<p>而且，这个大杂烩有一个好处——就是任何其它编程语言的开发者都不会觉得Swift很陌生——这一点很重要。</p>

<h3>拒绝隐式（Refuse implicity）</h3>

<p>Swift去除了一些隐式操作，比如隐式类型转换和隐式方法重载这两个坑，干的漂亮。</p>

<h3>Swift的应用方向</h3>

<p>我认为Swift主要有下面这两个应用方向：</p>

<h4>教育</h4>

<p>我指的是编程教育。现有编程语言最大的问题就是交互性奇差，从而导致学习曲线陡峭。相信Swift及其交互性极强的编程环境能够打破这个局面，让更多的人——尤其是青少年，学会编程。</p>

<p>这里有必要再次提到<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，看了这个视频你就会明白一个交互性强的编程环境能够带来什么。</p>

<h4>应用开发</h4>

<p>现有的iOS和OS X应用开发均使用Objective-C，而Objective-C是一门及其繁琐（verbose）且学习曲线比较陡峭的语言，如果Swift能够提供一个同现有Obj-C框架的简易互操作接口，我相信会有大量的程序员转投Swift；与此同时，Swift简易的语法也会带来相当数量的其它平台开发者。</p>

<p>总之，上一次某家大公司大张旗鼓的推出一门编程语言及其编程平台还是在2000年（微软推出C#），将近15年之后，苹果推出Swift——作为开发者，我很高兴能够见证一门编程语言的诞生。</p>

<p>以上。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于锤子手机和锤子手机发布会]]></title>
    <link href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/"/>
    <updated>2014-05-24T01:33:38-07:00</updated>
    <id>http://zh.lucida.me/blog/on-the-keynote-of-t-one</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>本文记录了作者对<a href="http://v.youku.com/v_show/id_XNzE0Nzc0OTQ0.html">锤子手机发布会</a>和<a href="http://www.smartisan.com/">锤子手机</a>的一点感受，仅代表个人看法，但欢迎评论。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">http://zh.lucida.me/blog/on-the-keynote-of-t-one/</a></p>

<h2>重复</h2>

<p>演讲（或说服）有一个要点是重复，老罗显然深得此道，整场发布会下面的句式均被重复了不止五遍：</p>

<ul>
<li>作为一个大众消费品…………（表明自己站在消费者这边）</li>
<li>作为一个小厂商…………（博取听众（消费者）的同情（sympathy）和容忍（tolerance））</li>
<li>作为一个企业家，我不该…………（在贬低其它企业之后均以此句开脱）</li>
</ul>


<h2>误导</h2>

<p>在提到锤子手机音质时老罗举了这样的例子：</p>

<blockquote><p>我老婆之前认为自己是木耳，听不出音质的区别，但把苹果耳机换成几百森海塞尔后，她明显感到音质有了很大的提升。</p></blockquote>

<p>以证明即便是普通人也可以感受到音质的区别。</p>

<p>但这里有个问题：老罗夫人感受到的音质的提升源自于<strong>耳机</strong>，而非<strong>音源</strong>。在同等耳机的情况下，我怀疑老罗夫人是否还能听出锤子手机和同类手机间音质的区别。</p>

<p>此外，在提到无法更换壁纸的问题时老罗是这么解释的：</p>

<blockquote><p>我无法忍受把一堆图标堆在亲人的脸上。</p></blockquote>

<p>似乎确实很有道理，但再想一想，为什么一定要用亲人头像做壁纸呢？如果我要用风景或是纯色呢？</p>

<!-- more -->


<h2>冷知识</h2>

<p>老罗很擅长用一些冷门知识去吸引人，这样的例子在这次发布会上数不胜数：</p>

<ul>
<li>不断的列出硬件厂商的渊源。</li>
<li>指出锤子手机手机盒子使用了某英国著名公司的纸。</li>
<li>强调光线传感器的设计。</li>
<li>自带螺丝刀和若干螺丝钉。</li>
</ul>


<p>个人认为这些东西是Boilerplate——懂编程的童鞋应该明白我的意思。</p>

<h2>拍照效果</h2>

<p>老罗宣称锤子手机是目前最好的拍照手机之一，并花了大量时间去阐述他在打造拍照效果上所付出的努力，比如：</p>

<ul>
<li>寻找最好的拍照调校团队。</li>
<li>使用最好的摄像镜头。</li>
</ul>


<p>但令我疑惑的是：发布会并没有任何拍照效果的对比，甚至连锤子手机的拍照样张都没有——如果拍照效果真的那么强大，我不认为老罗会放这个贬低其他竞争对手的机会于不顾。</p>

<h2>双音量键</h2>

<p>锤子手机有一个很有趣的设计是双音量键——在单独使用时可以分别作为音量调节和亮度调节使用，而一起使用时则可以进行抢拍或快速启动某个指定应用程序。</p>

<p>这也带来了老罗所宣称的“全世界最快的抢拍手机”这个卖点。</p>

<p>但我还是有几个疑问：</p>

<ol>
<li>双音量键一起使用是一个很不直观的设计。</li>
<li>同时使用双音量键很不自然，不信的话你在你的手机上试试这个姿势。</li>
<li>从设计图上可以看出音量键并没有明显凸起——这意味着操作时需要按<strong>进</strong>音量键，也意味着任何手机壳或是bumper之类阻隔音量键的手机饰品均会妨碍音量键的正常使用。</li>
</ol>


<h2>对苹果的模仿</h2>

<h3>锤子手机在模仿iPhone5</h3>

<p>这里借用某条<a href="http://weibo.com/1847542877/B5fhi9RoE">微博</a>里的图片：</p>

<p><img src="http://i.imgur.com/VOSZ1dX.jpg" alt="无处不在的模仿" /></p>

<h3>锤子手机发布会处处在模仿iPhone1发布会</h3>

<p>iPhone1发布会时Jobs曾给出一个转盘手机的假想图：</p>

<p><img src="http://i.imgur.com/sfOzhfx.png" alt="转盘手机" /></p>

<p>老罗则给出一个锤子手机的假想图：</p>

<p><img src="http://i.imgur.com/fkoM9QQ.png" alt="锤子手机" /></p>

<p>iPhone1发布时Jobs强调三位一体的概念：</p>

<p><img src="http://i.imgur.com/WDmytpx.png" alt="三位一体" /></p>

<p>老罗也是如此：</p>

<p><img src="http://i.imgur.com/FK5fsC2.png" alt="又一个三位一体" /></p>

<p>Jobs经常在发布会最后来一个“One more thing”：</p>

<p><img src="http://i.imgur.com/ebmQPgi.png" alt="One more thing" /></p>

<p>到了老罗这里变成“还有两个好东西”：</p>

<p><img src="http://i.imgur.com/6yXVZ4a.png" alt="还有两个好东西" /></p>

<h2>软件改进</h2>

<p>下面是老罗重点介绍的锤子手机的软件改进：</p>

<ul>
<li>可以更换的主题：这个我真觉的不是啥改进——除非要和Windows Phone比。</li>
<li>手指横扫解决单手操作问题：很有创意的想法，但我注意到即便老罗本人如此操作锤子手机时也有相当的失误率——我怀疑这个功能的实用性。</li>
<li>通过短信内容智能新建日历：无论是Google还是Apple都已经有这个功能。</li>
<li>定时解除静音：很赞，这是我一直希望的功能。</li>
<li>区域截屏：看似很赞，但仔细一想几乎所有的手机聊天应用里面都带有编辑图片的选项，此外我个人对这个功能的稳定性有疑问。</li>
</ul>


<h2>总结</h2>

<p>锤子手机发布会最大的亮点是对OpenSSL的捐款，至于锤子手机本身……抱歉我没看到什么亮点。</p>

<p>但令我诧异的是很多资深人士纷纷表示看好锤子手机（发布会），<a href="http://www.weibo.com/fenng">fenng</a>甚至在微信上宣称这是手机行业迄今为止最好的产品发布会——</p>

<p><img src="http://i.imgur.com/MqEKRBk.jpg" alt="最好的产品发布会？？" /></p>

<p>我不清楚他是否也把iPhone发布会算在内。</p>

<p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress，就这场发布会所得到的信息，我依然认为锤子手机没有希望。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的算法学习之路]]></title>
    <link href="http://zh.lucida.me/blog/on-learning-algorithms/"/>
    <updated>2014-05-04T13:43:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-learning-algorithms</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>严格来说，本文题目应该是<strong>我的数据结构和算法学习之路</strong>，但这个写法实在太绕口——况且CS中的算法往往暗指数据结构和算法（例如<strong>算法导论</strong>指的实际上是<strong>数据结构和算法导论</strong>），所以我认为本文题目是合理的。</p>

<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/">http://zh.lucida.me/blog/on-learning-algorithms/</a></p>

<p>原文作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<h3>这篇文章讲了什么？</h3>

<ul>
<li>我这些年学习数据结构和算法的总结。</li>
<li>一些不错的算法书籍和教程。</li>
<li>算法的重要性。</li>
</ul>


<h2>初学</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的"学长"和"大神"请教应该读哪些算法书籍，"学长"们均推荐算法导论，还有几个"大神"推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了<a href="http://www.douban.com/">豆瓣</a>这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些"学长"或是"大神"靠谱的多得多。</p>

<!-- more -->


<h3>数据结构与算法分析——C语言描述</h3>

<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt="数据结构与算法分析——C语言描述" /></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N<sup>3</sup>)杀到O(N<sup>2</sup>)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h3>微软的梦工厂</h3>

<p><img src="http://img3.douban.com/lpic/s3322643.jpg" alt="微软的梦工厂" /></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了"找工作就要这样的公司"的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己"毕业就工作"的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h3>算法设计与分析</h3>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://img3.douban.com/lpic/s2019521.jpg" alt="算法设计与分析基础" /></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具。</p>

<h3>算法引论</h3>

<p><img src="http://img5.douban.com/lpic/s4230097.jpg" alt="算法引论" /></p>

<p><a href="http://book.douban.com/subject/4178907/">算法引论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://img3.douban.com/lpic/s2019521.jpg">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ol>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ol>


<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h3>百度实习面试</h3>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个<code>stof</code>（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li>原来自己连百度实习面试都过不去。</li>
<li>原来自己还是一个编程弱逼。</li>
<li>原来自己还是一个算法菜逼。</li>
</ul>


<p>痛定思痛，我开始了第二个"五年计划"，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h3>Elements of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s4243636.jpg" alt="Elements of Programming" /></p>

<p>由于一直觉得名字里带"Elements of"的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h3>C Interfaces and Implementation</h3>

<p><img src="http://img5.douban.com/lpic/s1686769.jpg" alt="C Interfaces and Implementation" /></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826292/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的<a href="http://www.amazon.com/review/RMXKDJNH8UOPU/">评论</a>：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是<code>stof</code>这种简单到爆的"算法"。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——<strong>纸上编码</strong>。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的<a href="http://book.douban.com/review/3733680/">文章</a>来黑那些动不动就"基础"或"内功"的所谓"大牛"们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote><p>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</p></blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸。</p>

<h3>LL(k)</h3>

<p>我在微软实习的第一个项目做的是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>分析——计算T-SQL存储过程的代码覆盖率。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://img5.douban.com/lpic/s24921197.jpg" alt="Language Implementation Patterns" /></p>

<p>比较奇诡的是，做这个项目时当时我刚好把<a href="http://www.antlr.org/">ANTLR</a>作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h3>拼音索引</h3>

<p>拼音索引是我接的一个手机应用私活里的小模块，用户期待在手机文本框可以根据输入给出智能提示：</p>

<p>比如说输入中国：</p>

<p><img src="http://i.imgur.com/tjKjyzN.png" alt="智能提示" /></p>

<p>同样，输入拼音也应给出提示：</p>

<p><img src="http://i.imgur.com/zTjEBik.png" alt="智能提示" /></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ol>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用<code>Int16</code>索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用<code>Int64</code>建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个<code>Int64</code>里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ol>


<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，<strong>如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞</strong>。</p>

<h3>快速字符串匹配</h3>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找"张晓明"，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。</p>

<p><img src="http://i.imgur.com/R3JalOH.jpg" alt="E51" /></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><img src="http://i.imgur.com/Pfff0e9.jpg" alt="Cry" /></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://img3.douban.com/lpic/s8978030.jpg" alt="Algorithms on Strings, Trees and Sequences" /></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h3>Writing Efficient Programs</h3>

<p>之后又做了若干个项目，多多少少都用到了"自制"的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种<strong>将有限计算资源发挥到极致</strong>的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://img3.douban.com/lpic/s3780111.jpg" alt="Writing Efficient Programs" /></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了<strong>过早优化是万恶之源</strong>之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h3>Algorithm Design Manual</h3>

<p><img src="http://img3.douban.com/lpic/s10347625.jpg" alt="Algorithm Design Manual" /></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3072383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h3>编程珠玑&amp;更多的编程珠玑</h3>

<p><img src="http://img3.douban.com/lpic/s2712842.jpg" alt="Programming Pearls" /></p>

<p><img src="http://img3.douban.com/lpic/s7073511.jpg" alt="More Programming Pearls" /></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h3>The Science of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s2812798.jpg" alt="The Science of Programming" /></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>引用的书籍，撸完<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>之后，本屌获得了<strong>证明简单代码段的正确性</strong>这个技能——求职面试三板斧之二。</p>

<p><strong>证明简单代码段的正确性</strong>是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的<a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">博客</a>，总之就是<strong>项目经历</strong>、<strong>纸上代码</strong>加<strong>正确性证明</strong>这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称<strong>拼写</strong>出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h3>Algorithms 4th</h3>

<p><img src="http://img5.douban.com/lpic/s8938479.jpg" alt="Algorithms" /></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h3>6.851 Advanced Data Structures</h3>

<p><img src="http://courses.csail.mit.edu/6.851/spring12/illus.png" alt="Advanced Data Structures" /></p>

<p><a href="http://courses.csail.mit.edu/6.851/">Advanced Data Structures</a>是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google <strong>Advanced Data Structures</strong>第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带"记忆"的数据结构（Data Structure with Persistence）。</li>
<li>van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。</li>
<li>o(1)时间复杂度的的LCA、RMQ和LA解法。</li>
<li>奇幻的o(n)时间复杂度的Suffix Tree构建方法。</li>
<li>o(lglgn)的BST。</li>
<li>&hellip;</li>
</ul>


<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决<strong>实际</strong>问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p><a href="http://norvig.com/">Peter Norvig</a>曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：</p>

<blockquote><p>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：</p>

<blockquote><p>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</p></blockquote>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>

<p>By <a href="http://zh.lucida.me">Lucida</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习&使用技术的四种层次]]></title>
    <link href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/"/>
    <updated>2014-04-12T17:53:21-07:00</updated>
    <id>http://zh.lucida.me/blog/levels-on-learning-and-using-technologies</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>技术，生活，反思。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/</a></p>

<h2>关于</h2>

<p>Bjarne Stroustrup在他的新书《<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A tour of C++</a>》</p>

<p><img src="http://i.imgur.com/VlQ7ROA.jpg" alt="A tour of C++" style="max-height: 370px;"/></p>

<p>里面举了一个旅行的例子来比喻初学编程语言：</p>

<blockquote><p>&hellip;as an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions what to see next&hellip;</p>

<p>&hellip;you do not know the city after such a tour. You do not understand all you have seen and heard. You do not know how to navigate the formal and informal rules that govern life in the city&hellip;</p>

<p>&hellip;to really know a city, you have to live in it, often for years.</p></blockquote>

<p>简而言之，编程语言是City，而开发者则是Traveller——这是一个很有意思的比喻，在这篇文章里，我试图<strong>延续</strong>这个类比（Analogy）——把这个类比放大到初学，掌握，了解以至精通一门技术的层面。</p>

<p>不过需要注意：我自己并没有精通哪一门技术——所以这篇文章的内容是值得怀疑（susceptible）的，但它可以作为一个不错的参考。</p>

<!-- more -->


<h2>0. Stranger（陌生人）</h2>

<p>使用一项技术最初的层次就是听说过没用过——就像我们之中的大多数人都听过南极，听过北极，知道南极有企鹅，北极有北极熊，但是却从来没有去过南极或北极。</p>

<p>Stranger具有以下的特征：</p>

<ul>
<li>知道这项技术的名字。</li>
<li>知道这项技术的一些术语。</li>
<li>知道这项技术的一些关键人物的名字。</li>
<li>了解少量技术的细节，但没有使用这项技术的实际经验。</li>
</ul>


<p>以我本人和RoR来打个比方：</p>

<ul>
<li>知道RoR是Ruby on Rails。</li>
<li>知道Rails，Gem和Rake的存在。</li>
<li>知道DHH也知道松本行弘。</li>
<li>看过<a href="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/">The Ruby Programming Language</a>，还使用一个基于RoR的博客框架<a href="http://octopress.org/">Octopress</a>写博客。</li>
<li>但从来没有使用RoR去搭建网站。</li>
</ul>


<p>所以我是一个RoR的Stranger。</p>

<p>对于新技术，绝大多数人都是Stranger——但是就我对国内技术社区的观察，相当数量的Stranger意识不到自己还是Stranger——认为知道一点术语一些人名就算了解一门技术，甚至把它写在简历上（Familiar with XXX）或是开始与别人进行讨论（当然都是毫无意义的讨论）。</p>

<h2>1. Tourist（旅行者）</h2>

<p>当开发者真正开始用一项技术作出了可以用的东西：</p>

<ul>
<li>面向用户的产品（End-User-Oriented Product），比如一个手机应用，或是一个浏览器插件。</li>
<li>或是面向程序员的工具（Programmer-Oriented Tools），比如一个页面抓取框架，或一个简单的Parser Generator。</li>
<li>注意教科书范例（Textbook examples）和Hello world不属于可以用的东西——这些只是Dead Code——被执行一两次，然后被遗忘。</li>
</ul>


<p>这时这个开发者就进入到了Tourist阶段：</p>

<ul>
<li>了解这项技术的基本元素。</li>
<li>使用这项技术做出了实用的产品或工具。</li>
<li>了解对这项技术的部分细节。</li>
</ul>


<p>根据的学习目的的不同，Tourist又可以分为Salesman和Sightseer。</p>

<h3>1.1. Salesman（旅行商）</h3>

<p><img src="http://i.imgur.com/k5oucJ5.jpg" alt="Salesman" style="max-height: 370px;"/></p>

<p>Salesman是具有明确目的的Tourist——他们学习技术的目标是为了完成某一项业务，就像旅行商去某地出差是为了卖商品而非观光一样。</p>

<p>绝大多数职业开发者在开发生涯中都会扮演Salesman这个角色——接到一个任务，涉及到某项不熟悉的技术，需要在限定时间内完成。</p>

<h3>1.2. Sightseer（观光者）</h3>

<p><img src="http://i.imgur.com/RpYoDXc.gif" alt="Sightseer" style="max-height: 370px;"/></p>

<p>和Salesman相反，Sightseer学习技术的目标是为了拓展视野，增加见识，而非完成某项特定业务。</p>

<p>具有主动学习精神的开发者在业余时会时常扮演Sightseer角色——找到自己认为有价值的新技术或是基础知识进行系统学习，从而拓宽视野，提高水平。</p>

<h2>2. Resident（居住者）</h2>

<p>如果一个旅行者在一个地方待了半年以上，那么他/她就会变得原来越像当地人。随着Tourist对某项技术的日益精进，他/她会逐渐演变成这项技术的Resident：</p>

<ul>
<li>熟悉这项技术的基本元素。</li>
<li>熟悉这项技术的生态系统（Ecology）：既包括开发工具（编辑器，命令行工具，集成开发环境等），也包括开发社区（讨论组，邮件列表等）。</li>
<li>了解这项技术能做什么，不能做什么。</li>
<li>了解这项技术有那些坑，如何绕过这些坑，以及识别这些坑带来的问题。</li>
<li>对某些领域有深入的研究——但并不受限于特定领域。</li>
<li>使用这项技术做出了有相当价值的产品或工具。</li>
</ul>


<p>同Tourist一样，根据使用技术的目标不同，Resident可以分为Worker和Craftsman：</p>

<h2>2.1. Worker（工人）</h2>

<p><img src="http://i.imgur.com/jGNNrQp.jpg" alt="Worker" style="max-height: 370px;"/></p>

<p>技术是Worker的谋生手段，一个优秀的Worker应具备以下特征：</p>

<ul>
<li>对于给定问题，知道如何给出经济有效的解决方案。</li>
<li>以团队合作为主，了解团队合作的价值，能够推动团队项目健康前进。</li>
<li>追求按时交付。</li>
</ul>


<h3>2.2. Craftsman（工匠）</h3>

<p><img src="http://i.imgur.com/9RRUjmb.jpg" alt="Craftsman" style="max-height: 370px;"/></p>

<p>同Worker不同，技术并非Craftsman的谋生手段，而是某种“副业”——用来提升声望，修炼开发水平。</p>

<p>一个优秀的Craftman往往具备以下特点：</p>

<ul>
<li>对于给定问题，知道如何给出优雅的解决方案。</li>
<li>以单兵作战为主，主要靠个人推进项目，但也能进行一定程度的团队合作。</li>
<li>追求极致美感。</li>
</ul>


<h2>3. Architect（架构者）</h2>

<p>有想法且有能力的人在一个地方待久了都会有将这个地方变的更好的冲动——一种方式是从源头出发，推翻旧制度建立新社会，也就是革命；另一种方式则是保留现有的制度，对其进行温和但持续的改进，也就是改良。</p>

<p>技术也是如此，任何技术都跟不上开发者成长的脚步，当这种差距到达一定程度时，就会有卓越的开发者站出来，创造出新的技术，他们就是Architect：</p>

<ul>
<li>熟悉多项互相关联的技术，并了解他们的优势和不足。</li>
<li>具备强大的领导能力，深厚的基础和大量实际开发经验。</li>
<li>能够带动整个技术的生态系统发展。</li>
<li>好吧，我编不下去了（尼玛我要都知道我还至于是IT苦屌么 &ndash;_-）</li>
</ul>


<p>如果你看过<a href="http://movie.douban.com/subject/1304141/">Matrix 2: Reloaded</a></p>

<p><img src="http://i.imgur.com/EDyNv4F.jpg" alt="Matrix 2: Reloaded" style="max-height: 370px;"/></p>

<p>就会知道Architect这个词放在这里再好不过。</p>

<p>根据目标不同，Architect分为Reformist和Revolutionist。</p>

<h3>3.1. Reformist（改良者）</h3>

<p><img src="http://i.imgur.com/xp2SzWu.jpg" alt="Reformist" style="max-height: 370px;"/></p>

<p>改良者的目标：<strong>把现有技术变的更好</strong>。（<strong>Makes</strong> existing technology better）</p>

<p>例如：</p>

<ul>
<li>GoF总结<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Pattern</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/John_Resig">John Resig</a>创造<a href="http://en.wikipedia.org/wiki/Jquery">jQuery</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>为C#引入<a href="http://en.wikipedia.org/wiki/LINQ">LINQ</a>。</li>
</ul>


<h3>3.2. Revolutionist（革命者）</h3>

<p><img src="http://i.imgur.com/cpmjDCC.jpg" alt="Revolutionist" style="max-height: 370px;"/></p>

<p>革命者的目标：<strong>用更好的技术取代现有技术</strong>。（<strong>Replaces</strong> existing technology with better one）</p>

<p>例如：</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Alan_kay">Alan Kay</a>把细胞的概念引入软件开发]进而创造出<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的核心概念。</li>
<li><a href="http://en.wikipedia.org/wiki/Donald_Knuth">Don Knuth</a>对计算机算法（<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>）以及计算机排版（TEX）的贡献。</li>
<li>iPhone于2010年之前的任何手机（iPhone4除外）。</li>
</ul>


<h2>小结</h2>

<p>这篇文章利用<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>里的隐喻，把学习/使用技术分成了四个层次七个头衔：Stranger，Tourist（Salesman，Sightseer），Resident（Worker，Craftsman），Architect（Reformist，Revolutionist），然后给出了各个头衔所应具备的特征和能力。</p>

<h3>关于同类文章</h3>

<p>之前也有类似的文章，例如<a href="http://blog.itpub.net/6517/viewspace-611506/">程序员的十层境界</a>和<a href="http://blog.csdn.net/happydeer/article/details/8107560">开发者的八种境界</a></p>

<p>这些文章的共同点：</p>

<ol>
<li>看似很牛逼但回想一下啥都没说。</li>
<li>不会给人带来什么价值。</li>
<li>没有一个鉴别的标准。</li>
<li>没有指导性，也没有使用价值。</li>
</ol>


<h3>本文的应用场景</h3>

<h4>考察状态</h4>

<p>以我自己对编程语言的掌握为例：</p>

<ul>
<li>C/C++: Stranger.</li>
<li>Python: Craftsman.</li>
<li>Java: Worker.</li>
<li>C#: Craftsman.</li>
<li>JavaScript: Sightseer.</li>
<li>Scheme: Sightseer</li>
</ul>


<p>将上面的列表转置：</p>

<ul>
<li>Stranger: C/C++</li>
<li>Sightseer: JavaScript, Scheme</li>
<li>Worker: Java</li>
<li>Craftsman: C#, Python</li>
</ul>


<p>结合这些头衔的定义，一目了然。</p>

<h4>制定计划</h4>

<p>运用本文的词汇，可以进行非常精炼的计划制定：</p>

<ul>
<li>例如 Make a thoroughly <strong>sightseeing</strong> of <strong>C++</strong>；</li>
<li>或是 Become a proficient <strong>worker</strong> on <strong>IntelliJ</strong>；</li>
<li>抑或 Take a short <strong>tour</strong> of <strong>Sublime Text</strong>。</li>
</ul>


<p>以上。</p>
]]></content>
  </entry>
  
</feed>
