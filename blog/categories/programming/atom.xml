<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-10-24T00:13:57-07:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/"/>
    <updated>2014-10-23T23:54:02-07:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/java-8-lambdas-insideout-language-features">http://zh.lucida.me/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li>深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<h2>关于</h2>

<p>本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>一文的翻译，那么问题来了：</p>

<h3>为什么要写（翻译）这个系列？</h3>

<!-- more -->


<ol>
<li>工作之后，我开始大量使用Java</li>
<li>公司将会在不久的未来使用Java 8</li>
<li>作为资质平庸的开发者，我需要打一点提前量，以免到时拙计</li>
<li>为了学习Java 8（主要是其中的lambda及相关库），我先后阅读了Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>，<a href="http://www.amazon.com/Cay-S.-Horstmann/e/B000AQ1QDY/">Cay Horstmann</a>（<a href="http://www.amazon.com/Core-Volume-I--Fundamentals-Edition-Series/dp/0137081898/">Core Java</a>的作者）的<a href="http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/">Java 8 for the Really Impatient</a>和Richard Warburton的<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a></li>
<li>但我感到并没有多大收获，Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>涉及了lambda表达式的每一个概念，但都是点到辄止；后两本书（尤其是<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>）花了大量篇幅介绍Java lambda及其类库，但实质内容不多，读完了还是没有对Java lambda产生一个清晰的认识</li>
<li>关键在于这些文章和书都没有解决我对Java lambda的困惑，比如：

<ul>
<li>Java 8中的lambda为什么要设计成这样？（为什么要一个lambda对应一个接口？而不是Structural Typing？）</li>
<li>lambda和匿名类型的关系是什么？lambda是匿名对象的语法糖吗？</li>
<li>Java 8是如何对lambda进行类型推导的？它的类型推导做到了什么程度？</li>
<li>Java 8为什么要引入默认方法？</li>
<li>Java编译器如何处理lambda？</li>
<li>等等……</li>
</ul>
</li>
<li>之后我在Google搜索这些问题，然后就找到<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的三篇关于Java lambda的文章（<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>，<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of Lambda libraries version</a>和<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">Translation of lambda</a>），读完之后上面的问题都得到了解决</li>
<li>为了加深理解，我决定翻译这一系列文章</li>
</ol>


<h3>警告（Caveats）</h3>

<p>如果你不知道什么是函数式编程，或者不了解<code>map</code>，<code>filter</code>，<code>reduce</code>这些常用的高阶函数，那么你不适合阅读本文，请先学习函数式编程基础（比如<a href="http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/">这本书</a>）。</p>

<hr />

<h1><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a> by <a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a></h1>

<blockquote><p>The high-level goal of Project Lambda is to enable programming patterns that require modeling code as data to be convenient and idiomatic in Java.</p></blockquote>

<h2>关于</h2>

<p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>

<ul>
<li>lambda表达式（又被成为“闭包”或“匿名方法”）</li>
<li>方法引用和构造方法引用</li>
<li>扩展的目标类型和类型推导</li>
<li>接口中的默认方法和静态方法</li>
</ul>


<h2>1. 背景</h2>

<p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>

<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：</p>

<p><code>java
public interface ActionListener {
  void actionPerformed(ActionEvent e);
}
</code></p>

<p>这里并不需要专门定义一个类来实现<code>ActionListener</code>接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</p>

<p>```
button.addActionListener(new ActionListener) {
  public void actionPerformed(ActionEvent e) {</p>

<pre><code>ui.dazzle(e.getModifiers());
</code></pre>

<p>  }
}
```</p>

<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>

<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的<a href="http://blogs.oracle.com/jrose/entry/better_closures">选择</a>，因为：</p>

<ol>
<li>语法过于冗余</li>
<li>匿名类中的<code>this</code>和变量名容易使人产生误解</li>
<li>类型载入和实例创建语义不够灵活</li>
<li>无法捕获非<code>final</code>的局部变量</li>
<li>无法对控制流进行抽象</li>
</ol>


<p>上面的多数问题均在Java SE 8中得以解决：</p>

<ul>
<li>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2</li>
<li>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3</li>
<li>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰</li>
</ul>


<p>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>

<h2>2. 函数式接口（Functional interfaces）</h2>

<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>

<ul>
<li>接口是Java类型系统的一部分</li>
<li>接口天然就拥有其运行时表示（Runtime representation）</li>
<li>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）</li>
</ul>


<p>上面提到的<code>ActionListener</code>接口只有一个方法，大多数回调接口都拥有这个特征：比如<code>Runnable</code>接口和<code>Comparator</code>接口。我们把这些只拥有一个方法的接口称为<em>函数式接口</em>。（之前它们被称为<em>SAM类型</em>，即<em>单抽象方法类型</em>（Single Abstract Method））</p>

<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个<code>Object</code>已经提供的方法，比如<code>toString()</code>，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过<code>@FunctionalInterface</code>注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>

<p>实现函数式类型的另一种方式是引入一个全新的<em>结构化</em>函数类型，我们也称其为“箭头”类型。例如，一个接收<code>String</code>和<code>Object</code>并返回<code>int</code>的函数类型可以被表示为<code>(String, Object) -&gt; int</code>。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>

<ul>
<li>它会为Java类型系统引入额外的复杂度，并带来<a href="http://en.wikipedia.org/wiki/Structural_type_system">结构类型（Structural Type）</a>和<a href="http://en.wikipedia.org/wiki/Nominal_type_system">指名类型（Nominal Type）</a>的混用。（Java几乎全部使用指名类型）</li>
<li>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型</li>
<li>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后</li>
<li>每个函数类型很难拥有其运行时表示，这意味着开发者会受到<a href="http://en.wikipedia.org/wiki/Type_erasure">类型擦除（erasure）</a>的困扰和局限。比如说，我们无法对方法<code>m(T-&gt;U)</code>和<code>m(X-&gt;Y)</code>进行重载（Overload）</li>
</ul>


<p>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：</p>

<ul>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html">java.security.PrivilegedAction</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html">java.util.Comparator</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html">java.io.FileFilter</a></li>
<li><a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html">java.beans.PropertyChangeListener</a></li>
</ul>


<p>除此之外，Java SE 8中增加了一个新的包：<code>java.util.function</code>，它里面包含了常用的函数式接口，例如：</p>

<ul>
<li><code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code></li>
<li><code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象，不返回值</li>
<li><code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象，返回<code>R</code>对象</li>
<li><code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂），不接收值</li>
<li><code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象，返回<code>T</code>对象</li>
<li><code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象，返回<code>T</code>对象</li>
</ul>


<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>。（我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如<code>BiFunction&lt;T, U, R&gt;</code>，它接收<code>T</code>对象和<code>U</code>对象，返回<code>R</code>对象。</p>

<h2>3. lambda表达式（lambda expressions）</h2>

<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作。</p>

<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>

<p>下面是一些lambda表达式：</p>

<p><code>
(int x, int y) -&gt; x + y
() -&gt; 42
(String s) -&gt; { System.out.println(s); }
</code></p>

<p>第一个lambda表达式接收<code>x</code>和<code>y</code>这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数'42'；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>

<p>lambda表达式的语法由参数列表、箭头符号<code>-&gt;</code>和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——

<ul>
<li><code>return</code>语句会把控制权交给匿名方法的调用者</li>
<li><code>break</code>和<code>continue</code>只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li>
</ul>
</li>
</ul>


<p>表达式函数体适合小型lambda表达式，它消除了<code>return</code>关键字，使得语法更加简洁。</p>

<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<p>下面是一些出现在语句中的lambda表达式：</p>

<p>```
FileFilter java = (File f) &ndash;> f.getName().endsWith(&ldquo;*.java&rdquo;);</p>

<p>String user = doPrivileged(() &ndash;> System.getProperty(&ldquo;user.name&rdquo;));</p>

<p>new Thread(() &ndash;> {
  connectToService();
  sendNotification();
}).start();
```</p>

<h2>4. 目标类型（Target typing）</h2>

<p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是<code>ActionListener</code>：</p>

<p><code>
ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());
</code></p>

<p>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>

<p>```
Callable<String> c = () &ndash;> &ldquo;done&rdquo;;</p>

<p>PrivilegedAction<String> a = () &ndash;> &ldquo;done&rdquo;;
```</p>

<p>第一个lambda表达式<code>() -&gt; "done"</code>是<code>Callable</code>的实例，而第二个lambda表达式则是<code>PrivilegedAction</code>的实例。</p>

<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导，这个<strong>被期待的类型</strong>被称为<em>目标类型</em>。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>

<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型<code>T</code>：</p>

<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li>
<li>lambda表达式的返回值和<code>T</code>的方法返回值相兼容（Compatible）</li>
<li>lambda表达式内所抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li>
</ul>


<p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>

<p><code>
Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);
</code></p>

<p>在上面的例子里，编译器可以推导出<code>s1</code>和<code>s2</code>的类型是<code>String</code>。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>

<p>```
FileFilter java = f &ndash;> f.getName().endsWith(&ldquo;.java&rdquo;);</p>

<p>button.addActionListener(e &ndash;> ui.dazzle(e.getModifiers()));
```</p>

<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>

<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：</p>

<p>```
List<String> ls = Collections.emptyList();
List<Integer> li = Collections.emptyList();</p>

<p>Map&lt;String, Integer> m1 = new HashMap&lt;>();
Map&lt;Integer, String> m2 = new HashMap&lt;>();
```</p>

<h2>5. 目标类型的上下文（Contexts for target typing）</h2>

<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>

<ul>
<li>变量声明</li>
<li>赋值</li>
<li>返回语句</li>
<li>数组初始化器</li>
<li>方法和构造方法的参数</li>
<li>lambda表达式函数体</li>
<li>条件表达式（<code>? :</code>）</li>
<li>转型（Cast）表达式</li>
</ul>


<p>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>

<p>```
Comparator<String> c;
c = (String s1, String s2) &ndash;> s1.compareToIgnoreCase(s2);</p>

<p>public Runnable toDoLater() {
  return () &ndash;> {</p>

<pre><code>System.out.println("later");
</code></pre>

<p>  }
}
```</p>

<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：</p>

<p>```
filterFiles(new FileFilter[] {</p>

<pre><code>          f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith("q")
        });
</code></pre>

<p>```</p>

<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>

<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有<strong>显式类型</strong>（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有<strong>隐式类型</strong>（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>

<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。</p>

<p><code>
List&lt;Person&gt; ps = ...
Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());
</code></p>

<p>在上面的代码中，<code>ps</code>的类型是<code>List&lt;Person&gt;</code>，所以<code>ps.stream()</code>的返回类型是<code>Stream&lt;Person&gt;</code>。<code>map()</code>方法接收一个类型为<code>Function&lt;T, R&gt;</code>的函数式接口，这里<code>T</code>的类型即是<code>Stream</code>元素的类型，也就是<code>Person</code>，而<code>R</code>的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导<code>R</code>的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回<code>String</code>，因此<code>R</code>的类型是<code>String</code>，因而<code>map()</code>返回<code>Stream&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>

<ul>
<li>使用显式lambda表达式（为参数<code>p</code>提供显式类型）以提供额外的类型信息</li>
<li>把lambda表达式转型为<code>Function&lt;Person, String&gt;</code></li>
<li>为泛型参数<code>R</code>提供一个实际类型。（<code>.&lt;String&gt;map(p -&gt; p.getName())</code>）</li>
</ul>


<p>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>

<p><code>
Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; { System.out.println("hi"); };
</code></p>

<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>

<p><code>
Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42);
</code></p>

<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>

<p><code>
// Object o = () -&gt; { System.out.println("hi"); }; 这段代码是非法的
Object o = (Runnable) () -&gt; { System.out.println("hi"); };
</code></p>

<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>

<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>

<p>```
List<String> ls = Collections.checkedList(new ArrayList&lt;>(), String.class);</p>

<p>Set<Integer> si = flag ? Collections.singleton(23) : Collections.emptySet();
```</p>

<h2>6. 词法作用域（Lexical scoping）</h2>

<p>在内部类中使用变量名（以及<code>this</code>）非常容易出错。内部类中通过继承得到的成员（包括来自<code>Object</code>的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的<code>this</code>引用会指向内部类自己而非外部类。</p>

<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，'this'关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>

<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把<code>"Hello, world!"</code>打印两遍：</p>

<p>```
public class Hello {
  Runnable r1 = () &ndash;> { System.out.println(this); }
  Runnable r2 = () &ndash;> { System.out.println(toString()); }</p>

<p>  public String toString() {  return &ldquo;Hello, world&rdquo;; }</p>

<p>  public static void main(String&hellip; args) {</p>

<pre><code>new Hello().r1.run();
new Hello().r2.run();
</code></pre>

<p>  }
}
```</p>

<p>与之相类似的内部类实现则会打印出类似<code>Hello$1@5b89a773</code>和<code>Hello$2@537a7706</code>之类的字符串，这往往会使开发者大吃一惊。</p>

<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如<code>for</code>循环和<code>catch</code>从句）一致。</p>

<p><strong>个人补充</strong>：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>

<p><code>
int i = 0;
int sum = 0;
for (int i = 1; i &lt; 10; i += 1) { //这里会出现编译错误，因为i已经在for循环外部声明过了
  sum += i;
}
</code></p>

<h2>7. 变量捕获（Variable capture）</h2>

<p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合<em>有效只读</em>（Effectively final）的局部变量。</p>

<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上<code>final</code>后也不会导致编译错误的局部变量就是有效只读变量。</p>

<p><code>
Callable&lt;String&gt; helloCallable(String name) {
  String hello = "Hello";
  return () -&gt; (hello + ", " + name);
}
</code></p>

<p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段的引用和未限定方法的调用在本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其它情况下，lambda对象不会保留任何对<code>this</code>的引用。</p>

<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>

<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>

<p><code>
int sum = 0;
list.forEach(e -&gt; { sum += e.size(); });
</code></p>

<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对<em>值</em>封闭，对<em>变量</em>开放。</p>

<p><strong>个人补充</strong>：lambda表达式对<em>值</em>封闭，对<em>变量</em>开放的原文是：lambda expressions close over <em>values</em>, not <em>variables</em>，我在这里增加一个例子以说明这个特性：</p>

<p>```
int sum = 0;
list.forEach(e &ndash;> { sum += e.size(); }); // Illegal, close over values</p>

<p>List<Integer> aList = new List&lt;>();
list.forEach(e &ndash;> { aList.add(e); }); // Legal, open over variables
```</p>

<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。<code>java.util.stream</code>包提供了各种通用的和专用的规约操作（例如<code>sum</code>、<code>min</code>和<code>max</code>），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替<code>forEach</code>：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .sum();
</code></pre>

<p>```</p>

<p><code>sum()</code>等价于下面的规约操作：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .reduce(0 , (x, y) -&gt; x + y);
</code></pre>

<p>```</p>

<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>

<p><code>
0 + list[0] + list[1] + list[2] + ...
</code></p>

<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>

<h2>8. 方法引用（Method references）</h2>

<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在<em>已有的</em>方法上实现同样的特性。</p>

<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>

<p>以下面的代码为例，假设我们要按照<code>name</code>或<code>age</code>为<code>Person</code>数组进行排序：</p>

<p>```
class Person {
  private final String name;
  private final int age;</p>

<p>  public int getAge() { return age; }
  public String getName() {return name; }
  &hellip;
}</p>

<p>Person[] people = &hellip;
Comparator<Person> byName = Comparator.comparing(p &ndash;> p.getName());
Arrays.sort(people, byName);
```</p>

<p>在这里我们可以用方法引用代替lambda表达式：</p>

<p><code>
Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);
</code></p>

<p>这里的<code>Person::getName</code>可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>

<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>

<p><code>
Consumer&lt;Integer&gt; b1 = System::exit;    // void exit(int status)
Consumer&lt;String[]&gt; b2 = Arrays:sort;    // void sort(Object[] a)
Consumer&lt;String&gt; b3 = MyProgram::main;  // void main(String... args)
Runnable r = Myprogram::mapToInt        // void main(String... args)
</code></p>

<h2>9. 方法引用的种类（Kinds of method references）</h2>

<p>方法引用有很多种，它们的语法如下：</p>

<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>


<p>对于静态方法引用，我们需要在类名和方法名之间加入<code>::</code>分隔符，例如<code>Integer::sum</code>。</p>

<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>

<p><code>
Set&lt;String&gt; knownNames = ...
Predicate&lt;String&gt; isKnown = knownNames::contains;
</code></p>

<p>这里的隐式lambda表达式（也就是实例方法引用）会从<code>knownNames</code>中捕获<code>String</code>对象，而它的方法体则会通过<code>Set.contains</code>使用该<code>String</code>对象。</p>

<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>

<p><code>
Callable&lt;Path&gt; c = ...
Privileged&lt;Path&gt; a = c::call;
</code></p>

<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>

<p><code>
Function&lt;String, String&gt; upperfier = String::toUpperCase;
</code></p>

<p>这里的隐式lambda表达式（即<code>String::toUpperCase</code>实例方法引用）有一个<code>String</code>参数，这个参数会被<code>toUpperCase</code>方法使用。</p>

<p>如果类型的实例方法是泛型的，那么我们就需要在<code>::</code>分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>

<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>

<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在<code>::</code>分隔符之前提供参数类型信息。</p>

<p>和静态方法引用类似，构造方法也可以通过<code>new</code>关键字被直接引用：</p>

<p><code>
SocketImplFactory factory = MySocketImpl::new;
</code></p>

<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>

<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照"菱形"构造方法调用时的方式进行推导。</p>

<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收<code>int</code>参数的数组构造方法。参考下面的代码：</p>

<p><code>
IntFunction&lt;int[]&gt; arrayMaker = int[]::new;
int[] array = arrayMaker.apply(10) // 创建数组 int[10]
</code></p>

<h2>10. 默认方法和静态接口方法（Default and static interface methods）</h2>

<p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把<em>代码即数据</em>（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>

<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。<em>默认方法</em>（之前被称为<em>虚拟扩展方法</em>或<em>守护方法</em>）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>

<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如<code>removeAll</code>方法应该被泛化为接收一个函数式接口<code>Predicate</code>，但这个新的方法应该被放在哪里呢？我们无法直接在<code>Collection</code>接口上新增方法——不然就会破坏现有的<code>Collection</code>实现。我们倒是可以在<code>Collections</code>工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>

<p><em>默认方法</em>利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是<em>抽象的</em>或是<em>默认的</em>。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>

<p>下面的例子展示了如何向<code>Iterator</code>接口增加默认方法<code>skip</code>：</p>

<p>```
interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();</p>

<p>  default void skip(int i) {</p>

<pre><code>for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next();
</code></pre>

<p>  }
}
```</p>

<p>根据上面的<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会自动继承<code>skip</code>方法。在使用者的眼里，<code>skip</code>不过是接口新增的一个虚拟方法。在没有覆盖<code>skip</code>方法的<code>Iterator</code>子类实例上调用<code>skip</code>会执行<code>skip</code>的默认实现：调用<code>hasNext</code>和<code>next</code>若干次。子类可以通过覆盖<code>skip</code>来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>

<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>

<p>除了默认方法，Java SE 8还在允许在接口中定义<em>静态</em>方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如<code>Collections</code>）。比如，我们一般需要使用静态辅助方法生成实现<code>Comparator</code>的比较器，在Java SE 8中我们可以直接把该静态方法定义在<code>Comparator</code>接口中：</p>

<p>```
public static &lt;T, U extends Comparable&lt;? super U>></p>

<pre><code>Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) {
</code></pre>

<p>  return (c1, c2) &ndash;> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
}
```</p>

<h2>11. 继承默认方法（Inheritance of default methods）</h2>

<p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>

<ul>
<li>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。</li>
<li>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。</li>
</ul>


<p>为了演示第二条规则，我们假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法。在下面的<code>implement</code>从句中，<code>List</code>中的方法声明会优先于<code>Queue</code>中的方法声明：</p>

<p><code>
class LinkedList&lt;E&gt; implements List&lt;E&gt;, Queue&lt;E&gt; { ... }
</code></p>

<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>

<p><code>
interface Robot implements Artist, Gun {
  default void draw() { Artist.super.draw(); }
}
</code></p>

<p><code>super</code>前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>

<p>最后，接口在<code>inherits</code>和<code>extends</code>从句中的声明顺序和它们被实现的顺序无关。</p>

<h2>12. 融会贯通（Putting it together）</h2>

<p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>

<p>比如说下面的代码：</p>

<p>```
List<Person> people = &hellip;
Collections.sort(people, new Comparator<Person>() {
  public int compare(Person x, Person y) {</p>

<pre><code>return x.getLastName().compareTo(y.getLastName());
</code></pre>

<p>  }
})
```</p>

<p>冗余代码实在太多了！</p>

<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>

<p>```
Collections.sort(people,</p>

<pre><code>             (Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName()));
</code></pre>

<p>```</p>

<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助<code>Comparator</code>里的<code>comparing</code>方法实现比较操作：</p>

<p><code>
Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName()));
</code></p>

<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>

<p><code>
Collections.sort(people, comparing(p -&gt; p.getLastName()));
</code></p>

<p>我们注意到这里的lambda表达式实际上是<code>getLastName</code>的代理（forwarder），于是我们可以用方法引用代替它：</p>

<p><code>
Collections.sort(people, comparing(Person::getLastName));
</code></p>

<p>最后，使用<code>Collections.sort</code>这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现<code>List</code>接口的数据结构提供特定（specialized）的高效实现，而且由于<code>Collections.sort</code>方法不属于<code>List</code>接口，用户在阅读<code>List</code>接口的文档时不会察觉在另外的<code>Collections</code>类中还有一个针对<code>List</code>接口的排序（<code>sort()</code>）方法。</p>

<p>默认方法可以有效的解决这个问题，我们为<code>List</code>增加默认方法<code>sort()</code>，然后就可以这样调用：</p>

<p><code>
people.sort(comparing(Person::getLastName));;
</code></p>

<p>此外，如果我们为<code>Comparator</code>接口增加一个默认方法<code>reversed()</code>（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>

<p><code>
people.sort(comparing(Person::getLastName).reversed());;
</code></p>

<h2>13. 小结（Summary）</h2>

<p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Top Coder算法题目浏览器]]></title>
    <link href="http://zh.lucida.me/blog/top-code-offline-browser/"/>
    <updated>2014-10-14T23:37:29-07:00</updated>
    <id>http://zh.lucida.me/blog/top-code-offline-browser</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>

<h2>关于</h2>

<p><a href="http://weibo.com/haoel">左耳朵耗子</a>在最近发了一条关于leetcode的微博：</p>

<p><img src="http://i.imgur.com/alUuOmx.jpg" alt="微博截图" /></p>

<p>佩服之余，想起自己两年前找工作时随手写的一个小程序：Top Coder算法题目浏览器，硬盘里翻了翻没找到，于是找师弟要了一份copy，截了几张图放到微博上。</p>

<p><img src="http://i.imgur.com/bIiXNR4.jpg" alt="微博截图" /></p>

<p>没想到不少人表示很感兴趣，还有些同学留下邮箱索要这个算法题目浏览器——我是懒的一个个发邮箱，所以干脆放到博客上，顺便提高下访问量 :)</p>

<!-- more -->


<h2>介绍</h2>

<h3>TC Browser</h3>

<p><strong>TC Browser</strong>：全称<strong>Top Coder offline Browser</strong>，是我为了方便自己练习算法题目而花一下午制作的Windows小程序。</p>

<p><strong>TC Browser</strong>内置2933道算法题目，这些算法题目覆盖动态规划（Dynamic Programming）、递归（Recursion）、迭代（Iteration）、暴力（Brute Force）和图论（Graph Theory）等17个分类，并按照级别（Level）不同和难度（Success Rate）不同进行分类，以便从简单到复杂逐步练习。</p>

<h4>TC Browser可以</h4>

<ul>
<li>离线浏览算法题目 &ndash;_&ndash;</li>
<li>按照算法、级别和难度过滤题目，以便逐步提高水平。</li>
<li>随机出题 &ndash;_&ndash;</li>
</ul>


<h4>TC Browser不可以</h4>

<ul>
<li>评判（Judge）题目，如它的名字，TC Browser只是一个题目浏览器，而非一个完整的OJ（Online Judge）。不过好在TC题目的Sample Input/Output比较全。</li>
<li>提供答案（Answer），嗯，这些题目都没有答案，所以对于初学者可能不合适。</li>
</ul>


<h3>为什么选择<a href="http://www.topcoder.com/">Top Coder</a>？</h3>

<ol>
<li>大量的算法题目：<strong>TC Browser</strong>是我两年半前写的，当时有2933道题目，现在的题目只会更多。</li>
<li>题目具有良好的分类：Top Coder里的每道算法题目都有明确的分类：类型（Category）、级别（Level）、难度（Success Rate）。</li>
<li>良好的题目陈述（Problem Statement）：Top Coder的题目陈述非常清晰，并且都带有若干组示例输入/输出（Sample Input/Output）。</li>
<li>题目相对实际（Practical）：相对于一些OJ的纯算法题目，Top Coder里面的题目更加实际——更接近与实际的编程而非单纯的算法演练，对于非算法竞赛出身的我非常合适。</li>
<li>Top Coder在线不稳定：也许是我的网络原因，我经常登陆不进Top Coder，这也是我编写离线版TC的原因之一。</li>
</ol>


<h2>使用</h2>

<h3>Top Coder术语</h3>

<p>如果你玩过Top Coder，请跳过本节 :&ndash;)</p>

<p>Top Coder的题目分为两个区（Division，简称D），每个区又分为三个级别（Level，简称L），每道题目有其通过率（Success Rate）。D1难度小于D2，L1难度小于L2小于L3，通过率越高难度越低。</p>

<p>举例来说，一道D1L1SR50的题目适合初学者练习，一道D2L2SR30的题目就可能需要相当的算法水准才能搞定。</p>

<h3>我如何使用TC Browser</h3>

<p>在找工作初期，我的算法水平非常拙计，于是我所练习的题目大多都是D1L2和D1L3，SR>40的题目，同时根据往届师兄师姐的面试经验，我会重点练习动态规划、递归、字符串操作和搜索这几个类型的题目。</p>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="截图" /></p>

<p>到了中后期，随着经验的累计，我开始练习D1L3的题目，并尝试一些D2L1的题目。</p>

<p><img src="http://i.imgur.com/yHE02Qi.jpg" alt="截图" /></p>

<p>到了最后，就开始使用Random模式——从D2L1和D2L2中随机出一道题目然后思考解决思路，想出来之后再随机下一道。</p>

<p>为了练习方便，我为TC Browser加了一个做题模式——其实就是把题目选择区隐藏，这样就可以方便的双窗口操作。</p>

<h4>浏览模式：</h4>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="浏览模式" /></p>

<h4>做题模式：</h4>

<p><img src="http://i.imgur.com/gNn58vt.jpg" alt="做题模式" /></p>

<p>顺便提一句，TC Browser左上角的Config、Switch Mode和About三个按钮只有Switch Mode能用——一个按钮，三倍情怀。</p>

<h3>面试有多难？</h3>

<p>就我的面试经验来说，D2L1的题目已经相当够用了——绝大多数的编程题目都没有超过D1L3的难度，要知道面试只有45分钟，搞那些惊天地泣鬼神的算法题目面试官和面试者谁都受不了。</p>

<p>但也要注意，我没有算法竞赛背景，所以面试官不会问太难的题目，但对于那些算法竞赛选手就是另一种情况了——面试官需要用更难的题目来确认你是一个合格的算法选手，正所谓道高一尺，魔高一丈。</p>

<h2>下载地址</h2>

<p>所以下载地址在这里：<a href="http://pan.baidu.com/s/1fGX5c">网盘地址</a></p>

<p>解压密码是宇宙的终极答案（The ultimate anwser to the universe）。</p>

<p>谢谢试用，至于代码可以自行反编译阅读（写的翔一般还是不读为好），恕不赘述。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 全程指南]]></title>
    <link href="http://zh.lucida.me/blog/sublime-text-complete-guide/"/>
    <updated>2014-09-27T13:57:15-07:00</updated>
    <id>http://zh.lucida.me/blog/sublime-text-complete-guide</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>摘要（Abstract）</h2>

<p>本文系统全面的介绍了Sublime Text，旨在成为最优秀的Sublime Text中文教程。</p>

<h3>更新记录</h3>

<ol>
<li>2014/09/27：完成初稿</li>
<li>2014/09/28：

<ul>
<li>更正打开控制台的快捷键为<code>Ctrl + `</code></li>
<li>更正全局替换的快捷键为<code>Ctrl + Alt + Enter</code></li>
</ul>
</li>
</ol>


<h2>前言（Prologue）</h2>

<p>Sublime Text是一款跨平台代码编辑器（Code Editor），从最初的Sublime Text 1.0，到现在的Sublime Text 3.0，Sublime Text从一个不知名的编辑器演变到现在几乎是各平台首选的GUI编辑器。而这样优秀的编辑器却没有一个靠谱的中文教程，所以我试图通过本文弥补这个缺陷。</p>

<h3>编辑器的选择（Editor Choices）</h3>

<p>从初学编程到现在，我用过的编辑器有EditPlus、UltraEdit、Notepad++、Vim、TextMate和Sublime Text，如果让我从中推荐，我会毫不犹豫的推荐Vim和Sublime Text，原因有下面几点：</p>

<!-- more -->


<ol>
<li><strong>跨平台</strong>：Vim和Sublime Text均为跨平台编辑器（在Linux、OS X和Windows下均可使用）。作为一个程序员，切换系统是常有的事情，为了减少重复学习，使用一个跨平台的编辑器是很有必要的。</li>
<li><strong>可扩展</strong>：Vim和Sublime Text都是可扩展的（Extensible），并包含大量实用插件，我们可以通过安装自己领域的插件来成倍提高工作效率。</li>
<li><strong>互补</strong>：Vim和Sublime Text分别是命令行环境（CLI）和图形界面环境（GUI）下的最佳选择，同时使用两者会大大提高工作效率。</li>
</ol>


<h3>个人背景（Personal Background）</h3>

<p>我是一名非常典型的程序员：平时工作主要在Linux环境下使用Java和Python，偶尔会用HTML+CSS+JavaScript编写网页；业余时会在Windows环境编写一些C#程序（包括控制台程序（Console Application）和移动应用（Mobile App），也会玩一些非主流语言（比如Haskell，ML和Ruby等）以拓展见识。</p>

<p>所以这篇文章会我的个人工作内容为主要使用场景（Scenario），尽管无法覆盖到所有的使用场景，但我认为依然可以覆盖到绝大部分，如果您认为我遗漏了什么内容，请在文章下面回复，我会尽量更新。</p>

<h3>本文风格（Writing Style）</h3>

<p>受益于<a href="http://en.wikipedia.org/wiki/The_C_Programming_Language">K&amp;R C</a>的写作风格，我倾向于以实际案例来讲解Sublime Text的功能，所以本文中的例子均源于我在实际开发时遇到的问题。</p>

<p>此外，把本文会使用大量动画（GIF）演示Sublime Text的编辑功能，因为我发现图片难以演示完整的编辑流程（Workflow），而视频又过于重量级。本文的GIF动画均使用<a href="http://screentogif.codeplex.com/">ScreenToGif</a>进行录制。</p>

<h3>编辑器（Editor） vs 集成开发环境（Integrated Development Environment，下文简称IDE）</h3>

<p>我经常看到一些程序员拿编辑器和IDE进行比较，诸如Vim比Eclipse强大或是Visual Studio太慢不如Notepad++好使之类的讨论比比皆是，个人认为这些讨论没有意义，因为编辑器和IDE根本是面向两种不同使用场景的工具：</p>

<ul>
<li>编辑器面向无语义的纯文本，不涉及领域逻辑，因此速度快体积小，适合编写单独的配置文件和动态语言脚本（Shell、Python和Ruby等）。</li>
<li>IDE面向有语义的代码，会涉及到大量领域逻辑，因此速度偏慢体积庞大，适合编写静态语言项目（Java、C++和C#等）。</li>
</ul>


<p>我认为应当使用正确的工具去做有价值的事情，并把效率最大化，所以我会用Eclipse编写Java项目，用Vim编写Shell，用Sublime Text编写JavaScript/HTML/Python，用Visual Studio编写C#。</p>

<p>前言到此结束，下面进入正题。</p>

<h2>安装（Installation）</h2>

<p>Sublime Text<a href="http://www.sublimetext.com/">官方网站</a>提供了Sublime Text各系统各版本的下载，目前Sublime Text的最新版本是<a href="http://www.sublimetext.com/3">Sublime Text 3</a>。这里以Windows版本的Sublime Text安装为例。</p>

<p>注意在安装时勾选<strong>Add to explorer context menu</strong>，这样在右键单击文件时就可以直接使用Sublime Text打开。</p>

<p><img src="http://i.imgur.com/zVtiXNP.jpg" alt="右键打开" /></p>

<h3>添加Sublime Text到环境变量</h3>

<p>使用<code>Win + R</code>运行<code>sysdm.cpl</code>打开“系统属性”。</p>

<p><img src="http://i.imgur.com/ysZe1BH.jpg" alt="sysdm.cpl" /></p>

<p>然后在“高级”选项卡里选择“环境变量”，编辑“Path”，增加Sublime Text的安装目录（例如<code>D:\Program Files\Sublime Text 3</code>）。</p>

<p><img src="http://i.imgur.com/dY5EaZX.jpg" alt="添加环境变量" /></p>

<p>接下来你就可以在命令行里面利用<code>subl</code>命令直接使用Sublime Text了：</p>

<p><code>
subl file    :: 使用Sublime Text打开file文件
subl folder  :: 使用Sublime Text打开folder文件夹
subl .       :: 使用Sublime Text当前文件夹
</code></p>

<h3>安装Package Control</h3>

<p>前文提到Sublime Text支持大量插件，如何找到并管理这些插件就成了一个问题，Package Control正是为了解决这个问题而出现的，利用它我们可以很方便的浏览、安装和卸载Sublime Text中的插件。</p>

<p>进入Package Control的<a href="https://sublime.wbond.net/">官网</a>，里面有详细的<a href="https://sublime.wbond.net/installation">安装教程</a>。Package Control支持Sublime Text 2和3，本文只给出3的安装流程：</p>

<ul>
<li>使用<code>Ctrl + `</code>打开Sublime Text控制台。</li>
<li>将下面的代码粘贴到控制台里：</li>
</ul>


<p><code>
import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)
</code></p>

<ul>
<li>等待Package Control安装完成。之后使用<code>Ctrl + Shift + P</code>打开命令板，输入<code>PC</code>应出现Package Control：</li>
</ul>


<p><img src="http://i.imgur.com/fgnl2Qj.jpg" alt="Package Control安装成功" /></p>

<p>成功安装Package Control之后，我们就可以方便的安装使用Sublime Text的各种插件：</p>

<p><img src="http://i.imgur.com/pnuar4c.gif" alt="使用Package Control安装插件" /></p>

<h2>购买（Purchase）</h2>

<p>Sublime Text是一个收费闭源软件，这在一定程度上成为了我支持Sublime Text的理由（我心中的软件靠谱程度：免费开源 &lt;&lt; 免费闭源 &lt; 收费开源 &lt; 收费闭源）：在<a href="https://www.sublimetext.com/buy">这里</a>购买。</p>

<p>不过不购买Sublime Text也可以“正常”使用它，只是Sublime Text会时不时的弹出一个对话框提醒你购买，此外窗口处会有一个很屌丝很low逼的<strong>(UNREGISTERED)</strong>。（在高频操作下，一般20分钟提示一次，个人认为算是很厚道了）</p>

<p><img src="http://i.imgur.com/hPNqz66.jpg" alt="提示注册" /></p>

<p>也许不少人会觉着Sublime Text 70刀的价格太贵，但相比它的功能和带来的效率提升，70刀真的不值一提，如果你不方便使用Paypal付款可以邮件联系我，你支付宝给我打款然后我帮你付款，价格按当日汇率折算（450元左右）。</p>

<p><img src="http://i.imgur.com/gWt2eLA.jpg" alt="购买之后" /></p>

<h2>概览（Tour）</h2>

<h3>基本概念（Basic Concepts）</h3>

<p>Sublime Text的界面如下：</p>

<p><img src="http://i.imgur.com/XrUYmH8.jpg" alt="Sublime Text" /></p>

<ul>
<li>标签（Tab）：无需介绍。</li>
<li>编辑区（Editing Area）：无需介绍。</li>
<li>侧栏（Side Bar）：包含当前打开的文件以及文件夹视图。</li>
<li>缩略图（Minimap）：如其名。</li>
<li>命令板（Command Palette）：Sublime Text的操作中心，它使得我们基本可以脱离鼠标和菜单栏进行操作。</li>
<li>控制台（Console）：使用<code>Ctrl + `</code>调出，它既是一个标准的Python REPL，也可以直接对Sublime Text进行配置。</li>
<li>状态栏（Status Bar）：显示当前行号、当前语言和Tab格式等信息。</li>
</ul>


<h3>配置（Settings）</h3>

<p>与其他GUI环境下的编辑器不同，Sublime Text并没有一个专门的配置界面，与之相反，Sublime Text使用JSON配置文件，例如：</p>

<p><code>
{
  "font_size": 12,
  "highlight_line": true,
}
</code></p>

<p>会将默认字体大小调整为12，并高亮当前行。</p>

<p>JSON配置文件的引入简化了Sublime Text的界面，但也使得配置变的复杂，一般我会到<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/settings.html">这里</a>查看可用的Sublime Text配置。</p>

<h2>编辑（Editing）</h2>

<p>Sublime Text的编辑十分人性化——它不像Vim那样反人类（尽管我也用Vim但我还是要说Vim的快捷键设定绝壁连代谢产物都不如），少量的快捷键就可以完成绝大多数编辑任务。</p>

<h3>基本编辑（Basic Editing）</h3>

<p><code>↑↓←→</code>就是<code>↑↓←→</code>，不是<code>KJHL</code>，（没错我就是在吐槽Vim，尼玛设成<code>WSAD</code>也比这个强啊），粘贴剪切复制均和系统一致。</p>

<p><code>Ctrl + Enter</code>在当前行下面新增一行然后跳至该行；<code>Ctrl + Shift + Enter</code>在当前行上面增加一行并跳至该行。</p>

<p><img src="http://i.imgur.com/rvzS9Ok.gif" alt="演示新增行" /></p>

<p><code>Ctrl + ←/→</code>进行逐词移动，相应的，<code>Ctrl + Shift + ←/→</code>进行逐词选择。</p>

<p><img src="http://i.imgur.com/jFnTDl3.gif" alt="演示逐词移动及选择" /></p>

<p><code>Ctrl + ↑/↓</code>移动当前显示区域，<code>Ctrl + Shift + ↑/↓</code>移动当前行。</p>

<p><img src="http://i.imgur.com/v31pd3k.gif" alt="演示移动当前行" /></p>

<h3>选择（Selecting）</h3>

<p>Sublime Text的一大亮点是支持多重选择——同时选择多个区域，然后同时进行编辑。</p>

<p><code>Ctrl + D</code>选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑。</p>

<p>多重选词的一大应用场景就是重命名——从而使得代码更加整洁。尽管Sublime Text无法像IDE（例如Eclipse）那样进行自动重命名，但我们可以通过多重选词+多重编辑进行直观且便捷的重命名：</p>

<p><img src="http://i.imgur.com/IRVbUTJ.gif" alt="利用多重选词进行重命名" /></p>

<p>有时我们需要对一片区域的所有行进行同时编辑，<code>Ctrl + Shift + L</code>可以将当前选中区域打散，然后进行同时编辑：</p>

<p><img src="http://i.imgur.com/0NHpXFl.gif" alt="利用打散为列表套上引号" /></p>

<p>有打散自然就有合并，<code>Ctrl + J</code>可以把当前选中区域合并为一行：</p>

<p><img src="http://i.imgur.com/hfRAyiy.gif" alt="合并选中行" /></p>

<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<p>Sublime Text提供了强大的查找（和替换）功能，为了提供一个清晰的介绍，我将Sublime Text的查找功能分为<strong>快速查找</strong>、<strong>标准查找</strong>和<strong>多文件查找</strong>三种类型。</p>

<h4>快速查找&amp;替换</h4>

<p>多数情况下，我们需要查找文中某个关键字出现的其它位置，这时并不需要重新将该关键字重新输入一遍然后搜索，我们只需要使用<code>Shift + ←/→</code>或<code>Ctrl + D</code>选中关键字，然后<code>F3</code>跳到其下一个出现位置，<code>Shift + F3</code>跳到其上一个出现位置，此外还可以用<code>Alt + F3</code>选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p>

<p><img src="http://i.imgur.com/gcaHacI.gif" alt="使用快速替换" /></p>

<h4>标准查找&amp;替换</h4>

<p>另一种常见的使用场景是搜索某个已知但不在当前显示区域的关键字，这时可以使用<code>Ctrl + F</code>调出搜索框进行搜索：</p>

<p><img src="http://i.imgur.com/6AaBiRS.jpg" alt="Sublime Text的搜索框" /></p>

<p>以及使用<code>Ctrl + H</code>进行替换：</p>

<p><img src="http://i.imgur.com/4NnE9SN.jpg" alt="Sublime Text的替换框" /></p>

<h5>关键字查找&amp;替换</h5>

<p>对于普通用户来说，常规的关键字搜索就可以满足其需求：在搜索框输入关键字后<code>Enter</code>跳至关键字当前光标的下一个位置，<code>Shift + Enter</code>跳至上一个位置，<code>Alt + Enter</code>选中其出现的所有位置（同样的，接下来可以进行快速替换）。</p>

<p>Sublime Text的查找有不同的模式：<code>Alt + C</code>切换大小写敏感（Case-sensitive）模式，<code>Alt + W</code>切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。</p>

<p><code>
"auto_find_in_selection": true
</code></p>

<p>这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：</p>

<p><img src="http://i.imgur.com/QRIsDra.gif" alt="使用范围搜索进行局部重命名" /></p>

<p>使用<code>Ctrl + H</code>进行标准替换，输入替换内容后，使用<code>Ctrl + Shift + H</code>替换当前关键字，<code>Ctrl + Alt + Enter</code>替换所有匹配关键字。</p>

<h5>正则表达式查找&amp;替换</h5>

<p><a href="http://en.wikipedia.org/wiki/Regular_expression">正则表达式</a>是非常强大的文本查找&amp;替换工具，Sublime Text中使用<code>Alt + R</code>切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html">Boost里的Perl正则表达式风格</a>。</p>

<p>出于篇幅原因，本文不会对正则表达式进行详细介绍，<a href="http://regex.info/">Mastering Regex</a>（中译本：<a href="http://book.douban.com/subject/2154713/">精通正则表达式</a>）对正则表达式的原理和各语言下的使用进行了详细介绍。此外网上有大量正则表达式的优秀教程（<a href="http://deerchao.net/tutorials/regex/regex.htm">“正则表达式30分钟入门教程”</a>和<a href="http://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90">MSDN正则表达式教程</a>.aspx)），以及在线测试工具（<a href="http://regexpal.com/">regexpal</a>和<a href="http://www.regexr.com/">regexer</a>）。</p>

<h4>多文件搜索&amp;替换</h4>

<p>使用<code>Ctrl + Shift + F</code>开启多文件搜索&amp;替换（注意此快捷键和搜狗输入法的简繁切换快捷键有冲突）：</p>

<p><img src="http://i.imgur.com/05Fchle.jpg" alt="多文件搜索界面" /></p>

<p>多文件搜索&amp;替换默认在当前打开的文件和文件夹进行搜索/替换，我们也可以指定文件/文件夹进行搜索/替换。</p>

<h3>跳转（Jumping）</h3>

<p>Sublime Text提供了强大的跳转功能使得我们可以在不同的文件/方法/函数中无缝切换。就我的使用经验而言，目前还没有哪一款编辑器可以在这个方面超越Sublime Text。</p>

<h4>跳转到文件</h4>

<p><code>Ctrl + P</code>会列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后<code>Enter</code>跳转至该文件。</p>

<p>需要注意的是，Sublime Text使用模糊字符串匹配（Fuzzy String Matching），这也就意味着你可以通过文件名的前缀、首字母或是某部分进行匹配：例如，<code>EIS</code>、<code>Eclip</code>和<code>Stupid</code>都可以匹配<code>EclipseIsStupid.java</code>。</p>

<p><img src="http://i.imgur.com/db15c5n.gif" alt="跳转到文件" /></p>

<h4>跳转到符号</h4>

<p>尽管是一个文本编辑器，Sublime Text能够对代码符号进行一定程度的索引。<code>Ctrl + R</code>会列出当前文件中的符号（例如类名和函数名，但无法深入到变量名），输入符号名称<code>Enter</code>即可以跳转到该处。此外，还可以使用<code>F12</code>快速跳转到当前光标所在符号的定义处（Jump to Definition）。</p>

<p><img src="http://i.imgur.com/D2rGDck.gif" alt="跳转到符号" /></p>

<p>比较有意思的是，对于Markdown，<code>Ctrl + R</code>会列出其大纲，非常实用。</p>

<p><img src="http://i.imgur.com/qDnjcNn.jpg" alt="Markdown大纲" /></p>

<h4>跳转到某行</h4>

<p><code>Ctrl + G</code>然后输入行号以跳转到指定行：</p>

<p><img src="http://i.imgur.com/F5BLsae.gif" alt="跳转到某行" /></p>

<h4>组合跳转</h4>

<p>在<code>Ctrl + P</code>匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p>

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>


<p><img src="http://i.imgur.com/3y9MG88.gif" alt="组合跳转演示" /></p>

<p>所以Sublime Text把<code>Ctrl + P</code>称之为<strong>“Go To Anything”</strong>，这个功能如此好用，以至于我认为没有其它编辑器能够超越它。</p>

<h3>中文输入法的问题</h3>

<p>从Sublime Text的初版（1.0）到现在（3.0 3065），中文输入法（包括日文输入法）都有一个问题：输入框不跟随。</p>

<p><img src="http://i.imgur.com/VQQ87Rr.jpg" alt="输入框不跟随" /></p>

<p>目前官方还没有修复这个bug，解决方法是安装<code>IMESupport</code>插件，之后重启Sublime Text问题就解决了。</p>

<p><img src="http://i.imgur.com/ErbK7wH.jpg" alt="修复之后输入框跟随" /></p>

<h3>文件夹（Folders）</h3>

<p>Sublime Text支持以文件夹做为单位进行编辑，这在编辑一个文件夹下的代码时尤其有用。在<code>File</code>下<code>Open Folder</code>：</p>

<p><img src="http://i.imgur.com/xS9Nriz.jpg" alt="文件夹视图" /></p>

<p>你会发现右边多了一个侧栏，这个侧栏列出了当前打开的文件和文件夹的文件，使用<code>Ctrl + K, Ctrl + B</code>显示或隐藏侧栏，使用<code>Ctrl + P</code>快速跳转到文件夹里的文件。</p>

<h2>窗口&amp;标签（Windows &amp; Tabs）</h2>

<p>Sublime Text是一个多窗口多标签编辑器：我们既可以开多个Sublime Text窗口，也可以在一个Sublime Text窗口内开多个标签。</p>

<h3>窗口（Window）</h3>

<p>使用<code>Ctrl + Shift + N</code>创建一个新窗口（该快捷键再次和搜狗输入法快捷键冲突，个人建议禁用所有搜狗输入法快捷键）。</p>

<p>当窗口内没有标签时，使用<code>Ctrl + W</code>关闭该窗口。</p>

<h3>标签（Tab）</h3>

<p>使用<code>Ctrl + N</code>在当前窗口创建一个新标签，<code>Ctrl + W</code>关闭当前标签，<code>Ctrl + Shift + T</code>恢复刚刚关闭的标签。</p>

<p>编辑代码时我们经常会开多个窗口，所以分屏很重要。<code>Alt + Shift + 2</code>进行左右分屏，<code>Alt + Shift + 8</code>进行上下分屏，<code>Alt + Shift + 5</code>进行上下左右分屏（即分为四屏）。</p>

<p><img src="http://i.imgur.com/lAvhuX6.gif" alt="各种分屏" /></p>

<p>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏。例如，<code>Ctrl + 1</code>会跳转到1屏，而<code>Ctrl + Shift + 2</code>会将当前屏移动到2屏。</p>

<h3>全屏（Full Screen）</h3>

<p>Sublime Text有两种全屏模式：普通全屏和无干扰全屏。</p>

<p>个人强烈建议在开启全屏前关闭菜单栏（Toggle Menu），否则全屏效果会大打折扣。</p>

<p><code>F11</code>切换普通全屏：</p>

<p><img src="http://i.imgur.com/Kdj9eEX.jpg" alt="普通全屏" /></p>

<p><code>Shift + F11</code>切换无干扰全屏：</p>

<p><img src="http://i.imgur.com/mnTIFQk.jpg" alt="无干扰全屏" /></p>

<h2>风格（Styles）</h2>

<p>风格对于任何软件都很重要，对编辑器也是如此，尤其是GUI环境下的编辑器。作为一个程序员，我希望我的编辑器足够简洁且足够个性。</p>

<p>Notepad++默认界面</p>

<p><img src="http://i.imgur.com/MZb7AsV.png" alt="Notepad++" /></p>

<p>Sublime Text默认界面</p>

<p><img src="http://i.imgur.com/ZzwQ0sI.png" alt="Sublime Text" /></p>

<p>所以在用过Sublime Text之后，我立刻就卸掉了Notepad++。</p>

<p>Sublime Text自带的风格是我喜欢的深色风格（也可以调成浅色），默认主题是<code>Monokai Bright</code>，这两者的搭配已经很不错了，不过我们还可以做得更好：接下来我将会展示如何通过设置偏好项和添加自定义风格/主题使得Sublime Text更加Stylish。</p>

<h3>一些设置（Miscellaneous Settings）</h3>

<p>下面是我个人使用的设置项。</p>

<p><code>
// 设置Sans-serif（无衬线）等宽字体，以便阅读
"font_face": "YaHei Consolas Hybrid",
"font_size": 12,
// 使光标闪动更加柔和
"caret_style": "phase",
// 高亮当前行
"highlight_line": true,
// 高亮有修改的标签
"highlight_modified_tabs": true,
</code></p>

<p>设置之后的效果如下：</p>

<p><img src="http://i.imgur.com/MkyHff5.jpg" alt="设置效果" /></p>

<h3>主题（Themes）</h3>

<p>Sublime Text有大量第三方主题：[<a href="https://sublime.wbond.net/browse/labels/theme">https://sublime.wbond.net/browse/labels/theme</a>]，这里我给出几个个人感觉不错的主题：</p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Light</a></h4>

<p><img src="http://i.imgur.com/exxgbm1.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Soda">Soda Dark</a></h4>

<p><img src="http://i.imgur.com/YsrCJMe.png" alt="深色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a></h4>

<p><img src="http://i.imgur.com/ECLGEWD.png" alt="Nexus" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland</a></h4>

<p><img src="http://i.imgur.com/LT0AyhR.png" alt="Flatland" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Light</a></h4>

<p><img src="http://i.imgur.com/j0hJqeV.png" alt="浅色版" /></p>

<h4><a href="https://sublime.wbond.net/packages/Theme%20-%20Spacegray">Spacegray Dark</a></h4>

<p><img src="http://i.imgur.com/CJJhvTj.png" alt="深色版" /></p>

<h3>配色（Color）</h3>

<p><a href="http://colorsublime.com/">colorsublime</a>包含了大量Sublime Text配色方案，并支持在线预览，配色方案的安装教程在<a href="http://colorsublime.com/how-to-install-a-theme">这里</a>，恕不赘述。</p>

<p>我个人使用的是<a href="https://sublime.wbond.net/packages/Theme%20-%20Nexus">Nexus</a>主题和<a href="https://sublime.wbond.net/packages/Theme%20-%20Flatland">Flatland Dark</a>配色，配置如下：</p>

<p><code>
"theme": "Nexus.sublime-theme",
"color_scheme": "Packages/Theme - Flatland/Flatland Dark.tmTheme",
</code></p>

<p>效果如下：</p>

<p><img src="http://i.imgur.com/gCxTGii.jpg" alt="Nexus+Flatland" /></p>

<h2>编码（Coding）</h2>

<p>优秀的编辑器使编码变的更加容易，所以Sublime Text提供了一系列功能以提高开发效率。</p>

<h3>良好实践（Good Practices）</h3>

<p>良好的代码应该是规范的，所以Google为每一门主流语言都设置了其代码规范（Code Style Guideline）。我自己通过下面的设置使以规范化自己的代码。</p>

<p><code>
// 设置tab的大小为2
"tab_size": 2,
// 使用空格代替tab
"translate_tabs_to_spaces": true,
// 添加行宽标尺
"rulers": [80, 100],
// 显示空白字符
"draw_white_space": "all",
// 保存时自动去除行末空白
"trim_trailing_white_space_on_save": true,
// 保存时自动增加文件末尾换行
"ensure_newline_at_eof_on_save": true,
</code></p>

<h3>代码段（Code Snippets）</h3>

<p>Sublime Text支持代码段（Code Snippet），输入代码段名称后<code>Tab</code>即可生成代码段。</p>

<p><img src="http://i.imgur.com/EQc1zNX.gif" alt="代码段效果" /></p>

<p>你可以通过Package Control安装第三方代码段，也可以自己创建代码段，参考<a href="http://www.hongkiat.com/blog/sublime-code-snippets/">这里</a>。</p>

<h3>格式化（Formatting）</h3>

<p>Sublime Text基本的手动格式化操作包括：<code>Ctrl + [</code>向左缩进，<code>Ctrl + ]</code>向右缩进，此外<code>Ctrl + Shift + V</code>可以以当前缩进粘贴代码（非常实用）。</p>

<p>除了手动格式化，我们也可以通过安装插件实现自动缩进和智能对齐：</p>

<ul>
<li><a href="https://sublime.wbond.net/packages/HTMLBeautify">HTMLBeautify</a>：格式化HTML。</li>
<li><a href="https://sublime.wbond.net/packages/AutoPEP8">AutoPEP8</a>：格式化Python代码。</li>
<li><a href="https://sublime.wbond.net/packages/Alignment">Alignment</a>：进行智能对齐。</li>
</ul>


<h3>自动完成（Auto Completion）</h3>

<p>Sublime Text 支持一定的自动完成，按<code>Tab</code>自动补全。</p>

<p><img src="http://i.imgur.com/cqBI3NW.jpg" alt="自动完成" /></p>

<h3>括号（Brackets）</h3>

<p>编写代码时会碰到大量的括号，利用<code>Ctrl + M</code>可以快速的在起始括号和结尾括号间切换，<code>Ctrl + Shift + M</code>则可以快速选择括号间的内容，对于缩进型语言（例如Python）则可以使用<code>Ctrl + Shift + J</code>。</p>

<p><img src="http://i.imgur.com/oxWjAo9.gif" alt="括号演示" /></p>

<p>此外，我使用<a href="https://sublime.wbond.net/packages/BracketHighlighter">BracketHighlighter</a>插件以高亮显示配对括号以及当前光标所在区域，效果如下：</p>

<p><img src="http://i.imgur.com/QQpG99h.gif" alt="插件演示" /></p>

<h3>命令行（Command Line）</h3>

<p>尽管提供了Python控制台，但Sublime Text的控制台仅支持单行输入，十分不方便，所以我使用<a href="https://sublime.wbond.net/packages/SublimeREPL">Sublime​REPL</a>以进行一些编码实验（Experiments）。</p>

<p><img src="http://i.imgur.com/dZgi8QZ.gif" alt="SublimeREPL演示" /></p>

<h2>其它（Miscellaneous）</h2>

<p>尽管我试图在本文包含尽可能多的Sublime Text实用技能，但受限于篇幅和我的个人经验，本文仍不免有所遗漏，欢迎在评论里指出本文的错误及遗漏。</p>

<p>下面是一些可能有用但我很少用到的功能：</p>

<ul>
<li>宏（Macro）：Sublime Text支持<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/extensibility/macros.html">录制宏</a>，但我在实际工作中并未发现宏有多大用处。</li>
<li>其它平台（Other Platforms）：本文只介绍了Windows平台上Sublime Text的使用，不过Linux和OS X上Sublime Text的使用方式和Windows差别不大，只是在快捷键上有所差异，请参考<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_win.html">Windows/Linux快捷键</a>和<a href="http://sublime-text-unofficial-documentation.readthedocs.org/en/latest/reference/keyboard_shortcuts_osx.html">OS X快捷键</a>。</li>
<li>项目（Projects）：Sublime Text支持简单的<a href="http://www.sublimetext.com/docs/3/projects.html">项目管理</a>，但我一般只用到文件夹。</li>
<li>Vim模式（Vintage）：Sublime Text自带<a href="http://www.sublimetext.com/docs/3/vintage.html">Vim模式</a>。</li>
<li>构建（Build）：通过配置，Sublime Text可以进行<a href="http://docs.sublimetext.info/en/latest/file_processing/build_systems.html">源码构建</a>。</li>
<li>调试（Debug）：通过安装<a href="https://sublime.wbond.net/search/debug">插件</a>，Sublime Text可以对代码进行调试。</li>
</ul>


<h2>快捷键列表（Shortcuts Cheatsheet）</h2>

<p>我把本文出现的Sublime Text按其类型整理在这里，以便查阅。</p>

<h3>通用（General）</h3>

<ul>
<li><code>↑↓←→</code>：上下左右移动光标，注意不是不是<code>KJHL</code>！</li>
<li><code>Alt</code>：调出菜单</li>
<li><code>Ctrl + Shift + P</code>：调出命令板（Command Palette）</li>
<li><code>Ctrl + `</code>：调出控制台</li>
</ul>


<h3>编辑（Editing）</h3>

<ul>
<li><code>Ctrl + Enter</code>：在当前行下面新增一行然后跳至该行</li>
<li><code>Ctrl + Shift + Enter</code>：在当前行上面增加一行并跳至该行</li>
<li><code>Ctrl + ←/→</code>：进行逐词移动</li>
<li><code>Ctrl + Shift + ←/→</code>进行逐词选择</li>
<li><code>Ctrl + ↑/↓</code>移动当前显示区域</li>
<li><code>Ctrl + Shift + ↑/↓</code>移动当前行</li>
</ul>


<h3>选择（Selecting）</h3>

<ul>
<li><code>Ctrl + D</code>：选择当前光标所在的词并高亮该词所有出现的位置，再次<code>Ctrl + D</code>选择该词出现的下一个位置，在多重选词的过程中，使用<code>Ctrl + K</code>进行跳过，使用<code>Ctrl + U</code>进行回退，使用<code>Esc</code>退出多重编辑</li>
<li><code>Ctrl + Shift + L</code>：将当前选中区域打散</li>
<li><code>Ctrl + J</code>：把当前选中区域合并为一行</li>
<li><code>Ctrl + M</code>：在起始括号和结尾括号间切换</li>
<li><code>Ctrl + Shift + M</code>：快速选择括号间的内容</li>
<li><code>Ctrl + Shift + J</code>：快速选择同缩进的内容</li>
<li><code>Ctrl + Shift + Space</code>：快速选择当前作用域（Scope）的内容</li>
</ul>


<h3>查找&amp;替换（Finding&amp;Replacing）</h3>

<ul>
<li><code>F3</code>：跳至当前关键字下一个位置</li>
<li><code>Shift + F3</code>：跳到当前关键字上一个位置</li>
<li><code>Alt + F3</code>：选中当前关键字出现的所有位置</li>
<li><code>Ctrl + F/H</code>：进行标准查找/替换，之后：

<ul>
<li><code>Alt + C</code>：切换大小写敏感（Case-sensitive）模式</li>
<li><code>Alt + W</code>：切换整字匹配（Whole matching）模式</li>
<li><code>Alt + R</code>：切换正则匹配（Regex matching）模式</li>
<li><code>Ctrl + Shift + H</code>：替换当前关键字</li>
<li><code>Ctrl + Alt + Enter</code>：替换所有关键字匹配</li>
</ul>
</li>
<li><code>Ctrl + Shift + F</code>：多文件搜索&amp;替换</li>
</ul>


<h3>跳转（Jumping）</h3>

<ul>
<li><code>Ctrl + P</code>：跳转到指定文件，输入文件名后可以：

<ul>
<li><code>@</code> 符号跳转：输入<code>@symbol</code>跳转到<code>symbol</code>符号所在的位置</li>
<li><code>#</code> 关键字跳转：输入<code>#keyword</code>跳转到<code>keyword</code>所在的位置</li>
<li><code>:</code> 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>
</li>
<li><code>Ctrl + R</code>：跳转到指定符号</li>
<li><code>Ctrl + G</code>：跳转到指定行号</li>
</ul>


<h3>窗口（Window）</h3>

<ul>
<li><code>Ctrl + Shift + N</code>：创建一个新窗口</li>
<li><code>Ctrl + N</code>：在当前窗口创建一个新标签</li>
<li><code>Ctrl + W</code>：关闭当前标签，当窗口内没有标签时会关闭该窗口</li>
<li><code>Ctrl + Shift + T</code>：恢复刚刚关闭的标签</li>
</ul>


<h3>屏幕（Screen）</h3>

<ul>
<li><code>F11</code>：切换普通全屏</li>
<li><code>Shift + F11</code>：切换无干扰全屏</li>
<li><code>Alt + Shift + 2</code>：进行左右分屏</li>
<li><code>Alt + Shift + 8</code>：进行上下分屏</li>
<li><code>Alt + Shift + 5</code>：进行上下左右分屏</li>
<li>分屏之后，使用<code>Ctrl + 数字键</code>跳转到指定屏，使用<code>Ctrl + Shift + 数字键</code>将当前屏移动到指定屏</li>
</ul>


<h2>延伸阅读（Further Reading）</h2>

<h3>书籍（Books）</h3>

<ul>
<li><a href="http://www.amazon.com/Mastering-Sublime-Community-Experience-Distilled/dp/1849698422/">Mastering Sublime Text</a>：我读过的唯一一本关于Sublime Text的书籍，书中介绍的插件很实用，但对编辑技巧介绍不全。</li>
<li><a href="http://www.amazon.com/Instant-Sublime-Text-Starter-Haughee/dp/1849693927/">Instant Sublime Text Starter</a>：另外一本关于Sublime Text的书，我没有读过。</li>
</ul>


<h3>链接（Links）</h3>

<ul>
<li>官方文档：<a href="http://www.sublimetext.com/docs/3/">http://www.sublimetext.com/docs/3/</a></li>
<li>官方论坛：<a href="http://www.sublimetext.com/forum/">http://www.sublimetext.com/forum/</a></li>
<li>Stack Overflow的Sublime Text频道：

<ul>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext">http://stackoverflow.com/questions/tagged/sublimetext</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext2">http://stackoverflow.com/questions/tagged/sublimetext2</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/sublimetext3">http://stackoverflow.com/questions/tagged/sublimetext3</a></li>
</ul>
</li>
<li>非官方文档：<a href="http://sublime-text-unofficial-documentation.readthedocs.org/">http://sublime-text-unofficial-documentation.readthedocs.org/</a> 甚至比官方文档还要全面！</li>
<li>Package Control：<a href="https://sublime.wbond.net/">https://sublime.wbond.net/</a> 大量的Sublime Text插件和主题。</li>
</ul>


<h3>视频（Videos）</h3>

<ul>
<li>Getting Started with SublimeText：<a href="https://www.youtube.com/watch?v=04gKiTiRlq8">https://www.youtube.com/watch?v=04gKiTiRlq8</a></li>
<li>Sublime Text Pefect Workflow：<a href="https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g">https://www.youtube.com/watch?v=bpEp0ePIOEM&amp;list=PLuwqxbvf3olpLsnFvo06gbrkcEB5o7K0g</a></li>
</ul>


<h2>关于作者（About Me）</h2>

<p><a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/sublime-text-complete-guide/">http://zh.lucida.me/blog/sublime-text-complete-guide/</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<p>正在尽量努力成为一名靠谱的软件工程师 :&ndash;|</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——2. Blunders, Typos, Mismatches, and Language Liability]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-2/"/>
    <updated>2014-06-27T15:46:53-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-2</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-2/">Blunders, Typos, Mismatches, and Language Liability</a></li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>对编程错误的分析</h2>

<p>上篇文章（<a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a>）介绍了Knuth对编程错误的分类，基于Knuth的分类和我自己的编程经验，从这篇文章开始我将会给出各类编程错误的<strong>案例</strong>、<strong>诱因</strong>和<strong>对策</strong>。</p>

<p>按照复杂程度的不同，Knuth将编程错误分为三大类，这篇文章介绍第一类错误——简单的错误：</p>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<!-- more -->


<h2>粗心大意（a trivial typo）</h2>

<blockquote><p>Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</p>

<p>我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</p></blockquote>

<p><strong>粗心大意</strong>这类差错源自于Knuth奇葩的开发方式——先把程序在纸上写好然后再"誊写"到计算机中，而在"誊写"时可能会敲错几个字符，从而导致程序出错。</p>

<p>除去面试时的白板编码，我认为现代程序开发不可能在纸上进行——从而也不可能产生这种差错，所以不加赘述。</p>

<h2>鬼使神差（a blunder or botch）</h2>

<blockquote><p>Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</p>

<p>我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</p></blockquote>

<h3>案例</h3>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>中提到一个低级Bug：TEX代码里有两个变量<code>new_line</code>和<code>next_line</code>：<code>new_line</code>用于表示程序当前的状态，而<code>next_line</code>则指代换行符。然而开发过程中Knuth混淆了这两个变量的用途——由于这两个变量属于同一类型所以编译器无法检测出这个问题，这个Bug直到后来程序运行了一段时间才被发现。</p>

<h3>诱因</h3>

<ul>
<li>变量名含糊不清：导致之后的误用。</li>
<li>编程语言过分宽容：某些编程语言对代码特别宽容——比如动态编程语言会将静态编程语言在编译时做的类型检查拖到运行时，尽管获得了灵活性，但却损失了精确性。从而导致<strong>鬼使神差</strong>这类静态语言编译期就能检查到的错误直到运行时才会被发现。</li>
<li>加班超负荷工作：从而导致写出翔一般的代码。</li>
</ul>


<h3>对策</h3>

<ol>
<li>使用精准的名字：

<ul>
<li>作用域越长的变量的名字越要精确。</li>
<li>使用精准的英文词汇描述变量。</li>
<li>更多关于命名的信息请参考<a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/">Code Complete</a>中<strong>The Power of Variable Names</strong>一节。</li>
</ul>
</li>
<li>严格控制全局变量：

<ul>
<li>能不用则不用。</li>
<li>如果不得不使用，使用明确的名字，进行详细的注释，并注明不得不使用全局变量的原因。。</li>
</ul>
</li>
<li>优先使用强类型：例如对于内置强类型枚举（Enum）的语言（例如Java，C#，和C++），使用枚举类型表示状态（State），而非整数类型。</li>
<li>将编译器警告调到最高级：然后清除代码中所有的Warning。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>单步（Step Into）自己的代码：编写新代码后进行单步调试——你脑中的代码和实际可能不一样。</li>
<li>进行代码审查：可以参考<a href="http://coolshell.cn/articles/11432.html">这篇文章</a>。</li>
<li>不要在混沌状态提交代码。</li>
</ol>


<h2>丢三落四（a forgotten function）</h2>

<blockquote><p>Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</p>

<p>我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</p></blockquote>

<h3>案例</h3>

<h4>烫烫烫烫烫</h4>

<p>C语言中忘记初始化数组，从而输出喜闻乐见的“烫烫烫烫烫烫烫烫烫烫烫烫”。</p>

<p><img src="http://i.imgur.com/9RcLu2x.png" alt="烫烫烫烫烫烫" /></p>

<p>对于需要手动管理内存的语言（C/C++），忘记释放内存或忘记初始化内存都会导致各种奇诡的问题。</p>

<h4>过早优化</h4>

<p>在开发TEX时，Knuth试图去优化<code>get_next</code>这个被频繁调用的函数。经过一番思考，Knuth认为<code>cur_cs = 0</code>这段代码是不必要的，于是他将这段代码删除，代码依然"正常"运行。然而过了一段时间后Knuth发现TEX在处理对齐（Alignment）时有时会出现问题——经过一番调试，Knuth发现原来那段被删除的代码是必要的（necessary）。</p>

<p>郁闷之余，Knuth援引了那句著名的话（Hoare&rsquo;s dictum）——过早优化是万恶之源（Premature optimization is the root of all evil in programming），很多书都以为这句话是Knuth说的，实际上它属于<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>。</p>

<h3>诱因</h3>

<h4>远距离操作</h4>

<p>远距离操作指那些间隔特别长的操作，例如下面的代码：</p>

<p><code>
obj.Init()
obj.DoSomething()
// Hundred of lines
obj.DoSomething()
obj.Close()
</code></p>

<p>从<code>Init</code>到<code>Close</code>的距离过远，在编写了几十甚至上百行其它代码之后，很容易漏掉<code>obj.Close()</code>从而导致资源泄漏。</p>

<h4>贸然修改代码</h4>

<p>我个人认为Knuth所犯的错误不在于过早优化，而在于他在对代码理解不充分的情况下就去贸然修改——这往往会带来各种问题。</p>

<h3>应对</h3>

<ul>
<li>避免远距离操作：

<ul>
<li>对于内存管理：C++提供了智能指针。</li>
<li>多数编程语言提供了上下文管理器（Context Manager）：例如Java 7的<code>try</code>，C#的<code>using</code>，以及Python的<code>with</code>，利用这些机制，可以有效的减少远距离操作，比如前文的代码用Python可以这么写：</li>
</ul>
</li>
</ul>


<p><code>python
with Obj.Init() as obj:
  obj.DoSomething()
  // Hundred of lines
  obj.DoSomething()
</code></p>

<ul>
<li> 整理代码段落，避免复杂交织的逻辑，这里可以参考<a href="http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293">The Art of Readable Code</a>对Aesthetics的定义。</li>
</ul>


<p><img class="right <a" src="href="http://i.imgur.com/Mvr8zx2.jpg">http://i.imgur.com/Mvr8zx2.jpg</a>" width="180" height="250" title="Working Effectively with Legacy Code" ></p>

<ul>
<li><p>不要贸然修改代码：</p>

<ul>
<li>修改代码前要确保充分理解代码的原理，以及修改会带来的影响（Effect Analysis）。</li>
<li>修改代码后要保证被修改的部分得到测试，<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively with Legacy Code</a>提供了很多优秀的修改实践。</li>
</ul>
</li>
<li><p>代码审查：代码审查可以有效的控制编程差错。</p></li>
<li>不要在混沌状态提交代码。</li>
</ul>


<h2>言非所指（a language liability）</h2>

<blockquote><p>Here I misused or misunderstood the programming language or system hardware I was working with.</p>

<p>我对编程语言（或是系统硬件）理解有误，从而造成错误。</p></blockquote>

<h3>案例</h3>

<h4>JavaScript</h4>

<p>下面是JavaScript的真值表（源自Douglas Crockford）：</p>

<p><code>js
''        ==   '0'           // false
0         ==   ''            // true
0         ==   '0'           // true
false     ==   'false'       // false
false     ==   '0'           // true
false     ==   undefined     // false
false     ==   null          // false
null      ==   undefined     // true
" \t\r\n" ==   0             // true
</code></p>

<p>此外还有下面这个对比：</p>

<p><img src="http://i.imgur.com/5RCkNLK.jpg" alt="JavaScript the Good Parts" /></p>

<p>对于这种翔一样的语言，想不掉进坑里是非常困难的。</p>

<p>（讽刺的是，JavaScript统治了浏览器端，而且它还试图染指服务器端。）</p>

<h4>操作符优先级</h4>

<p><img class="right <a" src="href="http://i.imgur.com/5WjUpyd.jpg">http://i.imgur.com/5WjUpyd.jpg</a>" width="160" height="200" title="the Practice of Programming" ></p>

<p>[Brian Kernighan]曾在在<a href="http://cm.bell-labs.com/cm/cs/tpop/index.html">the Practice of Programming</a>中提到<code>if (x &amp; MASK == BITS)</code>这个例子：</p>

<p>我们一般会把<code>if (x &amp; MASK == BITS)</code>理解为<code>if ((x &amp; MASK) == BITS)</code>；</p>

<p>但实际上<code>if (x &amp; MASK == BITS)</code>和<code>if (x &amp; (MASK == BITS))</code>等价，而这显然不是我们想要的结果。</p>

<h3>诱因</h3>

<ul>
<li>对编程语言不够了解。</li>
<li>编程语言本身设计有问题。</li>
<li>对操作符优先级理解不足。</li>
</ul>


<h5>应对</h5>

<ul>
<li>深入理解编程语言——知道哪有坑：

<ul>
<li>学习编程语言不只是学它的语法——还要学习它的用法（Usages），最佳实践（Best Practices），误区（Traps），惯例（Conventions）和风格（Styles）等等，阅读<em>Effective</em>、<em>More Effective</em>、<em>Exceptional</em>、<em>More Exceptional</em>、<em>Pitfalls/Traps</em>和<em>the Good Parts</em>等系列的编程书籍以了解这些内容。</li>
<li><a href="http://joearms.github.io/">Joe Armstrong</a>在<a href="http://codersatwork.com/">Coders at work</a>的访谈中提到学习编程语言最好的方式是实现它（“The best way to learn a programming language is to implement it yourself”），我尝试用这种方法学习JavaScript，效果还不错。</li>
</ul>
</li>
<li>使用且仅使用语言的良子集——避开那些坑：

<ul>
<li><a href="http://crockford.com/">Douglas Crockford</a>在<a href="http://www.amazon.com/exec/obidos/ASIN/0596517742/">JavaScript: the Good Parts</a>中仅仅摘取了一个很小的JavaScript良子集进行编程，Kernighan和Plauger在<a href="http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/">Software Tools</a>则扩展了Fortran的一个良子集进行编程。语言提供的特性不代表你必须要使用它，容易产生错误（Error Prone）的语言特性应当被禁用。</li>
</ul>
</li>
<li>使用括号明确（Explicitify）操作符优先级——哪怕你能一眼看出<code>return true || true &amp;&amp; false</code>的返回值。</li>
<li>谨慎使用宏（macro）。</li>
<li>代码审查：提交代码之前至少需要一个该精通语言的人的审查，以免踩进语言的坑里。</li>
</ul>


<h2>事与愿违（a mismatch between modules）</h2>

<blockquote><p>Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</p>

<p>我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</p></blockquote>

<h3>案例</h3>

<h4>火星探测器坠毁</h4>

<p>史上最贵的<strong>事与愿违</strong>的Bug出现在1998年的NASA火星探测器中，这个Bug直接导致火星探测器坠毁，损失高达<a href="http://www.computerworld.com/s/article/9183580/Epic_failures_11_infamous_software_bugs">3.27亿美元</a>。</p>

<p>而这个Bug的成因在我们看来实际很可笑——Lockheed Martin公司在<a href="http://www.jpl.nasa.gov/news/releases/99/mcoloss1.html">调查</a>后发现，由于不同开发团队使用的计量单位不同——一个团队使用英制单位（英寸，英尺或英镑等），而其它开发团队使用公制（厘米或公斤等），从而导致系统运算错误，最终导致探测器坠毁。</p>

<h4>愚蠢的API设计</h4>

<p>以前在Microsoft实习时，我曾经编写过一个动画方法，用于移动屏幕上某个控件，这个方法大概是下面这个样子：</p>

<p>```csharp
// Returns a DoubleAnimation which moves control from (x1, y1) to (x2, y2).
public DoubleAnimation CreateAnimation(Control control, int x1, int y1, int x2, int y2, double duration) {</p>

<pre><code>// Some code...
</code></pre>

<p>}
```</p>

<p><code>CreateAnimation</code>用于创建一个<code>DoubleAnimation</code>，把某个控件从<code>(x1, y1)</code>移动到<code>(x2, y2)</code>，移动耗时<code>duration</code>毫秒。</p>

<p>之后就出现了下面一系列翔一般的代码：</p>

<p><code>csharp
var gridAnimation1 = CreateAnimation(grid1, grid1.X, grid1.Y, 480, 0, 500);
var gridAnimation2 = CreateAnimation(grid2, grid2.X, grid2.Y, 0, 0, 500);
var popUpAnimation = CreateAnimation(popUp, 0, -320, 0, 320, 500);
</code></p>

<p>以及误用（组员（包括我自己）把<code>duration</code>当成秒来用）：</p>

<p><code>csharp
var gridAnimation1 = CreateAnimation(grid1, 480, 800, 480, 0, 0.5);
</code></p>

<p>这个方法如同<strong>病毒</strong>一般，既使得调用代码变的丑陋不堪，同时带来了各种Bug，导致后来的维护者叫苦不迭，</p>

<p>现在回想下，我肯定不会把它设计成这副模样——一种方法是使用<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>，例如：</p>

<p><code>csharp
var gridAnimation = grid.FromCurrentPosition().MoveTo(x: 0, y: 0).InMilliSeconds(500);
var popUpAnimation = popUp.From(x: 0, y: -320).MoveTo(x: 0, y: 320).InMilliSeconds(500);
</code></p>

<p>从而使代码简洁明确。</p>

<h3>诱因</h3>

<p><strong>事与愿违</strong>源于糟糕的设计——人会犯错误，而糟糕的设计会大大加剧错误几率。</p>

<p><img class="right <a" src="href="http://i.imgur.com/jdeK9F0.jpg">http://i.imgur.com/jdeK9F0.jpg</a>" width="270" height="270" title="Tony Hoare" ></p>

<p>然而良好的设计非常困难——<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>曾在他的图灵奖获奖感言（<a href="http://zoo.cs.yale.edu/classes/cs422/2014/bib/hoare81emperor.pdf">The Emperor&rsquo;s Old Clothes</a>）中指出：</p>

<blockquote><p>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.</p></blockquote>

<h3>应对</h3>

<p>尽管Knuth把<strong>事与愿违</strong>归类为简单的差错，但我并不这么认为。<strong>事与愿违</strong>源于错误的设计，解决<strong>事与愿违</strong>的关键不在于修复其造成的差错，而在于处理造成<strong>事与愿违</strong>原因。修复<strong>事与愿违</strong>的错误很简单，但处理<strong>事与愿违</strong>的原因就复杂多了。</p>

<p><img class="right <a" src="href="http://i.imgur.com/tll1S89.jpg">http://i.imgur.com/tll1S89.jpg</a>" width="180" height="240" title="Awaken the Giant Within" ></p>

<p><a href="http://www.tonyrobbins.com/">Tony Robbins</a>曾在<a href="http://www.amazon.com/Awaken-Giant-Within-Immediate-Emotional/dp/0671791540/">Awaken the Giant Within</a>一书中讲了这样一个故事：</p>

<blockquote><p>一个医生在河边发现有一个人溺水，然后她跳进河里，把溺水者救上岸进行抢救。然而没过多久她又听到呼救声，她继续跳进河里，把溺水者救上岸抢救，然后她又听到求救，于是她又跳进河里…… 不幸的是，这名医生忙于抢救眼前的溺水者，而没有时间去上游查看是谁把这些人扔到水里的。</p></blockquote>

<p><img class="right <a" src="href="http://i.imgur.com/t5zjiGY.jpg">http://i.imgur.com/t5zjiGY.jpg</a>" width="180" height="240" title="Stream Analysis" ></p>

<p><a href="http://www.jerryporras.com/">Jerry Porras</a>也在<a href="http://www.amazon.com/Stream-Analysis-Organizational-Addison-Wesley-Organization/dp/0201056933/">Stream Analysis</a>中提到：</p>

<blockquote><p>People, especially people in organizations, tend to work on getting rid of symptoms, rather than solving the real problems.</p></blockquote>

<p>因此，处理<strong>事与愿违</strong>要从设计着手（Solving the real problems），这里从设计者和使用者两个角度出发：</p>

<h4>设计者</h4>

<ol>
<li>谨慎设计API：

<ul>
<li>API应该由经验丰富的人设计。</li>
<li>API设计应遵循一定的原则，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Josha Bloch</a>曾在Google做过一个非常出色的关于API设计的演讲：<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">How To Design A Good API and Why it Matters</a>。</li>
<li>API在投入使用前应进行可用性测试——糟糕的API不仅会降低开发效率，还会像病毒一般引入各种各样的差错。</li>
</ul>
</li>
<li>利用类型系统：

<ul>
<li>避免基本类型（Primitive Type）：对于有意义的数据，使用其类型而非基本类型。例如：使用<code>Money</code>表示金钱，而非使用<code>double</code>。</li>
<li>避免使用动态语言（例如Python和Ruby）构建大型系统：动态语言的作用仅限于快速开发原型系统，在我看来，动态语言像是纸和胶水，可以用它们快速构建一些玩具模型（原型系统），但用它们建造摩天大厦（大型系统）就太离谱了。</li>
</ul>
</li>
<li>设计文档+审查：软件设计在实现前应有详细的设计文档（Design Document），并至少通过两名以上经验丰富的开发者的审查。</li>
</ol>


<h4>使用者</h4>

<p><img class="right <a" src="href="http://i.imgur.com/3vIYjeg.jpg">http://i.imgur.com/3vIYjeg.jpg</a>" width="180" height="240" title="Debugging" ></p>

<ol>
<li>仔细阅读文档——Read the manual, and read everything, cover to cover，参见<a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>里的第一条调试原则——<strong>Understand the system</strong>。</li>
<li>调用API时仔细阅读其样例代码（Sample Code）和文档说明，不要想当然。</li>
<li>对于已有（Existing）的糟糕API，考虑对其进行封装（Wrapping），以免接下来的误用。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>代码审查：代码审查可以有效的控制编程差错。</li>
</ol>


<p>关于"简单"的编程差错就介绍到这里，下篇将介绍源自算法和数据结构的错误——Algorithm + Data Structures &ndash;> Programming。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——1. A Taxonomy of Programming Errors]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-1/"/>
    <updated>2014-06-24T15:32:12-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-1</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>编程错误的分类</h2>

<p>前文讲到Knuth在开发TEX的过程中遇到了各式各样的差错，为了理解并控制编程错误，Knuth将这些错误整理到<a href="http://texdoc.net/texmf-dist/doc/generic/knuth/errata/errorlog.pdf">记录日志</a>，并将这些差错分为15类。为了引用方便，我将它们翻译成中文。</p>

<p>注意：</p>

<ol>
<li>为了引用方便，Knuth使用英文首字母指代各个编程错误的分类，出于同样的原因，我将这些分类一一翻译为成语。</li>
<li>保留原文，以便读者理解，以免信息丢失。</li>
<li>原文中的"my"和"I"以及译文中的"我"均指Knuth本人。</li>
<li>如果认为翻译不靠谱请在评论中指出 :)</li>
</ol>


<p>下面是Knuth对TEX错误的分类：</p>

<!-- more -->


<hr />

<ul>
<li><strong>A: an algorithm awry.</strong> Here my original method proved to be incorrect or inadequate.</li>
<li><strong>不可胜算</strong>：我最初设想的算法有误或存在不足。</li>
</ul>


<hr />

<ul>
<li><strong>B: a blunder or botch.</strong> Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</li>
<li><strong>鬼使神差</strong>：我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</li>
</ul>


<hr />

<ul>
<li><strong>C: a cleanup for consistency or clarity.</strong> Here I changed the rules of the language to make things easier to remember and/or more logical.</li>
<li><strong>得心应手</strong>：我对语言（TEX）规则进行整理，使其符合逻辑，更加易用。</li>
</ul>


<hr />

<ul>
<li><strong>D: a data structure debacle.</strong> Here I didn&rsquo;t properly update the representation of information to preserve the appropriate invariants.</li>
<li><strong>差之毫厘</strong>：我对数据结构的操作有误，使其处在不一致的状态（破坏了其本应维持的不变式）。</li>
</ul>


<hr />

<ul>
<li><strong>E: an efficiency enhancement.</strong> Here I changed the program so that it would run faster; the existing code was correct but slow.</li>
<li><strong>多快好省</strong>：尽管原来的代码正确，但速度很慢，于是我修改代码以改善程序的性能。</li>
</ul>


<hr />

<ul>
<li><strong>F: a forgotten function.</strong> Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</li>
<li><strong>丢三落四</strong>：我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</li>
</ul>


<hr />

<ul>
<li><strong>G: a generalization or growth of ability.</strong> Here I realized that some extension of the existing specifications was desirable.</li>
<li><strong>虚怀若谷</strong>：我将一些已有的代码进行扩展/抽象使其更加通用。</li>
</ul>


<hr />

<ul>
<li><strong>I: an interactive improvement.</strong> Here I made TEX respond better to the user&rsquo;s needs.</li>
<li><strong>各得其所</strong>：我使TEX对用户更加友好。</li>
</ul>


<hr />

<ul>
<li><strong>L: a language liability.</strong> Here I misused or misunderstood the programming language or system hardware I was working with.</li>
<li><strong>言非所指</strong>：我对编程语言（或是系统硬件）理解有误，从而造成错误。</li>
</ul>


<hr />

<ul>
<li><strong>M: a mismatch between modules.</strong> Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</li>
<li><strong>事与愿违</strong>：我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</li>
</ul>


<hr />

<ul>
<li><strong>P: a promotion of portability.</strong> Here I changed the organization or documentation of the program; this affected only a person who would try to read or modify the code, not a person who tried to run it.</li>
<li><strong>焕然一新</strong>：我对程序的结构或是文档进行改善，从而在不改变程序的前提下改善其可读性和可修改性。</li>
</ul>


<hr />

<ul>
<li><strong>Q: a quest for quality.</strong> Here I changed the specifications of what the program should output from given input, when I learned how to improve the typographic appearance of the output.</li>
<li><strong>精益求精</strong>：在对字体版式有了更深入的理解之后，我对程序进行修改，以获得更好的输出效果。</li>
</ul>


<hr />

<ul>
<li><strong>R: a reinforcement of robustness.</strong> Whenever I realized that TEX could loop or crash in the presence of certain erroneous input, I tried to make the code bulletproof.</li>
<li><strong>百毒不侵</strong>：一旦我意识到TEX有可能在极端情况下崩溃，我就会想方设法使程序变的更加健壮。</li>
</ul>


<hr />

<ul>
<li><strong>S: a surprising scenario.</strong> Errors of type S were particularly bad bugs that forced me to change my original ideas, because of unforeseen interactions between various parts of the program.</li>
<li><strong>出乎意料</strong>：由于我最初对问题的定义或是对程序间模块的交互理解不足，导致一些无法预见的错误——这类错误往往很棘手。</li>
</ul>


<hr />

<ul>
<li><strong>T: a trivial typo.</strong> Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</li>
<li><strong>粗心大意</strong>：我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</li>
</ul>


<hr />

<h2>进一步的分类</h2>

<h3>Knuth随后将这15个分类分为两大类：</h3>

<ul>
<li><strong>不可胜算</strong>、<strong>鬼使神差</strong>、<strong>差之毫厘</strong>、<strong>丢三落四</strong>、<strong>言非所指</strong>、<strong>事与愿违</strong>、<strong>百毒不侵</strong>、<strong>出乎意料</strong>和<strong>粗心大意</strong>属于程序的差错（Bugs）。</li>
<li><strong>得心应手</strong>、<strong>多快好省</strong>、<strong>虚怀若谷</strong>、<strong>各得其所</strong>、<strong>焕然一新</strong>和<strong>精益求精</strong>属于对程序的改进（Enhancements）。</li>
</ul>


<h3>然后按复杂程度把差错（Bugs）分为三类：</h3>

<h4>简单的差错</h4>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<h4>复杂的差错</h4>

<ul>
<li><strong>不可胜算</strong>：算法设计不当。</li>
<li><strong>差之毫厘</strong>：数据结构维护不周。</li>
</ul>


<h4>棘手的差错</h4>

<ul>
<li><strong>百毒不侵</strong>：对错误输入处理不当而造成的问题。</li>
<li><strong>出乎意料</strong>：由于对问题的理解不足，从而导致各种诡异的问题。</li>
</ul>


<h2><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>的不足</h2>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对TEX的错误进行了详细的分析，并对这些错误进行了系统的分类，但我认为这篇文章仍有一些不足：</p>

<ol>
<li>Knuth并未对编程错误给出应对策略。</li>
<li><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文成于1989年，其中记载的是1978年至1982年Knuth开发TEX时碰到的各种问题——30年前的编程语言和现在严重脱节。</li>
</ol>


<p>所以，我打算（不自量力的）结合自己的经验，在Knuth的分析基础上再进一步——从下篇开始，我会为每一类编程错误给出其案例，诱因和应对策略。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>
]]></content>
  </entry>
  
</feed>
