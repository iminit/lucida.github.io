<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-06-23T23:26:09+01:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——0. Knuth, Tex, and the Errors of TEX]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-0/"/>
    <updated>2014-06-23T23:14:42+01:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-0</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>

<h2>概要</h2>

<p>这是一个系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<p>原本我计划在一篇文章完成所有内容，然而随着写作的深入，我发现文章的篇幅越来越长——考虑到可读性，我决定将这篇文章拓展为一个系列，计划如下：</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li>A Taxonomy of Programming Errors</li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems.</li>
<li>Epilogue</li>
</ol>


<!-- more -->


<h2>免责声明（Disclaimer）</h2>

<p>几天前我在知乎上读到一篇关于Swift的<a href="http://www.zhihu.com/question/24002984">讨论</a>：</p>

<p>胡搅蛮缠</p>

<p><img src="http://i.imgur.com/ezV72EP.png" alt="讨论1" /></p>

<p>无知者无畏</p>

<p><img src="http://i.imgur.com/XXo9TlC.png" alt="讨论2" /></p>

<p>为了避免无谓的讨论，如果您认为iPhone系统闹钟可以用200行代码搞定，或者觉着Python适合编写大型项目，那么这个系列不适合您阅读。</p>

<h2>编程错误（Programming Errors）</h2>

<p>作为软件开发者，我自己写过一些微型程序（500行左右）和一些中小型应用（5'000~20'000行），实习时做过一些小项目（2'000行左右），到现在参与大型项目（100'000行以上）。如果让我总结这些项目的共同点，那么就是我在这些项目里都犯了各式各样的错误——小到喜闻乐见的"烫烫烫烫烫烫烫烫"，大到破坏整个应用兼容性导致上千用户流失，有的错误很愚蠢，有的错误则是聪明反被聪明误。</p>

<p>不过我可以安慰自己，因为我并非孤独——计算机程序向来以错误百出而臭名昭著，以至于计算机先驱<a href="http://en.wikipedia.org/wiki/Grace_hopper">Grace Hopper</a>近乎自嘲的为计算机程序错误取了一个别名——Bug。在之后的六十余年，Bug和其衍生词Debug一直是了所有程序员的梦魇。</p>

<p>Grace Hopper发现的“Bug”</p>

<p><img src="http://i.imgur.com/m36RhHW.jpg" alt="第一个Bug" /></p>

<p>随着经验的累积，我隐隐感觉到这些编程错误有一定的规律，因为我开始发现一些错误似乎在哪里见过，于是我开始寻找这方面的书籍和文献，以控制/减少自己的编程错误。</p>

<blockquote><p>Those who cannot remember the past are condemned to repeat it.</p>

<p>George Santayana</p></blockquote>

<p>然后我找到了<a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>的<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>。</p>

<h2>the Errors of TEX</h2>

<h3>背景</h3>

<p><img src="http://i.imgur.com/UF1uTSy.jpg" alt="Knuth" /></p>

<p>相信任何学计算机的人都知道Knuth和他神话（或神化）般（的[TAOCP]七卷本（未完成），但对Knuth开发的[TEX]以及Knuth开发TEX的流程可能就不是那么了解了，所以我在这里简单介绍下。</p>

<p><img src="http://i.imgur.com/3HzERY5.jpg" alt="TAOCP" /></p>

<p>撰写并出版[TAOCP]前三卷之后，Knuth发现印刷排版烂的一逼，在没有好使的数字排版系统的情况下，Knuth决定自己搞一个出来——于是就有了TEX。</p>

<p><img src="http://i.imgur.com/e6FqiCM.jpg" alt="TEX" /></p>

<p>不过排版系统并非简单的（Trivial）系统，即便如Knuth此般异禀天赋，也无法从容应付——事实上Knuth在开发TEX的过程中遇到了大量的错误，这些错误从TEX初版（1978年）到<a href="http://tug.org/TUGboat/tb35-1/tb109knut.pdf">最近的一次性能调优</a>（2014年），源源不断，挥之不去。</p>

<p>这些错误让Knuth很头痛，为了理解并控制编程错误，Knuth将这些错误整理到记录日志，并对这些编程错误进行分类，这成为了<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文的基础。</p>

<h3>插曲</h3>

<p>Knuth开发TEX的流程在我等屌丝码农看来绝对匪夷所思，在<a href="http://www.codersatwork.com/">Coders at Work</a>一书对Knuth的访谈里，Knuth提到：</p>

<blockquote><p>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>

<p>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p></blockquote>

<p>尽管有可能是1978年还没有好用的交互编程环境（Interactive Programming Environment），但Knuth六个月纸上设计纸上写代码的开发方式仍可以说是编程史上的一朵奇葩。如果放到今天，Knuth一定会被各路敏捷极限TDD编程<em>高手</em>喷出翔。</p>

<p>插曲到此为止，下篇进入正题——编程错误的分类（A Taxonomy of Programming Errors）。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[来自苹果的编程语言——Swift简介]]></title>
    <link href="http://zh.lucida.me/blog/an-introduction-to-swift/"/>
    <updated>2014-06-03T02:22:19+01:00</updated>
    <id>http://zh.lucida.me/blog/an-introduction-to-swift</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>这篇文章简要介绍了苹果于<a href="https://developer.apple.com/wwdc/">WWDC 2014</a>发布的编程语言——Swift。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>

<h2>前言</h2>

<p>在这里我认为有必要提一下<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，Swift编程环境的大部分概念都源自于<a href="http://worrydream.com/">Bret</a>这个演讲。</p>

<p>接下来进入正题。</p>

<h2>Swift是什么？</h2>

<p>Swift是苹果于WWDC 2014发布的编程语言，这里引用<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>的原话：</p>

<blockquote><p>Swift is a new programming language for iOS and OS X apps that builds on the best of C and Objective-C, without the constraints of C compatibility.</p>

<p>Swift adopts safe programming patterns and adds modern features to make programming easier, more flexible and more fun.</p>

<p>Swift&rsquo;s clean slate, backed by the mature and much-loved Cocoa and Cocoa Touch frameworks, is an opportunity to imagine how software development works.</p>

<p>Swift is the first industrial-quality systems programming language that is as expressive and enjoyable as a scripting language.</p></blockquote>

<p>简单的说：</p>

<ol>
<li>Swift用来写iOS和OS X程序。（估计也不会支持其它屌丝系统）</li>
<li>Swift吸取了C和Objective-C的优点，且更加强大易用。</li>
<li>Swift可以使用现有的Cocoa和Cocoa Touch框架。</li>
<li>Swift兼具编译语言的高性能（Performance）和脚本语言的交互性（Interactive）。</li>
</ol>


<h2>Swift语言概览</h2>

<!-- more -->


<h3>基本概念</h3>

<p>注：这一节的代码源自<strong><a href="https://itunes.apple.com/gb/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></strong>中的<em>A Swift Tour</em>。</p>

<h4>Hello, world</h4>

<p>类似于脚本语言，下面的代码即是一个完整的Swift程序。</p>

<p><code>csharp
println("Hello, world")
</code></p>

<h4>变量与常量</h4>

<p>Swift使用<code>var</code>声明变量，<code>let</code>声明常量。</p>

<p><code>csharp
var myVariable = 42
myVariable = 50
let myConstant = 42
</code></p>

<h4>类型推导</h4>

<p>Swift支持类型推导（Type Inference），所以上面的代码不需指定类型，如果需要指定类型：</p>

<p><code>csharp
let explicitDouble : Double = 70
</code></p>

<p>Swift不支持隐式类型转换（Implicitly casting），所以下面的代码需要显式类型转换（Explicitly casting）：</p>

<p><code>csharp
let label = "The width is "
let width = 94
let labelWidth = label + String(width)
</code></p>

<h4>字符串格式化</h4>

<p>Swift使用<code>\(item)</code>的形式进行字符串格式化：</p>

<p><code>csharp
let apples = 3
let oranges = 5
let appleSummary = "I have \(apples) apples."
let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></p>

<h3>数组和字典</h3>

<p>Swift使用<code>[]</code>操作符声明数组（array）和字典（dictionary）：</p>

<p>```csharp
var shoppingList = [&ldquo;catfish&rdquo;, &ldquo;water&rdquo;, &ldquo;tulips&rdquo;, &ldquo;blue paint&rdquo;]
shoppingList[1] = &ldquo;bottle of water&rdquo;</p>

<p>var occupations = [</p>

<pre><code>"Malcolm": "Captain",
"Kaylee": "Mechanic",
</code></pre>

<p>]
occupations[&ldquo;Jayne&rdquo;] = &ldquo;Public Relations&rdquo;
```</p>

<p>一般使用初始化器（initializer）语法创建空数组和空字典：</p>

<p><code>csharp
let emptyArray = String[]()
let emptyDictionary = Dictionary&lt;String, Float&gt;()
</code></p>

<p>如果类型信息已知，则可以使用<code>[]</code>声明空数组，使用<code>[:]</code>声明空字典。</p>

<h3>控制流</h3>

<h4>概览</h4>

<p>Swift的条件语句包含<code>if</code>和<code>switch</code>，循环语句包含<code>for-in</code>、<code>for</code>、<code>while</code>和<code>do-while</code>，循环/判断条件不需要括号，但循环/判断体（body）必需括号：</p>

<p>```csharp
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {</p>

<pre><code>if score &gt; 50 {
    teamScore += 3
} else {
    teamScore += 1
}
</code></pre>

<p>}
```</p>

<h4>可空类型</h4>

<p>结合<code>if</code>和<code>let</code>，可以方便的处理可空变量（nullable variable）。对于空值，需要在类型声明后添加<code>?</code>显式标明该类型可空。</p>

<p>```csharp
var optionalString: String? = &ldquo;Hello&rdquo;
optionalString == nil</p>

<p>var optionalName: String? = &ldquo;John Appleseed&rdquo;
var gretting = &ldquo;Hello!&rdquo;
if let name = optionalName {</p>

<pre><code>gretting = "Hello, \(name)"
</code></pre>

<p>}
```</p>

<h4>灵活的switch</h4>

<p>Swift中的<code>switch</code>支持各种各样的比较操作：</p>

<p>```csharp
let vegetable = &ldquo;red pepper&rdquo;
switch vegetable {
case &ldquo;celery&rdquo;:</p>

<pre><code>let vegetableComment = "Add some raisins and make ants on a log."
</code></pre>

<p>case &ldquo;cucumber&rdquo;, &ldquo;watercress&rdquo;:</p>

<pre><code>let vegetableComment = "That would make a good tea sandwich."
</code></pre>

<p>case let x where x.hasSuffix(&ldquo;pepper&rdquo;):</p>

<pre><code>let vegetableComment = "Is it a spicy \(x)?"
</code></pre>

<p>default:</p>

<pre><code>let vegetableComment = "Everything tastes good in soup."
</code></pre>

<p>}
```</p>

<h4>其它循环</h4>

<p><code>for-in</code>除了遍历数组也可以用来遍历字典：</p>

<p>```csharp
let interestingNumbers = [</p>

<pre><code>"Prime": [2, 3, 5, 7, 11, 13],
"Fibonacci": [1, 1, 2, 3, 5, 8],
"Square": [1, 4, 9, 16, 25],
</code></pre>

<p>]
var largest = 0
for (kind, numbers) in interestingNumbers {</p>

<pre><code>for number in numbers {
    if number &gt; largest {
        largest = number
    }
}
</code></pre>

<p>}
largest
```</p>

<p><code>while</code>循环和<code>do-while</code>循环：</p>

<p>```csharp
var n = 2
while n &lt; 100 {</p>

<pre><code>n = n * 2
</code></pre>

<p>}
n</p>

<p>var m = 2
do {</p>

<pre><code>m = m * 2
</code></pre>

<p>} while m &lt; 100
m
```</p>

<p>Swift支持传统的<code>for</code>循环，此外也可以通过结合<code>..</code>（生成一个区间）和<code>for-in</code>实现同样的逻辑。</p>

<p>```csharp
var firstForLoop = 0
for i in 0..3 {</p>

<pre><code>firstForLoop += i
</code></pre>

<p>}
firstForLoop</p>

<p>var secondForLoop = 0
for var i = 0; i &lt; 3; ++i {</p>

<pre><code>secondForLoop += 1
</code></pre>

<p>}
secondForLoop
```</p>

<p>注意：Swift除了<code>..</code>还有<code>...</code>：<code>..</code>生成前闭后开的区间，而<code>...</code>生成前闭后闭的区间。</p>

<h3>函数和闭包</h3>

<h4>函数</h4>

<p>Swift使用<code>func</code>关键字声明函数：</p>

<p>```csharp
func greet(name: String, day: String) &ndash;> String {</p>

<pre><code>return "Hello \(name), today is \(day)."
</code></pre>

<p>}
greet(&ldquo;Bob&rdquo;, &ldquo;Tuesday&rdquo;)
```</p>

<p>通过元组（Tuple）返回多个值：</p>

<p>```csharp
func getGasPrices() &ndash;> (Double, Double, Double) {</p>

<pre><code>return (3.59, 3.69, 3.79)
</code></pre>

<p>}
getGasPrices()
```</p>

<p>支持带有变长参数的函数：</p>

<p>```csharp
func sumOf(numbers: Int&hellip;) &ndash;> Int {</p>

<pre><code>var sum = 0
for number in numbers {
    sum += number
}
return sum
</code></pre>

<p>}
sumOf()
sumOf(42, 597, 12)
```</p>

<p>函数也可以嵌套函数：</p>

<p>```csharp
func returnFifteen() &ndash;> Int {</p>

<pre><code>var y = 10
func add() {
    y += 5
}
add()
return y
</code></pre>

<p>}
returnFifteen()
```</p>

<p>作为头等对象，函数既可以作为返回值，也可以作为参数传递：</p>

<p>```csharp
func makeIncrementer() &ndash;> (Int &ndash;> Int) {</p>

<pre><code>func addOne(number: Int) -&gt; Int {
    return 1 + number
}
return addOne
</code></pre>

<p>}
var increment = makeIncrementer()
increment(7)
```</p>

<p>```csharp
func hasAnyMatches(list: Int[], condition: Int &ndash;> Bool) &ndash;> Bool {</p>

<pre><code>for item in list {
    if condition(item) {
        return true
    }
}
return false
</code></pre>

<p>}
func lessThanTen(number: Int) &ndash;> Bool {</p>

<pre><code>return number &lt; 10
</code></pre>

<p>}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
```</p>

<h4>闭包</h4>

<p>本质来说，函数是特殊的闭包，Swift中可以利用<code>{}</code>声明匿名闭包：</p>

<p>```csharp
numbers.map({</p>

<pre><code>(number: Int) -&gt; Int in
let result = 3 * number
return result
})
</code></pre>

<p>```</p>

<p>当闭包的类型已知时，可以使用下面的简化写法：</p>

<p><code>csharp
numbers.map({ number in 3 * number })
</code></p>

<p>此外还可以通过参数的位置来使用参数，当函数最后一个参数是闭包时，可以使用下面的语法：</p>

<p><code>csharp
sort([1, 5, 3, 12, 2]) { $0 &gt; $1 }
</code></p>

<h3>类和对象</h3>

<h4>创建和使用类</h4>

<p>Swift使用<code>class</code>创建一个类，类可以包含字段和方法：</p>

<p>```csharp
class Shape {</p>

<pre><code>var numberOfSides = 0
func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}
```</p>

<p>创建<code>Shape</code>类的实例，并调用其字段和方法。</p>

<p><code>csharp
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></p>

<p>通过<code>init</code>构建对象，既可以使用<code>self</code>显式引用成员字段（<code>name</code>），也可以隐式引用（<code>numberOfSides</code>）。</p>

<p>```csharp
class NamedShape {</p>

<pre><code>var numberOfSides: Int = 0
var name: String

init(name: String) {
    self.name = name
}

func simpleDescription() -&gt; String {
    return "A shape with \(numberOfSides) sides."
}
</code></pre>

<p>}
```</p>

<p>使用<code>deinit</code>进行清理工作。</p>

<h4>继承和多态</h4>

<p>Swift支持继承和多态（<code>override</code>父类方法）：</p>

<p>```csharp
class Square: NamedShape {</p>

<pre><code>var sideLength: Double

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 4
}

func area() -&gt; Double {
    return sideLength * sideLength
}

override func simpleDescription() -&gt; String {
    return "A square with sides of length \(sideLength)."
}
</code></pre>

<p>}
let test = Square(sideLength: 5.2, name: &ldquo;my test square&rdquo;)
test.area()
test.simpleDescription()
```</p>

<p>注意：如果这里的<code>simpleDescription</code>方法没有被标识为<code>override</code>，则会引发编译错误。</p>

<h4>属性</h4>

<p>为了简化代码，Swift引入了属性（property），见下面的<code>perimeter</code>字段：</p>

<p>```csharp
class EquilateralTriangle: NamedShape {</p>

<pre><code>var sideLength: Double = 0.0

init(sideLength: Double, name: String) {
    self.sideLength = sideLength
    super.init(name: name)
    numberOfSides = 3
}

var perimeter: Double {
get {
    return 3.0 * sideLength
}
set {
    sideLength = newValue / 3.0
}
}

override func simpleDescription() -&gt; String {
    return "An equilateral triagle with sides of length \(sideLength)."
}
</code></pre>

<p>}
var triangle = EquilateralTriangle(sideLength: 3.1, name: &ldquo;a triangle&rdquo;)
triangle.perimeter
triangle.perimeter = 9.9
triangle.sideLength
```</p>

<p>注意：赋值器（setter）中，接收的值被自动命名为<code>newValue</code>。</p>

<h4>willSet和didSet</h4>

<p><code>EquilateralTriangle</code>的构造器进行了如下操作：</p>

<ol>
<li>为子类型的属性赋值。</li>
<li>调用父类型的构造器。</li>
<li>修改父类型的属性。</li>
</ol>


<p>如果不需要计算属性的值，但需要在赋值前后进行一些操作的话，使用<code>willSet</code>和<code>didSet</code>：</p>

<p>```csharp
class TriangleAndSquare {</p>

<pre><code>var triangle: EquilateralTriangle {
willSet {
    square.sideLength = newValue.sideLength
}
}
var square: Square {
willSet {
    triangle.sideLength = newValue.sideLength
}
}
init(size: Double, name: String) {
    square = Square(sideLength: size, name: name)
    triangle = EquilateralTriangle(sideLength: size, name: name)
}
</code></pre>

<p>}
var triangleAndSquare = TriangleAndSquare(size: 10, name: &ldquo;another test shape&rdquo;)
triangleAndSquare.square.sideLength
triangleAndSquare.square = Square(sideLength: 50, name: &ldquo;larger square&rdquo;)
triangleAndSquare.triangle.sideLength
```</p>

<p>从而保证<code>triangle</code>和<code>square</code>拥有相等的<code>sideLength</code>。</p>

<h4>调用方法</h4>

<p>Swift中，函数的参数名称只能在函数内部使用，但方法的参数名称除了在内部使用外还可以在外部使用（第一个参数除外），例如：</p>

<p>```csharp
class Counter {</p>

<pre><code>var count: Int = 0
func incrementBy(amount: Int, numberOfTimes times: Int) {
    count += amount * times
}
</code></pre>

<p>}
var counter = Counter()
counter.incrementBy(2, numberOfTimes: 7)
```</p>

<p>注意Swift支持为方法参数取别名：在上面的代码里，<code>numberOfTimes</code>面向外部，<code>times</code>面向内部。</p>

<h4>?的另一种用途</h4>

<p>使用可空值时，<code>?</code>可以出现在方法、属性或下标前面。如果<code>?</code>前的值为<code>nil</code>，那么<code>?</code>后面的表达式会被忽略，而原表达式直接返回<code>nil</code>，例如：</p>

<p><code>csharp
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional
square")
let sideLength = optionalSquare?.sideLength
</code>
当<code>optionalSquare</code>为<code>nil</code>时，<code>sideLength</code>属性调用会被忽略。</p>

<h3>枚举和结构</h3>

<h4>枚举</h4>

<p>使用<code>enum</code>创建枚举——注意Swift的枚举可以关联方法：</p>

<p>```csharp
enum Rank: Int {</p>

<pre><code>case Ace = 1
case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
case Jack, Queen, King
    func simpleDescription() -&gt; String {
    switch self {
        case .Ace:
            return "ace"
        case .Jack:
            return "jack"
        case .Queen:
            return "queen"
        case .King:
            return "king"
        default:
            return String(self.toRaw())
    }
}
</code></pre>

<p>}
let ace = Rank.Ace
let aceRawValue = ace.toRaw()
```</p>

<p>使用<code>toRaw</code>和<code>fromRaw</code>在原始（raw）数值和枚举值之间进行转换：
```csharp
if let convertedRank = Rank.fromRaw(3) {</p>

<pre><code>let threeDescription = convertedRank.simpleDescription()
</code></pre>

<p>}
```</p>

<p>注意枚举中的成员值（member value）是实际的值（actual value），和原始值（raw value）没有必然关联。</p>

<p>一些情况下枚举不存在有意义的原始值，这时可以直接忽略原始值：</p>

<p>```csharp
enum Suit {</p>

<pre><code>case Spades, Hearts, Diamonds, Clubs
    func simpleDescription() -&gt; String {
    switch self {
        case .Spades:
            return "spades"
        case .Hearts:
            return "hearts"
        case .Diamonds:
            return "diamonds"
        case .Clubs:
            return "clubs"
    }
}
</code></pre>

<p>}
let hearts = Suit.Hearts
let heartsDescription = hearts.simpleDescription()
```</p>

<p>除了可以关联方法，枚举还支持在其成员上关联值，同一枚举的不同成员可以有不同的关联的值：</p>

<p>```csharp
enum ServerResponse {</p>

<pre><code>case Result(String, String)
case Error(String)
</code></pre>

<p>}</p>

<p>let success = ServerResponse.Result(&ldquo;6:00 am&rdquo;, &ldquo;8:09 pm&rdquo;)
let failure = ServerResponse.Error(&ldquo;Out of cheese.&rdquo;)</p>

<p>switch success {</p>

<pre><code>case let .Result(sunrise, sunset):
    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
case let .Error(error):
    let serverResponse = "Failure... \(error)"
</code></pre>

<p>}
```</p>

<h4>结构</h4>

<p>Swift使用<code>struct</code>关键字创建结构。结构支持构造器和方法这些类的特性。结构和类的最大区别在于：结构的实例按值传递（passed by value），而类的实例按引用传递（passed by reference）。</p>

<p>```csharp
struct Card {</p>

<pre><code>var rank: Rank
var suit: Suit
func simpleDescription() -&gt; String {
    return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
}
</code></pre>

<p>}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
```</p>

<h3>协议（protocol）和扩展（extension）</h3>

<h4>协议</h4>

<p>Swift使用<code>protocol</code>定义协议：</p>

<p>```csharp
protocol ExampleProtocol {</p>

<pre><code>var simpleDescription: String { get }
mutating func adjust()
</code></pre>

<p>}
```</p>

<p>类型、枚举和结构都可以实现（adopt）协议：</p>

<p>```csharp
class SimpleClass: ExampleProtocol {</p>

<pre><code>var simpleDescription: String = "A very simple class."
var anotherProperty: Int = 69105
func adjust() {
    simpleDescription += " Now 100% adjusted."
}
</code></pre>

<p>}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription</p>

<p>struct SimpleStructure: ExampleProtocol {</p>

<pre><code>var simpleDescription: String = "A simple structure"
mutating func adjust() {
    simpleDescription += " (adjusted)"
}
</code></pre>

<p>}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
```</p>

<h4>扩展</h4>

<p>扩展用于在已有的类型上增加新的功能（比如新的方法或属性），Swift使用<code>extension</code>声明扩展：</p>

<p>```csharp
extension Int: ExampleProtocol {</p>

<pre><code>var simpleDescription: String {
    return "The number \(self)"
}
mutating func adjust() {
    self += 42
}
</code></pre>

<p>}
7.simpleDescription
```</p>

<h3>泛型（generics）</h3>

<p>Swift使用<code>&lt;&gt;</code>来声明泛型函数或泛型类型：</p>

<p>```csharp
func repeat<ItemType>(item: ItemType, times: Int) &ndash;> ItemType[] {</p>

<pre><code>var result = ItemType[]()
for i in 0..times {
    result += item
}
return result
</code></pre>

<p>}
repeat(&ldquo;knock&rdquo;, 4)
```</p>

<p>Swift也支持在类、枚举和结构中使用泛型：</p>

<p>```csharp
// Reimplement the Swift standard library&rsquo;s optional type
enum OptionalValue<T> {</p>

<pre><code>case None
case Some(T)
</code></pre>

<p>}
var possibleInteger: OptionalValue<Int> = .None
possibleInteger = .Some(100)
```</p>

<p>有时需要对泛型做一些需求（requirements），比如需求某个泛型类型实现某个接口或继承自某个特定类型、两个泛型类型属于同一个类型等等，Swift通过<code>where</code>描述这些需求：</p>

<p>```csharp
func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element> (lhs: T, rhs: U) &ndash;> Bool {</p>

<pre><code>for lhsItem in lhs {
    for rhsItem in rhs {
        if lhsItem == rhsItem {
            return true
        }
    }
}
return false
</code></pre>

<p>}
anyCommonElements([1, 2, 3], [3])
```</p>

<p>Swift语言概览就到这里，有兴趣的朋友请进一步阅读<a href="">The Swift Programming Language</a>。</p>

<p>接下来聊聊个人对Swift的一些感受。</p>

<h2>个人感受</h2>

<p><strong>注意</strong>：下面的感受纯属个人意见，仅供参考。</p>

<h3>大杂烩</h3>

<p>尽管我接触Swift不足两小时，但很容易看出Swift吸收了大量其它编程语言中的元素，这些元素包括但不限于：</p>

<ol>
<li>属性（Property）、可空值（Nullable type）语法和泛型（Generic Type）语法源自C#。</li>
<li>格式风格与Go相仿（没有句末的分号，判断条件不需要括号）。</li>
<li>Python风格的当前实例引用语法（使用<code>self</code>）和列表字典声明语法。</li>
<li>Haskell风格的区间声明语法（比如<code>1..3</code>，<code>1...3</code>）。</li>
<li>协议和扩展源自Objective-C（自家产品随便用）。</li>
<li>枚举类型很像Java（可以拥有成员或方法）。</li>
<li><code>class</code>和<code>struct</code>的概念和C#极其相似。</li>
</ol>


<p>注意这里不是说Swift是抄袭——实际上编程语言能玩的花样基本就这些，况且Swift选的都是在我看来相当不错的特性。</p>

<p>而且，这个大杂烩有一个好处——就是任何其它编程语言的开发者都不会觉得Swift很陌生——这一点很重要。</p>

<h3>拒绝隐式（Refuse implicity）</h3>

<p>Swift去除了一些隐式操作，比如隐式类型转换和隐式方法重载这两个坑，干的漂亮。</p>

<h3>Swift的应用方向</h3>

<p>我认为Swift主要有下面这两个应用方向：</p>

<h4>教育</h4>

<p>我指的是编程教育。现有编程语言最大的问题就是交互性奇差，从而导致学习曲线陡峭。相信Swift及其交互性极强的编程环境能够打破这个局面，让更多的人——尤其是青少年，学会编程。</p>

<p>这里有必要再次提到<a href="http://worrydream.com/">Bret Victor</a>的<a href="http://vimeo.com/36579366">Inventing on Principle</a>，看了这个视频你就会明白一个交互性强的编程环境能够带来什么。</p>

<h4>应用开发</h4>

<p>现有的iOS和OS X应用开发均使用Objective-C，而Objective-C是一门及其繁琐（verbose）且学习曲线比较陡峭的语言，如果Swift能够提供一个同现有Obj-C框架的简易互操作接口，我相信会有大量的程序员转投Swift；与此同时，Swift简易的语法也会带来相当数量的其它平台开发者。</p>

<p>总之，上一次某家大公司大张旗鼓的推出一门编程语言及其编程平台还是在2000年（微软推出C#），将近15年之后，苹果推出Swift——作为开发者，我很高兴能够见证一门编程语言的诞生。</p>

<p>以上。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>转载前请保留出处链接，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的算法学习之路]]></title>
    <link href="http://zh.lucida.me/blog/on-learning-algorithms/"/>
    <updated>2014-05-04T21:43:42+01:00</updated>
    <id>http://zh.lucida.me/blog/on-learning-algorithms</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>严格来说，本文题目应该是<strong>我的数据结构和算法学习之路</strong>，但这个写法实在太绕口——况且CS中的算法往往暗指数据结构和算法（例如<strong>算法导论</strong>指的实际上是<strong>数据结构和算法导论</strong>），所以我认为本文题目是合理的。</p>

<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/">http://zh.lucida.me/blog/on-learning-algorithms/</a></p>

<p>原文作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<h3>这篇文章讲了什么？</h3>

<ul>
<li>我这些年学习数据结构和算法的总结。</li>
<li>一些不错的算法书籍和教程。</li>
<li>算法的重要性。</li>
</ul>


<h2>初学</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的"学长"和"大神"请教应该读哪些算法书籍，"学长"们均推荐算法导论，还有几个"大神"推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了<a href="http://www.douban.com/">豆瓣</a>这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些"学长"或是"大神"靠谱的多得多。</p>

<!-- more -->


<h3>数据结构与算法分析——C语言描述</h3>

<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt="数据结构与算法分析——C语言描述" /></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N<sup>3</sup>)杀到O(N<sup>2</sup>)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h3>微软的梦工厂</h3>

<p><img src="http://img3.douban.com/lpic/s3322643.jpg" alt="微软的梦工厂" /></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了"找工作就要这样的公司"的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己"毕业就工作"的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h3>算法设计与分析</h3>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://img3.douban.com/lpic/s2019521.jpg" alt="算法设计与分析基础" /></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具。</p>

<h3>算法引论</h3>

<p><img src="http://img5.douban.com/lpic/s4230097.jpg" alt="算法引论" /></p>

<p><a href="http://book.douban.com/subject/4178907/">算法引论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://img3.douban.com/lpic/s2019521.jpg">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ol>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ol>


<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h3>百度实习面试</h3>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个<code>stof</code>（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li>原来自己连百度实习面试都过不去。</li>
<li>原来自己还是一个编程弱逼。</li>
<li>原来自己还是一个算法菜逼。</li>
</ul>


<p>痛定思痛，我开始了第二个"五年计划"，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h3>Elements of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s4243636.jpg" alt="Elements of Programming" /></p>

<p>由于一直觉得名字里带"Elements of"的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h3>C Interfaces and Implementation</h3>

<p><img src="http://img5.douban.com/lpic/s1686769.jpg" alt="C Interfaces and Implementation" /></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826292/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的<a href="http://www.amazon.com/review/RMXKDJNH8UOPU/">评论</a>：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是<code>stof</code>这种简单到爆的"算法"。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——<strong>纸上编码</strong>。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的<a href="http://book.douban.com/review/3733680/">文章</a>来黑那些动不动就"基础"或"内功"的所谓"大牛"们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote><p>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</p></blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸。</p>

<h3>LL(k)</h3>

<p>我在微软实习的第一个项目做的是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>分析——计算T-SQL存储过程的代码覆盖率。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://img5.douban.com/lpic/s24921197.jpg" alt="Language Implementation Patterns" /></p>

<p>比较奇诡的是，做这个项目时当时我刚好把<a href="http://www.antlr.org/">ANTLR</a>作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h3>拼音索引</h3>

<p>拼音索引是我接的一个手机应用私活里的小模块，用户期待在手机文本框可以根据输入给出智能提示：</p>

<p>比如说输入中国：</p>

<p><img src="http://i.imgur.com/tjKjyzN.png" alt="智能提示" /></p>

<p>同样，输入拼音也应给出提示：</p>

<p><img src="http://i.imgur.com/zTjEBik.png" alt="智能提示" /></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ol>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用<code>Int16</code>索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用<code>Int64</code>建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个<code>Int64</code>里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ol>


<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，<strong>如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞</strong>。</p>

<h3>快速字符串匹配</h3>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找"张晓明"，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。</p>

<p><img src="http://i.imgur.com/R3JalOH.jpg" alt="E51" /></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><img src="http://i.imgur.com/Pfff0e9.jpg" alt="Cry" /></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://img3.douban.com/lpic/s8978030.jpg" alt="Algorithms on Strings, Trees and Sequences" /></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h3>Writing Efficient Programs</h3>

<p>之后又做了若干个项目，多多少少都用到了"自制"的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种<strong>将有限计算资源发挥到极致</strong>的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://img3.douban.com/lpic/s3780111.jpg" alt="Writing Efficient Programs" /></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了<strong>过早优化是万恶之源</strong>之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h3>Algorithm Design Manual</h3>

<p><img src="http://img3.douban.com/lpic/s10347625.jpg" alt="Algorithm Design Manual" /></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3072383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h3>编程珠玑&amp;更多的编程珠玑</h3>

<p><img src="http://img3.douban.com/lpic/s2712842.jpg" alt="Programming Pearls" /></p>

<p><img src="http://img3.douban.com/lpic/s7073511.jpg" alt="More Programming Pearls" /></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h3>The Science of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s2812798.jpg" alt="The Science of Programming" /></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>引用的书籍，撸完<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>之后，本屌获得了<strong>证明简单代码段的正确性</strong>这个技能——求职面试三板斧之二。</p>

<p><strong>证明简单代码段的正确性</strong>是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的<a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">博客</a>，总之就是<strong>项目经历</strong>、<strong>纸上代码</strong>加<strong>正确性证明</strong>这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称<strong>拼写</strong>出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h3>Algorithms 4th</h3>

<p><img src="http://img5.douban.com/lpic/s8938479.jpg" alt="Algorithms" /></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h3>6.851 Advanced Data Structures</h3>

<p><img src="http://courses.csail.mit.edu/6.851/spring12/illus.png" alt="Advanced Data Structures" /></p>

<p><a href="http://courses.csail.mit.edu/6.851/">Advanced Data Structures</a>是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google <strong>Advanced Data Structures</strong>第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带"记忆"的数据结构（Data Structure with Persistence）。</li>
<li>van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。</li>
<li>o(1)时间复杂度的的LCA、RMQ和LA解法。</li>
<li>奇幻的o(n)时间复杂度的Suffix Tree构建方法。</li>
<li>o(lglgn)的BST。</li>
<li>&hellip;</li>
</ul>


<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决<strong>实际</strong>问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p><a href="http://norvig.com/">Peter Norvig</a>曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：</p>

<blockquote><p>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：</p>

<blockquote><p>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</p></blockquote>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>

<p>By <a href="http://zh.lucida.me">Lucida</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[90分钟实现一门编程语言——极简解释器教程]]></title>
    <link href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/"/>
    <updated>2014-03-23T19:08:35+00:00</updated>
    <id>http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp</id>
    <content type="html"><![CDATA[<h2>关键字</h2>

<p>解释器, C#, Scheme, 函数式编程</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/</a></p>

<h2>关于</h2>

<p>本文介绍了如何使用C#实现一个简化Scheme——iScheme及其解释器。</p>

<p>如果你对下面的内容感兴趣：</p>

<ul>
<li>实现基本的词法分析，语法分析并生成抽象语法树。</li>
<li>实现嵌套作用域和函数调用。</li>
<li>解释器的基本原理。</li>
<li>以及一些C#编程技巧。</li>
</ul>


<p>那么请继续阅读。</p>

<p>如果你对以下内容感兴趣：</p>

<ul>
<li>高级的词法/语法分析技术。</li>
<li>类型推导/分析。</li>
<li>目标代码优化。</li>
</ul>


<p>本文则过于初级，你可以跳过本文，但欢迎指出本文的错误 :&ndash;)</p>

<!-- more -->


<h2>代码样例</h2>

<p>```csharp 代码示例
public static int Add(int a, int b) {</p>

<pre><code>return a + b;
</code></pre>

<p>}</p>

<blockquote><blockquote><p>Add(3, 4)
7</p>

<p>Add(5, 5)
10
```</p></blockquote></blockquote>

<p>这段代码定义了<code>Add</code>函数，接下来的<code>&gt;&gt;</code>符号表示对<code>Add(3, 4)</code>进行求值，再下一行的<code>&gt;&gt; 7</code>表示上一行的求值结果，不同的求值用换行分开。可以把这里的<code>&gt;&gt;</code>理解成控制台提示符（即Terminal中的PS）。</p>

<h2>什么是解释器</h2>

<p><img src="http://i.imgur.com/C8lxHfr.jpg" alt="解释器图示" /></p>

<p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>（Interpreter）是一种程序，能够读入程序并直接输出结果，如上图。相对于<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E5%99%A8">编译器</a>（Compiler），<a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>并不会生成目标机器代码，而是直接运行源程序，简单来说：</p>

<blockquote><p><a href="http://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>是运行程序的程序。</p></blockquote>

<p>计算器就是一个典型的解释器，我们把数学公式（源程序）给它，它通过运行它内部的"解释器"给我们答案。</p>

<p><img src="http://i.imgur.com/FC1nqko.jpg" alt="CASIO 计算器" /></p>

<h2>iScheme编程语言</h2>

<p>iScheme是什么？</p>

<ul>
<li>Scheme语言的一个极简子集。</li>
<li>虽然小，但变量，算术|比较|逻辑运算，列表，函数和递归这些编程语言元素一应俱全。</li>
<li>非常非常慢——可以说它只是为演示本文的概念而存在。</li>
</ul>


<p>OK，那么Scheme是什么？</p>

<ul>
<li>一种函数式程序设计语言。</li>
<li>一种Lisp方言。</li>
<li>麻省理工学院程序设计入门课程使用的语言（参见<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/">MIT 6.001</a>和《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造与解释</a>》）。</li>
</ul>


<p><img src="http://i.imgur.com/66TdRMD.jpg" alt="计算机程序的构造与解释" /></p>

<ul>
<li>使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>（Polish Notation）。</li>
<li>更多的介绍参见<a href="http://zh.wikipedia.org/wiki/Scheme">Scheme编程语言</a>。</li>
</ul>


<p>以计算阶乘为例：</p>

<p>```csharp C#版阶乘
public static int Factorial(int n) {</p>

<pre><code>if (n == 1) {
    return 1;
} else {
    return n * Factorial(n - 1);
}
</code></pre>

<p>}
```</p>

<p>```scm iScheme版阶乘
(def factorial (lambda (n) (</p>

<pre><code>if (= n 1)
   1
   (* n (factorial (- n 1))))))
</code></pre>

<p>```</p>

<h3>数值类型</h3>

<p>由于iScheme只是一个用于演示的语言，所以目前只提供对整数的支持。iScheme使用C#的<code>Int64</code>类型作为其内部的数值表示方法。</p>

<h3>定义变量</h3>

<p><code>``scm iScheme使用</code>def`关键字定义变量</p>

<blockquote><blockquote><p>(def a 3)
3</p>

<p>a
3
```</p></blockquote></blockquote>

<h3>算术|逻辑|比较操作</h3>

<p>与常见的编程语言（C#, Java, C++, C）不同，Scheme使用<a href="http://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">波兰表达式</a>，即前缀表示法。例如：</p>

<p>```csharp C#中的算术|逻辑|比较操作
// Arithmetic ops
a + b * c
a / (b + c + d)
// Logical ops
(cond1 &amp;&amp; cond2) || cond3
// Comparing ops
a == b
1 &lt; a &amp;&amp; a &lt; 3</p>

<p>```</p>

<p><code>scm 对应的iScheme代码
; Arithmetic ops
(+ a (* b c))
(/ a (+ b c d))
; Logical ops
(or (and cond1 cond2) cond3)
; Comparing ops
(= a b)
(&lt; 1 a 3)
</code></p>

<p>需要注意的几点：</p>

<ol>
<li>iScheme中的操作符可以接受不止两个参数——这在一定程度上控制了括号的数量。</li>
<li>iScheme逻辑操作使用<code>and</code>, <code>or</code>和<code>not</code>代替了常见的<code>&amp;&amp;</code>, <code>||</code>和<code>!</code>——这在一定程度上增强了程序的可读性。</li>
</ol>


<h3>顺序语句</h3>

<p>iScheme使用<code>begin</code>关键字标识顺序语句，并以最后一条语句的值作为返回结果。以求两个数的平均值为例：</p>

<p><code>csharp C#的顺序语句
int a = 3;
int b = 5;
int c = (a + b) / 2;
</code></p>

<p>```scm iScheme的顺序语句
(def c (begin</p>

<pre><code>(def a 3)
(def b 5)
(/ (+ a b) 2)))
</code></pre>

<p>```</p>

<h3>控制流操作</h3>

<p>iScheme中的控制流操作只包含<code>if</code>。</p>

<p>```scm if语句示例</p>

<blockquote><blockquote><p>(define a (if (> 3 2) 1 2))
1</p>

<p>a
1
```</p></blockquote></blockquote>

<h3>列表类型</h3>

<p>iScheme使用<code>list</code>关键字定义列表，并提供<code>first</code>关键字获取列表的第一个元素；提供<code>rest</code>关键字获取列表除第一个元素外的元素。</p>

<p>```scm iScheme的列表示例</p>

<blockquote><blockquote><p>(define alist (list 1 2 3 4))
(list 1 2 3 4)</p>

<p>(first alist)
1</p>

<p>(rest alist)
(2 3 4)
```</p></blockquote></blockquote>

<h3>定义函数</h3>

<p>iScheme使用<code>func</code>关键字定义函数：</p>

<p>```scm iScheme的函数定义
(def square (func (x) (* x x)))</p>

<p>(def sum_square (func (a b) (+ (square a) (square b))))
```</p>

<p>```csharp 对应的C#代码
public static int Square (int x) {</p>

<pre><code>return x * x;
</code></pre>

<p>}</p>

<p>public static int SumSquare(int a, int b) {</p>

<pre><code>return Square(a) + Square(b);
</code></pre>

<p>}
```</p>

<h3>递归</h3>

<p>由于iScheme中没有<code>for</code>或<code>while</code>这种命令式语言（Imperative Programming Language）的循环结构，递归成了重复操作的唯一选择。</p>

<p>以计算最大公约数为例：</p>

<p>```scm iScheme计算最大公约数
(def gcd (func (a b)</p>

<pre><code>(if (= b 0)
    a
    (func (b (% a b))))))
</code></pre>

<p>```</p>

<p>```csharp 对应的C#代码
public static int GCD (int a, int b) {</p>

<pre><code>if (b == 0) {
    return a;
} else {
    return GCD(b, a % b);
}
</code></pre>

<p>}
```</p>

<h3>高阶函数</h3>

<p>和Scheme一样，函数在iScheme中是头等对象，这意味着：</p>

<ul>
<li>可以定义一个变量为函数。</li>
<li>函数可以接受一个函数作为参数。</li>
<li>函数返回一个函数。</li>
</ul>


<p>```scm iScheme的高阶函数示例
; Defines a multiply function.
(def mul (func (a b) (* a b)))
; Defines a list map function.
(def map (func (f alist)</p>

<pre><code>(if (empty? alist)
    (list )
    (append (list (f (first alist))) (map f (rest alist)))
    )))
</code></pre>

<p>; Doubles a list using map and mul.</p>

<blockquote><blockquote><p>(map (mul 2) (list 1 2 3))
(list 2 4 6)
```</p></blockquote></blockquote>

<h3>小结</h3>

<p>对iScheme的介绍就到这里——事实上这就是iScheme的所有元素，会不会太简单了？ &ndash;_&ndash;</p>

<p>接下来进入正题——从头开始构造iScheme的解释程序。</p>

<h2>解释器构造</h2>

<p>iScheme解释器主要分为两部分，解析（Parse）和求值（Evaluation）：</p>

<ul>
<li>解析（Parse）：解析源程序，并生成解释器可以理解的中间（Intermediate）结构。这部分包含词法分析，语法分析，语义分析，生成语法树。</li>
<li>求值（Evaluation）：执行解析阶段得到的中介结构然后得到运行结果。这部分包含作用域，类型系统设计和语法树遍历。</li>
</ul>


<h3>词法分析</h3>

<p>词法分析负责把源程序解析成一个个词法单元（Lex），以便之后的处理。</p>

<p>iScheme的词法分析极其简单——由于iScheme的词法元素只包含括号，空白，数字和变量名，因此C#自带的<code>String#Split</code>就足够。</p>

<p>```csharp iScheme的词法分析及测试
public static String[] Tokenize(String text) {</p>

<pre><code>String[] tokens = text.Replace("(", " ( ").Replace(")", " ) ").Split(" \t\r\n".ToArray(), StringSplitOptions.RemoveEmptyEntries);
return tokens;
</code></pre>

<p>}</p>

<p>// Extends String.Join for a smooth API.
public static String Join(this String separator, IEnumerable<Object> values) {</p>

<pre><code>return String.Join(separator, values);
</code></pre>

<p>}</p>

<p>// Displays the lexes in a readable form.
public static String PrettyPrint(String[] lexes) {</p>

<pre><code>return "[" + ", ".Join(lexes.Select(s =&gt; "'" + s + "'") + "]";
</code></pre>

<p>}</p>

<p>// Some tests</p>

<blockquote><blockquote><p>PrettyPrint(Tokenize(&ldquo;a&rdquo;))
[&lsquo;a&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(def a 3)&rdquo;))
[&lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;]</p>

<p>PrettyPrint(Tokenize(&ldquo;(begin (def a 3) (<em> a a))&rdquo;))
[&lsquo;begin&rsquo;, &lsquo;(&rsquo;, &lsquo;def&rsquo;, &lsquo;a&rsquo;, &lsquo;3&rsquo;, &lsquo;)&rsquo;, &lsquo;(&rsquo;, &lsquo;</em>&rsquo;, &lsquo;a&rsquo;, &lsquo;a&rsquo;, &lsquo;)&rsquo;, &lsquo;)&rsquo;]
```</p></blockquote></blockquote>

<h4>注意</h4>

<ul>
<li>个人不喜欢<code>String.Join</code>这个静态方法，所以这里使用C#的<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>（Extension Methods）对String类型做了一个扩展。</li>
<li>相对于LINQ Syntax，我个人更喜欢LINQ Extension Methods，接下来的代码也都会是这种风格。</li>
<li>不要以为词法分析都是这么离谱般简单！vczh的<a href="http://www.cnblogs.com/geniusvczh/p/3577561.html">词法分析教程</a>给出了一个完整编程语言的词法分析教程。</li>
</ul>


<h3>语法树生成</h3>

<p>得到了词素之后，接下来就是进行语法分析。不过由于Lisp类语言的程序即是语法树，所以语法分析可以直接跳过。</p>

<p>以下面的程序为例：</p>

<p>```scm 程序即语法树
;
(def x (if (> a 1) a 1))
; 换一个角度看的话：
(</p>

<pre><code>def
x
(
    if
    (
        &gt;
        a
        1
    )
    a
    1
)
</code></pre>

<p>)
```</p>

<p>更加直观的图片：</p>

<p><img src="http://i.imgur.com/NVolNQE.png" alt="抽象语法树" /></p>

<p>这使得<a href="http://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">抽象语法树</a>（Abstract Syntax Tree）的构建变得极其简单（无需考虑操作符优先级等问题），我们使用<code>SExpression</code>类型定义iScheme的语法树（事实上<a href="http://en.wikipedia.org/wiki/S-expression">S Expression</a>也是Lisp表达式的名字）。</p>

<p>```csharp 抽象语法树的定义
public class SExpression {</p>

<pre><code>public String Value { get; private set; }
public List&lt;SExpression&gt; Children { get; private set; }
public SExpression Parent { get; private set; }

public SExpression(String value, SExpression parent) {
    this.Value = value;
    this.Children = new List&lt;SExpression&gt;();
    this.Parent = parent;
}

public override String ToString() {
    if (this.Value == "(") {
        return "(" + " ".Join(Children) + ")";
    } else {
        return this.Value;
    }
}
</code></pre>

<p>}
```</p>

<p>然后用下面的步骤构建语法树：</p>

<ol>
<li>碰到左括号，创建一个新的节点到当前节点（<code>current</code>），然后重设当前节点。</li>
<li>碰到右括号，回退到当前节点的父节点。</li>
<li>否则把为当前词素创建节点，添加到当前节点中。</li>
</ol>


<p>```csharp 抽象语法树的构建过程
public static SExpression ParseAsIScheme(this String code) {</p>

<pre><code>SExpression program = new SExpression(value: "", parent: null);
SExpression current = program;
foreach (var lex in Tokenize(code)) {
    if (lex == "(") {
        SExpression newNode = new SExpression(value: "(", parent: current);
        current.Children.Add(newNode);
        current = newNode;
    } else if (lex == ")") {
        current = current.Parent;
    } else {
        current.Children.Add(new SExpression(value: lex, parent: current));
    }
}
return program.Children[0];
</code></pre>

<p>}
```</p>

<h4>注意</h4>

<ul>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb384054.aspx">自动属性</a>（Auto Property），从而避免重复编写样版代码（Boilerplate Code）。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/dd264739.aspx">命名参数</a>（Named Parameters）提高代码可读性：<code>new SExpression(value: "", parent: null)</code>比<code>new SExpression("", null)</code>可读。</li>
<li>使用<a href="http://msdn.microsoft.com/zh-cn/library/bb383977.aspx">扩展方法</a>提高代码流畅性：<code>code.Tokenize().ParseAsIScheme</code>比<code>ParseAsIScheme(Tokenize(code))</code>流畅。</li>
<li>大多数编程语言的语法分析不会这么简单！如果打算实现一个类似C#的编程语言，你需要更强大的语法分析技术：

<ul>
<li>如果打算手写语法分析器，可以参考LL(k), Precedence Climbing和Top Down Operator Precedence。</li>
<li>如果打算生成语法分析器，可以参考ANTLR或Bison。</li>
</ul>
</li>
</ul>


<h3>作用域</h3>

<p><a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a>决定程序的运行环境。iScheme使用嵌套作用域。</p>

<p>以下面的程序为例</p>

<p>```scm</p>

<blockquote><blockquote><p>(def x 1)
1</p>

<p>(def y (begin (def x 2) (* x x)))
4</p>

<p>x
1
```</p></blockquote></blockquote>

<p><img src="http://i.imgur.com/TzBY0vd.jpg" alt="作用域示例" /></p>

<p>利用C#提供的<code>Dictionary&lt;TKey, TValue&gt;</code>类型，我们可以很容易的实现iScheme的作用域<code>SScope</code>：</p>

<p>```csharp iScheme的作用域实现
public class SScope {</p>

<pre><code>public SScope Parent { get; private set; }
private Dictionary&lt;String, SObject&gt; variableTable;

public SScope(SScope parent) {
    this.Parent = parent;
    this.variableTable = new Dictionary&lt;String, SObject&gt;();
}

public SObject Find(String name) {
    SScope current = this;
    while (current != null) {
        if (current.variableTable.ContainsKey(name)) {
            return current.variableTable[name];
        }
        current = current.Parent;
    }
    throw new Exception(name + " is not defined.");
}

public SObject Define(String name, SObject value) {
    this.variableTable.Add(name, value);
    return value;
}
</code></pre>

<p>}
```</p>

<h3>类型实现</h3>

<p>iScheme的类型系统极其简单——只有数值，Bool，列表和函数，考虑到他们都是iScheme里面的值对象（Value Object），为了便于对它们进行统一处理，这里为它们设置一个统一的父类型<code>SObject</code>：</p>

<p><code>csharp
public class SObject { }
</code></p>

<h4>数值类型</h4>

<p>iScheme的数值类型只是对.Net中<code>Int64</code>（即C#里的<code>long</code>）的简单封装：</p>

<p>```csharp
public class SNumber : SObject {</p>

<pre><code>private readonly Int64 value;
public SNumber(Int64 value) {
    this.value = value;
}
public override String ToString() {
    return this.value.ToString();
}
public static implicit operator Int64(SNumber number) {
    return number.value;
}
public static implicit operator SNumber(Int64 value) {
    return new SNumber(value);
}
</code></pre>

<p>}
```</p>

<p>注意这里使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p><code>csharp
SNumber foo = 30;
SNumber bar = 40;
SNumber foobar = foo * bar;
</code></p>

<p>而不必：</p>

<p><code>csharp
SNumber foo = new SNumber(value: 30);
SNumber bar = new SNumber(value: 40);
SNumber foobar = new SNumber(value: foo.Value * bar.Value);
</code></p>

<p>为了方便，这里也为SObject增加了<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>（尽管<code>Int64</code>可以被转换为<code>SNumber</code>且<code>SNumber</code>继承自<code>SObject</code>，但.Net无法直接把<code>Int64</code>转化为<code>SObject</code>）：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Int64 value) {
    return (SNumber)value;
}
</code></pre>

<p>}
```</p>

<h4>Bool类型</h4>

<p>由于Bool类型只有True和False，所以使用静态对象就足矣。</p>

<p>```csharp
public class SBool : SObject {</p>

<pre><code>public static readonly SBool False = new SBool();
public static readonly SBool True = new SBool();
public override String ToString() {
    return ((Boolean)this).ToString();
}
public static implicit operator Boolean(SBool value) {
    return value == SBool.True;
}
public static implicit operator SBool(Boolean value) {
    return value ? True : False;
}
</code></pre>

<p>}
```</p>

<p>这里同样使用了C#的<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>，这使得我们可以：</p>

<p>```csharp
SBool foo = a > 1;
if (foo) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>而不用</p>

<p>```csharp
SBool foo = a > 1 ? SBool.True: SBool.False;
if (foo == SBool.True) {</p>

<pre><code>// Do something...
</code></pre>

<p>}
```</p>

<p>同样，为<code>SObject</code>增加<a href="http://msdn.microsoft.com/zh-cn/library/z5z9kes2.aspx">隐式操作符重载</a>：</p>

<p>```csharp
public class SObject {</p>

<pre><code>...
public static implicit operator SObject(Boolean value) {
    return (SBool)value;
}
</code></pre>

<p>}
```</p>

<h4>列表类型</h4>

<p>iScheme使用.Net中的<code>IEnumberable&lt;T&gt;</code>实现列表类型<code>SList</code>：</p>

<p>```csharp
public class SList : SObject, IEnumerable<SObject> {</p>

<pre><code>private readonly IEnumerable&lt;SObject&gt; values;
public SList(IEnumerable&lt;SObject&gt; values) {
    this.values = values;
}
public override String ToString() {
    return "(list " + " ".Join(this.values) + ")";
}
public IEnumerator&lt;SObject&gt; GetEnumerator() {
    return this.values.GetEnumerator();
}
IEnumerator IEnumerable.GetEnumerator() {
    return this.values.GetEnumerator();
}
</code></pre>

<p>}
```</p>

<p>实现<code>IEnumerable&lt;SObject&gt;</code>后，就可以直接使用LINQ的一系列扩展方法，十分方便。</p>

<h4>函数类型</h4>

<p>iScheme的函数类型（<code>SFunction</code>）由三部分组成：</p>

<ul>
<li>函数体：即对应的<code>SExpression</code>。</li>
<li>参数列表。</li>
<li>作用域：函数拥有自己的作用域</li>
</ul>


<p>```csharp SFunction的实现
public class SFunction : SObject {</p>

<pre><code>public SExpression Body { get; private set; }
public String[] Parameters { get; private set; }
public SScope Scope { get; private set; }
public Boolean IsPartial {
    get {
        return this.ComputeFilledParameters().Length.InBetween(1, this.Parameters.Length);
    }
}

public SFunction(SExpression body, String[] parameters, SScope scope) {
    this.Body = body;
    this.Parameters = parameters;
    this.Scope = scope;
}

public SObject Evaluate() {
    String[] filledParameters = this.ComputeFilledParameters();
    if (filledParameters.Length &lt; Parameters.Length) {
        return this;
    } else {
        return this.Body.Evaluate(this.Scope);
    }
}

public override String ToString() {
    return String.Format("(func ({0}) {1})",
        " ".Join(this.Parameters.Select(p =&gt; {
            SObject value = null;
            if ((value = this.Scope.FindInTop(p)) != null) {
                return p + ":" + value;
            }
            return p;
        })), this.Body);
}

private String[] ComputeFilledParameters() {
    return this.Parameters.Where(p =&gt; Scope.FindInTop(p) != null).ToArray();
}
</code></pre>

<p>}
```</p>

<h5>需要注意的几点</h5>

<ul>
<li>iScheme支持部分求值（Partial Evaluation），这意味着：</li>
</ul>


<p>```scm 部分求值</p>

<blockquote><blockquote><p>(def mul (func (a b) (<em> a b)))
(func (a b) (</em> a b))</p>

<p>(mul 3 4)
12</p>

<p>(mul 3)
(func (a:3 b) (* a b))</p>

<p>((mul 3) 4)
12
```</p></blockquote></blockquote>

<p>也就是说，当<code>SFunction</code>的实际参数（Argument）数量小于其形式参数（Parameter）的数量时，它依然是一个函数，无法被求值。</p>

<p>这个功能有什么用呢？生成高阶函数。有了部分求值，我们就可以使用</p>

<p>```scm
(def mul (func (a b) (* a b)))
(def mul3 (mul 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<p>而不用专门定义一个生成函数：</p>

<p>```scm
(def times (func (n) (func (n x) (* n x)) ) )
(def mul3 (times 3))</p>

<blockquote><blockquote><p>(mul3 3)
9
```</p></blockquote></blockquote>

<ul>
<li><code>SFunction#ToString</code>可以将其自身还原为源代码——从而大大简化了iScheme的理解和测试。</li>
</ul>


<h3>内置操作</h3>

<p>iScheme的内置操作有四种：算术|逻辑|比较|列表操作。</p>

<p>我选择了表达力（Expressiveness）强的lambda方法表来定义内置操作：</p>

<p>首先在<code>SScope</code>中添加静态字段<code>builtinFunctions</code>，以及对应的访问属性<code>BuiltinFunctions</code>和操作方法<code>BuildIn</code>。</p>

<p>```csharp
public class SScope {</p>

<pre><code>private static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; builtinFunctions =
    new Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt;();
public static Dictionary&lt;String, Func&lt;SExpression[], SScope, SObject&gt;&gt; BuiltinFunctions {
    get { return builtinFunctions; }
}
// Dirty HACK for fluent API.
public SScope BuildIn(String name, Func&lt;SExpression[], SScope, SObject&gt; builtinFuntion) {
    SScope.builtinFunctions.Add(name, builtinFuntion);
    return this;
}
</code></pre>

<p>}
```</p>

<p>注意：</p>

<ol>
<li><code>Func&lt;T1, T2, TRESULT&gt;</code>是C#提供的委托类型，表示一个接受<code>T1</code>和<code>T2</code>，返回<code>TRESULT</code></li>
<li>这里有一个小HACK，使用实例方法（Instance Method）修改静态成员（Static Member），从而实现一套流畅的API（参见<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>）。</li>
</ol>


<p>接下来就可以这样定义内置操作：</p>

<p>```csharp
new SScope(parent: null)</p>

<pre><code>.BuildIn("+", addMethod)
.BuildIn("-", subMethod)
.BuildIn("*", mulMethod)
.BuildIn("/", divMethod);
</code></pre>

<p>```</p>

<p>一目了然。</p>

<h4>断言（Assertion）扩展</h4>

<p>为了便于进行<a href="http://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">断言</a>，我对<code>Boolean</code>类型做了一点点扩展。</p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>从而可以写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<p>而不用</p>

<p>```csharp
if (a &lt; 3) {</p>

<pre><code>    throw new Exception("Value must be less than 3.");
</code></pre>

<p>}
```</p>

<h4>算术操作</h4>

<p>iScheme算术操作包含<code>+ - * / %</code>五个操作，它们仅应用于数值类型（也就是<code>SNumber</code>）。</p>

<p>从加减法开始：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;();
return numbers.Sum(n =&gt; n);
</code></pre>

<p>})
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Select(obj =&gt; obj.Evaluate(scope)).Cast&lt;SNumber&gt;().ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>注意到这里有一段重复逻辑负责转型求值（Cast then Evaluation），考虑到接下来还有不少地方要用这个逻辑，我把这段逻辑抽象成扩展方法：</p>

<p>```csharp
public static IEnumerable<T> Evaluate<T>(this IEnumerable<SExpression> expressions, SScope scope)
where T : SObject {</p>

<pre><code>return expressions.Evaluate(scope).Cast&lt;T&gt;();
</code></pre>

<p>}
public static IEnumerable<SObject> Evaluate(this IEnumerable<SExpression> expressions, SScope scope) {</p>

<pre><code>return expressions.Select(exp =&gt; exp.Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>然后加减法就可以如此定义：</p>

<p>```csharp
.BuildIn(&ldquo;+&rdquo;, (args, scope) => (args.Evaluate<SNumber>(scope).Sum(s => s)))
.BuildIn(&ldquo;&ndash;&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
if (numbers.Length == 1) {
    return -firstValue;
}
return firstValue - numbers.Skip(1).Sum(s =&gt; s);
</code></pre>

<p>})
```</p>

<p>乘法，除法和求模定义如下：</p>

<p>```csharp
.BuildIn(&ldquo;*&rdquo;, (args, scope) => args.Evaluate<SNumber>(scope).Aggregate((a, b) => a * b))
.BuildIn(&ldquo;/&rdquo;, (args, scope) => {</p>

<pre><code>var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
Int64 firstValue = numbers[0];
return firstValue / numbers.Skip(1).Aggregate((a, b) =&gt; a * b);
</code></pre>

<p>})
.BuildIn(&ldquo;%&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 2).OrThrows("Parameters count in mod should be 2");
var numbers = args.Evaluate&lt;SNumber&gt;(scope).ToArray();
return numbers[0] % numbers[1];
</code></pre>

<p>})
```</p>

<h4>逻辑操作</h4>

<p>iScheme逻辑操作包括<code>and</code>，<code>or</code>和<code>not</code>，即与，或和非。</p>

<p>需要注意的是iScheme逻辑操作是<a href="http://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC">短路求值</a>（Short-circuit evaluation），也就是说：</p>

<ul>
<li><code>(and condA condB)</code>，如果<code>condA</code>为假，那么整个表达式为假，无需对<code>condB</code>求值。</li>
<li><code>(or condA condB)</code>，如果<code>condA</code>为真，那么整个表达式为真，无需对<code>condB</code>求值。</li>
</ul>


<p>此外和<code>+ - * /</code>一样，<code>and</code>和<code>or</code>也可以接收任意数量的参数。</p>

<p>需求明确了接下来就是实现，iScheme的逻辑操作实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;and&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return !args.Any(arg =&gt; !(SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;or&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 0).OrThrows();
return args.Any(arg =&gt; (SBool)arg.Evaluate(scope));
</code></pre>

<p>})
.BuildIn(&ldquo;not&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length == 1).OrThrows();
return args[0].Evaluate(scope);
</code></pre>

<p>})
```</p>

<h4>比较操作</h4>

<p>iScheme的比较操作包括<code>= &lt; &gt; &gt;= &lt;=</code>，需要注意下面几点：</p>

<ul>
<li><code>=</code>是比较操作而非赋值操作。</li>
<li>同算术操作一样，它们应用于数值类型，并支持任意数量的参数。</li>
</ul>


<p><code>=</code>的实现如下：</p>

<p>```csharp
.BuildIn(&ldquo;=&rdquo;, (args, scope) => {</p>

<pre><code>(args.Length &gt; 1).OrThrows("Must have more than 1 argument in relation operation.");
SNumber current = (SNumber)args[0].Evaluate(scope);
foreach (var arg in args.Skip(1)) {
    SNumber next = (SNumber)arg.Evaluate(scope);
    if (current == next) {
        current = next;
    } else {
        return false;
    }
}
return true;
</code></pre>

<p>})
```</p>

<p>可以预见所有的比较操作都将使用这段逻辑，因此把这段比较逻辑抽象成一个扩展方法：</p>

<p>```csharp
public static SBool ChainRelation(this SExpression[] expressions, SScope scope, Func&lt;SNumber, SNumber, Boolean> relation) {</p>

<pre><code>(expressions.Length &gt; 1).OrThrows("Must have more than 1 parameter in relation operation.");
SNumber current = (SNumber)expressions[0].Evaluate(scope);
foreach (var obj in expressions.Skip(1)) {
    SNumber next = (SNumber)obj.Evaluate(scope);
    if (relation(current, next)) {
        current = next;
    } else {
        return SBool.False;
    }
}
return SBool.True;
</code></pre>

<p>}
```</p>

<p>接下来就可以很方便的定义比较操作：</p>

<p><code>csharp
.BuildIn("=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; (Int64)s1 == (Int64)s2))
.BuildIn("&gt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt; s2))
.BuildIn("&lt;", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt; s2))
.BuildIn("&gt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &gt;= s2))
.BuildIn("&lt;=", (args, scope) =&gt; args.ChainRelation(scope, (s1, s2) =&gt; s1 &lt;= s2))
</code></p>

<p>注意<code>=</code>操作的实现里面有<code>Int64</code>强制转型——因为我们没有重载<code>SNumber#Equals</code>，所以无法直接通过<code>==</code>来比较两个<code>SNumber</code>。</p>

<h4>列表操作</h4>

<p>iScheme的列表操作包括<code>first</code>，<code>rest</code>，<code>empty?</code>和<code>append</code>，分别用来取列表的第一个元素，除第一个以外的部分，判断列表是否为空和拼接列表。</p>

<p><code>first</code>和<code>rest</code>操作如下：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;first&gt; must apply to a list.");
return list.First();
</code></pre>

<p>})
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => {</p>

<pre><code>SList list = null;
(args.Length == 1 &amp;&amp; (list = (args[0].Evaluate(scope) as SList)) != null).OrThrows("&lt;rest&gt; must apply to a list.");
return new SList(list.Skip(1));
</code></pre>

<p>})
```</p>

<p>又发现相当的重复逻辑——判断参数是否是一个合法的列表，重复代码很邪恶，所以这里把这段逻辑抽象为扩展方法：</p>

<p>```csharp
public static SList RetrieveSList(this SExpression[] expressions, SScope scope, String operationName) {</p>

<pre><code>SList list = null;
(expressions.Length == 1 &amp;&amp; (list = (expressions[0].Evaluate(scope) as SList)) != null)
    .OrThrows("&lt;" + operationName + "&gt; must apply to a list");
return list;
</code></pre>

<p>}
```</p>

<p>有了这个扩展方法，接下来的列表操作就很容易实现：</p>

<p>```csharp
.BuildIn(&ldquo;first&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;first&rdquo;).First())
.BuildIn(&ldquo;rest&rdquo;, (args, scope) => new SList(args.RetrieveSList(scope, &ldquo;rest&rdquo;).Skip(1)))
.BuildIn(&ldquo;append&rdquo;, (args, scope) => {</p>

<pre><code>SList list0 = null, list1 = null;
(args.Length == 2
    &amp;&amp; (list0 = (args[0].Evaluate(scope) as SList)) != null
    &amp;&amp; (list1 = (args[1].Evaluate(scope) as SList)) != null).OrThrows("Input must be two lists");
return new SList(list0.Concat(list1));
</code></pre>

<p>})
.BuildIn(&ldquo;empty?&rdquo;, (args, scope) => args.RetrieveSList(scope, &ldquo;empty?&rdquo;).Count() == 0)
```</p>

<h4>测试</h4>

<p>iScheme的内置操作完成之后，就可以测试下初步成果了。</p>

<p>首先添加基于控制台的分析/求值（Parse/Evaluation）循环：</p>

<p>```csharp
public static void KeepInterpretingInConsole(this SScope scope, Func&lt;String, SScope, SObject> evaluate) {</p>

<pre><code>while (true) {
    try {
        Console.ForegroundColor = ConsoleColor.Gray;
        Console.Write("&gt;&gt; ");
        String code;
        if (!String.IsNullOrWhiteSpace(code = Console.ReadLine())) {
            Console.ForegroundColor = ConsoleColor.Green;
            Console.WriteLine("&gt;&gt; " + evaluate(code, scope));
        }
    } catch (Exception ex) {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("&gt;&gt; " + ex.Message);
    }
}
</code></pre>

<p>}
```</p>

<p>然后在<code>SExpression#Evaluate</code>中补充调用代码：</p>

<p>```csharp
public override SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    }
} else {
    SExpression first = this.Children[0];
    if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).Select(node =&gt; node.Evaluate(scope)).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    }
}
throw new Exception("THIS IS JUST TEMPORARY!");
</code></pre>

<p>}
```</p>

<p>最后在<code>Main</code>中调用该解释/求值循环：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // 省略若干内置函数
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>运行程序，输入一些简单的表达式：</p>

<p><img src="http://i.imgur.com/FEVEVGW.jpg" alt="运行结果" /></p>

<p>看样子还不错 :&ndash;)</p>

<p>接下来开始实现iScheme的执行（Evaluation）逻辑。</p>

<h3>执行逻辑</h3>

<p>iScheme的执行就是把语句（SExpression）在作用域（SScope）转化成对象（SObject）并对作用域（SScope）产生作用的过程，如下图所示。</p>

<p><img src="http://i.imgur.com/2j4ztfF.png" alt="编程语言的实质" /></p>

<p>iScheme的执行逻辑就在<code>SExpression#Evaluate</code>里面：</p>

<p>```csharp
public class SExpression {</p>

<pre><code>// ...
public override SObject Evaluate(SScope scope) {
    // TODO: Todo your ass.
}
</code></pre>

<p>}
```</p>

<p>首先明确输入和输出：</p>

<ol>
<li>处理字面量（Literals）：<code>3</code>；和具名量（Named Values）：<code>x</code></li>
<li>处理<code>if</code>：<code>(if (&lt; a 3) 3 a)</code></li>
<li>处理<code>def</code>：<code>(def pi 3.14)</code></li>
<li>处理<code>begin</code>：<code>(begin (def a 3) (* a a))</code></li>
<li>处理<code>func</code>：<code>(func (x) (* x x))</code></li>
<li>处理内置函数调用：<code>(+ 1 2 3 (first (list 1 2)))</code></li>
<li>处理自定义函数调用：<code>(map (func (x) (* x x)) (list 1 2 3))</code></li>
</ol>


<p>此外，情况1和2中的<code>SExpression</code>没有子节点，可以直接读取其<code>Value</code>进行求值，余下的情况需要读取其<code>Children</code>进行求值。</p>

<p>首先处理没有子节点的情况：</p>

<h4>处理字面量和具名量</h4>

<p>```csharp
if (this.Children.Count == 0) {</p>

<pre><code>Int64 number;
if (Int64.TryParse(this.Value, out number)) {
    return number;
} else {
    return scope.Find(this.Value);
}
</code></pre>

<p>}
```</p>

<p>接下来处理带有子节点的情况：</p>

<p>首先获得当前节点的第一个节点：</p>

<p><code>csharp
SExpression first = this.Children[0];
</code></p>

<p>然后根据该节点的<code>Value</code>决定下一步操作：</p>

<h4>处理<code>if</code></h4>

<p><code>if</code>语句的处理方法很直接——根据判断条件（condition）的值判断执行哪条语句即可：</p>

<p>```csharp
if (first.Value == &ldquo;if&rdquo;) {</p>

<pre><code>SBool condition = (SBool)(this.Children[1].Evaluate(scope));
return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
</code></pre>

<p>}
```</p>

<h4>处理<code>def</code></h4>

<p>直接定义即可：</p>

<p>```csharp
else if (first.Value == &ldquo;def&rdquo;) {</p>

<pre><code>return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
</code></pre>

<p>}
```</p>

<h4>处理<code>begin</code></h4>

<p>遍历语句，然后返回最后一条语句的值：</p>

<p>```csharp
else if (first.Value == &ldquo;begin&rdquo;) {</p>

<pre><code>SObject result = null;
foreach (SExpression statement in this.Children.Skip(1)) {
    result = statement.Evaluate(scope);
}
return result;
</code></pre>

<p>}
```</p>

<h4>处理<code>func</code></h4>

<p>利用<code>SExpression</code>构建<code>SFunction</code>，然后返回：</p>

<p>```csharp
else if (first.Value == &ldquo;func&rdquo;) {</p>

<pre><code>SExpression body = this.Children[2];
String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
SScope newScope = new SScope(scope);
return new SFunction(body, parameters, newScope);
</code></pre>

<p>}
```</p>

<h4>处理<code>list</code></h4>

<p>首先把<code>list</code>里的元素依次求值，然后创建<code>SList</code>：</p>

<p>```csharp
else if (first.Value == &ldquo;list&rdquo;) {</p>

<pre><code>return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
</code></pre>

<p>}
```</p>

<h4>处理内置操作</h4>

<p>首先得到参数的表达式，然后调用对应的内置函数：</p>

<p>```csharp
else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {</p>

<pre><code>var arguments = this.Children.Skip(1).ToArray();
return SScope.BuiltinFunctions[first.Value](arguments, scope);
</code></pre>

<p>}
```</p>

<h4>处理自定义函数调用</h4>

<p>自定义函数调用有两种情况：</p>

<ol>
<li>非具名函数调用：<code>((func (x) (* x x)) 3)</code></li>
<li>具名函数调用：<code>(square 3)</code></li>
</ol>


<p>调用自定义函数时应使用新的作用域，所以为<code>SFunction</code>增加<code>Update</code>方法：</p>

<p>```csharp
public SFunction Update(SObject[] arguments) {</p>

<pre><code>var existingArguments = this.Parameters.Select(p =&gt; this.Scope.FindInTop(p)).Where(obj =&gt; obj != null);
var newArguments = existingArguments.Concat(arguments).ToArray();
SScope newScope = this.Scope.Parent.SpawnScopeWith(this.Parameters, newArguments);
return new SFunction(this.Body, this.Parameters, newScope);
</code></pre>

<p>}
```</p>

<p>为了便于创建自定义作用域，并判断函数的参数是否被赋值，为<code>SScope</code>增加<code>SpawnScopeWith</code>和<code>FindInTop</code>方法：</p>

<p>```csharp
public SScope SpawnScopeWith(String[] names, SObject[] values) {</p>

<pre><code>(names.Length &gt;= values.Length).OrThrows("Too many arguments.");
SScope scope = new SScope(this);
for (Int32 i = 0; i &lt; values.Length; i++) {
    scope.variableTable.Add(names[i], values[i]);
}
return scope;
</code></pre>

<p>}
public SObject FindInTop(String name) {</p>

<pre><code>if (variableTable.ContainsKey(name)) {
    return variableTable[name];
}
return null;
</code></pre>

<p>}
```</p>

<p>下面是函数调用的实现：</p>

<p>```csharp
else {</p>

<pre><code>SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
return function.Update(arguments).Evaluate();
</code></pre>

<p>}
```</p>

<h4>完整的求值代码</h4>

<p>综上所述，求值代码如下</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>if (this.Children.Count == 0) {
    Int64 number;
    if (Int64.TryParse(this.Value, out number)) {
        return number;
    } else {
        return scope.Find(this.Value);
    }
} else {
    SExpression first = this.Children[0];
    if (first.Value == "if") {
        SBool condition = (SBool)(this.Children[1].Evaluate(scope));
        return condition ? this.Children[2].Evaluate(scope) : this.Children[3].Evaluate(scope);
    } else if (first.Value == "def") {
        return scope.Define(this.Children[1].Value, this.Children[2].Evaluate(new SScope(scope)));
    } else if (first.Value == "begin") {
        SObject result = null;
        foreach (SExpression statement in this.Children.Skip(1)) {
            result = statement.Evaluate(scope);
        }
        return result;
    } else if (first.Value == "func") {
        SExpression body = this.Children[2];
        String[] parameters = this.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
        SScope newScope = new SScope(scope);
        return new SFunction(body, parameters, newScope);
    } else if (first.Value == "list") {
        return new SList(this.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
    } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
        var arguments = this.Children.Skip(1).ToArray();
        return SScope.BuiltinFunctions[first.Value](arguments, scope);
    } else {
        SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
        var arguments = this.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
        return function.Update(arguments).Evaluate();
    }
}
</code></pre>

<p>}
```</p>

<h4>去除尾递归</h4>

<p>到了这里iScheme解释器就算完成了。但仔细观察求值过程还是有一个很大的问题，尾递归调用：</p>

<ul>
<li>处理<code>if</code>的尾递归调用。</li>
<li>处理函数调用中的尾递归调用。</li>
</ul>


<p>Alex Stepanov曾在<a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">Elements of Programming</a>中介绍了一种将严格尾递归调用（Strict tail-recursive call）转化为迭代的方法，细节恕不赘述，以阶乘为例：</p>

<p>```c
// Recursive factorial.
int fact (int n) {</p>

<pre><code>if (n == 1)
    return result;
return n * fact(n - 1);
</code></pre>

<p>}
// First tranform to tail recursive version.
int fact (int n, int result) {</p>

<pre><code>if (n == 1)
    return result;
else {
    result *= n;
    n -= 1;
    return fact(n, result);// This is a strict tail-recursive call which can be omitted
}
</code></pre>

<p>}
// Then transform to iterative version.
int fact (int n, int result) {</p>

<pre><code>while (true) {
    if (n == 1)
        return result;
    else {
        result *= n;
        n -= 1;
    }
}
</code></pre>

<p>}
```</p>

<p>应用这种方法到<code>SExpression#Evaluate</code>，得到转换后的版本：</p>

<p>```csharp
public SObject Evaluate(SScope scope) {</p>

<pre><code>SExpression current = this;
while (true) {
    if (current.Children.Count == 0) {
        Int64 number;
        if (Int64.TryParse(current.Value, out number)) {
            return number;
        } else {
            return scope.Find(current.Value);
        }
    } else {
        SExpression first = current.Children[0];
        if (first.Value == "if") {
            SBool condition = (SBool)(current.Children[1].Evaluate(scope));
            current = condition ? current.Children[2] : current.Children[3];
        } else if (first.Value == "def") {
            return scope.Define(current.Children[1].Value, current.Children[2].Evaluate(new SScope(scope)));
        } else if (first.Value == "begin") {
            SObject result = null;
            foreach (SExpression statement in current.Children.Skip(1)) {
                result = statement.Evaluate(scope);
            }
            return result;
        } else if (first.Value == "func") {
            SExpression body = current.Children[2];
            String[] parameters = current.Children[1].Children.Select(exp =&gt; exp.Value).ToArray();
            SScope newScope = new SScope(scope);
            return new SFunction(body, parameters, newScope);
        } else if (first.Value == "list") {
            return new SList(current.Children.Skip(1).Select(exp =&gt; exp.Evaluate(scope)));
        } else if (SScope.BuiltinFunctions.ContainsKey(first.Value)) {
            var arguments = current.Children.Skip(1).ToArray();
            return SScope.BuiltinFunctions[first.Value](arguments, scope);
        } else {
            SFunction function = first.Value == "(" ? (SFunction)first.Evaluate(scope) : (SFunction)scope.Find(first.Value);
            var arguments = current.Children.Skip(1).Select(s =&gt; s.Evaluate(scope)).ToArray();
            SFunction newFunction = function.Update(arguments);
            if (newFunction.IsPartial) {
                return newFunction.Evaluate();
            } else {
                current = newFunction.Body;
                scope = newFunction.Scope;
            }
        }
    }
}
</code></pre>

<p>}
```</p>

<h4>一些演示</h4>

<p>基本的运算</p>

<p><img src="http://i.imgur.com/3417GE2.jpg" alt="基本的运算" /></p>

<p>高阶函数</p>

<p><img src="http://i.imgur.com/47a7jhf.jpg" alt="高阶函数" /></p>

<h2>回顾</h2>

<h3>小结</h3>

<p>除去注释（貌似没有注释-_-），iScheme的解释器的实现代码一共333行——包括空行，括号等元素。</p>

<p>在这300余行代码里，实现了函数式编程语言的大部分功能：算术|逻辑|运算，嵌套作用域，顺序语句，控制语句，递归，<a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>，<a href="http://zh.wikipedia.org/wiki/%E9%83%A8%E5%88%86%E6%B1%82%E5%80%BC">部分求值</a>。</p>

<p>与我两年之前实现的Scheme方言<a href="http://www.cnblogs.com/figure9/archive/2011/07/10/2102613.html">Lucida</a>相比，iScheme除了没有字符串类型，其它功能和Lucida相同，而代码量只是前者的八分之一，编写时间是前者的十分之一（Lucida用了两天，iScheme用了一个半小时），可扩展性和易读性均秒杀前者。这说明了：</p>

<ol>
<li>代码量不能说明问题。</li>
<li>不同开发者生产效率的差别会非常巨大。</li>
<li>这两年我还是学到了一点东西的。-_&ndash;</li>
</ol>


<h3>一些设计决策</h3>

<h4>使用扩展方法提高可读性</h4>

<p>例如，通过定义<code>OrThrows</code></p>

<p>```csharp
public static void OrThrows(this Boolean condition, String message = null) {</p>

<pre><code>if (!condition) { throw new Exception(message ?? "WTF"); }
</code></pre>

<p>}
```</p>

<p>写出流畅的断言：</p>

<p><code>csharp
(a &lt; 3).OrThrows("Value must be less than 3.");
</code></p>

<h4>声明式编程风格</h4>

<p>以<code>Main</code>函数为例：</p>

<p>```csharp
static void Main(String[] cmdArgs) {</p>

<pre><code>new SScope(parent: null)
    .BuildIn("+", (args, scope) =&gt; (args.Evaluate&lt;SNumber&gt;(scope).Sum(s =&gt; s)))
    // Other build
    .BuildIn("empty?", (args, scope) =&gt; args.RetrieveSList("empty?").Count() == 0)
    .KeepInterpretingInConsole((code, scope) =&gt; code.ParseAsIScheme().Evaluate(scope));
</code></pre>

<p>}
```</p>

<p>非常直观，而且</p>

<ul>
<li>如果需要添加新的操作，添加写一行<code>BuildIn</code>即可。</li>
<li>如果需要使用其它语法，替换解析函数<code>ParseAsIScheme</code>即可。</li>
<li>如果需要从文件读取代码，替换执行函数<code>KeepInterpretingInConsole</code>即可。</li>
</ul>


<h3>不足</h3>

<p>当然iScheme还是有很多不足：</p>

<p>语言特性方面：</p>

<ol>
<li>缺乏实用类型：没有<code>Double</code>和<code>String</code>这两个关键类型，更不用说复合类型（Compound Type）。</li>
<li>没有IO操作，更不要说网络通信。</li>
<li>效率低下：尽管去除尾递归挽回了一点效率，但iScheme的执行效率依然惨不忍睹。</li>
<li>错误信息：错误信息基本不可读，往往出错了都不知道从哪里找起。</li>
<li>不支持延续调用（Call with current continuation，即call/cc）。</li>
<li>没有并发。</li>
<li>各种bug：比如可以定义文本量，无法重载默认操作，空括号被识别等等。</li>
</ol>


<p>设计实现方面：</p>

<ol>
<li>使用了可变（Mutable）类型。</li>
<li>没有任何注释（因为觉得没有必要 &ndash;_-）。</li>
<li>糟糕的类型系统：Lisp类语言中的数据和程序可以不分彼此，而iScheme的实现中确把数据和程序分成了<code>SObject</code>和<code>SExpression</code>，现在我依然没有找到一个融合他们的好办法。</li>
</ol>


<p>这些就留到以后慢慢处理了 &ndash;_-（TODO YOUR ASS）</p>

<h2>延伸阅读</h2>

<h3>书籍</h3>

<ol>
<li>Compilers: Priciples, Techniques and Tools Principles: <a href="http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/">http://www.amazon.co.uk/Compilers-Principles-Techniques-V-Aho/dp/1292024348/</a></li>
<li>Language Implementation Patterns: <a href="http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/">http://www.amazon.co.uk/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/</a></li>
<li>*The Definitive ANTLR4 Reference: <a href="http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/">http://www.amazon.co.uk/Definitive-ANTLR-4-Reference/dp/1934356999/</a></li>
<li>Engineering a compiler: <a href="http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/">http://www.amazon.co.uk/Engineering-Compiler-Keith-Cooper/dp/012088478X/</a></li>
<li>Flex &amp; Bison: <a href="http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/">http://www.amazon.co.uk/flex-bison-John-Levine/dp/0596155972/</a></li>
<li>*Writing Compilers and Interpreters: <a href="http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/">http://www.amazon.co.uk/Writing-Compilers-Interpreters-Software-Engineering/dp/0470177071/</a></li>
<li>Elements of Programming: <a href="http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/">http://www.amazon.co.uk/Elements-Programming-Alexander-Stepanov/dp/032163537X/</a></li>
</ol>


<p>注：带*号的没有中译本。</p>

<h3>文章</h3>

<p>大多和编译前端相关，自己没时间也没能力研究后端。-_&ndash;</p>

<p>为什么编译技术很重要？看看Steve Yegge（没错，就是被王垠黑过的Google高级技术工程师）是怎么说的（需要翻墙）。</p>

<p><a href="http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html">http://steve-yegge.blogspot.co.uk/2007/06/rich-programmer-food.html</a></p>

<p>本文重点参考的Peter Norvig的两篇文章：</p>

<ol>
<li>How to write a lisp interpreter in Python: <a href="http://norvig.com/lispy.html">http://norvig.com/lispy.html</a></li>
<li>An even better lisp interpreter in Python: <a href="http://norvig.com/lispy2.html">http://norvig.com/lispy2.html</a></li>
</ol>


<p>几种简单实用的语法分析技术：</p>

<ol>
<li>LL(k) Parsing：

<ul>
<li><a href="http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/">http://eli.thegreenplace.net/2008/09/26/recursive-descent-ll-and-predictive-parsers/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/">http://eli.thegreenplace.net/2009/03/20/a-recursive-descent-parser-with-an-infix-expression-evaluator/</a></li>
<li><a href="http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/">http://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers/</a></li>
</ul>
</li>
<li>Top Down Operator Precendence：<a href="http://javascript.crockford.com/tdop/tdop.html">http://javascript.crockford.com/tdop/tdop.html</a></li>
<li>Precendence Climbing Parsing：<a href="http://en.wikipedia.org/wiki/Operator-precedence_parser">http://en.wikipedia.org/wiki/Operator-precedence_parser</a></li>
</ol>


<h2>关于本文作者</h2>

<p>曾经的Windows/.Net/C#程序员，研究生毕业后糊里糊涂变成Linux/Java开发者。所谓一入Java深似海，现在无比怀念使用C#的岁月。</p>

<p>对解释器/编译器感兴趣，现在正在自学Coursera的<a href="https://class.coursera.org/compilers-004">Compiler课程</a>。</p>

<p>欢迎来信交流技术：lunageek#gmail#com</p>
]]></content>
  </entry>
  
</feed>
