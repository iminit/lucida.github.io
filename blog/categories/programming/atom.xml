<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-12-12T22:43:09-08:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features/"/>
    <updated>2014-12-12T22:23:36-08:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<p>本文是深入理解Java 8 Lambda系列的第二篇，主要介绍Java 8针对新增语言特性而新增的类库（例如Streams API、Collectors和并行）。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of the Lambda: Libraries Edition</a>一文的翻译。</p>

<h2><a name="about">关于</a></h2>

<p>Java SE 8增加了新的语言特性（例如lambda表达式和默认方法），为此Java SE 8的类库也进行了很多改进，本文简要介绍了这些改进。在阅读本文前，你应该先阅读<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/">深入浅出Java 8 Lambda（语言篇）</a>，以便对Java SE 8的新增特性有一个全面了解。</p>

<h2><a name="background">背景（Background）</a></h2>

<p>自从lambda表达式成为Java语言的一部分之后，Java集合（Collections）API就面临着大幅变化。而<a href="https://jcp.org/en/jsr/detail?id=355">JSR 355</a>（规定了Java lambda表达式的标准）的正式启用更是使得Java集合API变的过时不堪。尽管我们可以从头实现一个新的集合框架（比如“Collection II”），但取代现有的集合框架是一项非常艰难的工作，因为集合接口渗透了Java生态系统的每个角落，将它们一一换成新类库需要相当长的时间。因此，我们决定采取演化的策略（而非推倒重来）以改进集合API：</p>

<!-- more -->


<ul>
<li>为现有的接口（例如<code>Collection</code>，<code>List</code>和<code>Stream</code>）增加扩展方法；</li>
<li>在类库中增加新的<em>流</em>（stream，即<code>java.util.stream.Stream</code>）抽象以便进行聚集（aggregation）操作；</li>
<li>改造现有的类型使之可以提供流视图（stream view）；</li>
<li>改造现有的类型使之可以容易的使用新的编程模式，这样用户就不必抛弃使用以久的类库，例如<code>ArrayList</code>和<code>HashMap</code>（当然这并不是说集合API会常驻永存，毕竟集合API在设计之初并没有考虑到lambda表达式。我们可能会在未来的JDK中添加一个更现代的集合类库）。</li>
</ul>


<p>除了上面的改进，还有一项重要工作就是提供更加易用的并行（Parallelism）库。尽管Java平台已经对并行和并发提供了强有力的支持，然而开发者在实际工作（将串行代码并行化）中仍然会碰到很多问题。因此，我们希望Java类库能够既便于编写串行代码也便于编写并行代码，因此我们把编程的重点从具体执行细节（how computation should be formed）转移到抽象执行步骤（what computation should be perfomed）。除此之外，我们还需要在将并行变的<em>容易</em>（easier）和将并行变的<em>不可见</em>（invisible）之间做出抉择，我们选择了一个折中的路线：提供<em>显式</em>（explicit）但<em>非侵入</em>（unobstrusive）的并行。（如果把并行变的透明，那么很可能会引入不确定性（nondeterminism）以及各种数据竞争（data race）问题）</p>

<h2><a name="interal_vs_external_iteration">内部迭代和外部迭代（Internal  vs external iteration）</a></h2>

<p>集合类库主要依赖于<em>外部迭代</em>（external iteration）。<code>Collection</code>实现<code>Iterable</code>接口，从而使得用户可以依次遍历集合的元素。比如我们需要把一个集合中的形状都设置成红色，那么可以这么写：</p>

<p><code>java
for (Shape shape : shapes) {
  shape.setColor(RED);
}
</code></p>

<p>这个例子演示了外部迭代：for-each循环调用<code>shapes</code>的<code>iterator()</code>方法进行依次遍历。外部循环的代码非常直接，但它有如下问题：</p>

<ul>
<li>Java的for循环是串行的，而且必须按照集合中元素的顺序进行依次处理；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路（short-circuiting）求值以及惰性求值改善性能。</li>
</ul>


<p>尽管有时for-each循环的这些特性（串行，依次）是我们所期待的，但它对改善性能造成了阻碍。</p>

<p>我们可以使用<em>内部迭代</em>（internal iteration）替代外部迭代，用户把对迭代的控制权交给类库，并向类库传递迭代时所需执行的代码。</p>

<p>下面是前例的内部迭代代码：</p>

<p><code>java
shapes.forEach(s -&gt; s.setColor(RED));
</code></p>

<p>尽管看起来只是一个小小的语法改动，但是它们的实际差别非常巨大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>

<p>外部迭代同时承担了<em>做什么</em>（把形状设为红色）和<em>怎么做</em>（得到<code>Iterator</code>实例然后依次遍历）两项职责，而内部迭代只负责<em>做什么</em>，而把<em>怎么做</em>留给类库。通过这样的职责转变：用户的代码会变得更加清晰，而类库则可以进行各种优化，从而使所有用户都从中受益。</p>

<h2><a name="stream">流（Stream）</a></h2>

<p><em>流</em>是Java SE 8类库中新增的关键抽象，它被定义于<code>java.util.stream</code>（这个包里有若干流类型：<code>Stream&lt;T&gt;</code>代表对象引用流，此外还有一系列特化（specialization）流，比如<code>IntStream</code>代表整形数字流）。每个流代表一个值序列，流提供一系列常用的聚集操作，使得我们可以便捷的在它上面进行各种运算。集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构。</p>

<p>流的操作可以被组合成<em>流水线</em>（Pipeline）。以前面的例子为例，如果我们只想把蓝色改成红色：</p>

<p>```java
shapes.stream()</p>

<pre><code>  .filter(s -&gt; s.getColor() == BLUE)
  .forEach(s -&gt; s.setColor(RED));
</code></pre>

<p>```</p>

<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流视图（stream view），接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>

<p>如果我们想把蓝色的形状提取到新的<code>List</code>里，则可以：</p>

<p>```java
List<Shape> blue = shapes.stream()</p>

<pre><code>                     .filter(s -&gt; s.getColor() == BLUE)
                     .collect(Collectors.toList());
</code></pre>

<p>```</p>

<p><code>collect()</code>操作会把其接收的元素聚集（aggregate）到一起（这里是<code>List</code>），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到<code>List</code>中。（如需更多<code>collect()</code>方法的细节，请阅读<a href="#collectors">Collectors</a>一节）</p>

<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>

<p>```java
Set<Box> hasBlueShape = shapes.stream()</p>

<pre><code>                          .filter(s -&gt; s.getColor() == BLUE)
                          .map(s -&gt; s.getContainingBox())
                          .collect(Collectors.toSet());
</code></pre>

<p>```</p>

<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>

<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>

<p>```java
int sum = shapes.stream()</p>

<pre><code>            .filter(s -&gt; s.getColor() == BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>这些例子演示了流框架的设计，以及如何使用流框架解决实际问题。</p>

<h2><a name="stream_vs_collection">流和集合（Streams vs Collections）</a></h2>

<p>集合和流尽管在表面上看起来很相似，但它们的设计目标是不同的：集合主要用来对其元素进行有效（effective）的管理和访问（access），而流并不支持对其元素进行直接操作或直接访问，而只支持通过声明式操作在其上进行运算然后得到结果。除此之外，流和集合还有一些其它不同：</p>

<ul>
<li>无存储：流并不存储值；流的元素源自数据源（可能是某个数据结构、生成函数或I/O通道等等），通过一系列计算步骤得到；</li>
<li>天然的函数式风格（Functional in nature）：对流的操作会产生一个结果，但流的数据源不会被修改；</li>
<li>惰性求值：多数流操作（包括过滤、映射、排序以及去重）都可以以惰性方式实现。这使得我们可以用一遍遍历完成整个流水线操作，并可以用短路操作提供更高效的实现；</li>
<li>无需上界（Bounds optional）：不少问题都可以被表达为无限流（infinite stream）：用户不停地读取流直到满意的结果出现为止（比如说，枚举<a href="http://en.wikipedia.org/wiki/Perfect_number">完美数</a>这个操作可以被表达为在所有整数上进行过滤）。集合是有限的，但流不是（操作无限流时我们必需使用短路操作，以确保操作可以在有限时间内完成）；</li>
</ul>


<p>从API的角度来看，流和集合完全互相独立，不过我们可以既把集合作为流的数据源（<code>Collection</code>拥有<code>stream()</code>和<code>parallelStream()</code>方法），也可以通过流产生一个集合（使用前例的<code>collect()</code>方法）。<code>Collection</code>以外的类型也可以作为<code>stream</code>的数据源，比如JDK中的<code>BufferedReader</code>、<code>Random</code>和<code>BitSet</code>已经被改造可以用做流的数据源，<code>Arrays.stream()</code>则产生给定数组的流视图。事实上，任何可以用<code>Iterator</code>描述的对象都可以成为流的数据源，如果有额外的信息（比如大小、是否有序等特性），库还可以进行进一步的优化。</p>

<h3><a name="laziness">惰性（Laziness）</a></h3>

<p>过滤和映射这样的操作既可以被<em>急性求值</em>（以<code>filter</code>为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被<em>惰性求值</em>（用<code>Stream</code>代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</p>

<p>对于过滤和映射这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像<code>sum()</code>这样生成值的操作和<code>forEach()</code>这样产生副作用的操作都是“天然急性求值”，因为它们必须要产生具体的结果。</p>

<p>以下面的流水线为例：</p>

<p>```java
int sum = shapes.stream()</p>

<pre><code>            .filter(s -&gt; s.getColor() == BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>这里的过滤操作和映射操作是惰性的，这意味着在调用<code>sum()</code>之前，我们不会从数据源提取任何元素。在<code>sum</code>操作开始之后，我们把过滤、映射以及求和混合在对数据源的一遍遍历之中。这样可以大大减少维持中间结果所带来的开销。</p>

<p>大多数循环都可以用数据源（数组、集合、生成函数以及I/O管道）上的聚合操作来表示：进行一系列惰性操作（过滤和映射等操作），然后用一个急性求值操作（<code>forEach</code>，<code>toArray</code>和<code>collect</code>等操作）得到最终结果——例如过滤—映射—累积，过滤—映射—排序—遍历等组合操作。惰性操作一般被用来计算中间结果，这在Streams API设计中得到了很好的体现——与其让<code>filter</code>和<code>map</code>返回一个集合，我们选择让它们返回一个新的流。在Streams API中，返回流对象的操作都是惰性操作，而返回非流对象的操作（或者无返回值的操作，例如<code>forEach()</code>）都是急性操作。绝大多数情况下，潜在的惰性操作会被用于聚合，这正是我们想要的——流水线中的每一轮操作都会接收输入流中的元素，进行转换，然后把转换结果传给下一轮操作。</p>

<p>在使用这种<em>数据源—惰性操作—惰性操作—急性操作</em>流水线时，流水线中的惰性几乎是不可见的，因为计算过程被夹在数据源和最终结果（或副作用操作）之间。这使得API的可用性和性能得到了改善。</p>

<p>对于<code>anyMatch(Predicate)</code>和<code>findFirst()</code>这些急性求值操作，我们可以使用短路（short-circuiting）来终止不必要的运算。以下面的流水线为例：</p>

<p>```java
Optional<Shape> firstBlue = shapes.stream()</p>

<pre><code>                              .filter(s -&gt; s.getColor() == BLUE)
                              .findFirst();
</code></pre>

<p>```</p>

<p>由于过滤这一步是惰性的，<code>findFirst</code>在从其上游得到一个元素之后就会终止，这意味着我们只会处理这个元素及其之前的元素，而不是所有元素。<code>findFirst()</code>方法返回<code>Optional</code>对象，因为集合中有可能不存在满足条件的元素。<code>Optional</code>是一种用于描述可缺失值的类型。</p>

<p>在这种设计下，用户并不需要显式进行惰性求值，甚至他们都不需要了解惰性求值。类库自己会选择最优化的计算方式。</p>

<h3><a name="parallelism">并行（Parallelism）</a></h3>

<p>流水线既可以串行执行也可以并行执行，并行或串行是流的属性。除非你显式要求使用并行流，否则JDK总会返回串行流。（串行流可以通过<code>parallel()</code>方法被转化为并行流）</p>

<p>尽管并行是显式的，但它并不需要成为侵入式的。利用<code>parallelStream()</code>，我们可以轻松的把之前重量求和的代码并行化：</p>

<p>```java
int sum = shapes.parallelStream()</p>

<pre><code>            .filter(s -&gt; s.getColor = BLUE)
            .mapToInt(s -&gt; s.getWeight())
            .sum();
</code></pre>

<p>```</p>

<p>并行化之后和之前的代码区别并不大，然而我们可以很容易看出它是并行的（此外我们并不需要自己去实现并行代码）。</p>

<p>因为流的数据源可能是一个可变集合，如果在遍历流时数据源被修改，就会产生干扰（interference）。所以在进行流操作时，流的数据源应保持不变（held constant）。这个条件并不难维持，如果集合只属于当前线程，只要lambda表达式不修改流的数据源就可以。（这个条件和遍历集合时所需的条件相似，如果集合在遍历时被修改，绝大多数的集合实现都会抛出<code>ConcurrentModificationException</code>）我们把这个条件称为无干扰性（non-interference）。</p>

<p>我们应避免在传递给流方法的lambda产生副作用。一般来说，打印调试语句这种输出变量的操作是安全的，然而在lambda表达式里访问可变变量就有可能造成数据竞争或是其它意想不到的问题，因为lambda在执行时可能会同时运行在多个线程上，因而它们所看到的元素有可能和正常的顺序不一致。无干扰性有两层含义：</p>

<ol>
<li>不要干扰数据源；</li>
<li>不要干扰其它lambda表达式，当一个lambda在修改某个可变状态而另一个lambda在读取该状态时就会产生这种干扰。</li>
</ol>


<p>只要满足无干扰性，我们就可以安全的进行并行操作并得到可预测的结果，即便对线程不安全的集合（例如<code>ArrayList</code>）也是一样。</p>

<h2><a name="examples">实例（Examples）</a></h2>

<p>下面的代码源自JDK中的<code>Class</code>类型（<code>getEnclosingMethod</code>方法），这段代码会遍历所有声明的方法，然后根据方法名称、返回类型以及参数的数量和类型进行匹配：</p>

<p>```java
for (Method method : enclosingInfo.getEnclosingClass().getDeclaredMethods()) {
  if (method.getName().equals(enclosingInfo.getName())) {</p>

<pre><code>Class&lt; ? &gt;[] candidateParamClasses = method.getParameterTypes();
if (candidateParamClasses.length == parameterClasses.length) {
  boolean matches = true;
  for (int i = 0; i &lt; candidateParamClasses.length; i += 1) {
    if (!candidateParamClasses[i].equals(parameterClasses[i])) {
      matches = false;
      break;
    }
  }

  if (matches) { // finally, check return type
    if (method.getReturnType().equals(returnType)) {
      return method;
    }
  }
}
</code></pre>

<p>  }
}
throw new InternalError(&ldquo;Enclosing method not found&rdquo;);
```</p>

<p>通过使用流，我们不但可以消除上面代码里面所有的临时变量，还可以把控制逻辑交给类库处理。通过反射得到方法列表之后，我们利用<code>Arrays.stream</code>将它转化为<code>Stream</code>，然后利用一系列过滤器去除类型不符、参数不符以及返回值不符的方法，然后通过调用<code>findFirst</code>得到<code>Optional&lt;Method&gt;</code>，最后利用<code>orElseThrow</code>返回目标值或者抛出异常。</p>

<p>```java
return Arrays.stream(enclosingInfo.getEnclosingClass().getDeclaredMethods())</p>

<pre><code>         .filter(m -&gt; Objects.equal(m.getName(), enclosingInfo.getName()))
         .filter(m -&gt; Arrays.equal(m.getParameterTypes(), parameterClasses))
         .filter(m -&gt; Objects.equals(m.getReturnType(), returnType))
         .findFirst()
         .orElseThrow(() -&gt; new InternalError("Enclosing method not found"));
</code></pre>

<p>```</p>

<p>相对于未使用流的代码，这段代码更加紧凑，可读性更好，也不容易出错。</p>

<p>流操作特别适合对集合进行查询操作。假设有一个“音乐库”应用，这个应用里每个库都有一个专辑列表，每张专辑都有其名称和音轨列表，每首音轨表都有名称、艺术家和评分。</p>

<p>假设我们需要得到一个按名字排序的专辑列表，专辑列表里面的每张专辑都至少包含一首四星及四星以上的音轨，为了构建这个专辑列表，我们可以这么写：</p>

<p>```java
List<Album> favs = new ArrayList&lt;>();
for (Album album : albums) {
  boolean hasFavorite = false;
  for (Track track : album.tracks) {</p>

<pre><code>if (track.rating &gt;= 4) {
  hasFavorite = true;
  break;
}
</code></pre>

<p>  }
  if (hasFavorite)</p>

<pre><code>favs.add(album);
</code></pre>

<p>}
Collections.sort(favs, new Comparator<Album>() {
  public int compare(Album a1, Album a2) {</p>

<pre><code>return a1.name.compareTo(a2.name);
</code></pre>

<p>  }
});
```</p>

<p>我们可以用流操作来完成上面代码中的三个主要步骤——识别一张专辑是否包含一首评分大于等于四星的音轨（使用<code>anyMatch</code>）；按名字排序；以及把满足条件的专辑放在一个<code>List</code>中：</p>

<p>```java
List<Album> sortedFavs =</p>

<pre><code>albums.stream()
      .filter(a -&gt; a.tracks.anyMatch(t -&gt; (t.rating &gt;= 4)))
      .sorted(Comparator.comparing(a -&gt; a.name))
      .collect(Collectors.toList());
</code></pre>

<p>```</p>

<p><code>Compartor.comparing</code>方法接收一个函数（该函数返回一个实现了<code>Comparable</code>接口的排序键值），然后返回一个利用该键值进行排序的<code>Comparator</code>（请参考下面的<a href="#comparator_factories">比较器工厂</a>一节）。</p>

<h3><a name="collectors">收集器（Collectors）</a></h3>

<p>在之前的例子中，我们利用<code>collect()</code>方法把流中的元素聚合到<code>List</code>或<code>Set</code>中。<code>collect()</code>接收一个类型为<code>Collector</code>的参数，这个参数决定了如何把流中的元素聚合到其它数据结构中。<code>Collectors</code>类包含了大量常用收集器的工厂方法，<code>toList()</code>和<code>toSet()</code>就是其中最常见的两个，除了它们还有很多收集器，用来对数据进行对复杂的转换。</p>

<p><code>Collector</code>的类型由其输入类型和输出类型决定。以<code>toList()</code>收集器为例，它的输入类型为<code>T</code>，输出类型为<code>List&lt;T&gt;</code>，<code>toMap</code>是另外一个较为复杂的<code>Collector</code>，它有若干个版本。最简单的版本接收一对函数作为输入，其中一个函数用来生成键（key），另一个函数用来生成值（value）。<code>toMap</code>的输入类型是<code>T</code>，输出类型是<code>Map&lt;K, V&gt;</code>，其中<code>K</code>和<code>V</code>分别是前面两个函数所生成的键类型和值类型。（复杂版本的<code>toMap</code>收集器则允许你指定目标<code>Map</code>的类型或解决键冲突）。举例来说，下面的代码以目录数字为键值创建一个倒排索引：</p>

<p>```java
Map&lt;Integer, Album> albumsByCatalogNumber =</p>

<pre><code>albums.stream()
      .collect(Collectors.toMap(a -&gt; a.getCatalogNumber(), a -&gt; a));
</code></pre>

<p>```</p>

<p><code>groupingBy</code>是一个与<code>toMap</code>相类似的收集器，比如说我们想要把我们最喜欢的音乐按歌手列出来，这时我们就需要这样的<code>Collector</code>：它以<code>Track</code>作为输入，以<code>Map&lt;Artist, List&lt;Track&gt;&gt;</code>作为输出。<code>groupingBy</code>收集器就可以胜任这个工作，它接收分类函数（classification function），然后根据这个函数生成<code>Map</code>，该<code>Map</code>的键是分类函数的返回结果，值是该分类下的元素列表。</p>

<p>```java
Map&lt;Artist, List<Track>> favsByArtist =</p>

<pre><code>tracks.stream()
      .filter(t -&gt; t.rating &gt;= 4)
      .collect(Collectors.groupingBy(t -&gt; t.artist));
</code></pre>

<p>```</p>

<p>收集器可以通过组合和复用来生成更加复杂的收集器，简单版本的<code>groupingBy</code>收集器把元素按照分类函数为每个元素计算出分类键值，然后把输入元素输出到对应的分类列表中。除了这个版本，还有一个更加通用（general）的版本允许你使用<em>其它</em>收集器来整理输入元素：它接收一个分类函数以及一个下流（downstream）收集器（单参数版本的<code>groupingBy</code>使用<code>toList()</code>作为其默认下流收集器）。举例来说，如果我们想把每首歌曲的演唱者收集到<code>Set</code>而非<code>List</code>中，我们可以使用<code>toSet</code>收集器：</p>

<p>```java
Map&lt;Artist, Set<Track>> favsByArtist =</p>

<pre><code>tracks.stream()
      .filter(t -&gt; t.rating &gt;= 4)
      .collect(Collectors.groupingBy(t -&gt; t.artist,
                                     Collectors.toSet()));
</code></pre>

<p>```</p>

<p>如果我们需要按照歌手和评分来管理歌曲，我们可以生成多级<code>Map</code>：</p>

<p>```java
Map&lt;Artist, Map&lt;Integer, List<Track>>> byArtistAndRating =</p>

<pre><code>tracks.stream()
      .collect(groupingBy(t -&gt; t.artist,
                          groupingBy(t -&gt; t.rating)));
</code></pre>

<p>```</p>

<p>在最后的例子里，我们创建了一个歌曲标题里面的词频分布。我们首先使用<code>Stream.flatMap()</code>得到一个歌曲流，然后用<code>Pattern.splitAsStream</code>把每首歌曲的标题打散成词流；接下来我们用<code>groupingBy</code>和<code>String.toUpperCase</code>对这些词进行不区分大小写的分组，最后使用<code>counting()</code>收集器计算每个词出现的次数（从而无需创建中间集合）。</p>

<p>```java
Pattern pattern = Pattern.compile(&ldquo;\s+&rdquo;);
Map&lt;String, Integer> wordFreq =</p>

<pre><code>tracks.stream()
      .flatMap(t -&gt; pattern.splitAsStream(t.name)) // Stream&lt;String&gt;
      .collect(groupingBy(s -&gt; s.toUpperCase(),
                          counting()));
</code></pre>

<p>```</p>

<p><code>flatMap</code>接收一个返回流（这里是歌曲标题里的词）的函数。它利用这个函数将输入流中的每个元素转换为对应的流，然后把这些流拼接到一个流中。所以上面代码中的<code>flatMap</code>会返回所有歌曲标题里面的词，接下来我们不区分大小写的把这些词分组，并把词频作为值（value）储存。</p>

<p><code>Collectors</code>类包含大量的方法，这些方法被用来创造各式各样的收集器，以便进行查询、列表（tabulation）和分组等工作，当然你也可以实现一个自定义<code>Collector</code>。</p>

<h2><a name="parallelism_under_the_hood">并行的实质（Parallelism under the hood）</a></h2>

<p>Java SE 7引入了<a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">Fork/Join</a>模型，以便高效实现并行计算。不过，通过Fork/Join编写的并行代码和同功能的串行代码的差别非常巨大，这使改写串行代码变的非常困难。通过提供串行流和并行流，用户可以在串行操作和并行操作之间进行便捷的切换（无需重写代码），从而使得编写正确的并行代码变的更加容易。</p>

<p>为了实现并行计算，我们一般要把计算过程递归分解（recursive decompose）为若干步：</p>

<ul>
<li>把问题分解为子问题；</li>
<li>串行解决子问题从而得到部分结果（partial result）；</li>
<li>合并部分结果合为最终结果。</li>
</ul>


<p>这也是Fork/Join的实现原理。</p>

<p>为了能够并行化任意流上的所有操作，我们把流抽象为<code>Spliterator</code>，<code>Spliterator</code>是对传统迭代器概念的一个泛化。分割迭代器（spliterator）既支持顺序依次访问数据，也支持分解数据：就像<code>Iterator</code>允许你跳过一个元素然后保留剩下的元素，<code>Spliterator</code>允许你把输入元素的一部分（一般来说是一半）转移（carve off）到另一个新的<code>Spliterator</code>中，而剩下的数据则会被保存在原来的<code>Spliterator</code>里。（这两个分割迭代器还可以被进一步分解）除此之外，分割迭代器还可以提供源的元数据（比如元素的数量，如果已知的话）和其它一系列布尔值特征（比如说“元素是否被排序”这样的特征），Streams框架可以利用这些数据来进行优化。</p>

<p>上面的分解方法也同样适用于其它数据结构，数据结构的作者只需要提供分解逻辑，然后就可以直接享用并行流操作带来的遍历。</p>

<p>大多数用户无需去实现<code>Spliterator</code>接口，因为集合上的<code>stream()</code>方法往往就足够了。但如果你需要实现一个集合或一个流，那么你可能需要手动实现<code>Spliterator</code>接口。<code>Spliterator</code>接口的API如下所示：</p>

<p>```java
public interface Spliterator<T> {
  // Element access
  boolean tryAdvance(Consumer&lt; ? super T> action);
  void forEachRemaining(Consumer&lt; ? super T> action);</p>

<p>  // Decomposition
  Spliterator<T> trySplit();</p>

<p>  //Optional metadata
  long estimateSize();
  int characteristics();
  Comparator&lt; ? super T> getComparator();
}
```</p>

<p>集合库中的基础接口<code>Collection</code>和<code>Iterable</code>都实现了正确但相对低效的<code>spliterator()</code>实现，但派生接口（例如<code>Set</code>）和具体实现类（例如<code>ArrayList</code>）均提供了高效的分割迭代器实现。分割迭代器的实现质量会影响到流操作的执行效率；如果在<code>split()</code>方法中进行良好（平衡）的划分，CPU的利用率会得到改善；此外，提供正确的特性（characteristics）和大小（size）这些元数据有利于进一步优化。</p>

<h3><a name="encounter_order">出现顺序（Encounter order）</a></h3>

<p>多数数据结构（例如列表，数组和I/O通道）都拥有<em>自然出现顺序</em>（natural encounter order），这意味着它们的元素出现顺序是可预测的。其它的数据结构（例如<code>HashSet</code>）则没有一个明确定义的出现顺序（这也是<code>HashSet</code>的<code>Iterator</code>实现中不保证元素出现顺序的原因）。</p>

<p>是否具有明确定义的出现顺序是<code>Spliterator</code>检查的特性之一（这个特性也被流使用）。除了少数例外（比如<code>Stream.forEach()</code>和<code>Stream.findAny()</code>），并行操作一般都会受到出现顺序的限制。这意味着下面的流水线：</p>

<p>```java
List<String> names = people.parallelStream()</p>

<pre><code>                       .map(Person::getName)
                       .collect(toList());
</code></pre>

<p>```</p>

<p>代码中名字出现的顺序必须要和流中的<code>Person</code>出现的顺序一致。一般来说，这是我们所期待的结果，而且它对多大多数的流实现都不会造成明显的性能损耗。从另外的角度来说，如果源数据是<code>HashSet</code>，那么上面代码中名字就可以以任意顺序出现。</p>

<h2><a name="streams_lambdas_in_jdk">JDK中的流和lambda（Streams and lambdas in JDK）</a></h2>

<p><code>Stream</code>在Java SE 8中非常重要，我们希望可以在JDK中尽可能广的使用<code>Stream</code>。我们为<code>Collection</code>提供了<code>stream()</code>和<code>parallelStream()</code>，以便把集合转化为流；此外数组可以通过<code>Arrays.stream()</code>被转化为流。</p>

<p>除此之外，<code>Stream</code>中还有一些静态工厂方法（以及相关的原始类型流实现），这些方法被用来创建流，例如<code>Stream.of()</code>，<code>Stream.generate</code>以及<code>IntStream.range</code>。其它的常用类型也提供了流相关的方法，例如<code>String.chars</code>，<code>BufferedReader.lines</code>，<code>Pattern.splitAsStream</code>，<code>Random.ints</code>和<code>BitSet.stream</code>。</p>

<p>最后，我们提供了一系列API用于构建流，类库的编写者可以利用这些API来在流上实现其它聚集操作。实现<code>Stream</code>至少需要一个<code>Iterator</code>，不过如果编写者还拥有其它元数据（例如数据大小），类库就可以通过<code>Spliterator</code>提供一个更加高效的实现（就像JDK中所有的集合一样）。</p>

<h3><a name="comparator_factories">比较器工厂（Comparator factories）</a></h3>

<p>我们在<code>Comparator</code>接口中新增了若干用于生成比较器的实用方法：</p>

<p>静态方法<code>Comparator.comparing()</code>接收一个函数（该函数返回一个实现<code>Comparable</code>接口的比较键值），返回一个<code>Comparator</code>，它的实现十分简洁：</p>

<p>```java
public static &lt;T, U extends Comparable&lt; ? super U>> Compartor<T> comparing(</p>

<pre><code>Function&lt; ? super T, ? extends U&gt; keyExtractor) {
</code></pre>

<p>  return (c1, c2) &ndash;> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
}
```</p>

<p>我们把这种方法称为<em>高阶函数</em>——以函数作为参数或是返回值的函数。我们可以使用高阶函数简化代码：</p>

<p><code>java
List&lt;Person&gt; people = ...
people.sort(comparing(p -&gt; p.getLastName()));
</code></p>

<p>这段代码比“过去的代码”（一般要定义一个实现<code>Comparator</code>接口的匿名类）要简洁很多。但是它真正的威力在于它大大改进了可组合性（composability）。举例来说，<code>Comparator</code>拥有一个用于逆序的默认方法。于是，如果想把列表按照姓进行反序排序，我们只需要创建一个和之前一样的比较器，然后调用反序方法即可：</p>

<p><code>java
people.sort(comparing(p -&gt; p.getLastName()).reversed());
</code></p>

<p>与之类似，默认方法<code>thenComparing</code>允许你去改进一个已有的<code>Comparator</code>：在原比较器返回相等的结果时进行进一步比较。下面的代码演示了如何按照姓和名进行排序：</p>

<p>```java
Comparator<Person> c = Comparator.comparing(p &ndash;> p.getLastName())</p>

<pre><code>                             .thenComparing(p -&gt; p.getFirstName());
</code></pre>

<p>people.sort&copy;;
```</p>

<h3><a name="mutative_collection_operation">可变的集合操作（Mutative  collection operation）</a></h3>

<p>集合上的流操作一般会生成一个新的值或集合。不过有时我们希望就地修改集合，所以我们为集合（例如<code>Collection</code>，<code>List</code>和<code>Map</code>）提供了一些新的方法，比如<code>Iterable.forEach(Consumer)</code>，<code>Collection.removeAll(Predicate)</code>，<code>List.replaceAll(UnaryOperator)</code>，<code>List.sort(Comparator)</code>和<code>Map.computeIfAbsent()</code>。除此之外，<code>ConcurrentMap</code>中的一些非原子方法（例如<code>replace</code>和<code>putIfAbsent</code>）被提升到<code>Map</code>之中。</p>

<h2><a name="summary">小结（Summary）</a></h2>

<p>引入lambda表达式是Java语言的巨大进步，但这还不够——开发者每天都要使用核心类库，为了开发者能够尽可能方便的使用语言的新特性，语言的演化和类库的演化是不可分割的。<code>Stream</code>抽象作为新增类库特性的核心，提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。</p>

<p>未完待续——</p>

<p>下篇：深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从2000毫秒到10毫秒——Lucida拼音库的设计与实现]]></title>
    <link href="http://zh.lucida.me/blog/lucida-pinyin-converter/"/>
    <updated>2014-12-07T00:27:17-08:00</updated>
    <id>http://zh.lucida.me/blog/lucida-pinyin-converter</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lucida-pinyin-converter">从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>本文介绍了Lucida拼音库的设计、实现以及优化过程。Lucida拼音库以微软拼音库为基础，能够快速的把汉字转化为对应的拼音，它比微软拼音库快200多倍，同时占用内存不到微软拼音库的八分之一。</p>

<h2>背景</h2>

<p>Lucida拼音库是我三年前编写<a href="http://www.windowsphone.com/zh-cn/store/app/%E4%B8%AD%E6%96%87%E6%8B%A8%E5%8F%B7%E5%8A%A9%E6%89%8B/3e4f73b2-c70e-40dd-b3b8-1d2135e9af56">拨号助手</a>时自行设计并实现的一个工具类（Utility Class）。它可以把中文转化成汉语拼音，并可以在Windows Phone 7上使用。</p>

<p>我曾经在<a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>里面提到过我为什么需要这个工具类（用户期望根据拼音给出智能提示），以及为什么需要自己动手编写，而不是使用现成的代码（<a href="http://www.microsoft.com/zh-cn/download/details.aspx?id=15251">微软拼音库</a>）。有兴趣的同学可以阅读<a href="http://zh.lucida.me/blog/on-learning-algorithms/">那篇文章</a>了解背景。</p>

<p>我个人习惯使用自上而下（Top-Down）的方式设计类，Lucida拼音库也不例外：</p>

<ol>
<li>API设计；</li>
<li>具体实现；</li>
<li>测试；</li>
<li>度量->优化->度量->优化&hellip;</li>
</ol>


<p>接下来我将按照这个步骤一一介绍Lucida拼音库从设计到实现的过程。</p>

<!-- more -->


<h2>API设计（API Design）</h2>

<p>API设计<a href="http://www.newt.com/java/GoodApiDesign-JoshBloch.pdf">至关重要</a>——结合<a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Framework Design Guidelines</a>和<a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Joshua Bloch</a>关于如何设计API的<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">演讲</a>，我在设计API时会遵循以下步骤：</p>

<ol>
<li>确认功能需求；</li>
<li>确认至少三个不同的使用场景；</li>
<li>确认API。</li>
</ol>


<h3>功能需求</h3>

<p>Lucida拼音库将汉字转化为拼音——但为了编码，我们需要更加细化的需求：</p>

<ol>
<li>能够得到给定汉字的拼音；（<code>'中' -&gt; "ZHONG"</code>）</li>
<li>能够得到给定多音汉字的所有拼音；（<code>'曾' -&gt; ["CENG", "ZENG"]</code>）</li>
<li>能够判断一个给定字符是否是汉字；（<code>'中' -&gt; true; 'A' -&gt; false</code>）</li>
<li><strong>只</strong>需要拼音，<strong>不</strong>需要音调。</li>
</ol>


<h3>使用场景</h3>

<p>结合实际需求，我写下了如下使用场景：</p>

<p><code>csharp 得到汉字的拼音
String[] pinyins = '曾'.GetPinyins();
// pinyins == ["CENG", "ZENG"]
</code></p>

<p><code>csharp 得到中文词汇的拼音
String value = "中华人民";
String[] pinyinOfValue = value.Select(c =&gt; c.GetPinyins()[0]).ToArray();
// pinyinOfValue == ["ZHONG", "HUA", "REN", "MIN"]
</code></p>

<p>```csharp 得到得到混合词汇的首字母缩写
String mixed = &ldquo;IBM中国有限公司&rdquo;;
String initialOfMixed = String.Join(&ldquo;&rdquo;, mixed.Select(c => {
  if (&ldquo;ABCDEFGHIJKLMNOPQRSTUVWXYZ&rdquo;.Contains(c.ToUpper())) {</p>

<pre><code>return c.ToUpper();
</code></pre>

<p>  } else if (c.IsChinese()) {</p>

<pre><code>return c.GetPinyins()[0][0];
</code></pre>

<p>  } else {</p>

<pre><code>return "";
</code></pre>

<p>  }
}));
// initialOfMixed == [&ldquo;IBMZGYXGS&rdquo;]
```</p>

<p>不难看出<code>GetPinyins</code>和<code>IsChinese</code>是Lucida拼音库的关键操作。</p>

<h3>API设计</h3>

<p>根据前面的使用场景，不难得到下面的API：</p>

<p>```csharp Lucida拼音库API
public static class ChineseCharExtensions {
  /// <summary>
  /// Gets an array of Pinyin from the given character.
  /// </summary>
  /// <exception cref="ArgumentOutOfRangeException">Throws when the given character is not a Chinese character.</exception>
  public static String[] GetPinyins(this Char chr) ;</p>

<p>  /// <summary>
  /// Indicates whether the given character is a Chinese character.
  /// </summary>
  public static Boolean IsChinese(this Char chr) ;
}
```</p>

<p><code>ChineseCharExtensions</code>是一个扩展类，它为<code>Char</code>提供<code>GetPinyins</code>和<code>IsChinese</code>这两个<a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">扩展方法</a>，从而允许我们直接在<code>Char</code>类型上调用这两个方法，非常方便。</p>

<p>可能有人会问为什么不引入<code>GetFirstPinyin</code>或<code>GetInitial</code>这样的辅助方法。我的答案是：<strong>一个类应该提供少量正交的（Orthogonal）高性能方法，调用者根据需求进行进一步抽象。</strong></p>

<h2>实现（Implementation）</h2>

<blockquote><p>问：把大象放进冰箱需要几步？
答：三步：1. 打开冰箱门；2. 把大象放进去；3. 关上冰箱。</p></blockquote>

<p>API设计告诉我们做什么（What to do），接下来我们需要确定怎么做（How to do），也就是代码实现。</p>

<p>Windows Phone 7不支持大容量<code>Dictionary</code>（这也是微软拼音库无法在Windows Phone 7上正常运行的原因），所以我们不能直接使用.Net自带的字典数据结构。但拼音转换需要一个字典结构——对于给定的字符返回其拼音——也就是说我们要<strong>自己实现</strong>一个类似<code>Dictionary&lt;Char, String[]&gt;</code>的数据结构，但又不能直接使用<code>Dictionary</code>。从性能方面考虑，这个数据结构应该尽可能使用<code>Int32</code>、<code>String</code>和<code>String[]</code>这些低开销基本类型，而<strong>不</strong>使用<code>List&lt;String&gt;</code>或<code>Dictionary&lt;Char, String[]&gt;</code>这些高开销类型。</p>

<p>为了实现<code>汉字 -&gt; 拼音</code>这个字典结构，我们需要解决下面这两个问题：</p>

<ol>
<li>如何在不使用<code>Dictionary</code>的前提下查找汉字？</li>
<li>如何尽可能紧凑的表示拼音？我们可以为每个汉字用<code>String</code>数组表示拼音，但两万多个<code>String</code>数组无疑是不小的开销。</li>
</ol>


<h3>如何查找汉字</h3>

<p>这个问题并不难解决，我们可以把两万多个汉字拼接成一个字符串，然后对这个字符串进行排序，接下来用二分搜索查找汉字。我们可以把这个大号字符串（两万多个汉字）放在代码里，从而省去排序时间：</p>

<p><code>csharp
private static Char[] ChineseCharacters = "〇一丁丂七丄丅...".ToArray();
</code></p>

<p>接下来我们可以用二分搜索查找汉字：</p>

<p><code>csharp
private static Int32 FindCharacter(Char chr) {
  return Array.BinarySearch(ChineseCharacters, chr);
}
</code></p>

<p>但是转念一想，为什么要二分搜索呢？就像C标准库里的<code>isupper</code>和<code>islower</code>一样，我可以使用一个位图（Bit-map）来查找汉字，从而把速度从o(logN)降到o(1)：</p>

<p>```csharp
/// <summary>
/// The minimum integer value of a valid Chinese character.
/// </summary>
private static readonly Int32 MinValue = 12295;</p>

<p>/// <summary>
/// The maximum integer value of a valid Chinese character.
/// </summary>
private static readonly Int32 MaxValue = 59491;</p>

<p>private static Boolean[] ChineseCharactersTruthTable = { true, false, &hellip; };
```</p>

<p>有了<code>ChineseCharactersTruthTable</code>，我们可以很容易的实现<code>IsChinese</code>：</p>

<p><code>csharp
public static Boolean IsChinese(this Char chr) {
  return MinValue &lt;= chr &amp;&amp; chr &lt;= MaxValue &amp;&amp; ChineseCharactersTruthTable[chr - MinValue];
}
</code></p>

<h3>如何表示拼音</h3>

<p>最直接的表示拼音的方式是使用<code>String[][]</code>，它按照<code>ChineseCharacters</code>中的汉字顺序保存着每个汉字的拼音：</p>

<p><code>csharp
private static String[][] PinyinsTable = { new String[] {"LING"}, new String[] {"YI"}, ... };
</code></p>

<p>然后利用它和<code>FindCharacter</code>实现<code>GetPinyins</code>：</p>

<p>```csharp
public static String[] GetPinyins(this Char chr) {
  Int32 index = FindCharacter(chr);
  if (index != -1) {</p>

<pre><code>return PinyinsTable[index];
</code></pre>

<p>  } else {</p>

<pre><code>throw new ArgumentOutOfRangeException("chr", chr, "Expect a Chinese character.");
</code></pre>

<p>  }
}
```</p>

<p>但用多维数组表示<code>PinyinTable</code>存在很多问题：</p>

<ol>
<li><code>PinyinTable</code>是一个由两万多个数组组成的多维数组——构造它可是不小的开销；</li>
<li><code>GetPinyins</code>会直接返回<code>PinyinTable</code>里的子数组引用，如果用户修改了子数组那么原始数组<code>PinyinTable</code>也会遭到修改。（是的，我们可以返回一个拷贝，然而这又造成了性能开销）</li>
</ol>


<p>出于这两个原因，我们不会使用<code>String[][]</code>。我们应该使用一种紧凑的方式表达拼音，这时我的第一反应就是用<code>Int64</code>表示拼音，我的理由如下：</p>

<ol>
<li>尽管汉字有多音字，但我估计每个多音字的发音不会超过8种；</li>
<li>我估计汉字的拼音应该不会超过500种，也就是说可以用9位（Bit）表示一个拼音；</li>
<li>所以<code>Int64</code>可以容纳7个拼音（64 > 7 * 9），我认为这足够了。</li>
</ol>


<p>为了验证我的猜想，我编写了一段代码用来计算汉字的拼音数量：</p>

<p>```csharp 计算汉字拼音有多少种
Console.WriteLine(ChineseCharacters</p>

<pre><code>.Select(c =&gt; new ChineseChar(c).Pinyins)
.Aggregate(new HashSet&lt;String&gt;(), (hashSet, pinyins) =&gt; {
  foreach (String pinyin in pinyins.Where(p =&gt; p != null)) {
    hashSet.Add(pinyin.Substring(0, pinyin.Length - 1));
  }
  return hashSet;
}).Count);
</code></pre>

<p>// &ndash;> 403
```</p>

<p>所以汉字拼音一共有<strong>403</strong>种——然后我用一段代码来算一个汉字最多能有多少拼音：</p>

<p>```csharp 计算一个汉字最多能有几种拼音
var chr = Pinyin.HanziArray</p>

<pre><code>.Select(c =&gt; new {
  Value = c,
  Pinyins = new ChineseChar(c).Pinyins.Where(p =&gt; p != null).ToArray()
})
.Aggregate((a, b) =&gt; a.Pinyins.Length &gt; b.Pinyins.Length ? a : b);
</code></pre>

<p>Console.WriteLine(chr.Value + &ldquo;: &rdquo; + String.Join(&ldquo;, &rdquo;, chr.Pinyins));</p>

<p>// &ndash;> 差: CHA1, CHA4, CHA5, CHAI1, CHAI4, CHAI5, CI1, CI5
```</p>

<p>好吧<em>差</em>有8种拼音，不过由于我们不考虑音调，所以再算一遍：</p>

<p>```csharp 计算一个汉字最多能有几种拼音（不考虑音调）
var chr = Pinyin.HanziArray
  .Select(c => new {</p>

<pre><code>Value = c,
Pinyins = new HashSet&lt;String&gt;(
    new ChineseChar(c).Pinyins
      .Where(p =&gt; p != null)
      .Select(s =&gt; s.Substring(0, s.Length - 1)))
</code></pre>

<p>  })
  .Aggregate((a, b) => a.Pinyins.Count > b.Pinyins.Count ? a : b);
Console.WriteLine(chr.Value + &ldquo;: &rdquo; + String.Join(&ldquo;, &rdquo;, chr.Pinyins));</p>

<p>// &ndash;> 轧: GA, YA, YAI, ZHA
```</p>

<p>这证明了我的猜想：一个汉字最多有4种拼音（不考虑音调），拼音一共有403种。所以我们可以用9位（Bit）表示一个拼音，从而最多使用36位。也就是说<code>Int64</code>可以被用来表示一个汉字的拼音，以<code>差</code>为例，它有CHA、CHAI和CI三种发音：</p>

<p><img src="http://i.imgur.com/1IKzPu2.png" alt="图解差的拼音表示" /></p>

<p>所以，我们可以用<code>Int64[]</code>来代替前面的<code>String[][]</code>，每一个<code>Int64</code>代表一个汉字的拼音：</p>

<p><code>csharp
private static Int64[] PinyinCodes = { 175, 357, 196677, 186002, 246, ... }
</code></p>

<p><code>PinyinCodes</code>的引入使得<code>ChineseCharactersTruthTable</code>变的多余，因为现在可以通过检查<code>PinyinCodes</code>的值来判断一个字符是否为汉字：</p>

<p><code>csharp
public static Boolean IsChinese(Char chr) {
  return MinValue &lt;= chr &amp;&amp; chr &lt;= MaxValue &amp;&amp; PinyinCodes[chr - MinValue] != 0;
}
</code></p>

<p>此外我们需要编写额外一个方法用来把<code>Int64</code>解码（Decode）为对应的拼音，并增加一个类型为<code>String[]</code>的<code>PinyinTable</code>保存汉字中所有的拼音：</p>

<p>```csharp
private static String[] PinyinTable = { &ldquo;A&rdquo;, &ldquo;AI&rdquo;, &ldquo;AN&rdquo;, &ldquo;ANG&rdquo;, &ldquo;AO&rdquo;, &ldquo;BA&rdquo;, &hellip; };</p>

<p>private static String[] DecodePinyins(Int64 pinyinCode) {
  Int16 count = 0;
  for (Int64 tmp = pinyinCode; tmp > 0; count += 1, tmp >>= 9) ;
  String[] pinyins = new String[count];
  for (Int16 i = 0; pinyinCode > 0; i += 1, pinyinCode >>= 9) {</p>

<pre><code>pinyins[i] = PinyinTable[(pinyinCode &amp; 511) - 1];
</code></pre>

<p>  }
  return pinyins;
}
```</p>

<p>然后利用它们来实现<code>GetPinyins</code>：</p>

<p>```csharp
public static String[] GetPinyins(this Char chr) {
  if (IsChinese(chr)) {</p>

<pre><code>return DecodePinyins(PinyinCodes[chr - MinValue]);
</code></pre>

<p>  } else {</p>

<pre><code>throw new ArgumentOutOfRangeException("chr", chr, "Expect a Chinese character.");
</code></pre>

<p>  }
}
```</p>

<p>实现了<code>IsChinese</code>和<code>GetPinyins</code>，Lucida拼音库的实现就基本完成了，接下来是测试。</p>

<h2>测试（Test）</h2>

<p>我的测试思路很简单：我假设微软拼音库是正确的，如果Lucida拼音库和微软拼音库具有一致的行为（Behavior），那么Lucida拼音库就是正确的。</p>

<p>测试代码非常简单直接：遍历所有的字符（<code>Char</code>），检查Lucida拼音库是否和微软拼音库具有一致的行为。</p>

<p>```csharp 等价性测试
[TestClass]
public class ChineseCharExtensionsTest {
  [TestMethod]
  public void TestIsChinese() {</p>

<pre><code>var invalidCases = AllChars()
    .Where(c =&gt; c.IsChinese() != ChineseChar.IsValidChar(c))
    .Select(c =&gt; new {
      Value = c,
      Expected = ChineseChar.IsValidChar(c),
      Actual = c.IsChinese()
    });
Assert.AreEqual(String.Empty, String.Join("\n", invalidCases));
</code></pre>

<p>  }</p>

<p>  [TestMethod]
  public void TestGetPinyins() {</p>

<pre><code>var invalidCases = AllChars()
    .Where(c =&gt; ChineseChar.IsValidChar(c))
    .Select(c =&gt; new {
      Value = c,
      Expected = new HashSet&lt;String&gt;(
          new ChineseChar(c).Pinyins
              .Where(p =&gt; p != null)
              .Select(p =&gt; p.Substring(0, p.Length - 1))),
      Actual = new HashSet&lt;String&gt;(c.GetPinyins())
    })
    .Where(o =&gt; !o.Expected.SetEquals(o.Actual))
    .Select(o =&gt; new {
      Value = o.Value,
      Expected = String.Join(", ", o.Expected),
      Actual = String.Join(",", o.Actual)
    });
Assert.AreEqual(String.Empty, String.Join("\n", invalidCases));
</code></pre>

<p>  }</p>

<p>  private static IEnumerable<Char> AllChars() {</p>

<pre><code>for (Char value = Char.MinValue; value != Char.MaxValue; value += (Char)1) {
  yield return value;
}
</code></pre>

<p>  }
}
```</p>

<p>然后测试就通过了 &ndash;_&ndash;# 我甚至手动改了下代码让测试失败再改回来让测试通过以确定测试是有效的。</p>

<h2>度量（Profiling）</h2>

<p>理论上来说我的拼音库要比微软拼音库速度快，而且占用空间小。但是理论归理论，我们需要度量（Profile）程序来验证它。我在这里使用Visual Studio 2013自带的性能分析工具（Performance and Diagnostics）进行时间度量和内存度量。</p>

<p>度量程序如下。我使用一短（30个字符）一长（22047个字符）两个字符串作为测试数据，然后使用<code>ByMsLibrary</code>和<code>ByLucLibrary</code>分别用微软拼音库和我的拼音查询库将这两个字符串转化成对应的拼音：</p>

<p>```csharp 度量用例
private static Char[] shortText = &ldquo;前面三辆囚车中分别监禁的是三个男子，都作书生打扮，一个是白发&rdquo;.ToArray();
  var longText = File.ReadAllText(@&ldquo;sample_text.txt&rdquo;).ToArray();</p>

<p>private static Char[] longText = File.ReadAllText(@&ldquo;sample_text.txt&rdquo;).ToArray();</p>

<p>private static String ByMsLibrary(Char[] chrArray) {
  return String.Join(&ldquo; &rdquo;,</p>

<pre><code>  chrArray.Where(ch =&gt; ChineseChar.IsValidChar(ch)).Select(ch =&gt; new ChineseChar(ch).Pinyins[0]));
</code></pre>

<p>}</p>

<p>private static String ByLucLibrary(Char[] chrArray) {
  return String.Join(&ldquo; &rdquo;,</p>

<pre><code>  chrArray.Where(ch =&gt; ch.IsChinese()).Select(ch =&gt; ch.GetPinyins()[0]));
</code></pre>

<p>}
```</p>

<h3>时间度量（Timing Profiling）</h3>

<h4>短字符串</h4>

<p><code>csharp
  String value1 = ByMsLibrary(shortText);
  String value2 = ByLucLibrary(shortText);
</code></p>

<p><img src="http://i.imgur.com/IPHln3j.png" alt="短字符串时间度量" /></p>

<p>对于短字符串（30个字符），Lucida拼音库的性能优势并不明显（3毫秒对48毫秒，尽管也快了16倍），值得一提的是，微软拼音库花了30毫秒用于初始化，而我的拼音查询库只用了不到2毫秒。</p>

<h4>长字符串</h4>

<p><code>csharp
  String value1 = ByMsLibrary(longText);
  String value2 = ByLucLibrary(longText);
</code></p>

<p><img src="http://i.imgur.com/AfU1pCX.png" alt="长字符串时间度量" /></p>

<p>对于长字符串（22047个字符），我的拼音查询库的性能优势得到了展现：微软拼音库用了1603毫秒，而我的拼音查询库只用了7毫秒——比微软拼音库快200多倍。</p>

<h3>内存度量（Memory Profiling）</h3>

<h4>微软拼音库 + 短字符串</h4>

<p><code>csharp
  String value = ByMsLibrary(shortText);
</code></p>

<p><img src="http://i.imgur.com/fvohazD.png" alt="微软拼音库 + 短字符串" /></p>

<p>微软拼音库使用了1633KB内存：内存大量被花费在反序列化拼音信息（<code>CharUnit.Deserialize</code>）、读取资源（<code>ResourceReader.GetResourceData</code>）和初始化列表（<code>List.Add</code>）上。</p>

<h4>Lucida拼音库 + 短字符串</h4>

<p><code>csharp
  String value = ByLucLibrary(shortText);
</code></p>

<p><img src="http://i.imgur.com/RFOzRJ8.png" alt="Lucida拼音库 + 短字符串" /></p>

<p>Lucida拼音库使用了392KB内存——大约是微软拼音库的四分之一，几乎所有的内存都被花费在初始化拼音编码数组上。</p>

<h4>微软拼音库 + 长字符串</h4>

<p><code>csharp
  String value = ByMsLibrary(longText);
</code></p>

<p><img src="http://i.imgur.com/fpcDFbt.png" alt="微软拼音库 + 长字符串" /></p>

<p>微软拼音库使用了6229KB内存，这时<code>CharUnit</code>对象的获取和初始化成为了内存占用的主力。</p>

<h4>Lucida拼音库 + 长字符串</h4>

<p><code>csharp
  String value = ByLucLibrary(longText);
</code></p>

<p><img src="http://i.imgur.com/tH0KIiR.png" alt="Lucida拼音库 + 长字符串" /></p>

<p>Lucida拼音库使用了1354KB内存——依然不到微软拼音库的四分之一，初始化拼音编码数组仍占据了接近三成，可以注意到获取拼音时生成的字符串数组（<code>String[]</code>）占据了大量的内存。</p>

<h2>优化（Optimization）</h2>

<p>上面的代码是我三年前写下的，尽管它已经足够快足够紧凑——速度比微软拼音库快200多倍，初始化时间不到微软拼音库的三十分之一，占用内存不到微软拼音库的四分之一，但我认为它可以被继续优化——毕竟我当时在实现它时为了赶进度没有进行进一步的优化。</p>

<p>由于汉字查询的时间复杂度已是o(1)，而且内存度量显示Lucida拼音库在初始化时消耗了相当内存——所以接下来的优化主要从空间复杂度着手：</p>

<h3>稀疏数组（Sparse Array）</h3>

<p>汉字的最小编码是<code>12295</code>，最大编码是<code>59491</code>，为了简便，我直接开了一个大小为<code>47197</code>（<code>59491 - 12295 + 1</code>）的<code>Int64</code>数组用来存储拼音编码。但汉字实际上是<code>20591</code>个，这意味着有一多半的空间都被浪费了。</p>

<p>我猜测汉字编码应该是连续的——就像英文字母的ASCII表示一样。于是我编写了一小段代码来观察汉字编码分布，实验证明：尽管汉字编码是不连续，但它们只集中在<code>[12295, 12295]</code>、<code>[19968, 40869]</code>和<code>[59418, 59491]</code>这三个区间，也就是说可以用大小总和不到<code>21000</code>的三个数组来存储拼音编码，从而节省了一多半空间。</p>

<p>于是我用三个数组代替了原来的<code>PinyinCodes</code>，代码变的有些复杂，但是有测试在我也不怕会搞出什么问题。修改完成之后，我重新进行了性能和内存度量：</p>

<p>```text</p>

<pre><code>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</code></pre>

<p>短字符串         3毫秒            6毫秒             392KB             182KB
长字符串         7毫秒            10毫秒           1354KB             857KB
```</p>

<p>和我的估计差不多：由于分支判断增多导致运行时间增加了3毫秒，但内存占用则少了很多。</p>

<h3>拼音编码（Pinyin Encoding）</h3>

<p>我之前的代码存在另外一个问题：汉字拼音有403种，一个汉字最多有4种拼音，于是我使用4个9位，也就是36位，来表示一个汉字的拼音。</p>

<p>这个方法看似合理，但存在一个问题：太多的空间被浪费掉了。</p>

<p>为什么我会这么说呢？是的，汉字是有很多多音字，但不会有那么多多音字。我的方案考虑了所有可能的拼音组合，也就是<code>403 + 403 * 402 + 403 * 402 * 401 + 403 * 402 * 401 * 400 = 26,050,889,215</code>种，而汉字只有20591个，所以我原来的方案至少浪费了99.9999%以上的空间。</p>

<p>我估计所有可能的拼音组合不到一万种，为了印证我的猜想，我编写了另外一段代码计算汉字拼音有多少种组合——答案是<code>2163</code>。也就是说，我完全可以使用<code>Int16</code>来编码汉字拼音。每个编码对应一种拼音组合（例如<code>'差'</code>对应<code>"CA;CHA;CI"</code>），然后使用<code>String#Split</code>得到拼音，这样连移位操作也可以省略。</p>

<p>完成修改之后，我再次进行了性能和内存度量，效果如下：</p>

<p>```</p>

<pre><code>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</code></pre>

<p>短字符串         6毫秒           12毫秒             182KB            127KB
长字符串        10毫秒           15毫秒             857KB           1643KB
```</p>

<p>令我吃惊的是这个"优化"并没有得到预想的效果：改变编码后的拼音库仅仅在短字符输入时节省了60KB内存，而在处理长字符时内存占用反而增加了一倍，经过进一步度量我发现<code>GetPinyins</code>在调用<code>String#Split</code>时消耗了大量内存。</p>

<p>于是我使用了另一种方法——去除<code>String#Split</code>，但保留<code>Int16</code>编码，然后通过一个大小为2163的<code>Int64</code>数组来保存原来的<code>Int64</code>拼音编码。然后我再次进行了性能和内存度量，效果如下：</p>

<p>```</p>

<pre><code>              优化前时间       优化后时间       优化前内存占用     优化后内存占用
</code></pre>

<p>短字符串        12毫秒            3毫秒             127KB             74KB
长字符串        15毫秒            7毫秒             857KB            776KB
```</p>

<p>度量结果显示速度得到了提升——恢复到了优化内存之前的水平，而内存占用被进一步缩小。</p>

<h2>总结（Summary）</h2>

<p>通过空间换时间（Time-Space Trade Off）、紧凑表示（Compact Representation）、减少抽象层级（Reduce Abstract Level）以及时间/内存度量（Timing/Memory Profiling）等优化策略。我在微软拼音库的基础上实现了更加短小迅速的Lucida拼音库：</p>

<ul>
<li>查询速度比微软拼音库快200倍以上；</li>
<li>占用内存不到微软拼音库的八分之一；</li>
<li>启动速度比微软拼音库快30倍以上；</li>
<li>库的大小不到微软拼音库的五分之一。</li>
</ul>


<p>这个比较并不公平——因为微软拼音库支持音调和笔画，而Lucida拼音库只支持汉字到拼音，但我认为这并不是产生性能差距的主要原因——如果让我设计一个和微软拼音库功能一模一样的拼音库，我相信我至少可以把速度提升50倍，并把内存占用降低至原来的三分之一。</p>

<h3>回顾（Review）</h3>

<p>下面是对整个优化过程的回顾：</p>

<p>以长字符串（22047个字符）作为基准</p>

<p>```</p>

<pre><code>                           时间           内存占用
</code></pre>

<ol>
<li>微软拼音库              1603毫秒          6229KB</li>
<li>去除字典                 21毫秒          1471KB</li>
<li>使用位图代替二分搜索         7毫秒          1354KB</li>
<li>使用稀疏数组              10毫秒           857KB</li>
<li>使用紧凑表示               7毫秒           776KB
```</li>
</ol>


<p>以短字符串（30个字符）作为基准</p>

<p>```</p>

<pre><code>                           时间          内存占用
</code></pre>

<ol>
<li>微软拼音库                48毫秒          1633KB</li>
<li>去除字典                   7毫秒           536KB</li>
<li>使用位图代替二分搜索         3毫秒           392KB</li>
<li>使用稀疏数组               6毫秒           182KB</li>
<li>使用紧凑表示               3毫秒            74KB
```</li>
</ol>


<h3>得到的经验（Lessons Learned）</h3>

<ol>
<li>转移所有不必要的运行时计算到代码时（Move all unnecessary runtime computations to coding-time）：Lucida拼音库大量使用了这个技巧，例如汉字拼音编码都是手动编码生成，从而避免运行时计算；</li>
<li>如果追求性能，尽可能使用基本类型构建数据结构：Lucida拼音库没有使用任何.Net自带的<code>List</code>或是<code>Dictionary</code>类型；</li>
<li>通过实验验证猜想：我在编写Lucida拼音库时进行了很多假设（例如汉字编码是连续的和汉字拼音的组合是有限的等等），这些假设需要通过实验证明；</li>
<li>时间和空间不一定是矛盾的：Lucida拼音库就是一个很好的例子——200倍以上的速度提升——八分之一以下的内存占用；</li>
<li>通过度量进行优化，而非猜测：我曾经认为<code>String#Split</code>不会造成太大的性能损耗，事实恰恰相反；</li>
<li>如果可能，使用o(1)的算法；</li>
<li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">Make it run, make it correct, make it fast</a>；</li>
<li>代码优化会牺牲可读性：我不认为会有人能直接读懂Lucida拼音库的代码：</li>
</ol>


<p><img src="http://i.imgur.com/lT8SHBY.png" alt="Lucida拼音库部分代码" /></p>

<p>事实上它的大部分都是我通过另外一个程序生成，而另外一个程序则是通过另外一个程序生成 &ndash;_&ndash;#</p>

<h2>引用（References）</h2>

<ol>
<li><a href="http://www.amazon.com/Writing-Efficient-Programs-Prentice-Hall-Software/dp/013970244X/">Writing Efficient Programs</a>;</li>
<li><a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast">Make it run, make it correct, make it fast</a>;</li>
<li><a href="http://msdn.microsoft.com/en-us/library/ms182398.aspx">Profiling in Visual Studio 2013</a>;</li>
<li><a href="http://java.bizhat.com/~cs134/Resources/Reading/Articles/Bentley/p1087-bentley.pdf">Perspective on Performance</a></li>
<li><a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Framework Design Guidelines</a>;</li>
<li><a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613/">Joshua Bloch</a>关于如何设计API的<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">演讲</a>;</li>
<li><a href="http://research.microsoft.com/en-us/um/people/blampson/33-hints/webpage.html">Hints for Computer System Design</a>;</li>
<li><a href="http://zh.lucida.me/blog/on-learning-algorithms/">我的算法学习之路</a>.</li>
</ol>


<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lucida-pinyin-converter">从2000毫秒到10毫秒——Lucida拼音库的设计与实现</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精益技术简历之道——改善技术简历的47条原则]]></title>
    <link href="http://zh.lucida.me/blog/lean-technical-resume/"/>
    <updated>2014-11-01T21:08:43-07:00</updated>
    <id>http://zh.lucida.me/blog/lean-technical-resume</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<h2>关于</h2>

<p>这篇文章围绕着技术简历这个话题，从版式、个人信息、技术能力、项目经历和教育背景等方面出发，给出了编写高质量技术简历所应遵循的47条原则。它们既有益于求职者编写高质量的简历，也有助于招聘者筛选合格的求职者。</p>

<h2>为什么要编写这篇文章？</h2>

<p>技术简历既是技术人员求职必不可少的一环，也是找工作的第一步，其重要性不言而喻。然而关于如何编写技术简历的靠谱教程却少之又少，以至于求职者无法编写出合格的简历，而招聘者无法从简历中看出求职者的真实水平。</p>

<p>一些人可能会反对：如何编写技术简历还不简单，网上到处都是嘛！找一个教程，套一个模板，简历不就出来了嘛！</p>

<ul>
<li><a href="http://jingyan.baidu.com/article/363872ecf0fa656e4ba16f80.html">求职简历怎么写</a>，</li>
<li><a href="http://bbs.yingjiesheng.com/thread-180175-1-1.html">资深HR告诉你到底怎么写一份好的简历</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_4a388a6d01008cza.html">技术人员的简历编写技巧</a></li>
<li><a href="http://wenku.baidu.com/view/98f781d528ea81c758f57876.html">精美简历模板集合</a></li>
<li><a href="http://wenku.baidu.com/link?url=ocsWDBteInQGBzY562PWrz7_ZRZHF9BkzonuRAYmFCFGFCmMjXLPB3wSMxuQOFmbzx8FnuhJXogWHVmS8ViYt2nfkY_Xj3RT7ifLZH2WoZe">IT求职简历模板</a></li>
</ul>


<p>上面的教程和模板是我在谷歌和百度搜索“如何编写技术简历”和“技术简历模板”得到的结果，它们的共性是<strong>完全不适用于技术领域</strong>：这些教程和模板会指导你写出一篇<del>屁话连连空话连篇看似出彩但</del>毫无实质内容的嘴遁简历，是的，它们可能适用于一些国有企业，但对于追求实际的外企和民企完全不适用。</p>

<p>技术领域追求<strong>简练、客观、实际和成就</strong>，而不是<strong>冗余、主观、抽象和过程</strong>。如果求职者使用上面的教程或模板编写技术简历，那么结果注定会非常糟糕；如果招聘者使用上面的教程来甄别求职者，那么注定会招进一群光说不做的饭桶。我不是在开玩笑——尽管算上实习我只工作了三年，但我已经见证过很多优秀的童鞋因为简历被公司拒之门外，也见证过招聘者/HR因为不懂甄别简历，搞进来一群莫名其妙的家伙来面试，既浪费时间，又浪费资源。</p>

<p>所以我决定写一篇如何编写技术简历的文章，也就是<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>：</p>

<ol>
<li>为技术人员提供一个靠谱实用的技术简历编写教程</li>
<li>为招聘人员提供一个便捷高效的技术简历甄别教程</li>
</ol>


<p>结合国外书籍/文章和我自己的经验，我总结出47项编写高质量技术简历的原则，<strong>这些原则既可以作为求职者编写技术简历的准则，也可以作为招聘人员筛选技术简历的标准。</strong></p>

<p>此外，随着越来越多的人开始海外求职，我特别针对英文简历编写了9项原则，以帮助国人编写合格的英文技术简历。</p>

<p>注：本文标题中的的“精益”（Lean）源于精益创业（<a href="http://theleanstartup.com/">the Lean Startup</a>）。</p>

<h2>注意</h2>

<p>为了完成这篇文章，我从我的微博关注者中征集了一系列简历（感谢你们的信任！）。下文有可能会出现你们简历中的部分内容（当然我会进行改动以便保护你们的隐私），如果觉得不妥，请与我联系，我会将其删除。</p>

<p>下面进入正文。</p>

<!-- more -->


<hr />

<h2>精益技术简历原则</h2>

<h3>关于</h3>

<p>为了使本文更加严谨有序，我在组织简历原则时参考了编程书籍中著名的Effective系列（例如<a href="http://book.douban.com/subject/1842426/">Effective C++</a>和<a href="http://book.douban.com/subject/3360807/">Effective Java</a>）以及<a href="http://book.douban.com/subject/3267575/">Framework Design Guidelines</a>的行文风格：</p>

<ul>
<li>“使用……”、“对……进行……”、“按照……”这些原则属于必须遵循的原则</li>
<li>“不要使用……”、“不要……”、“避免……”这些原则属于必须避免的原则</li>
<li>“考虑……”、“不必……”、“谨慎……”这些原则属于我个人建议的原则，你可以去违反它们，但我个人不推荐这样做</li>
</ul>


<p>为了便于阅读和理解，我将这些原则按照进行了分类：</p>

<ul>
<li><strong>排版</strong>分类中的原则介绍了如何写出美观的简历</li>
<li>一般来说一封简历都会包含<strong>个人信息</strong>、<strong>技术能力</strong>、<strong>项目经验</strong>、<strong>教育背景</strong>和<strong>个人爱好</strong>，所以我将简历内容相关的原则按照这些分类进行了组织</li>
<li><strong>英文简历</strong>分类介绍了如何改善你的英文简历</li>
<li>未被分组的原则被归类到<strong>其他</strong></li>
</ul>


<h3><a name="sec1">版式</a></h3>

<p>版式（排版和样式）并不是简历内容的一部分，但却会对简历给人的第一印象造成很大影响——“字如其人”，简历版式可以反映其作者是否严谨是否认真。如果版式过于糟糕，那么简历很可能会被直接筛掉。</p>

<h4><a name="rule1">1. 使用对齐</a></h4>

<p>对齐（Alignment）是良好排版的第一要素——对齐不仅使简历层次分明，也会给人有力的感觉，例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="未对齐的简历" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="对齐的简历" /></p>

<h4><a name="rule2">2. 不必使用居中</a></h4>

<p>居中会破坏对齐，减弱整体的层次感，所以我不建议在简历中使用居中。例如：</p>

<p><img src="http://i.imgur.com/nJRMSaQ.png" alt="居中标题" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/hQdUkR3.png" alt="非居中标题" /></p>

<p>是的，这条原则里使用的图片来自<a href="#rule1">原则 1. 使用对齐</a>，请牢记：<strong>左/右对齐优于居中对齐。</strong></p>

<h4><a name="rule3">3. 谨慎使用<strong>粗体</strong></a></h4>

<p>粗体是一个很强大的工具，它可以有效的去引导简历阅读者的视线，并突出重要的内容。但我在阅读简历的时候发现不少人对粗体使用不当——滥用，用错，甚至是全文使用粗体，这使得简历完全无法被正常阅读。</p>

<p>粗体适用于去突出<strong>成就</strong>（Achievements），例如：</p>

<ul>
<li>量化的成就：将页面加载速度提升<strong>50%</strong></li>
<li>良好的成绩：GPA <strong>4.0/4.0</strong></li>
<li>奖项：ICPC/ACM比赛中获得XX赛区<strong>一等奖</strong></li>
<li>他人的推荐语：<strong>“XX是我见过的最优秀的实习生”</strong></li>
</ul>


<p>在其它场景下，我不推荐使用粗体，此外注意不要过多使用粗体——<strong>粗体是为了突出成就，不是为了突出技术关键字</strong>，<strong>太多的粗体会导致什么也突出不出来。</strong></p>

<h4><a name="rule4">4. 避免不必要的折行</a></h4>

<p>折行（Wrap）指当一行内容过长时会自动进入下一行。我不是说不可以折行（那就成了古龙小说了 :&ndash;/），而是说不要使用不必要的折行，比如说：</p>

<p><img src="http://i.imgur.com/oWHWfnO.png" alt="不必要的折行" /></p>

<p>就不如</p>

<p><img src="http://i.imgur.com/RHoQFdQ.png" alt="去掉折行" /></p>

<p>不必要的折行会降低简历的密度，破坏简历的层次感，而且会给人没话说有意占行数的感觉。请务必避免这样的折行。</p>

<h4><a name="rule5">5. 使用制表符辅助对齐</a></h4>

<p>为了进行对齐，我们往往需要添加一些空白符。在这里请使用制表符（tab）而非空格（space），因为：</p>

<ol>
<li>空格往往不会带来严格的对齐（因为简历字体往往不是等宽的）</li>
<li>制表符在打印版本下的表现更佳</li>
</ol>


<h3><a name="sec2">个人信息</a></h3>

<p>个人信息部分决定了简历阅读者对简历的第一印象，请务必在这部分内容多下功夫。</p>

<h4><a name="rule6">6. 不要使用不必要的条目名称</a></h4>

<p>条目名称（Column name）这个词很拗口，我举一个例子：“姓名：张大锤”和“电话：135-9112-7890”里的“姓名”和“电话”就是条目名称。</p>

<p>绝大多数的条目名称都是不必要的——“张大锤”一看就是一个名字，“135-9112-7890”一看就是一个手机号码。这种条目信息会让简历变得拖沓啰嗦，请务必删除它们。</p>

<p>此外，请牢记<strong>“个人简历”是简历上最大的废话</strong>——这当然是一封简历，不用你提醒。可笑的是很多所谓的“500强简历模板”还把“个人简历”作为简历抬头（Header）。</p>

<h4><a name="rule7">7. 使用分隔符增强电话号码的可读性</a></h4>

<p>请使用“-”和“()”格式化你的电话号码，例如：把<strong>8618601007070</strong> 改为 <strong>(+86) 186-0100-7070</strong>，以便简历阅读者能够正确便捷的拨打你的号码，此外这样的号码也显得更加专业。</p>

<h4><a name="rule8">8. 使用可以点击的链接</a></h4>

<ul>
<li>使用<a href="http://zh.lucida.me">http://zh.lucida.me</a>而非http<nolink>://zh.lucida.me</li>
<li>使用<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#109;&#121;&#109;&#97;&#x69;&#x6c;&#x40;&#x67;&#x67;&#103;&#x2e;&#x63;&#111;&#x6d;">&#x6d;&#121;&#x6d;&#x61;&#105;&#108;&#64;&#103;&#103;&#x67;&#46;&#99;&#111;&#109;</a>而非mymail<nolink>@ggg.com</li>
</ul>


<p>这样简历阅读者就可以直接点击，而不是费力的把链接复制粘贴到某个输入栏中。</p>

<h4><a name="rule9">9. 不要使用照片</a></h4>

<p>照片不会对你的简历产生任何正面价值，而且它会破坏简历的结构，请不要在简历中使用照片。</p>

<h4><a name="rule10">10. 不要写无关个人信息</a></h4>

<p>是的，你是在写技术简历，而不是在写入党申请或征婚启事之类的东西，所以请不要在简历中出现下面这些信息：</p>

<ul>
<li>性别</li>
<li>生日</li>
<li>星座</li>
<li>籍贯</li>
<li>通信地址</li>
<li>民族</li>
<li>政治面貌（WTF!!??）</li>
<li>身高/体重</li>
</ul>


<p>理想的个人信息应该包括姓名、联系方式（电邮地址和手机号码），如果你有不错的技术博客也可以把它放在上面。</p>

<h4><a name="rule11">11. 使用客观事实而非主观描述</a></h4>

<p>我经常在简历里面看到诸如“我是一个热爱编程的开发者”或是“我精力充沛，热爱学习，能够长时间从事编程工作”之类的个人评价，总之就是把雇主希望看到的性格特点堆在一起，有时感动的我都想哭。</p>

<p>但感动归感动，这些感人肺腑的个人评价我向来直接无视——<strong>我为什么要相信你呢？</strong>引用<a href="https://lkml.org/lkml/2000/8/25/132">Linus的话</a>，<strong>Talk is cheap, show me the code</strong>。如果要说明你是一个热爱编程的开发者，那么请出你的Github页面或优秀的个人作品；如果要说明你热爱学习，请给出你读过的书或写过的书评。总之，使用客观事实，而非主观描述。</p>

<h4><a name="rule12">12. 考虑提供他人的评价</a></h4>

<p>这条原则是上一条原则的扩充——找你的导师、老板或者同事为你写一个评语，相对于主观描述，他人的评价往往更加可信。如果你的评价者是业内权威，那么效果就会更好。</p>

<h4><a name="rule13">13. 不必写求职目标</a></h4>

<p>我读过的很多简历都有“Objective”（求职目标）这一栏，一般求职者会在这里写他所期待的职位。我个人非常不喜欢求职目标这一栏，因为求职目标给我一种海投简历的感觉。如果走的是内部推荐，或者使用目标公司的求职页面，请去掉求职目标，你应该已经了解投递职位，不需要在简历里面重复。</p>

<h3><a name="sec3">技术能力</a></h3>

<p>技术能力是技术简历里面重要的一环，一般来说简历阅读者会通过这部分内容了解你的技能集（Skill set），从而构成对你的第一技术印象。</p>

<h4><a name="rule14">14. 不要堆砌技术名词</a></h4>

<p>技术简历中一个常见误区是堆砌技术名词，一些求职者认为在简历上写的技术越多越好，于是把自己会的、用过的、见过的甚至没见过的技术都堆在一起，比如：</p>

<p>Technical Skills</p>

<ul>
<li>Programming Language: HTML, CSS, PHP, JavaScript, SQL, Haskell, Perl, Python, C, C++, Java, Ruby, Prolog, .NET, C#, Assembly, REXX, Verilog, R, Visual Basic, MATLAB, jQuery, Angular, SASS</li>
<li>Operating System: Unix/Linux, Mac, MS-DOS, Windows 7/8, Windows Server 2003/2008/2012, z/VM</li>
<li>Software: Adobe Creative Cloud Dreamweaver, Photoshop, InDesign, Audition. WordPress, OmniUpdate, Google Analytics, Eclipse, NetBeans, LaTex, Microsoft Office Suite, Microsoft Excel, Project, Visio, Visual Studio</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>是的，一个人可以同时掌握甚至精通多种编程语言，但一般来说这种可能性很小。当我看到这样的技术描述，我会迅速的跳转到简历的项目经验环节，如果我无法在项目经验里找到对应的技术，我会直接把这个简历筛掉。（我把它叫做“未声明引用”（Undeclared reference）：你说你精通C++，但你却没有C++的项目经验，你确定不是在逗我？）</p>

<p>所以，不要堆砌技术名词，技术简历并非多多益善，熟悉什么技术就写什么技术，然后在项目经验里面给出你熟悉该技术的证据（evidence），这样会使你的简历更有说服力。</p>

<h4><a name="rule15">15. 对技术进行分类</a></h4>

<p>技术能力部分的另一个常见问题是缺乏分类或者分类错误，比如：</p>

<p><code>
编程语言：C++, C#, Visual Studio, Shell, Python, Eclipse, Java
</code></p>

<p><img src="http://i.imgur.com/PpAXta9.jpg" alt="分类不清" /></p>

<p>这样的简历也会被直接扔进废纸篓——连编程语言和编程环境都分不清，招你作甚。</p>

<p>正确分类后就清楚了很多：</p>

<p><code>
编程语言：C++, C#, Java, Python, Shell
开发环境：Visual Studio, Eclipse
</code></p>

<h4><a name="rule16">16. 使用正确的技术名称</a></h4>

<p>这个原则非常简单（甚至有点弱智）——正确拼写技术名称，并使用正确的大小写。我在这里摘取了一些我见过的技术名词错误：</p>

<ul>
<li>Andoid &ndash;> Android</li>
<li>IOS, ios &ndash;> iOS</li>
<li>javascript &ndash;> JavaScript</li>
<li>coffescript &ndash;> CoffeeScript</li>
<li>intelij &ndash;> IntelliJ</li>
<li>Dikjstra &ndash;> Dijkstra</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="别字错误" /></p>

<p>请严格检查此类错误——这类错误会大大降低你的简历的专业性，并给人非常不好的印象</p>

<h4><a name="rule17">17. 不要写电脑能力</a></h4>

<p>技术简历需要展现你的技术能力（Technical Skills），而不是电脑能力（Computer Skills），这两个概念比较拗口，所以我在这里举几个例子：</p>

<ul>
<li>技术能力包括：编程（C++/Java/Python），开发环境（Visual Studio/IntelliJ/Eclipse），测试（JUnit/TestNG/mockito/truth），用户体验（Axure/Expression Blend）等等。</li>
<li>电脑能力包括：日常办公（Word/Excel/PowerPoint/Office），图形界面操作系统（Windows 7/8）的使用，浏览器（IE/Chrome/Safari）的使用等等。</li>
</ul>


<p>电脑能力不但会稀释你的简历含金量，还会给人极不专业的感觉。不要在技术简历里面出现任何电脑能力——据说某公司甚至定了一个规矩，<strong>只要在技术简历里面看到Office字样就直接滤掉</strong>（靠谱！）。</p>

<h4><a name="rule18">18. 按照熟悉程度对技术能力进行排序</a></h4>

<p>这个原则十分简单——使用合适的词汇描述你的技术能力，并按照熟悉程度排序，例如：</p>

<p><code>
编程语言：C++, C#, Java, Python, JavaScript
</code></p>

<p>就不如</p>

<p><code>
编程语言：熟悉C++、C#和Java，了解Python和JavaScript
</code></p>

<p>另一种方式是使用比较符：</p>

<p><code>
编程语言：C++ = C# &gt; Java &gt; Python = JavaScript
</code></p>

<p>注意：没有必要在技术能力后面加上使用时间，比如：</p>

<p><code>
技术名称     熟练程度     使用时间
C++           精通         8年
Java          熟悉         5年
</code></p>

<p>时间没有意义——搞技术的都明白技术的使用时间和技术的熟练程度没有任何关系（谁知道这货是不是用了1个月C++然后在后面的95个月不断重复第一个月的东西？），只可惜有些HR永远都不懂这个道理，也不肯懂。</p>

<h4><a name="rule19">19. 不要写过于特定的技术</a></h4>

<p>什么叫做过于特定（Specific）的技术呢？举个例子：</p>

<p><code>
熟悉单例（Singleton）模式
</code></p>

<p><img src="http://i.imgur.com/gQwjJhC.png" alt="捂脸" /></p>

<p>且不说单例是不是一个好模式，单例模式有什么好熟悉的？这种东西也配写到简历上吗？至少在我看来，“熟悉单例模式”就跟“熟悉for循环”、“精通if语句”一般可笑。</p>

<h4><a name="rule20">20. 谨慎使用精通</a></h4>

<p>精通和Proficient是非常Strong的词汇，在简历上写精通类词汇也许会帮你得到面试机会，但你要面对难度更高的面试——招聘者会通过更高难度的问题来确认你真的是精通，而不是在嘴遁。</p>

<p>但如果你真的精通某项技术，那就自信的写上精通，然后用项目经历和面试中的表现说服招聘者，这样往往有助于你拿到Strong Offer。</p>

<h4><a name="rule21">21. 使用项目经验印证技术能力</a></h4>

<p>这条原则在<a href="#rule13">原则13 不要堆砌技术名词</a>也有提到——你的技术能力应该在你的项目经历中得到<strong>全部</strong>体现，技术能力展现你的技能集（Skills Set），而项目经验为其提供证据（Evidence）。打个比方，如果你提到你熟悉C++，那么你就需要在项目经验中提到C++，否则我认为你在说谎或者忘记把C++的项目经验写在简历上，说谎和健忘，两者都不是好事。</p>

<h3><a name="sec4">项目经历</a></h3>

<p>项目经历是简历阅读者进一步了解求职者技术能力的重要依据，良好的项目经历应当清晰，简洁，既印证前面提到的技术能力，也反映出求职者应对复杂度（Handle complexity）的能力。</p>

<h4><a name="rule22">22. 按照时间对项目经历排序</a></h4>

<p>一般来说，项目经历应该按照时间倒序排序——最新的项目经历放在最前。此外，考虑去掉过于久远（比如说，七八年前）的项目经历，因为你很有可能已经忘了七八年前做过的东西了。</p>

<p>另外一种排序方式是按照项目的重要程度排序——最重要的项目放在最前，但我个人不推荐这种方式，因为往往最重要的项目都在最近，如果你最重要的项目在很多年，那么很有可能你这些年毫无长进。</p>

<h4><a name="rule23">23. 不要列出过多的项目</a></h4>

<p>我经常看到非常长的简历：三四页纸，两三千字，十余个项目，恨不得把他/她做过的东西全都铺上去。而事实证明写出这样简历的人水平都不怎么样——至少就我的个人经验而言。</p>

<p>项目经历不是自传，不用把你全部的经历铺上去，也不要写过多的项目经历——三个项目是一个不错的选择，五个就有点多，十个就会没人看。要知道三个优秀的项目远胜十个一般的项目。</p>

<p>所以问题来了，什么是优秀的项目呢？就技术项目而言，我的评估标准是复杂度（Complexity）和影响力（Impact）：一个项目，如果复杂度和影响力都有那是最好，如果只有一个也不错，如果都没有那就呵呵。我会在<a href="#rule25">原则25 强调影响力和复杂度</a>中进一步说明。</p>

<h4><a name="rule24">24. 强调成果而非过程</a></h4>

<p>我在我之前的<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">关于锤子手机和锤子手机发布会</a>提到过：</p>

<blockquote><p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress。</p></blockquote>

<p>技术简历也是如此，不要在项目经历中过度强调你有多努力。“连续高强度工作三个月”和“在深夜重构了XX项目中的代码”并不是一个好的项目描述：如果你“连续高强度工作三个月”却无法说明你的工作成果，“在深夜重构了XX项目中的代码”却无法说明重构后代码改进了多少，那我认为你的“努力”毫无意义。</p>

<p>强调你的项目成果（Achievements）而非过程，“将网站访问量提升300%”、“将响应时间从1.5s减少到0.1s以内”都是不错的成果。</p>

<h4><a name="rule25">25. 使用量化结果而非抽象描述</a></h4>

<p>我经常在简历上看到“改善了代码的质量”、“提升了启动速度”和“大大增加了网站访问量”之类的描述，我的第一反应就是：</p>

<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p><strong>用个数字你会死啊！！！看新闻联播看多了吧亲！！！！</strong></p>

<p>接下来的反应是：</p>

<ul>
<li>“改善了代码的质量”——改善了多少？你是如何评估的？圈复杂度？测试覆盖度？Bug的数量？ ？？？</li>
<li>“提升了启动速度”——提升了多少？用户的反馈如何？是否在可接受的范围内？ ？？？</li>
<li>“大大增加了网站访问量”——“大大”是什么？访问量增加了多少？访问量原来是多少？ ？？？</li>
</ul>


<p>如果我找不到上面问题的答案，我会直接无视这些抽象描述——还是那句话，我为什么要相信你的一面之词？而且你连话都说不清。</p>

<h4><a name="rule26">26. 强调影响力和复杂度</a></h4>

<blockquote><p>&ldquo;Controlling complexity is the essence of computer programming.&rdquo;</p>

<p>Brian Kernighan</p></blockquote>

<p>控制复杂度使程序设计的根本（essense），所以绝大多数IT公司在招聘时都会把应对复杂度（Handle complexity）放在职位描述里面——你如果能把难题搞定，那么简单题也不在话下。如果你做过的项目足够复杂，那么就证明你能扛得住复杂度，是个好<del>备胎</del>备选（Candidate）。</p>

<p>那么什么样的项目经历称得上复杂呢？我在这里给出一个不严谨的分类，仅供参考：</p>

<ul>
<li>编程复杂度：操作系统，编译器/解释器，图形学编程，网络协议设计与实现等</li>
<li>算法复杂度：算法竞赛奖项等（不好意思我不熟悉算法所以给不出啥例子 &ndash;_-）</li>
<li>设计复杂度：大型网站，企业级应用，分布式应用等</li>
</ul>


<p>衡量项目的另一个重要依据是影响力（Impact），有的软件项目可能不那么复杂，但是它具有相当大的影响力，例如jQuery、RoR和JUnit：</p>

<blockquote><p>&ldquo;Never in the field of software development have so many owed so much to so few lines of code (JUnit).&rdquo;</p>

<p>Martin Fowler</p></blockquote>

<p>如果你的项目并不复杂，那么请强调它的影响力，用户量超过十万的手机应用和被广泛应用的类库都是很好的项目，尽管它们可能并不复杂。</p>

<p>如果一个项目既没有复杂度，也没有影响力，那么直接删掉它——不要犹豫，它不会为你的简历提供任何价值。</p>

<h3><a name="sec5">教育背景</a></h3>

<p>教育背景是简历的另一项重要内容，它对于应届生尤其重要——因为应届生往往没有太多的工作经历。</p>

<h4><a name="rule27">27. 不要写大学之前的教育经历</a></h4>

<p>我不明白为什么很多人把高中甚至初中都写在简历里——也许你的高中/初中很出色，不过那么多年前的事情就不用再提了吧 &ndash;_&ndash;||</p>

<h4><a name="rule28">28. 不要写课程列表</a></h4>

<p>我在简历的教育背景部分发现的另一个奇怪的现象是课程列表（Courseworks）：求职者把大学专业课程一水排开，放在简历里面，颇是壮观：</p>

<p>专业课程：</p>

<ul>
<li>计算机科学导论，C语言及程序设计，计算机组成原理，数据结构，算法设计，离散数学，操作系统原理，编译原理，计算机网络，数据库系统原理，面向对象编程，软件工程，图像处理技术，人工智能及其应用，网络工程</li>
</ul>


<p><img src="http://i.imgur.com/hFIZhRE.jpg" alt="吓得我都坐地上了" /></p>

<p>更加令人啼笑皆非的是把<strong>所有</strong>的大学课程放在一起：</p>

<p>大学课程：</p>

<ul>
<li>高等数学，线性代数，大学物理，概率与数理统计，毛泽东思想概论，思想道德修养，邓小平理论，马列政治经济学原理……</li>
</ul>


<p><img src="http://i.imgur.com/VZl1YOF.jpg" alt="坑爹呢这是" /></p>

<p>每当看到这样的简历我都在想我是该筛掉你呢还是筛掉你呢还是筛掉你呢？</p>

<p><strong>不要写课程列表</strong>，除非你有想特别强调的特殊专业课，而且你在该课上有突出表现（比如“编译原理（实现了带下标检查的扩展C编译器）”就不错）。</p>

<h4><a name="rule29">29. 考虑使用成绩或排名</a></h4>

<p>如果你的大学成绩或排名还不错，那么请把它放在教育背景中，例如：</p>

<p><code>
2009 ~ 2013    学士    大连理工大学    软件工程    GPA: 3.8/4.0，排名：3/153
</code></p>

<p>就不错。</p>

<p>但如果你的成绩一般（80%一下）或排名一般（前20%开外），那么就不要提它们（我就是这么做的，-_&ndash;#）</p>

<h4><a name="rule30">30. 考虑使用导师（老师）的评语</a></h4>

<p>这条原则和<a href="#rule12">原则12. 考虑提供他人的评价</a>相类似，与其说你在学校多么努力，不如让你的专业课老师（导师）给你一个评价。</p>

<p>注意：不要使用辅导员的评价，是的，辅导员在大学很重要，但辅导员对学生的评价往往没有<strong>专业</strong>参考价值。</p>

<h4><a name="rule31">31. 考虑使用学业相关的奖项</a></h4>

<p>请把在校期间的<strong>重要奖项</strong>放在教育背景中，比如“一等奖学金”，“数学建模大赛一等奖”就不错。</p>

<p>我在阅读简历时见到过很多学霸——学校里面获得的奖项接近一页纸之多。这是个好事，不过放太多奖无益于突出重点，所以请参考<a href="#rule23">原则 23. 不要列出过多的项目</a>：精选3到5个最有说服力的奖项，然后把它们放在教育背景中。</p>

<h3><a name="sec6">个人爱好</a></h3>

<p>个人爱好对技术简历往往毫无价值，所以这里的原则只有一条——</p>

<h4><a name="rule32">32. 避免写个人爱好</a></h4>

<p>除非你在个人爱好上取得了相当的成就，否则不要写个人爱好。每个人都喜欢音乐，都喜欢看书，也都喜欢技术，这种<del>屁话</del>套话还是留到入职邮件再说也不迟。</p>

<h3><a name="sec7">英文简历</a></h3>

<p>海外求职需要英文简历，而英文简历需要专业的英语——阅读你简历的人很有可能只懂英文，如果你的英文太糟糕那么他/她很可能会无视你的技术而直接把你筛掉。</p>

<h4><a name="rule33">33. 不要出现拼写错误</a></h4>

<p>请打开拼写检查——要知道简历里面的拼写错误是致命的。我在这里给出一些常见的拼写错误：</p>

<ul>
<li>explaination &ndash;> explanation</li>
<li>convenence &ndash;> convenience</li>
<li>seperate &ndash;> separate</li>
<li>Febuary &ndash;> February</li>
<li>embarass &ndash;> embarrass</li>
<li>consience &ndash;> conscience</li>
<li>mispell &ndash;> misspell</li>
<li>enginner &ndash;> engineer</li>
</ul>


<p><img src="http://i.imgur.com/gQwjJhC.png" alt="金馆长" /></p>

<p>更多的拼写错误请参考<a href="http://grammar.yourdictionary.com/spelling-and-word-lists/misspelled.html">这里</a>。</p>

<h4><a name="rule34">34. 不要使用全角字符</a></h4>

<p>务必不要在英文简历中使用全角字符：</p>

<ol>
<li>全角字符会影响英文排版，使其变的很难看</li>
<li>对方的机器上可能没有对应的字库，因而无法显示全角字符</li>
</ol>


<p>我个人推荐在英文简历中只使用ASCII字符集里的字符。</p>

<h4><a name="rule35">35. 使用正确的词汇</a></h4>

<p><img src="http://i.imgur.com/SJF8N2m.jpg" alt="神翻译" /></p>

<p>国人英文简历的一大通病是用词不当，下面是我阅读英文技术简历时所发现的最常见的三个错误：</p>

<ol>
<li>“<strong>实现</strong>了xx功能”：使用<strong>Implement</strong>，而不是<strong>Achieve</strong></li>
<li>“软件工程师”：使用<strong>Software Developer</strong>或<strong>Software Engineer</strong>，而不是<strong>Software Programmer</strong></li>
<li>“我对xxx<strong>感兴趣</strong>”：使用<strong>I am interested in &hellip;</strong>，而不是<strong>I am interesting in</strong>，详见<a href="http://www.learnersdictionary.com/qa/what-is-the-difference-between-interested-and-interesting">这里</a></li>
</ol>


<p>用词不当会影响简历阅读者的理解，为其带来相当负面的印象。为了减少这类错误，你应该去阅读更多的专业英文著作，或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule36">36. 使用简洁的句子</a></h4>

<p>受中式思维的影响，我们的英文往往很冗余（Verbose），我举两个简单的例子</p>

<ul>
<li>“during the development period”应该是“during the development”：因为“development”本身已经包含“过程（period）”的意思。</li>
<li>“implemented xxx successfully”应当是“implemented xxx”：既然使用了过去式，那么你已经把它实现（implement）了，那自然就是“成功”实现。如果想要强调“成功”，那么可以用“accomplished xxx”。</li>
</ul>


<p>这里水一句：一般来说中国人对这种英语完全不敏感，反而很亲切（因为更接近中式思维），那为什么我对这种英语特别在意呢？因为我有几个伦敦同事特别在意英语的纯正性，初到伦敦时，无论是吃饭、聊天还是提交代码，他们都会无时无刻的纠正我的语法错误和发音错误（我想我已经被他们纠正几千多次了-_&ndash;#），所以我现在对此类中式英语异常敏感。</p>

<p>此外在简历里面我们有时可以忽略主语（Subject），例如：</p>

<p>```
Project A:</p>

<pre><code>I implemented the communication module.
I wrote tests for the communication module.
I deployed the module into our system.
</code></pre>

<p>```</p>

<p>可以这么写</p>

<p>```
Project A:</p>

<pre><code>Implemented the communication module.
Wrote tests for the communication module.
Deployed the module into our system.
</code></pre>

<p>```</p>

<p>这样不但更加简洁，而且用动词开头会让句子显得更加有力，给人以自信的感觉。</p>

<p>为了使简历中的英文句子更加简洁，你应该去阅读更多的英文写作书籍（例如<a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>和<a href="http://www.amazon.com/Writing-Well-30th-Anniversary-Edition/dp/0060891548/">On writing well</a>），或者找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule37">37. 避免中式英语</a></h4>

<p>这个原则实际上是<a href="#rule35">原则35. 使用正确的词汇</a>和<a href="#rule36">原则36. 使用简洁的句子</a>的扩展，因为这两个原则都属于中式英语的范畴。</p>

<p>中式英语的源头在于用中式思维将中文逐字转化成英语，尽管我们不会搞出这样的错误：</p>

<p><img src="http://i.imgur.com/PfkAXV7.jpg" alt="神翻译" /></p>

<p>但是小错是难免的，我已经不止三次的听到有人使用"red color"这个神奇的短语了。（red本身就是颜色，所以完全不需要后面的color）如果你打算根除中式英语，你有两种途径：</p>

<ol>
<li>找几个腹黑伦敦同事。-_&ndash;#</li>
<li>阅读<a href="http://book.douban.com/subject/1229822/">中式英语之鉴</a></li>
</ol>


<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p>这是我读过最好的（貌似也是唯一的）讲中式英语的书籍。</p>

<p>当然，如果你只是把简历改的不那么中式，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h4><a name="rule38">38. 使用一致的时态</a></h4>

<p>这个原则很简单——使用一致的时态：</p>

<ul>
<li>对于个人评价：使用现代式。</li>
<li>对于项目经历：使用过去式。</li>
</ul>


<p>之所以把这么简单的原则提出来，是因为我都过的英文简历几乎都违反了这个原则——它们或者在个人评价里“I was a passionate programmer”（嗯，你过去很激情那么现在呢？），或者在项目经历里“Implement xxx”（一直实现到现在不容易啊童鞋！）。</p>

<h4><a name="rule39">39. 考虑提供缩写词的解释</a></h4>

<p>不是所有人都了解你的工作或研究，所以对于<strong>不常用</strong>和<strong>有歧义</strong>的首字母缩写词（Acronym），请提供全称。</p>

<p>注意我说的是<strong>不常用</strong>和<strong>有歧义</strong>的缩写词，你无需告诉简历阅读者HTML的全称是HyperText Markup Language，也无需说明MVC是Model View Controller，但你可能需要说明AST是Abstract Syntax Tree，DSL是Domain Specific Language（而不是Digital Subscriber Line）。</p>

<h4><a name="rule40">40. 使用Bullets组织长段</a></h4>

<p>如果一段项目过长，请使用Bullets而不是“Firstly&hellip;, secondly&hellip;, finally&hellip;”，例如：</p>

<p>Firstly, I collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java. Secondly, I developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos. Finally, I improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</p>

<p>即便是一个English native speaker，看到这样的大长段也会发怵，这里可以利用Bullets改善可读性：</p>

<ol>
<li>Collected, managed and analysed data from the health and the legal sector with Data Mining and Natural Language Processing using Python, Perl, and Java.</li>
<li>Developed web applications to showcase the findings with Jsp, JavaScript. HTML, CSS, J2EE, Tomcat and MySql that led to successful research demos.</li>
<li>Improved the performance of an Java online education forum analysis tool by redesigning the GUI and utilizing multi-threading.</li>
</ol>


<h4><a name="rule41">41. 打下良好的英文基础</a></h4>

<p>归根到底，写好英文简历需要良好的英文基础，所以我在这里推荐几本不错的英语基础书籍：</p>

<p><img src="http://img3.douban.com/lpic/s1446975.jpg" alt="Practical English Usage" /></p>

<p><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a>：简洁，精炼，学习英文语法和口语的必备书籍。</p>

<p><img src="http://img5.douban.com/lpic/s11442466.jpg" alt="Collins Pocket English Thesaurus" /></p>

<p><a href="http://www.amazon.com/Collins-Pocket-English-Thesaurus-Dictionaries/dp/0007450567/">Collins Pocket English Thesaurus</a>：个人无责任推荐——每天看一点，这本书不会提升你的词汇量（Total Vocabulary），但会提升你的有效词汇量（Effective Vocabulary）。</p>

<p><img src="http://img5.douban.com/lpic/s4228916.jpg" alt="Elements of Style" /></p>

<p><a href="http://www.amazon.com/The-Elements-Style-Fourth-Edition/dp/020530902X/">Elements of Style</a>：英语写作第一书。无论是写作，还是编程，都能从本书受益良多。</p>

<p><img src="http://img5.douban.com/lpic/s8476196.jpg" alt="中式英语之鉴" /></p>

<p><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a>：可能是目前唯一一本讲述中式英语的书籍，尽管书中的例子有点政治化，但不妨碍本书是一本好书。</p>

<p>这篇文章的主题并非英语学习，如果你对英语学习有兴趣可以去Google和<del>逼乎</del>知乎搜索更相关的答案。</p>

<p>当然，如果你只是想得到一个不错的英文简历，你完全可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h3><a name="sec8">其它</a></h3>

<p>剩下的是一些通用原则。</p>

<h4><a name="rule42">42. 考虑使用超链接</a></h4>

<p>这项原则是<em>原则8. 使用可以点击的链接</em>的扩充——超链接适用于简历全文，而不只适用于个人信息里的个人主页和邮箱地址：</p>

<ul>
<li>如果你的作品/项目有介绍链接，请提供它</li>
<li>如果你的作品/项目有在线演示，请提供它</li>
<li>如果你的作品/项目有用户反馈，请提供它</li>
</ul>


<p>使用超链接时要注意一点：使用隐式超链接而非显式超链接，例如使用<a href="http://www.google.com">Google</a>而非<a href="http://www.google.com">http://www.google.com</a>。因为显式超链接往往很长而且不可读，还会破坏打印版简历的效果。</p>

<h4><a name="rule43">43. 考虑提供一个“加强版”简历</a></h4>

<p>这项原则是<a href="#rule42">原则42. 考虑使用超链接</a>的补充，简历受限于篇幅（一般是一页）和格式（一般是PDF），无法提供更多丰富多彩的内容。但你可以用超链接关联一个外部“加强版”简历。</p>

<p>一个典型例子是<a href="http://iconmoon.com/about/">JJ Ying</a>的在线“简历”（使用Parallax效果），这种“加强版”简历往往会使简历阅读者眼前一亮，从而大大增加你的简历通过率。</p>

<h4><a name="rule44">44. 考虑提供开发社区账号</a></h4>

<p>如果你有非常活跃的开发社区（例如<a href="http://stackoverflow.com/">Stack Overflow</a>，<a href="https://github.com/">GitHub</a>和<a href="http://www.reddit.com/r/programming/">Reddit Programming</a>等开发社区）账号，那么请在简历中提供它们。</p>

<p>注意我说的开发社区账号，而不是社交网络账号：提供<a href="http://www.renren.com/">人人</a>、<a href="http://www.weibo.com/">微博</a>或<a href="https://www.facebook.com/">Facebook</a>账号不会对简历有任何帮助。</p>

<h4><a name="rule45">45. 持续更新简历</a></h4>

<p>优秀的简历应该是<del>与时俱进</del>持续更新的。从现在开始，定一个周期（一个月或三个月），然后以这个周期持续更新简历，这样你可以：</p>

<ol>
<li>随时拥有最新的简历，而不是在求职时挖空心思编写</li>
<li>形成一个成长记录，以便自我改善</li>
<li>时刻提醒自己持续学习，如果你发现这个周期的简历同上个周期变化不大，你就要好好反思下了</li>
</ol>


<p>以我自己为例，我维护着一个Markdown简历，每两个月一更新，通过更新记录/当前简历/下一步计划，我可以更有效的指导我的学习和工作。</p>

<h4><a name="rule46">46. 不断提升个人能力</a></h4>

<blockquote><p>“没有声音，再好的戏也出不来”
某广告语</p></blockquote>

<p>简历原则有助于展示（Demostrate）实力，而不是放大（Amplify）实力——打个比方，你的实力有100分，低劣的简历会让你看起来只有50分，而良好的简历则会展现出你100分，但不要指望简历会把你变成200分——我承认有些人可以通过说谎/造假/吹牛达到这个效果，但我不推荐这种透支信用的做法。</p>

<p>所以，优秀简历的根本是强大的实力，多学习，多做有影响力/复杂度（参考<a href="#rule26">原则26. 强调影响力和复杂度</a>）的项目，而不是在马上找工作的时候挖空心思编项目堆技能。没有声音，再好的戏也出不来。</p>

<h4><a name="rule47">47. 考虑征求他人意见</a></h4>

<blockquote><p>“当局者迷，旁观者清”</p></blockquote>

<p>在投递简历前，最好去征求他人意见——外人往往可以看出你简历的不足，指出低级错误，给出不错的建议。</p>

<p>当然你也可以找一个靠谱的人审阅你的简历（比如<a href="http://www.weibo.com/pegong/">@peng_gong</a>）。</p>

<h2>总结</h2>

<p>在这里我把精益技术简历的47条原则整理在一起，以便阅读整理：</p>

<h3><a href="#sec1">版式</a></h3>

<ol>
<li><a href="#rule1">原则1：使用对齐</a></li>
<li><a href="#rule2">原则2：不必使用居中</a></li>
<li><a href="#rule3">原则3：谨慎使用<strong>粗体</strong></a></li>
<li><a href="#rule4">原则4：避免不必要的折行</a></li>
<li><a href="#rule5">原则5：使用制表符辅助对齐</a></li>
</ol>


<h3><a href="#sec2">个人信息</a></h3>

<ol>
<li><a href="#rule6">原则6：不要使用不必要的条目名称</a></li>
<li><a href="#rule7">原则7：使用分隔符增强电话号码的可读性</a></li>
<li><a href="#rule8">原则8：使用可以点击的链接</a></li>
<li><a href="#rule9">原则9：不要使用照片</a></li>
<li><a href="#rule10">原则10：不要写无关个人信息</a></li>
<li><a href="#rule11">原则11：使用客观事实而非主观描述</a></li>
<li><a href="#rule12">原则12：考虑提供他人的评价</a></li>
<li><a href="#rule13">原则13：不必写求职目标</a></li>
</ol>


<h3><a href="#sec3">技术能力</a></h3>

<ol>
<li><a href="#rule14">原则14：不要堆砌技术名词</a></li>
<li><a href="#rule15">原则15：对技术进行分类</a></li>
<li><a href="#rule16">原则16：使用正确的技术名称</a></li>
<li><a href="#rule17">原则17：不要写电脑能力</a></li>
<li><a href="#rule18">原则18：按照熟悉程度对技术能力进行排序</a></li>
<li><a href="#rule19">原则19：不要写过于特定的技术</a></li>
<li><a href="#rule20">原则20：谨慎使用精通</a></li>
<li><a href="#rule21">原则21：使用项目经验印证技术能力</a></li>
</ol>


<h3><a href="#sec4">项目经历</a></h3>

<ol>
<li><a href="#rule22">原则22：按照时间对项目经历排序</a></li>
<li><a href="#rule23">原则23：不要列出过多的项目</a></li>
<li><a href="#rule24">原则24：强调成果而非过程</a></li>
<li><a href="#rule25">原则25：使用量化结果而非抽象描述</a></li>
<li><a href="#rule26">原则26：强调影响力和复杂度</a></li>
</ol>


<h3><a href="#sec5">教育背景</a></h3>

<ol>
<li><a href="#rule27">原则27：不要写大学之前的教育经历</a></li>
<li><a href="#rule28">原则28：不要写课程列表</a></li>
<li><a href="#rule29">原则29：考虑使用成绩或排名</a></li>
<li><a href="#rule30">原则30：考虑使用导师（老师）的评语</a></li>
<li><a href="#rule31">原则31：考虑使用学业相关的奖项</a></li>
</ol>


<h3><a href="#sec6">个人爱好</a></h3>

<ol>
<li><a href="#rule32">原则32：避免写个人爱好</a></li>
</ol>


<h3><a href="#sec7">英文简历</a></h3>

<ol>
<li><a href="#rule33">原则33：不要出现拼写错误</a></li>
<li><a href="#rule34">原则34：不要使用全角字符</a></li>
<li><a href="#rule35">原则35：使用正确的词汇</a></li>
<li><a href="#rule36">原则36：使用简洁的句子</a></li>
<li><a href="#rule37">原则37：避免中式英语</a></li>
<li><a href="#rule38">原则38：使用一致的时态</a></li>
<li><a href="#rule39">原则39：考虑提供缩写词的解释</a></li>
<li><a href="#rule40">原则40：使用Bullets组织长段</a></li>
<li><a href="#rule41">原则41：打下良好的英文基础</a></li>
</ol>


<h3><a href="#sec8">其它</a></h3>

<ol>
<li><a href="#rule42">原则42：考虑使用超链接</a></li>
<li><a href="#rule43">原则43：考虑提供一个“加强版”简历</a></li>
<li><a href="#rule44">原则44：考虑提供开发社区账号</a></li>
<li><a href="#rule45">原则45：持续更新简历</a></li>
<li><a href="#rule46">原则46：不断提升个人能力</a></li>
<li><a href="#rule47">原则47：考虑征求他人意见</a></li>
</ol>


<h2>参考</h2>

<p>书籍：</p>

<ol>
<li><a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X/">Cracking the Coding Interview: 150 Programming Questions and Solutions</a></li>
<li><a href="http://www.amazon.com/The-Google-Resume-Prepare-Microsoft/dp/0470927623/">The Google Resume: How to Prepare for a Career and Land a Job at Apple, Microsoft, Google, or any Top Tech Company</a></li>
<li><a href="http://www.amazon.com/Land-Tech-Love-Pragmatic-Life/dp/1934356263/">Land the Tech Job You Love</a></li>
<li><a href="http://www.amazon.cn/%E5%8C%97%E4%BA%AC%E5%A4%96%E5%9B%BD%E8%AF%AD%E5%A4%A7%E5%AD%A6%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E6%8C%87%E5%AE%9A%E5%8F%82%E8%80%83%E7%94%A8%E4%B9%A6-%E4%B8%AD%E5%BC%8F%E8%8B%B1%E8%AF%AD%E4%B9%8B%E9%89%B4-%E5%B9%B3%E5%8D%A1%E5%A7%86/dp/B005NPZZYS/">中式英语之鉴</a></li>
<li><a href="http://www.amazon.com/Practical-English-Usage-Michael-Swan/dp/0194420981/">Practical English Usage</a></li>
</ol>


<p>链接：</p>

<ol>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人</a></li>
<li><a href="http://www.weibo.com/p/1001603769729557894059">英文简历咨询服务</a>：再次谢谢关注者的简历！</li>
</ol>


<hr />

<p>以上。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/lean-technical-resume">精益技术简历之道</a>, <a href="http://zh.lucida.me/blog/lean-technical-resume">http://zh.lucida.me/blog/lean-technical-resume</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）]]></title>
    <link href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features/"/>
    <updated>2014-10-23T23:54:02-07:00</updated>
    <id>http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法）</a></li>
<li>深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</li>
<li>深入理解Java 8 Lambda（原理篇——Java编译器如何处理lambda）</li>
</ol>


<h2>关于</h2>

<p>本文是深入理解Java 8 Lambda系列的第一篇，主要介绍Java 8新增的语言特性（比如lambda和方法引用），语言概念（比如目标类型和变量捕获）以及设计思路。</p>

<p>本文是对<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>一文的翻译，那么问题来了：</p>

<h3>为什么要写（翻译）这个系列？</h3>

<!-- more -->


<ol>
<li>工作之后，我开始大量使用Java</li>
<li>公司将会在不久的未来使用Java 8</li>
<li>作为资质平庸的开发者，我需要打一点提前量，以免到时拙计</li>
<li>为了学习Java 8（主要是其中的lambda及相关库），我先后阅读了Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>，<a href="http://www.amazon.com/Cay-S.-Horstmann/e/B000AQ1QDY/">Cay Horstmann</a>（<a href="http://www.amazon.com/Core-Volume-I--Fundamentals-Edition-Series/dp/0137081898/">Core Java</a>的作者）的<a href="http://www.amazon.com/Java-SE8-Really-Impatient-Course/dp/0321927761/">Java 8 for the Really Impatient</a>和Richard Warburton的<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a></li>
<li>但我感到并没有多大收获，Oracle的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">官方文档</a>涉及了lambda表达式的每一个概念，但都是点到辄止；后两本书（尤其是<a href="http://www.amazon.com/Java-Lambdas-Pragmatic-Functional-Programming/dp/1449370772/">Java 8 Lambdas</a>）花了大量篇幅介绍Java lambda及其类库，但实质内容不多，读完了还是没有对Java lambda产生一个清晰的认识</li>
<li>关键在于这些文章和书都没有解决我对Java lambda的困惑，比如：

<ul>
<li>Java 8中的lambda为什么要设计成这样？（为什么要一个lambda对应一个接口？而不是Structural Typing？）</li>
<li>lambda和匿名类型的关系是什么？lambda是匿名对象的语法糖吗？</li>
<li>Java 8是如何对lambda进行类型推导的？它的类型推导做到了什么程度？</li>
<li>Java 8为什么要引入默认方法？</li>
<li>Java编译器如何处理lambda？</li>
<li>等等……</li>
</ul>
</li>
<li>之后我在Google搜索这些问题，然后就找到<a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a>的三篇关于Java lambda的文章（<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a>，<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-libraries-final.html">State of Lambda libraries version</a>和<a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">Translation of lambda</a>），读完之后上面的问题都得到了解决</li>
<li>为了加深理解，我决定翻译这一系列文章</li>
</ol>


<h3>警告（Caveats）</h3>

<p>如果你不知道什么是函数式编程，或者不了解<code>map</code>，<code>filter</code>，<code>reduce</code>这些常用的高阶函数，那么你不适合阅读本文，请先学习函数式编程基础（比如<a href="http://www.amazon.com/How-Design-Programs-Introduction-Programming/dp/0262062186/">这本书</a>）。</p>

<hr />

<h1><a href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html">State of Lambda</a> by <a href="http://www.oracle.com/us/technologies/java/briangoetzchief-188795.html">Brian Goetz</a></h1>

<blockquote><p>The high-level goal of Project Lambda is to enable programming patterns that require modeling code as data to be convenient and idiomatic in Java.</p></blockquote>

<h2>关于</h2>

<p>本文介绍了Java SE 8中新引入的lambda语言特性以及这些特性背后的设计思想。这些特性包括：</p>

<ul>
<li>lambda表达式（又被成为“闭包”或“匿名方法”）</li>
<li>方法引用和构造方法引用</li>
<li>扩展的目标类型和类型推导</li>
<li>接口中的默认方法和静态方法</li>
</ul>


<h2>1. 背景</h2>

<p>Java是一门面向对象编程语言。面向对象编程语言和函数式编程语言中的基本元素（Basic Values）都可以动态封装程序行为：面向对象编程语言使用带有方法的对象封装行为，函数式编程语言使用函数封装行为。但这个相同点并不明显，因为Java的对象往往比较“重量级”：实例化一个类型往往会涉及不同的类，并需要初始化类里的字段和方法。</p>

<p>不过有些Java对象只是对单个函数的封装。例如下面这个典型用例：Java API中定义了一个接口（一般被称为回调接口），用户通过提供这个接口的实例来传入指定行为，例如：</p>

<p><code>java
public interface ActionListener {
  void actionPerformed(ActionEvent e);
}
</code></p>

<p>这里并不需要专门定义一个类来实现<code>ActionListener</code>接口，因为它只会在调用处被使用一次。用户一般会使用匿名类型把行为内联（inline）：</p>

<p>```
button.addActionListener(new ActionListener) {
  public void actionPerformed(ActionEvent e) {</p>

<pre><code>ui.dazzle(e.getModifiers());
</code></pre>

<p>  }
}
```</p>

<p>很多库都依赖于上面的模式。对于并行API更是如此，因为我们需要把待执行的代码提供给并行API，并行编程是一个非常值得研究的领域，因为在这里摩尔定律得到了重生：尽管我们没有更快的CPU核心（core），但是我们有更多的CPU核心。而串行API就只能使用有限的计算能力。</p>

<p>随着回调模式和函数式编程风格的日益流行，我们需要在Java中提供一种尽可能轻量级的将代码封装为数据（Model code as data）的方法。匿名内部类并不是一个好的<a href="http://blogs.oracle.com/jrose/entry/better_closures">选择</a>，因为：</p>

<ol>
<li>语法过于冗余</li>
<li>匿名类中的<code>this</code>和变量名容易使人产生误解</li>
<li>类型载入和实例创建语义不够灵活</li>
<li>无法捕获非<code>final</code>的局部变量</li>
<li>无法对控制流进行抽象</li>
</ol>


<p>上面的多数问题均在Java SE 8中得以解决：</p>

<ul>
<li>通过提供更简洁的语法和局部作用域规则，Java SE 8彻底解决了问题1和问题2</li>
<li>通过提供更加灵活而且便于优化的表达式语义，Java SE 8绕开了问题3</li>
<li>通过允许编译器推断变量的“常量性”（finality），Java SE 8减轻了问题4带来的困扰</li>
</ul>


<p>不过，Java SE 8的目标并非解决所有上述问题。因此捕获可变变量（问题4）和非局部控制流（问题5）并不在Java SE 8的范畴之内。（尽管我们可能会在未来提供对这些特性的支持）</p>

<h2>2. 函数式接口（Functional interfaces）</h2>

<p>尽管匿名内部类有着种种限制和问题，但是它有一个良好的特性，它和Java类型系统结合的十分紧密：每一个函数对象都对应一个接口类型。之所以说这个特性是良好的，是因为：</p>

<ul>
<li>接口是Java类型系统的一部分</li>
<li>接口天然就拥有其运行时表示（Runtime representation）</li>
<li>接口可以通过Javadoc注释来表达一些非正式的协定（contract），例如，通过注释说明该操作应可交换（commutative）</li>
</ul>


<p>上面提到的<code>ActionListener</code>接口只有一个方法，大多数回调接口都拥有这个特征：比如<code>Runnable</code>接口和<code>Comparator</code>接口。我们把这些只拥有一个方法的接口称为<em>函数式接口</em>。（之前它们被称为<em>SAM类型</em>，即<em>单抽象方法类型</em>（Single Abstract Method））</p>

<p>我们并不需要额外的工作来声明一个接口是函数式接口：编译器会根据接口的结构自行判断（判断过程并非简单的对接口方法计数：一个接口可能冗余的定义了一个<code>Object</code>已经提供的方法，比如<code>toString()</code>，或者定义了静态方法或默认方法，这些都不属于函数式接口方法的范畴）。不过API作者们可以通过<code>@FunctionalInterface</code>注解来显式指定一个接口是函数式接口（以避免无意声明了一个符合函数式标准的接口），加上这个注解之后，编译器就会验证该接口是否满足函数式接口的要求。</p>

<p>实现函数式类型的另一种方式是引入一个全新的<em>结构化</em>函数类型，我们也称其为“箭头”类型。例如，一个接收<code>String</code>和<code>Object</code>并返回<code>int</code>的函数类型可以被表示为<code>(String, Object) -&gt; int</code>。我们仔细考虑了这个方式，但出于下面的原因，最终将其否定：</p>

<ul>
<li>它会为Java类型系统引入额外的复杂度，并带来<a href="http://en.wikipedia.org/wiki/Structural_type_system">结构类型（Structural Type）</a>和<a href="http://en.wikipedia.org/wiki/Nominal_type_system">指名类型（Nominal Type）</a>的混用。（Java几乎全部使用指名类型）</li>
<li>它会导致类库风格的分歧——一些类库会继续使用回调接口，而另一些类库会使用结构化函数类型</li>
<li>它的语法会变得十分笨拙，尤其在包含受检异常（checked exception）之后</li>
<li>每个函数类型很难拥有其运行时表示，这意味着开发者会受到<a href="http://en.wikipedia.org/wiki/Type_erasure">类型擦除（erasure）</a>的困扰和局限。比如说，我们无法对方法<code>m(T-&gt;U)</code>和<code>m(X-&gt;Y)</code>进行重载（Overload）</li>
</ul>


<p>所以我们选择了“使用已知类型”这条路——因为现有的类库大量使用了函数式接口，通过沿用这种模式，我们使得现有类库能够直接使用lambda表达式。例如下面是Java SE 7中已经存在的函数式接口：</p>

<ul>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html">java.lang.Runnable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html">java.security.PrivilegedAction</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html">java.util.Comparator</a></li>
<li><a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html">java.io.FileFilter</a></li>
<li><a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html">java.beans.PropertyChangeListener</a></li>
</ul>


<p>除此之外，Java SE 8中增加了一个新的包：<code>java.util.function</code>，它里面包含了常用的函数式接口，例如：</p>

<ul>
<li><code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code></li>
<li><code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象，不返回值</li>
<li><code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象，返回<code>R</code>对象</li>
<li><code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂），不接收值</li>
<li><code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象，返回<code>T</code>对象</li>
<li><code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象，返回<code>T</code>对象</li>
</ul>


<p>除了上面的这些基本的函数式接口，我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口，例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>。（我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口，如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口，例如<code>BiFunction&lt;T, U, R&gt;</code>，它接收<code>T</code>对象和<code>U</code>对象，返回<code>R</code>对象。</p>

<h2>3. lambda表达式（lambda expressions）</h2>

<p>匿名类型最大的问题就在于其冗余的语法。有人戏称匿名类型导致了“高度问题”（height problem）：比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作。</p>

<p>lambda表达式是匿名方法，它提供了轻量级的语法，从而解决了匿名内部类带来的“高度问题”。</p>

<p>下面是一些lambda表达式：</p>

<p><code>
(int x, int y) -&gt; x + y
() -&gt; 42
(String s) -&gt; { System.out.println(s); }
</code></p>

<p>第一个lambda表达式接收<code>x</code>和<code>y</code>这两个整形参数并返回它们的和；第二个lambda表达式不接收参数，返回整数'42'；第三个lambda表达式接收一个字符串并把它打印到控制台，不返回值。</p>

<p>lambda表达式的语法由参数列表、箭头符号<code>-&gt;</code>和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样——

<ul>
<li><code>return</code>语句会把控制权交给匿名方法的调用者</li>
<li><code>break</code>和<code>continue</code>只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须返回值</li>
</ul>
</li>
</ul>


<p>表达式函数体适合小型lambda表达式，它消除了<code>return</code>关键字，使得语法更加简洁。</p>

<p>lambda表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使lambda表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<p>下面是一些出现在语句中的lambda表达式：</p>

<p>```
FileFilter java = (File f) &ndash;> f.getName().endsWith(&ldquo;*.java&rdquo;);</p>

<p>String user = doPrivileged(() &ndash;> System.getProperty(&ldquo;user.name&rdquo;));</p>

<p>new Thread(() &ndash;> {
  connectToService();
  sendNotification();
}).start();
```</p>

<h2>4. 目标类型（Target typing）</h2>

<p>需要注意的是，函数式接口的名称并不是lambda表达式的一部分。那么问题来了，对于给定的lambda表达式，它的类型是什么？答案是：它的类型是由其上下文推导而来。例如，下面代码中的lambda表达式类型是<code>ActionListener</code>：</p>

<p><code>
ActionListener l = (ActionEvent e) -&gt; ui.dazzle(e.getModifiers());
</code></p>

<p>这就意味着同样的lambda表达式在不同上下文里可以拥有不同的类型：</p>

<p>```
Callable<String> c = () &ndash;> &ldquo;done&rdquo;;</p>

<p>PrivilegedAction<String> a = () &ndash;> &ldquo;done&rdquo;;
```</p>

<p>第一个lambda表达式<code>() -&gt; "done"</code>是<code>Callable</code>的实例，而第二个lambda表达式则是<code>PrivilegedAction</code>的实例。</p>

<p>编译器负责推导lambda表达式的类型。它利用lambda表达式所在上下文<strong>所期待的类型</strong>进行推导，这个<strong>被期待的类型</strong>被称为<em>目标类型</em>。lambda表达式只能出现在目标类型为函数式接口的上下文中。</p>

<p>当然，lambda表达式对目标类型也是有要求的。编译器会检查lambda表达式的类型和目标类型的方法签名（method signature）是否一致。当且仅当下面所有条件均满足时，lambda表达式才可以被赋给目标类型<code>T</code>：</p>

<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数和<code>T</code>的方法参数在数量和类型上一一对应</li>
<li>lambda表达式的返回值和<code>T</code>的方法返回值相兼容（Compatible）</li>
<li>lambda表达式内所抛出的异常和<code>T</code>的方法<code>throws</code>类型相兼容</li>
</ul>


<p>由于目标类型（函数式接口）已经“知道”lambda表达式的形式参数（Formal parameter）类型，所以我们没有必要把已知类型再重复一遍。也就是说，lambda表达式的参数类型可以从目标类型中得出：</p>

<p><code>
Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);
</code></p>

<p>在上面的例子里，编译器可以推导出<code>s1</code>和<code>s2</code>的类型是<code>String</code>。此外，当lambda的参数只有一个而且它的类型可以被推导得知时，该参数列表外面的括号可以被省略：</p>

<p>```
FileFilter java = f &ndash;> f.getName().endsWith(&ldquo;.java&rdquo;);</p>

<p>button.addActionListener(e &ndash;> ui.dazzle(e.getModifiers()));
```</p>

<p>这些改进进一步展示了我们的设计目标：“不要把高度问题转化成宽度问题。”我们希望语法元素能够尽可能的少，以便代码的读者能够直达lambda表达式的核心部分。</p>

<p>lambda表达式并不是第一个拥有上下文相关类型的Java表达式：泛型方法调用和“菱形”构造器调用也通过目标类型来进行类型推导：</p>

<p>```
List<String> ls = Collections.emptyList();
List<Integer> li = Collections.emptyList();</p>

<p>Map&lt;String, Integer> m1 = new HashMap&lt;>();
Map&lt;Integer, String> m2 = new HashMap&lt;>();
```</p>

<h2>5. 目标类型的上下文（Contexts for target typing）</h2>

<p>之前我们提到lambda表达式智能出现在拥有目标类型的上下文中。下面给出了这些带有目标类型的上下文：</p>

<ul>
<li>变量声明</li>
<li>赋值</li>
<li>返回语句</li>
<li>数组初始化器</li>
<li>方法和构造方法的参数</li>
<li>lambda表达式函数体</li>
<li>条件表达式（<code>? :</code>）</li>
<li>转型（Cast）表达式</li>
</ul>


<p>在前三个上下文（变量声明、赋值和返回语句）里，目标类型即是被赋值或被返回的类型：</p>

<p>```
Comparator<String> c;
c = (String s1, String s2) &ndash;> s1.compareToIgnoreCase(s2);</p>

<p>public Runnable toDoLater() {
  return () &ndash;> {</p>

<pre><code>System.out.println("later");
</code></pre>

<p>  }
}
```</p>

<p>数组初始化器和赋值类似，只是这里的“变量”变成了数组元素，而类型是从数组类型中推导得知：</p>

<p>```
filterFiles(new FileFilter[] {</p>

<pre><code>          f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith("q")
        });
</code></pre>

<p>```</p>

<p>方法参数的类型推导要相对复杂些：目标类型的确认会涉及到其它两个语言特性：重载解析（Overload resolution）和参数类型推导（Type argument inference）。</p>

<p>重载解析会为一个给定的方法调用（method invocation）寻找最合适的方法声明（method declaration）。由于不同的声明具有不同的签名，当lambda表达式作为方法参数时，重载解析就会影响到lambda表达式的目标类型。编译器会通过它所得之的信息来做出决定。如果lambda表达式具有<strong>显式类型</strong>（参数类型被显式指定），编译器就可以直接 使用lambda表达式的返回类型；如果lambda表达式具有<strong>隐式类型</strong>（参数类型被推导而知），重载解析则会忽略lambda表达式函数体而只依赖lambda表达式参数的数量。</p>

<p>如果在解析方法声明时存在二义性（ambiguous），我们就需要利用转型（cast）或显式lambda表达式来提供更多的类型信息。如果lambda表达式的返回类型依赖于其参数的类型，那么lambda表达式函数体有可能可以给编译器提供额外的信息，以便其推导参数类型。</p>

<p><code>
List&lt;Person&gt; ps = ...
Stream&lt;String&gt; names = ps.stream().map(p -&gt; p.getName());
</code></p>

<p>在上面的代码中，<code>ps</code>的类型是<code>List&lt;Person&gt;</code>，所以<code>ps.stream()</code>的返回类型是<code>Stream&lt;Person&gt;</code>。<code>map()</code>方法接收一个类型为<code>Function&lt;T, R&gt;</code>的函数式接口，这里<code>T</code>的类型即是<code>Stream</code>元素的类型，也就是<code>Person</code>，而<code>R</code>的类型未知。由于在重载解析之后lambda表达式的目标类型仍然未知，我们就需要推导<code>R</code>的类型：通过对lambda表达式函数体进行类型检查，我们发现函数体返回<code>String</code>，因此<code>R</code>的类型是<code>String</code>，因而<code>map()</code>返回<code>Stream&lt;String&gt;</code>。绝大多数情况下编译器都能解析出正确的类型，但如果碰到无法解析的情况，我们则需要：</p>

<ul>
<li>使用显式lambda表达式（为参数<code>p</code>提供显式类型）以提供额外的类型信息</li>
<li>把lambda表达式转型为<code>Function&lt;Person, String&gt;</code></li>
<li>为泛型参数<code>R</code>提供一个实际类型。（<code>.&lt;String&gt;map(p -&gt; p.getName())</code>）</li>
</ul>


<p>lambda表达式本身也可以为它自己的函数体提供目标类型，也就是说lambda表达式可以通过外部目标类型推导出其内部的返回类型，这意味着我们可以方便的编写一个返回函数的函数：</p>

<p><code>
Supplier&lt;Runnable&gt; c = () -&gt; () -&gt; { System.out.println("hi"); };
</code></p>

<p>类似的，条件表达式可以把目标类型“分发”给其子表达式：</p>

<p><code>
Callable&lt;Integer&gt; c = flag ? (() -&gt; 23) : (() -&gt; 42);
</code></p>

<p>最后，转型表达式（Cast expression）可以显式提供lambda表达式的类型，这个特性在无法确认目标类型时非常有用：</p>

<p><code>
// Object o = () -&gt; { System.out.println("hi"); }; 这段代码是非法的
Object o = (Runnable) () -&gt; { System.out.println("hi"); };
</code></p>

<p>除此之外，当重载的方法都拥有函数式接口时，转型可以帮助解决重载解析时出现的二义性。</p>

<p>目标类型这个概念不仅仅适用于lambda表达式，泛型方法调用和“菱形”构造方法调用也可以从目标类型中受益，下面的代码在Java SE 7是非法的，但在Java SE 8中是合法的：</p>

<p>```
List<String> ls = Collections.checkedList(new ArrayList&lt;>(), String.class);</p>

<p>Set<Integer> si = flag ? Collections.singleton(23) : Collections.emptySet();
```</p>

<h2>6. 词法作用域（Lexical scoping）</h2>

<p>在内部类中使用变量名（以及<code>this</code>）非常容易出错。内部类中通过继承得到的成员（包括来自<code>Object</code>的方法）可能会把外部类的成员掩盖（shadow），此外未限定（unqualified）的<code>this</code>引用会指向内部类自己而非外部类。</p>

<p>相对于内部类，lambda表达式的语义就十分简单：它不会从超类（supertype）中继承任何变量名，也不会引入一个新的作用域。lambda表达式基于词法作用域，也就是说lambda表达式函数体里面的变量和它外部环境的变量具有相同的语义（也包括lambda表达式的形式参数）。此外，'this'关键字及其引用在lambda表达式内部和外部也拥有相同的语义。</p>

<p>为了进一步说明词法作用域的优点，请参考下面的代码，它会把<code>"Hello, world!"</code>打印两遍：</p>

<p>```
public class Hello {
  Runnable r1 = () &ndash;> { System.out.println(this); }
  Runnable r2 = () &ndash;> { System.out.println(toString()); }</p>

<p>  public String toString() {  return &ldquo;Hello, world&rdquo;; }</p>

<p>  public static void main(String&hellip; args) {</p>

<pre><code>new Hello().r1.run();
new Hello().r2.run();
</code></pre>

<p>  }
}
```</p>

<p>与之相类似的内部类实现则会打印出类似<code>Hello$1@5b89a773</code>和<code>Hello$2@537a7706</code>之类的字符串，这往往会使开发者大吃一惊。</p>

<p>基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文中的局部变量，它的行为和那些拥有参数的控制流结构（例如<code>for</code>循环和<code>catch</code>从句）一致。</p>

<p><strong>个人补充</strong>：这个说法很拗口，所以我在这里加一个例子以演示词法作用域：</p>

<p><code>
int i = 0;
int sum = 0;
for (int i = 1; i &lt; 10; i += 1) { //这里会出现编译错误，因为i已经在for循环外部声明过了
  sum += i;
}
</code></p>

<h2>7. 变量捕获（Variable capture）</h2>

<p>在Java SE 7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。我们现在放宽了这个限制——对于lambda表达式和内部类，我们允许在其中捕获那些符合<em>有效只读</em>（Effectively final）的局部变量。</p>

<p>简单的说，如果一个局部变量在初始化后从未被修改过，那么它就符合有效只读的要求，换句话说，加上<code>final</code>后也不会导致编译错误的局部变量就是有效只读变量。</p>

<p><code>
Callable&lt;String&gt; helloCallable(String name) {
  String hello = "Hello";
  return () -&gt; (hello + ", " + name);
}
</code></p>

<p>对<code>this</code>的引用，以及通过<code>this</code>对未限定字段的引用和未限定方法的调用在本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其它情况下，lambda对象不会保留任何对<code>this</code>的引用。</p>

<p>这个特性对内存管理是一件好事：内部类实例会一直保留一个对其外部类实例的强引用，而那些没有捕获外部类成员的lambda表达式则不会保留对外部类实例的引用。要知道内部类的这个特性往往会造成内存泄露。</p>

<p>尽管我们放宽了对捕获变量的语法限制，但试图修改捕获变量的行为仍然会被禁止，比如下面这个例子就是非法的：</p>

<p><code>
int sum = 0;
list.forEach(e -&gt; { sum += e.size(); });
</code></p>

<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起race condition。除非我们能够强制（最好是在编译时）这样的函数不能离开其当前线程，但如果这么做了可能会导致更多的问题。简而言之，lambda表达式对<em>值</em>封闭，对<em>变量</em>开放。</p>

<p><strong>个人补充</strong>：lambda表达式对<em>值</em>封闭，对<em>变量</em>开放的原文是：lambda expressions close over <em>values</em>, not <em>variables</em>，我在这里增加一个例子以说明这个特性：</p>

<p>```
int sum = 0;
list.forEach(e &ndash;> { sum += e.size(); }); // Illegal, close over values</p>

<p>List<Integer> aList = new List&lt;>();
list.forEach(e &ndash;> { aList.add(e); }); // Legal, open over variables
```</p>

<p>lambda表达式不支持修改捕获变量的另一个原因是我们可以使用更好的方式来实现同样的效果：使用规约（reduction）。<code>java.util.stream</code>包提供了各种通用的和专用的规约操作（例如<code>sum</code>、<code>min</code>和<code>max</code>），就上面的例子而言，我们可以使用规约操作（在串行和并行下都是安全的）来代替<code>forEach</code>：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .sum();
</code></pre>

<p>```</p>

<p><code>sum()</code>等价于下面的规约操作：</p>

<p>```
int sum = list.stream()</p>

<pre><code>          .mapToInt(e -&gt; e.size())
          .reduce(0 , (x, y) -&gt; x + y);
</code></pre>

<p>```</p>

<p>规约需要一个初始值（以防输入为空）和一个操作符（在这里是加号），然后用下面的表达式计算结果：</p>

<p><code>
0 + list[0] + list[1] + list[2] + ...
</code></p>

<p>规约也可以完成其它操作，比如求最小值、最大值和乘积等等。如果操作符具有可结合性（associative），那么规约操作就可以容易的被并行化。所以，与其支持一个本质上是并行而且容易导致race condition的操作，我们选择在库中提供一个更加并行友好且不容易出错的方式来进行累积（accumulation）。</p>

<h2>8. 方法引用（Method references）</h2>

<p>lambda表达式允许我们定义一个匿名方法，并允许我们以函数式接口的方式使用它。我们也希望能够在<em>已有的</em>方法上实现同样的特性。</p>

<p>方法引用和lambda表达式拥有相同的特性（例如，它们都需要一个目标类型，并需要被转化为函数式接口的实例），不过我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有方法。</p>

<p>以下面的代码为例，假设我们要按照<code>name</code>或<code>age</code>为<code>Person</code>数组进行排序：</p>

<p>```
class Person {
  private final String name;
  private final int age;</p>

<p>  public int getAge() { return age; }
  public String getName() {return name; }
  &hellip;
}</p>

<p>Person[] people = &hellip;
Comparator<Person> byName = Comparator.comparing(p &ndash;> p.getName());
Arrays.sort(people, byName);
```</p>

<p>在这里我们可以用方法引用代替lambda表达式：</p>

<p><code>
Comparator&lt;Person&gt; byName = Comparator.comparing(Person::getName);
</code></p>

<p>这里的<code>Person::getName</code>可以被看作为lambda表达式的简写形式。尽管方法引用不一定（比如在这个例子里）会把语法变的更紧凑，但它拥有更明确的语义——如果我们想要调用的方法拥有一个名字，我们就可以通过它的名字直接调用它。</p>

<p>因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：</p>

<p><code>
Consumer&lt;Integer&gt; b1 = System::exit;    // void exit(int status)
Consumer&lt;String[]&gt; b2 = Arrays:sort;    // void sort(Object[] a)
Consumer&lt;String&gt; b3 = MyProgram::main;  // void main(String... args)
Runnable r = Myprogram::mapToInt        // void main(String... args)
</code></p>

<h2>9. 方法引用的种类（Kinds of method references）</h2>

<p>方法引用有很多种，它们的语法如下：</p>

<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例上的实例方法引用：<code>instanceReference::methodName</code></li>
<li>超类上的实例方法引用：<code>super::methodName</code></li>
<li>类型上的实例方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>Class::new</code></li>
<li>数组构造方法引用：<code>TypeName[]::new</code></li>
</ul>


<p>对于静态方法引用，我们需要在类名和方法名之间加入<code>::</code>分隔符，例如<code>Integer::sum</code>。</p>

<p>对于具体对象上的实例方法引用，我们则需要在对象名和方法名之间加入分隔符：</p>

<p><code>
Set&lt;String&gt; knownNames = ...
Predicate&lt;String&gt; isKnown = knownNames::contains;
</code></p>

<p>这里的隐式lambda表达式（也就是实例方法引用）会从<code>knownNames</code>中捕获<code>String</code>对象，而它的方法体则会通过<code>Set.contains</code>使用该<code>String</code>对象。</p>

<p>有了实例方法引用，在不同函数式接口之间进行类型转换就变的很方便：</p>

<p><code>
Callable&lt;Path&gt; c = ...
Privileged&lt;Path&gt; a = c::call;
</code></p>

<p>引用任意对象的实例方法则需要在实例方法名称和其所属类型名称间加上分隔符：</p>

<p><code>
Function&lt;String, String&gt; upperfier = String::toUpperCase;
</code></p>

<p>这里的隐式lambda表达式（即<code>String::toUpperCase</code>实例方法引用）有一个<code>String</code>参数，这个参数会被<code>toUpperCase</code>方法使用。</p>

<p>如果类型的实例方法是泛型的，那么我们就需要在<code>::</code>分隔符前提供类型参数，或者（多数情况下）利用目标类型推导出其类型。</p>

<p>需要注意的是，静态方法引用和类型上的实例方法引用拥有一样的语法。编译器会根据实际情况做出决定。</p>

<p>一般我们不需要指定方法引用中的参数类型，因为编译器往往可以推导出结果，但如果需要我们也可以显式在<code>::</code>分隔符之前提供参数类型信息。</p>

<p>和静态方法引用类似，构造方法也可以通过<code>new</code>关键字被直接引用：</p>

<p><code>
SocketImplFactory factory = MySocketImpl::new;
</code></p>

<p>如果类型拥有多个构造方法，那么我们就会通过目标类型的方法参数来选择最佳匹配，这里的选择过程和调用构造方法时的选择过程是一样的。</p>

<p>如果待实例化的类型是泛型的，那么我们可以在类型名称之后提供类型参数，否则编译器则会依照"菱形"构造方法调用时的方式进行推导。</p>

<p>数组的构造方法引用的语法则比较特殊，为了便于理解，你可以假想存在一个接收<code>int</code>参数的数组构造方法。参考下面的代码：</p>

<p><code>
IntFunction&lt;int[]&gt; arrayMaker = int[]::new;
int[] array = arrayMaker.apply(10) // 创建数组 int[10]
</code></p>

<h2>10. 默认方法和静态接口方法（Default and static interface methods）</h2>

<p>lambda表达式和方法引用大大提升了Java的表达能力（expressiveness），不过为了使把<em>代码即数据</em>（code-as-data）变的更加容易，我们需要把这些特性融入到已有的库之中，以便开发者使用。</p>

<p>Java SE 7时代为一个已有的类库增加功能是非常困难的。具体的说，接口在发布之后就已经被定型，除非我们能够一次性更新所有该接口的实现，否则向接口添加方法就会破坏现有的接口实现。<em>默认方法</em>（之前被称为<em>虚拟扩展方法</em>或<em>守护方法</em>）的目标即是解决这个问题，使得接口在发布之后仍能被逐步演化。</p>

<p>这里给出一个例子，我们需要在标准集合API中增加针对lambda的方法。例如<code>removeAll</code>方法应该被泛化为接收一个函数式接口<code>Predicate</code>，但这个新的方法应该被放在哪里呢？我们无法直接在<code>Collection</code>接口上新增方法——不然就会破坏现有的<code>Collection</code>实现。我们倒是可以在<code>Collections</code>工具类中增加对应的静态方法，但这样就会把这个方法置于“二等公民”的境地。</p>

<p><em>默认方法</em>利用面向对象的方式向接口增加新的行为。它是一种新的方法：接口方法可以是<em>抽象的</em>或是<em>默认的</em>。默认方法拥有其默认实现，实现接口的类型通过继承得到该默认实现（如果类型没有覆盖该默认实现）。此外，默认方法不是抽象方法，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口的单抽象方法限制。</p>

<p>下面的例子展示了如何向<code>Iterator</code>接口增加默认方法<code>skip</code>：</p>

<p>```
interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();</p>

<p>  default void skip(int i) {</p>

<pre><code>for ( ; i &gt; 0 &amp;&amp; hasNext(); i -= 1) next();
</code></pre>

<p>  }
}
```</p>

<p>根据上面的<code>Iterator</code>定义，所有实现<code>Iterator</code>的类型都会自动继承<code>skip</code>方法。在使用者的眼里，<code>skip</code>不过是接口新增的一个虚拟方法。在没有覆盖<code>skip</code>方法的<code>Iterator</code>子类实例上调用<code>skip</code>会执行<code>skip</code>的默认实现：调用<code>hasNext</code>和<code>next</code>若干次。子类可以通过覆盖<code>skip</code>来提供更好的实现——比如直接移动游标（cursor），或是提供为操作提供原子性（Atomicity）等。</p>

<p>当接口继承其它接口时，我们既可以为它所继承而来的抽象方法提供一个默认实现，也可以为它继承而来的默认方法提供一个新的实现，还可以把它继承而来的默认方法重新抽象化。</p>

<p>除了默认方法，Java SE 8还在允许在接口中定义<em>静态</em>方法。这使得我们可以从接口直接调用和它相关的辅助方法（Helper method），而不是从其它的类中调用（之前这样的类往往以对应接口的复数命名，例如<code>Collections</code>）。比如，我们一般需要使用静态辅助方法生成实现<code>Comparator</code>的比较器，在Java SE 8中我们可以直接把该静态方法定义在<code>Comparator</code>接口中：</p>

<p>```
public static &lt;T, U extends Comparable&lt;? super U>></p>

<pre><code>Comparator&lt;T&gt; comparing(Function&lt;T, U&gt; keyExtractor) {
</code></pre>

<p>  return (c1, c2) &ndash;> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
}
```</p>

<h2>11. 继承默认方法（Inheritance of default methods）</h2>

<p>和其它方法一样，默认方法也可以被继承，大多数情况下这种继承行为和我们所期待的一致。不过，当类型或者接口的超类拥有多个具有相同签名的方法时，我们就需要一套规则来解决这个冲突：</p>

<ul>
<li>类的方法（class method）声明优先于接口默认方法。无论该方法是具体的还是抽象的。</li>
<li>被其它类型所覆盖的方法会被忽略。这条规则适用于超类型共享一个公共祖先的情况。</li>
</ul>


<p>为了演示第二条规则，我们假设<code>Collection</code>和<code>List</code>接口均提供了<code>removeAll</code>的默认实现，然后<code>Queue</code>继承并覆盖了<code>Collection</code>中的默认方法。在下面的<code>implement</code>从句中，<code>List</code>中的方法声明会优先于<code>Queue</code>中的方法声明：</p>

<p><code>
class LinkedList&lt;E&gt; implements List&lt;E&gt;, Queue&lt;E&gt; { ... }
</code></p>

<p>当两个独立的默认方法相冲突或是默认方法和抽象方法相冲突时会产生编译错误。这时程序员需要显式覆盖超类方法。一般来说我们会定义一个默认方法，然后在其中显式选择超类方法：</p>

<p><code>
interface Robot implements Artist, Gun {
  default void draw() { Artist.super.draw(); }
}
</code></p>

<p><code>super</code>前面的类型必须是有定义或继承默认方法的类型。这种方法调用并不只限于消除命名冲突——我们也可以在其它场景中使用它。</p>

<p>最后，接口在<code>inherits</code>和<code>extends</code>从句中的声明顺序和它们被实现的顺序无关。</p>

<h2>12. 融会贯通（Putting it together）</h2>

<p>我们在设计lambda时的一个重要目标就是新增的语言特性和库特性能够无缝结合（designed to work together）。接下来，我们通过一个实际例子（按照姓对名字列表进行排序）来演示这一点：</p>

<p>比如说下面的代码：</p>

<p>```
List<Person> people = &hellip;
Collections.sort(people, new Comparator<Person>() {
  public int compare(Person x, Person y) {</p>

<pre><code>return x.getLastName().compareTo(y.getLastName());
</code></pre>

<p>  }
})
```</p>

<p>冗余代码实在太多了！</p>

<p>有了lambda表达式，我们可以去掉冗余的匿名类：</p>

<p>```
Collections.sort(people,</p>

<pre><code>             (Person x, Person y) -&gt; x.getLastName().compareTo(y.getLastName()));
</code></pre>

<p>```</p>

<p>尽管代码简洁了很多，但它的抽象程度依然很差：开发者仍然需要进行实际的比较操作（而且如果比较的值是原始类型那么情况会更糟），所以我们要借助<code>Comparator</code>里的<code>comparing</code>方法实现比较操作：</p>

<p><code>
Collections.sort(people, Comparator.comparing((Person p) -&gt; p.getLastName()));
</code></p>

<p>在类型推导和静态导入的帮助下，我们可以进一步简化上面的代码：</p>

<p><code>
Collections.sort(people, comparing(p -&gt; p.getLastName()));
</code></p>

<p>我们注意到这里的lambda表达式实际上是<code>getLastName</code>的代理（forwarder），于是我们可以用方法引用代替它：</p>

<p><code>
Collections.sort(people, comparing(Person::getLastName));
</code></p>

<p>最后，使用<code>Collections.sort</code>这样的辅助方法并不是一个好主意：它不但使代码变的冗余，也无法为实现<code>List</code>接口的数据结构提供特定（specialized）的高效实现，而且由于<code>Collections.sort</code>方法不属于<code>List</code>接口，用户在阅读<code>List</code>接口的文档时不会察觉在另外的<code>Collections</code>类中还有一个针对<code>List</code>接口的排序（<code>sort()</code>）方法。</p>

<p>默认方法可以有效的解决这个问题，我们为<code>List</code>增加默认方法<code>sort()</code>，然后就可以这样调用：</p>

<p><code>
people.sort(comparing(Person::getLastName));;
</code></p>

<p>此外，如果我们为<code>Comparator</code>接口增加一个默认方法<code>reversed()</code>（产生一个逆序比较器），我们就可以非常容易的在前面代码的基础上实现降序排序。</p>

<p><code>
people.sort(comparing(Person::getLastName).reversed());;
</code></p>

<h2>13. 小结（Summary）</h2>

<p>Java SE 8提供的新语言特性并不算多——lambda表达式，方法引用，默认方法和静态接口方法，以及范围更广的类型推导。但是把它们结合在一起之后，开发者可以编写出更加清晰简洁的代码，类库编写者可以编写更加强大易用的并行类库。</p>

<p>未完待续——</p>

<p>下篇：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-library-features">深入理解Java 8 Lambda（类库篇——Streams API，Collector和并行）</a></p>

<hr />

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features">http://zh.lucida.me/blog/java-8-lambdas-insideout-language-features</a></p>

<p>本文谢绝转载，如需转载需征得作者本人同意，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Top Coder算法题目浏览器]]></title>
    <link href="http://zh.lucida.me/blog/top-code-offline-browser/"/>
    <updated>2014-10-14T23:37:29-07:00</updated>
    <id>http://zh.lucida.me/blog/top-code-offline-browser</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>

<h2>关于</h2>

<p><a href="http://weibo.com/haoel">左耳朵耗子</a>在最近发了一条关于leetcode的微博：</p>

<p><img src="http://i.imgur.com/alUuOmx.jpg" alt="微博截图" /></p>

<p>佩服之余，想起自己两年前找工作时随手写的一个小程序：Top Coder算法题目浏览器，硬盘里翻了翻没找到，于是找师弟要了一份copy，截了几张图放到微博上。</p>

<p><img src="http://i.imgur.com/bIiXNR4.jpg" alt="微博截图" /></p>

<p>没想到不少人表示很感兴趣，还有些同学留下邮箱索要这个算法题目浏览器——我是懒的一个个发邮箱，所以干脆放到博客上，顺便提高下访问量 :)</p>

<!-- more -->


<h2>介绍</h2>

<h3>TC Browser</h3>

<p><strong>TC Browser</strong>：全称<strong>Top Coder offline Browser</strong>，是我为了方便自己练习算法题目而花一下午制作的Windows小程序。</p>

<p><strong>TC Browser</strong>内置2933道算法题目，这些算法题目覆盖动态规划（Dynamic Programming）、递归（Recursion）、迭代（Iteration）、暴力（Brute Force）和图论（Graph Theory）等17个分类，并按照级别（Level）不同和难度（Success Rate）不同进行分类，以便从简单到复杂逐步练习。</p>

<h4>TC Browser可以</h4>

<ul>
<li>离线浏览算法题目 &ndash;_&ndash;</li>
<li>按照算法、级别和难度过滤题目，以便逐步提高水平。</li>
<li>随机出题 &ndash;_&ndash;</li>
</ul>


<h4>TC Browser不可以</h4>

<ul>
<li>评判（Judge）题目，如它的名字，TC Browser只是一个题目浏览器，而非一个完整的OJ（Online Judge）。不过好在TC题目的Sample Input/Output比较全。</li>
<li>提供答案（Answer），嗯，这些题目都没有答案，所以对于初学者可能不合适。</li>
</ul>


<h3>为什么选择<a href="http://www.topcoder.com/">Top Coder</a>？</h3>

<ol>
<li>大量的算法题目：<strong>TC Browser</strong>是我两年半前写的，当时有2933道题目，现在的题目只会更多。</li>
<li>题目具有良好的分类：Top Coder里的每道算法题目都有明确的分类：类型（Category）、级别（Level）、难度（Success Rate）。</li>
<li>良好的题目陈述（Problem Statement）：Top Coder的题目陈述非常清晰，并且都带有若干组示例输入/输出（Sample Input/Output）。</li>
<li>题目相对实际（Practical）：相对于一些OJ的纯算法题目，Top Coder里面的题目更加实际——更接近与实际的编程而非单纯的算法演练，对于非算法竞赛出身的我非常合适。</li>
<li>Top Coder在线不稳定：也许是我的网络原因，我经常登陆不进Top Coder，这也是我编写离线版TC的原因之一。</li>
</ol>


<h2>使用</h2>

<h3>Top Coder术语</h3>

<p>如果你玩过Top Coder，请跳过本节 :&ndash;)</p>

<p>Top Coder的题目分为两个区（Division，简称D），每个区又分为三个级别（Level，简称L），每道题目有其通过率（Success Rate）。D1难度小于D2，L1难度小于L2小于L3，通过率越高难度越低。</p>

<p>举例来说，一道D1L1SR50的题目适合初学者练习，一道D2L2SR30的题目就可能需要相当的算法水准才能搞定。</p>

<h3>我如何使用TC Browser</h3>

<p>在找工作初期，我的算法水平非常拙计，于是我所练习的题目大多都是D1L2和D1L3，SR>40的题目，同时根据往届师兄师姐的面试经验，我会重点练习动态规划、递归、字符串操作和搜索这几个类型的题目。</p>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="截图" /></p>

<p>到了中后期，随着经验的累计，我开始练习D1L3的题目，并尝试一些D2L1的题目。</p>

<p><img src="http://i.imgur.com/yHE02Qi.jpg" alt="截图" /></p>

<p>到了最后，就开始使用Random模式——从D2L1和D2L2中随机出一道题目然后思考解决思路，想出来之后再随机下一道。</p>

<p>为了练习方便，我为TC Browser加了一个做题模式——其实就是把题目选择区隐藏，这样就可以方便的双窗口操作。</p>

<h4>浏览模式：</h4>

<p><img src="http://i.imgur.com/mOUMwlo.jpg" alt="浏览模式" /></p>

<h4>做题模式：</h4>

<p><img src="http://i.imgur.com/gNn58vt.jpg" alt="做题模式" /></p>

<p>顺便提一句，TC Browser左上角的Config、Switch Mode和About三个按钮只有Switch Mode能用——一个按钮，三倍情怀。</p>

<h3>面试有多难？</h3>

<p>就我的面试经验来说，D2L1的题目已经相当够用了——绝大多数的编程题目都没有超过D1L3的难度，要知道面试只有45分钟，搞那些惊天地泣鬼神的算法题目面试官和面试者谁都受不了。</p>

<p>但也要注意，我没有算法竞赛背景，所以面试官不会问太难的题目，但对于那些算法竞赛选手就是另一种情况了——面试官需要用更难的题目来确认你是一个合格的算法选手，正所谓道高一尺，魔高一丈。</p>

<h2>下载地址</h2>

<p>所以下载地址在这里：<a href="http://pan.baidu.com/s/1fGX5c">网盘地址</a></p>

<p>解压密码是宇宙的终极答案（The ultimate anwser to the universe）。</p>

<p>谢谢试用，至于代码可以自行反编译阅读（写的翔一般还是不读为好），恕不赘述。</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li>微博：<a href="http://www.weibo.com/pegong/">@peng_gong</a></li>
<li>豆瓣：<a href="http://www.douban.com/people/figure9/">@figure9</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/top-code-offline-browser/">http://zh.lucida.me/blog/top-code-offline-browser/</a></p>
]]></content>
  </entry>
  
</feed>
