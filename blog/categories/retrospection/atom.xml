<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Retrospection | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/retrospection/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-12-12T22:40:24-08:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计中的设计——1. Horror Vacui]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/"/>
    <updated>2014-07-26T16:10:03-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-1-horror-vacui</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<strong>设计</strong>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/design-of-design-0-horror-prologue/">设计中的设计——0. Prologue</a></li>
<li><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">设计中的设计——1. Horror Vacui</a></li>
</ol>


<h2>Horror Vacui</h2>

<blockquote><p>Horror Vacui——a Latin expression meaning &ldquo;fear of emptiness"——regards the desire to fill empty spaces with information of objects.</p></blockquote>

<p><strong><a href="http://en.wikipedia.org/wiki/Horror_vacui">Horror Vacui</a></strong>源自人对空旷空间的畏惧感——它是一种要将空间填满的心理，也是一种不留任何空白空间的艺术风格，这种风格的代表设计师包括David Carson和Vaughan Oliver，有兴趣的童鞋请自行Google他们的代表作品。</p>

<p>不过这篇文章讨论的并不是<strong>Horror Vacui</strong>艺术风格，而是<strong>Horror Vacui</strong>心理。</p>

<!-- more -->


<p>研究表明，<strong>Horror Vacui</strong>和<strong>价值感知（Value Perception）</strong>间存在反比关系——随着<strong>Horror Vacui</strong>的升高，价值感知随之下降。简单的来说——同样的空间，放的东西越多，给人的廉价感越强烈，反之亦然（vice versa）。</p>

<p>以服装店店面的设计为例：</p>

<p><img src="http://i.imgur.com/FFblJhS.png" alt="Horror Vacui" /></p>

<p>研究者做了一个调查，对于上面的店面设计风格，从左到右的空间利用率越来越低，然而给人的价值感知正好相反——几乎所有被调查者都认为最左的廉价感最强，而最右的高端感最强。</p>

<p>再来几个现实例子：</p>

<h3>店铺</h3>

<p><img class="<a" src="href="http://i.imgur.com/5LsZvER.jpg">http://i.imgur.com/5LsZvER.jpg</a>" width="600" height="400" title="西单某服装店" ></p>

<p><img class="<a" src="href="http://i.imgur.com/CtXZzWw.jpg">http://i.imgur.com/CtXZzWw.jpg</a>" width="600" height="400" title="优衣库" ></p>

<p><img class="<a" src="href="http://i.imgur.com/CUwAJDd.jpg">http://i.imgur.com/CUwAJDd.jpg</a>" width="600" height="400" title="Burberry" ></p>

<p>你觉得哪一个店更贵？</p>

<h3>食物</h3>

<p><img class="<a" src="href="http://i.imgur.com/YwI3YGU.jpg">http://i.imgur.com/YwI3YGU.jpg</a>" width="600" height="400" title="东北乱炖" ></p>

<p><img class="<a" src="href="http://i.imgur.com/pw8iVAa.jpg">http://i.imgur.com/pw8iVAa.jpg</a>" width="600" height="400" title="法式食物" ></p>

<p>你认为哪道菜更贵？</p>

<h2>Horror Vacui vs Minimalism</h2>

<p>Horror Vacui设计是Minimalism设计的反面，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>在介绍Horror Vacui时给出了下面刻薄但又实用的建议：</p>

<blockquote><p>To promote associations of high value, favor minimalism for affluent and well-educated audiences and horror vacui for poorer and less-educated audiences, and vice versa.</p></blockquote>

<p>简单来说：</p>

<ul>
<li>对于教育程度高或富有的用户，使用minimalism（极简）设计以带来高价值认知。</li>
<li>对于教育程度低或较穷的用户，使用horror vacui设计以带来高性价比认知。</li>
</ul>


<p>反之也一样：</p>

<ul>
<li>对于教育程度低或较穷的用户，minimalism设计会让他们认为这货性价比太低，不值得。</li>
<li>对于教育程度高或富有的用户，horror vacui设计会让他们认为这货太廉价，没必要。</li>
</ul>


<p>总之，不用给矮矬穷营造高大上，也不要给高帅富灌输便宜大碗，会有反效果。</p>

<h2>Universal Principles of Design</h2>

<p><img src="http://i.imgur.com/EEueKvz.jpg" alt="Universal Principles of Design" /></p>

<p>我在之前的<a href="http://zh.lucida.me/blog/on-reading-books/">如何阅读书籍</a>中提到利用结论型/指南型书籍精炼阅读专业周边书籍，<a href="http://www.amazon.co.uk/Universal-Principles-Design-Revised-Updated/dp/1592535879">Universal Principles of Design</a>就是设计中结论型书籍的代表作：</p>

<ol>
<li>包含一百多种实用设计原则，这些原则涵盖了改善可用性（Enhance usability）、影响感知（Infuluence Perception）、提升吸引力（Increase Appeal）、做出更好的设计决策（Make Better Design Decisions）以及设计教学（Teach through Design）这五大方面。</li>
<li>全书按照字母顺序（Alphabetical Order）组织，同时也包含按类别组织的目录，既方便查阅，也方便针对性阅读。</li>
<li>每一种设计原则都配有详细的文字介绍、图解、案例以及参考文献。</li>
</ol>


<p><img src="http://i.imgur.com/eqTjTqK.jpg" alt="样章" /></p>

<p>总之，这本书对于专业设计师可能比较初级，但对于设计入门者是绝好的书籍。任何涉及到制作最终用户产品的人员（包括开发、测试和产品等）都应该阅读此书，从而了解基本设计原则（principle）和术语（terminology），以便与设计师进行交流，做出令用户满意的高价值设计。</p>

<p>这本书有<a href="http://www.amazon.cn/%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%B3%95%E5%88%99-%E5%A8%81%E5%BB%89%E2%80%A2%E7%AB%8B%E5%BE%B7%E5%A8%81%E5%B0%94/dp/B00ES8JL8W/">中文译版</a>，但个人强烈推荐<a href="http://www.amazon.cn/Universal-Principles-of-Design-Lidwell-William/dp/1592535879/">原版</a>：因为这类书籍翻译过来会损失相当多的信息（注意并非否认翻译水平），此外原版价格也相当实惠。</p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-1-horror-vacui/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——2. Blunders, Typos, Mismatches, and Language Liability]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-2/"/>
    <updated>2014-06-27T15:46:53-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-2</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-2/">Blunders, Typos, Mismatches, and Language Liability</a></li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>对编程错误的分析</h2>

<p>上篇文章（<a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a>）介绍了Knuth对编程错误的分类，基于Knuth的分类和我自己的编程经验，从这篇文章开始我将会给出各类编程错误的<strong>案例</strong>、<strong>诱因</strong>和<strong>对策</strong>。</p>

<p>按照复杂程度的不同，Knuth将编程错误分为三大类，这篇文章介绍第一类错误——简单的错误：</p>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<!-- more -->


<h2>粗心大意（a trivial typo）</h2>

<blockquote><p>Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</p>

<p>我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</p></blockquote>

<p><strong>粗心大意</strong>这类差错源自于Knuth奇葩的开发方式——先把程序在纸上写好然后再"誊写"到计算机中，而在"誊写"时可能会敲错几个字符，从而导致程序出错。</p>

<p>除去面试时的白板编码，我认为现代程序开发不可能在纸上进行——从而也不可能产生这种差错，所以不加赘述。</p>

<h2>鬼使神差（a blunder or botch）</h2>

<blockquote><p>Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</p>

<p>我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</p></blockquote>

<h3>案例</h3>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>中提到一个低级Bug：TEX代码里有两个变量<code>new_line</code>和<code>next_line</code>：<code>new_line</code>用于表示程序当前的状态，而<code>next_line</code>则指代换行符。然而开发过程中Knuth混淆了这两个变量的用途——由于这两个变量属于同一类型所以编译器无法检测出这个问题，这个Bug直到后来程序运行了一段时间才被发现。</p>

<h3>诱因</h3>

<ul>
<li>变量名含糊不清：导致之后的误用。</li>
<li>编程语言过分宽容：某些编程语言对代码特别宽容——比如动态编程语言会将静态编程语言在编译时做的类型检查拖到运行时，尽管获得了灵活性，但却损失了精确性。从而导致<strong>鬼使神差</strong>这类静态语言编译期就能检查到的错误直到运行时才会被发现。</li>
<li>加班超负荷工作：从而导致写出翔一般的代码。</li>
</ul>


<h3>对策</h3>

<ol>
<li>使用精准的名字：

<ul>
<li>作用域越长的变量的名字越要精确。</li>
<li>使用精准的英文词汇描述变量。</li>
<li>更多关于命名的信息请参考<a href="http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/">Code Complete</a>中<strong>The Power of Variable Names</strong>一节。</li>
</ul>
</li>
<li>严格控制全局变量：

<ul>
<li>能不用则不用。</li>
<li>如果不得不使用，使用明确的名字，进行详细的注释，并注明不得不使用全局变量的原因。。</li>
</ul>
</li>
<li>优先使用强类型：例如对于内置强类型枚举（Enum）的语言（例如Java，C#，和C++），使用枚举类型表示状态（State），而非整数类型。</li>
<li>将编译器警告调到最高级：然后清除代码中所有的Warning。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>单步（Step Into）自己的代码：编写新代码后进行单步调试——你脑中的代码和实际可能不一样。</li>
<li>进行代码审查：可以参考<a href="http://coolshell.cn/articles/11432.html">这篇文章</a>。</li>
<li>不要在混沌状态提交代码。</li>
</ol>


<h2>丢三落四（a forgotten function）</h2>

<blockquote><p>Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</p>

<p>我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</p></blockquote>

<h3>案例</h3>

<h4>烫烫烫烫烫</h4>

<p>C语言中忘记初始化数组，从而输出喜闻乐见的“烫烫烫烫烫烫烫烫烫烫烫烫”。</p>

<p><img src="http://i.imgur.com/9RcLu2x.png" alt="烫烫烫烫烫烫" /></p>

<p>对于需要手动管理内存的语言（C/C++），忘记释放内存或忘记初始化内存都会导致各种奇诡的问题。</p>

<h4>过早优化</h4>

<p>在开发TEX时，Knuth试图去优化<code>get_next</code>这个被频繁调用的函数。经过一番思考，Knuth认为<code>cur_cs = 0</code>这段代码是不必要的，于是他将这段代码删除，代码依然"正常"运行。然而过了一段时间后Knuth发现TEX在处理对齐（Alignment）时有时会出现问题——经过一番调试，Knuth发现原来那段被删除的代码是必要的（necessary）。</p>

<p>郁闷之余，Knuth援引了那句著名的话（Hoare&rsquo;s dictum）——过早优化是万恶之源（Premature optimization is the root of all evil in programming），很多书都以为这句话是Knuth说的，实际上它属于<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>。</p>

<h3>诱因</h3>

<h4>远距离操作</h4>

<p>远距离操作指那些间隔特别长的操作，例如下面的代码：</p>

<p><code>
obj.Init()
obj.DoSomething()
// Hundred of lines
obj.DoSomething()
obj.Close()
</code></p>

<p>从<code>Init</code>到<code>Close</code>的距离过远，在编写了几十甚至上百行其它代码之后，很容易漏掉<code>obj.Close()</code>从而导致资源泄漏。</p>

<h4>贸然修改代码</h4>

<p>我个人认为Knuth所犯的错误不在于过早优化，而在于他在对代码理解不充分的情况下就去贸然修改——这往往会带来各种问题。</p>

<h3>应对</h3>

<ul>
<li>避免远距离操作：

<ul>
<li>对于内存管理：C++提供了智能指针。</li>
<li>多数编程语言提供了上下文管理器（Context Manager）：例如Java 7的<code>try</code>，C#的<code>using</code>，以及Python的<code>with</code>，利用这些机制，可以有效的减少远距离操作，比如前文的代码用Python可以这么写：</li>
</ul>
</li>
</ul>


<p><code>python
with Obj.Init() as obj:
  obj.DoSomething()
  // Hundred of lines
  obj.DoSomething()
</code></p>

<ul>
<li> 整理代码段落，避免复杂交织的逻辑，这里可以参考<a href="http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293">The Art of Readable Code</a>对Aesthetics的定义。</li>
</ul>


<p><img class="right <a" src="href="http://i.imgur.com/Mvr8zx2.jpg">http://i.imgur.com/Mvr8zx2.jpg</a>" width="180" height="250" title="Working Effectively with Legacy Code" ></p>

<ul>
<li><p>不要贸然修改代码：</p>

<ul>
<li>修改代码前要确保充分理解代码的原理，以及修改会带来的影响（Effect Analysis）。</li>
<li>修改代码后要保证被修改的部分得到测试，<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/">Working Effectively with Legacy Code</a>提供了很多优秀的修改实践。</li>
</ul>
</li>
<li><p>代码审查：代码审查可以有效的控制编程差错。</p></li>
<li>不要在混沌状态提交代码。</li>
</ul>


<h2>言非所指（a language liability）</h2>

<blockquote><p>Here I misused or misunderstood the programming language or system hardware I was working with.</p>

<p>我对编程语言（或是系统硬件）理解有误，从而造成错误。</p></blockquote>

<h3>案例</h3>

<h4>JavaScript</h4>

<p>下面是JavaScript的真值表（源自Douglas Crockford）：</p>

<p><code>js
''        ==   '0'           // false
0         ==   ''            // true
0         ==   '0'           // true
false     ==   'false'       // false
false     ==   '0'           // true
false     ==   undefined     // false
false     ==   null          // false
null      ==   undefined     // true
" \t\r\n" ==   0             // true
</code></p>

<p>此外还有下面这个对比：</p>

<p><img src="http://i.imgur.com/5RCkNLK.jpg" alt="JavaScript the Good Parts" /></p>

<p>对于这种翔一样的语言，想不掉进坑里是非常困难的。</p>

<p>（讽刺的是，JavaScript统治了浏览器端，而且它还试图染指服务器端。）</p>

<h4>操作符优先级</h4>

<p><img class="right <a" src="href="http://i.imgur.com/5WjUpyd.jpg">http://i.imgur.com/5WjUpyd.jpg</a>" width="160" height="200" title="the Practice of Programming" ></p>

<p>[Brian Kernighan]曾在在<a href="http://cm.bell-labs.com/cm/cs/tpop/index.html">the Practice of Programming</a>中提到<code>if (x &amp; MASK == BITS)</code>这个例子：</p>

<p>我们一般会把<code>if (x &amp; MASK == BITS)</code>理解为<code>if ((x &amp; MASK) == BITS)</code>；</p>

<p>但实际上<code>if (x &amp; MASK == BITS)</code>和<code>if (x &amp; (MASK == BITS))</code>等价，而这显然不是我们想要的结果。</p>

<h3>诱因</h3>

<ul>
<li>对编程语言不够了解。</li>
<li>编程语言本身设计有问题。</li>
<li>对操作符优先级理解不足。</li>
</ul>


<h5>应对</h5>

<ul>
<li>深入理解编程语言——知道哪有坑：

<ul>
<li>学习编程语言不只是学它的语法——还要学习它的用法（Usages），最佳实践（Best Practices），误区（Traps），惯例（Conventions）和风格（Styles）等等，阅读<em>Effective</em>、<em>More Effective</em>、<em>Exceptional</em>、<em>More Exceptional</em>、<em>Pitfalls/Traps</em>和<em>the Good Parts</em>等系列的编程书籍以了解这些内容。</li>
<li><a href="http://joearms.github.io/">Joe Armstrong</a>在<a href="http://codersatwork.com/">Coders at work</a>的访谈中提到学习编程语言最好的方式是实现它（“The best way to learn a programming language is to implement it yourself”），我尝试用这种方法学习JavaScript，效果还不错。</li>
</ul>
</li>
<li>使用且仅使用语言的良子集——避开那些坑：

<ul>
<li><a href="http://crockford.com/">Douglas Crockford</a>在<a href="http://www.amazon.com/exec/obidos/ASIN/0596517742/">JavaScript: the Good Parts</a>中仅仅摘取了一个很小的JavaScript良子集进行编程，Kernighan和Plauger在<a href="http://www.amazon.com/Software-Tools-Brian-W-Kernighan/dp/020103669X/">Software Tools</a>则扩展了Fortran的一个良子集进行编程。语言提供的特性不代表你必须要使用它，容易产生错误（Error Prone）的语言特性应当被禁用。</li>
</ul>
</li>
<li>使用括号明确（Explicitify）操作符优先级——哪怕你能一眼看出<code>return true || true &amp;&amp; false</code>的返回值。</li>
<li>谨慎使用宏（macro）。</li>
<li>代码审查：提交代码之前至少需要一个该精通语言的人的审查，以免踩进语言的坑里。</li>
</ul>


<h2>事与愿违（a mismatch between modules）</h2>

<blockquote><p>Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</p>

<p>我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</p></blockquote>

<h3>案例</h3>

<h4>火星探测器坠毁</h4>

<p>史上最贵的<strong>事与愿违</strong>的Bug出现在1998年的NASA火星探测器中，这个Bug直接导致火星探测器坠毁，损失高达<a href="http://www.computerworld.com/s/article/9183580/Epic_failures_11_infamous_software_bugs">3.27亿美元</a>。</p>

<p>而这个Bug的成因在我们看来实际很可笑——Lockheed Martin公司在<a href="http://www.jpl.nasa.gov/news/releases/99/mcoloss1.html">调查</a>后发现，由于不同开发团队使用的计量单位不同——一个团队使用英制单位（英寸，英尺或英镑等），而其它开发团队使用公制（厘米或公斤等），从而导致系统运算错误，最终导致探测器坠毁。</p>

<h4>愚蠢的API设计</h4>

<p>以前在Microsoft实习时，我曾经编写过一个动画方法，用于移动屏幕上某个控件，这个方法大概是下面这个样子：</p>

<p>```csharp
// Returns a DoubleAnimation which moves control from (x1, y1) to (x2, y2).
public DoubleAnimation CreateAnimation(Control control, int x1, int y1, int x2, int y2, double duration) {</p>

<pre><code>// Some code...
</code></pre>

<p>}
```</p>

<p><code>CreateAnimation</code>用于创建一个<code>DoubleAnimation</code>，把某个控件从<code>(x1, y1)</code>移动到<code>(x2, y2)</code>，移动耗时<code>duration</code>毫秒。</p>

<p>之后就出现了下面一系列翔一般的代码：</p>

<p><code>csharp
var gridAnimation1 = CreateAnimation(grid1, grid1.X, grid1.Y, 480, 0, 500);
var gridAnimation2 = CreateAnimation(grid2, grid2.X, grid2.Y, 0, 0, 500);
var popUpAnimation = CreateAnimation(popUp, 0, -320, 0, 320, 500);
</code></p>

<p>以及误用（组员（包括我自己）把<code>duration</code>当成秒来用）：</p>

<p><code>csharp
var gridAnimation1 = CreateAnimation(grid1, 480, 800, 480, 0, 0.5);
</code></p>

<p>这个方法如同<strong>病毒</strong>一般，既使得调用代码变的丑陋不堪，同时带来了各种Bug，导致后来的维护者叫苦不迭，</p>

<p>现在回想下，我肯定不会把它设计成这副模样——一种方法是使用<a href="http://en.wikipedia.org/wiki/Fluent_interface">Fluent Interface</a>，例如：</p>

<p><code>csharp
var gridAnimation = grid.FromCurrentPosition().MoveTo(x: 0, y: 0).InMilliSeconds(500);
var popUpAnimation = popUp.From(x: 0, y: -320).MoveTo(x: 0, y: 320).InMilliSeconds(500);
</code></p>

<p>从而使代码简洁明确。</p>

<h3>诱因</h3>

<p><strong>事与愿违</strong>源于糟糕的设计——人会犯错误，而糟糕的设计会大大加剧错误几率。</p>

<p><img class="right <a" src="href="http://i.imgur.com/jdeK9F0.jpg">http://i.imgur.com/jdeK9F0.jpg</a>" width="270" height="270" title="Tony Hoare" ></p>

<p>然而良好的设计非常困难——<a href="http://en.wikipedia.org/wiki/C._A._R._Hoare">Tony Hoare</a>曾在他的图灵奖获奖感言（<a href="http://zoo.cs.yale.edu/classes/cs422/2014/bib/hoare81emperor.pdf">The Emperor&rsquo;s Old Clothes</a>）中指出：</p>

<blockquote><p>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.</p></blockquote>

<h3>应对</h3>

<p>尽管Knuth把<strong>事与愿违</strong>归类为简单的差错，但我并不这么认为。<strong>事与愿违</strong>源于错误的设计，解决<strong>事与愿违</strong>的关键不在于修复其造成的差错，而在于处理造成<strong>事与愿违</strong>原因。修复<strong>事与愿违</strong>的错误很简单，但处理<strong>事与愿违</strong>的原因就复杂多了。</p>

<p><img class="right <a" src="href="http://i.imgur.com/tll1S89.jpg">http://i.imgur.com/tll1S89.jpg</a>" width="180" height="240" title="Awaken the Giant Within" ></p>

<p><a href="http://www.tonyrobbins.com/">Tony Robbins</a>曾在<a href="http://www.amazon.com/Awaken-Giant-Within-Immediate-Emotional/dp/0671791540/">Awaken the Giant Within</a>一书中讲了这样一个故事：</p>

<blockquote><p>一个医生在河边发现有一个人溺水，然后她跳进河里，把溺水者救上岸进行抢救。然而没过多久她又听到呼救声，她继续跳进河里，把溺水者救上岸抢救，然后她又听到求救，于是她又跳进河里…… 不幸的是，这名医生忙于抢救眼前的溺水者，而没有时间去上游查看是谁把这些人扔到水里的。</p></blockquote>

<p><img class="right <a" src="href="http://i.imgur.com/t5zjiGY.jpg">http://i.imgur.com/t5zjiGY.jpg</a>" width="180" height="240" title="Stream Analysis" ></p>

<p><a href="http://www.jerryporras.com/">Jerry Porras</a>也在<a href="http://www.amazon.com/Stream-Analysis-Organizational-Addison-Wesley-Organization/dp/0201056933/">Stream Analysis</a>中提到：</p>

<blockquote><p>People, especially people in organizations, tend to work on getting rid of symptoms, rather than solving the real problems.</p></blockquote>

<p>因此，处理<strong>事与愿违</strong>要从设计着手（Solving the real problems），这里从设计者和使用者两个角度出发：</p>

<h4>设计者</h4>

<ol>
<li>谨慎设计API：

<ul>
<li>API应该由经验丰富的人设计。</li>
<li>API设计应遵循一定的原则，<a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Josha Bloch</a>曾在Google做过一个非常出色的关于API设计的演讲：<a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">How To Design A Good API and Why it Matters</a>。</li>
<li>API在投入使用前应进行可用性测试——糟糕的API不仅会降低开发效率，还会像病毒一般引入各种各样的差错。</li>
</ul>
</li>
<li>利用类型系统：

<ul>
<li>避免基本类型（Primitive Type）：对于有意义的数据，使用其类型而非基本类型。例如：使用<code>Money</code>表示金钱，而非使用<code>double</code>。</li>
<li>避免使用动态语言（例如Python和Ruby）构建大型系统：动态语言的作用仅限于快速开发原型系统，在我看来，动态语言像是纸和胶水，可以用它们快速构建一些玩具模型（原型系统），但用它们建造摩天大厦（大型系统）就太离谱了。</li>
</ul>
</li>
<li>设计文档+审查：软件设计在实现前应有详细的设计文档（Design Document），并至少通过两名以上经验丰富的开发者的审查。</li>
</ol>


<h4>使用者</h4>

<p><img class="right <a" src="href="http://i.imgur.com/3vIYjeg.jpg">http://i.imgur.com/3vIYjeg.jpg</a>" width="180" height="240" title="Debugging" ></p>

<ol>
<li>仔细阅读文档——Read the manual, and read everything, cover to cover，参见<a href="http://www.amazon.com/Debugging-Indispensable-Software-Hardware-Problems/dp/0814474578/">Debugging: The 9 Indispensable Rules for Finding Even the Most Elusive Software and Hardware Problems</a>里的第一条调试原则——<strong>Understand the system</strong>。</li>
<li>调用API时仔细阅读其样例代码（Sample Code）和文档说明，不要想当然。</li>
<li>对于已有（Existing）的糟糕API，考虑对其进行封装（Wrapping），以免接下来的误用。</li>
<li>单元测试：编写单元测试，保证代码覆盖，确保一段代码都按期望的方式执行。</li>
<li>代码审查：代码审查可以有效的控制编程差错。</li>
</ol>


<p>关于"简单"的编程差错就介绍到这里，下篇将介绍源自算法和数据结构的错误——Algorithm + Data Structures &ndash;> Programming。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-2/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——1. A Taxonomy of Programming Errors]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-1/"/>
    <updated>2014-06-24T15:32:12-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-1</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>编程错误的分类</h2>

<p>前文讲到Knuth在开发TEX的过程中遇到了各式各样的差错，为了理解并控制编程错误，Knuth将这些错误整理到<a href="http://texdoc.net/texmf-dist/doc/generic/knuth/errata/errorlog.pdf">记录日志</a>，并将这些差错分为15类。为了引用方便，我将它们翻译成中文。</p>

<p>注意：</p>

<ol>
<li>为了引用方便，Knuth使用英文首字母指代各个编程错误的分类，出于同样的原因，我将这些分类一一翻译为成语。</li>
<li>保留原文，以便读者理解，以免信息丢失。</li>
<li>原文中的"my"和"I"以及译文中的"我"均指Knuth本人。</li>
<li>如果认为翻译不靠谱请在评论中指出 :)</li>
</ol>


<p>下面是Knuth对TEX错误的分类：</p>

<!-- more -->


<hr />

<ul>
<li><strong>A: an algorithm awry.</strong> Here my original method proved to be incorrect or inadequate.</li>
<li><strong>不可胜算</strong>：我最初设想的算法有误或存在不足。</li>
</ul>


<hr />

<ul>
<li><strong>B: a blunder or botch.</strong> Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</li>
<li><strong>鬼使神差</strong>：我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</li>
</ul>


<hr />

<ul>
<li><strong>C: a cleanup for consistency or clarity.</strong> Here I changed the rules of the language to make things easier to remember and/or more logical.</li>
<li><strong>得心应手</strong>：我对语言（TEX）规则进行整理，使其符合逻辑，更加易用。</li>
</ul>


<hr />

<ul>
<li><strong>D: a data structure debacle.</strong> Here I didn&rsquo;t properly update the representation of information to preserve the appropriate invariants.</li>
<li><strong>差之毫厘</strong>：我对数据结构的操作有误，使其处在不一致的状态（破坏了其本应维持的不变式）。</li>
</ul>


<hr />

<ul>
<li><strong>E: an efficiency enhancement.</strong> Here I changed the program so that it would run faster; the existing code was correct but slow.</li>
<li><strong>多快好省</strong>：尽管原来的代码正确，但速度很慢，于是我修改代码以改善程序的性能。</li>
</ul>


<hr />

<ul>
<li><strong>F: a forgotten function.</strong> Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</li>
<li><strong>丢三落四</strong>：我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</li>
</ul>


<hr />

<ul>
<li><strong>G: a generalization or growth of ability.</strong> Here I realized that some extension of the existing specifications was desirable.</li>
<li><strong>虚怀若谷</strong>：我将一些已有的代码进行扩展/抽象使其更加通用。</li>
</ul>


<hr />

<ul>
<li><strong>I: an interactive improvement.</strong> Here I made TEX respond better to the user&rsquo;s needs.</li>
<li><strong>各得其所</strong>：我使TEX对用户更加友好。</li>
</ul>


<hr />

<ul>
<li><strong>L: a language liability.</strong> Here I misused or misunderstood the programming language or system hardware I was working with.</li>
<li><strong>言非所指</strong>：我对编程语言（或是系统硬件）理解有误，从而造成错误。</li>
</ul>


<hr />

<ul>
<li><strong>M: a mismatch between modules.</strong> Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</li>
<li><strong>事与愿违</strong>：我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</li>
</ul>


<hr />

<ul>
<li><strong>P: a promotion of portability.</strong> Here I changed the organization or documentation of the program; this affected only a person who would try to read or modify the code, not a person who tried to run it.</li>
<li><strong>焕然一新</strong>：我对程序的结构或是文档进行改善，从而在不改变程序的前提下改善其可读性和可修改性。</li>
</ul>


<hr />

<ul>
<li><strong>Q: a quest for quality.</strong> Here I changed the specifications of what the program should output from given input, when I learned how to improve the typographic appearance of the output.</li>
<li><strong>精益求精</strong>：在对字体版式有了更深入的理解之后，我对程序进行修改，以获得更好的输出效果。</li>
</ul>


<hr />

<ul>
<li><strong>R: a reinforcement of robustness.</strong> Whenever I realized that TEX could loop or crash in the presence of certain erroneous input, I tried to make the code bulletproof.</li>
<li><strong>百毒不侵</strong>：一旦我意识到TEX有可能在极端情况下崩溃，我就会想方设法使程序变的更加健壮。</li>
</ul>


<hr />

<ul>
<li><strong>S: a surprising scenario.</strong> Errors of type S were particularly bad bugs that forced me to change my original ideas, because of unforeseen interactions between various parts of the program.</li>
<li><strong>出乎意料</strong>：由于我最初对问题的定义或是对程序间模块的交互理解不足，导致一些无法预见的错误——这类错误往往很棘手。</li>
</ul>


<hr />

<ul>
<li><strong>T: a trivial typo.</strong> Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</li>
<li><strong>粗心大意</strong>：我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</li>
</ul>


<hr />

<h2>进一步的分类</h2>

<h3>Knuth随后将这15个分类分为两大类：</h3>

<ul>
<li><strong>不可胜算</strong>、<strong>鬼使神差</strong>、<strong>差之毫厘</strong>、<strong>丢三落四</strong>、<strong>言非所指</strong>、<strong>事与愿违</strong>、<strong>百毒不侵</strong>、<strong>出乎意料</strong>和<strong>粗心大意</strong>属于程序的差错（Bugs）。</li>
<li><strong>得心应手</strong>、<strong>多快好省</strong>、<strong>虚怀若谷</strong>、<strong>各得其所</strong>、<strong>焕然一新</strong>和<strong>精益求精</strong>属于对程序的改进（Enhancements）。</li>
</ul>


<h3>然后按复杂程度把差错（Bugs）分为三类：</h3>

<h4>简单的差错</h4>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<h4>复杂的差错</h4>

<ul>
<li><strong>不可胜算</strong>：算法设计不当。</li>
<li><strong>差之毫厘</strong>：数据结构维护不周。</li>
</ul>


<h4>棘手的差错</h4>

<ul>
<li><strong>百毒不侵</strong>：对错误输入处理不当而造成的问题。</li>
<li><strong>出乎意料</strong>：由于对问题的理解不足，从而导致各种诡异的问题。</li>
</ul>


<h2><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>的不足</h2>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对TEX的错误进行了详细的分析，并对这些错误进行了系统的分类，但我认为这篇文章仍有一些不足：</p>

<ol>
<li>Knuth并未对编程错误给出应对策略。</li>
<li><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文成于1989年，其中记载的是1978年至1982年Knuth开发TEX时碰到的各种问题——30年前的编程语言和现在严重脱节。</li>
</ol>


<p>所以，我打算（不自量力的）结合自己的经验，在Knuth的分析基础上再进一步——从下篇开始，我会为每一类编程错误给出其案例，诱因和应对策略。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——0. Knuth, Tex, and the Errors of TEX]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-0/"/>
    <updated>2014-06-23T15:14:42-07:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-0</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<p>原本我计划在一篇文章完成所有内容，然而随着写作的深入，我发现文章的篇幅越来越长——考虑到可读性，我决定将这篇文章拓展为一个系列，计划如下：</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li>A Taxonomy of Programming Errors</li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<!-- more -->


<h2>免责声明（Disclaimer）</h2>

<p>几天前我在知乎上读到一篇关于Swift的<a href="http://www.zhihu.com/question/24002984">讨论</a>：</p>

<p>胡搅蛮缠</p>

<p><img src="http://i.imgur.com/ezV72EP.png" alt="讨论1" /></p>

<p>无知者无畏</p>

<p><img src="http://i.imgur.com/XXo9TlC.png" alt="讨论2" /></p>

<p>为了避免无谓的讨论，如果您认为iPhone系统闹钟可以用200行代码搞定，或者觉着Python适合编写大型项目，那么这个系列不适合您阅读。</p>

<h2>编程错误（Programming Errors）</h2>

<p>作为软件开发者，我自己写过一些微型程序（500行左右）和一些中小型应用（5'000~20'000行），实习时做过一些小项目（2'000行左右），到现在参与大型项目（100'000行以上）。如果让我总结这些项目的共同点，那么就是我在这些项目里都犯了各式各样的错误——小到喜闻乐见的"烫烫烫烫烫烫烫烫"，大到破坏整个应用兼容性导致上千用户流失，有的错误很愚蠢，有的错误则是聪明反被聪明误。</p>

<p>不过我可以安慰自己，因为我并非孤独——计算机程序向来以错误百出而臭名昭著，以至于计算机先驱<a href="http://en.wikipedia.org/wiki/Grace_hopper">Grace Hopper</a>近乎自嘲的为计算机程序错误取了一个别名——Bug。在之后的六十余年，Bug和其衍生词Debug一直是了所有程序员的梦魇。</p>

<p>Grace Hopper发现的“Bug”</p>

<p><img src="http://i.imgur.com/m36RhHW.jpg" alt="第一个Bug" /></p>

<p>随着经验的累积，我隐隐感觉到这些编程错误有一定的规律，因为我开始发现一些错误似乎在哪里见过，于是我开始寻找这方面的书籍和文献，以控制/减少自己的编程错误。</p>

<blockquote><p>Those who cannot remember the past are condemned to repeat it.</p>

<p>George Santayana</p></blockquote>

<p>然后我找到了<a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>的<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>。</p>

<h2>the Errors of TEX</h2>

<h3>背景</h3>

<p><img src="http://i.imgur.com/UF1uTSy.jpg" alt="Knuth" /></p>

<p>相信任何学计算机的人都知道Knuth和他神话（或神化）般（的<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>七卷本（未完成），但对Knuth开发的TEX以及Knuth开发TEX的流程可能就不是那么了解了，所以我在这里简单介绍下。</p>

<p><img src="http://i.imgur.com/3HzERY5.jpg" alt="TAOCP" /></p>

<p>撰写并出版<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>前三卷之后，Knuth发现印刷排版烂的一逼，在没有好使的数字排版系统的情况下，Knuth决定自己搞一个出来——于是就有了TEX。</p>

<p><img src="http://i.imgur.com/e6FqiCM.jpg" alt="TEX" /></p>

<p>不过排版系统并非简单的（Trivial）系统，即便如Knuth此般异禀天赋，也无法从容应付——事实上Knuth在开发TEX的过程中遇到了大量的错误，这些错误从TEX初版（1978年）到<a href="http://tug.org/TUGboat/tb35-1/tb109knut.pdf">最近的一次性能调优</a>（2014年），源源不断，挥之不去。</p>

<p>这些错误让Knuth很头痛，为了理解并控制编程错误，Knuth将这些错误整理到记录日志，并对这些编程错误进行分类，这成为了<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文的基础。</p>

<h3>插曲</h3>

<p>Knuth开发TEX的流程在我等屌丝码农看来绝对匪夷所思，在<a href="http://www.codersatwork.com/">Coders at Work</a>一书对Knuth的访谈里，Knuth提到：</p>

<blockquote><p>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>

<p>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p></blockquote>

<p>尽管有可能是1978年还没有好用的交互编程环境（Interactive Programming Environment），但Knuth六个月纸上设计纸上写代码的开发方式仍可以说是编程史上的一朵奇葩。如果放到今天，Knuth一定会被各路敏捷极限TDD编程<em>高手</em>喷出翔。</p>

<p>插曲到此为止，下篇进入正题——编程错误的分类（A Taxonomy of Programming Errors）。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——0. Prologue]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-0-prologue/"/>
    <updated>2014-06-06T15:06:06-07:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-0-prologue</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<em>设计</em>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<p>此外，副标题里使用<strong>Prologue</strong>，主要是因为我接下来提到的产品（设计）大多没有中文名——为了一致，我决定在这一系列所有文章的副标题中统一使用英文。</p>

<p>最后，这一系列博文和原研哉的<a href="http://book.douban.com/subject/1336111/">設計中的設計</a>无关，尽管它们名字相同。</p>

<h2>为什么要写这个系列？</h2>

<p>作为一个码农，按理说我应该和设计绝缘——设计是美工的事情嘛，码农负责写好代码就成。事实上我之前也一直这么认为。</p>

<!-- more -->


<p>但在三年前我这个看法被动摇了——2011年是国内移动互联网井喷的一年，随着iPhone及其模仿者的大行其道，曾经的手机王者Nokia被迅速的淘汰出市场；随着手机应用开发门槛的降低（从Symbian到iOS或Android），各种手机应用喷涌而出。</p>

<p>在这段时间我编写了一些手机应用，并通过QQ群，邮件列表以及论坛等渠道直接与用户交流，在这个过程中，我悲观的发现用户的思维模式和我（开发者）的思维模式完全不同，我认为理所当然的东西他们认为不可理喻，反之亦然。</p>

<p>在那段时间里我一度绝望的认为所有的用户都是神经病、弱智或是某些代谢产物，后来在Microsoft ATC实习时结识了几个设计师朋友（<a href="http://weibo.com/u/3848053360">@Xing</a>和<a href="http://weibo.com/u/2104950751">@Yan</a>），我向他们大吐苦水，他们则非常腹黑的讲了一个笑话：</p>

<blockquote><p>丈夫驾车出门。妻子在家听广播，听到一则报道，妻子连忙拿起电话。</p>

<p>妻子：老公啊，我刚听广播上说，高速公路上有一辆车在逆行，你千万要小心。</p>

<p>老公：哪是一辆啊，我看有好几百辆车都在逆行。</p></blockquote>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/hei.png" alt="黑" /></p>

<p>被善意的黑出翔之后，我认为我不能这样一直逆行下去——于是我开始天天死皮赖脸的向他们请教：从设计的原则，到设计的书籍，再到用户的心理，我强迫自己跳出码农的思维模式，像正常人一样思考。</p>

<p>感谢他们的指导，尽管我无法成为像他们一样专业的优秀设计师，但我形成了一个大体的设计观：比如一个好设计应该是什么样子，而一个烂设计又应该是什么样子。</p>

<p>在这个设计观的指引下，接下来我编写的手机应用都获得了不错的评价（几乎全五星），在做私活时也总能做出令客户满意的产品。</p>

<h2>优秀的产品&amp;杰出的设计</h2>

<p>在朋友的推荐下，最近把《道德经》看了一遍，我认为《道德经》里面的一段文字可以套用在产品和设计上：</p>

<blockquote><p>太上，不知有之；</p>

<p>其次，亲而誉之；</p>

<p>其次，畏之；</p>

<p>其次，侮之；</p>

<p>信不足焉，有不信焉。</p>

<p>—— 《道德经》 十七章</p></blockquote>

<p>把上面的文字应用到产品和设计：</p>

<ul>
<li>优秀的设计使用户专注于产品本身，而忽略设计的存在。（例如Google（搜索引擎）和iPad）</li>
<li>不错的设计使用户感到舒适，用户会称赞它的设计。（例如iPod Classic，<a href="http://www.parrot.com/zik/uk/">Parrot Zik</a>和Amazon Kindle）</li>
<li>马虎的设计使用户感到不适，用户很难掌握产品的功能。（例如早期版本的Microsoft Office，vim编辑器和JavaScript语言）</li>
<li>糟糕的设计会毁掉一个产品，用户会把产品和产品的设计骂出翔。（例如Nokia的Symbian触屏手机和绝大多数Linux桌面系统）</li>
</ul>


<p>需要注意，我在上面列举的产品都具有强大的功能——它们有的成功，有的失败，区别就在于设计。</p>

<h2>The Inmates are Running the Asylum</h2>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/inmates_asylum.jpg" alt="The Inmates are Running the Asylum" /></p>

<p><a href="http://www.amazon.com/The-Inmates-Are-Running-Asylum/dp/0672326140/">The Inmates are Running the Asylum</a>的全名是：The Inmates Are Running the Asylum : Why High Tech Products Drive Us Crazy and How to Restore the Sanity，直译成中文是：疯子开精神病院（为什么高科技产品总让我们抓狂以及如何打破这个窘境），可能是这个书名太惊悚，所以它的中文书名被分别译为<a href="http://book.douban.com/subject/1237849/">软件创新之路</a>（第一版）和<a href="http://book.douban.com/subject/1493316/">交互设计之路</a>（第二版）。</p>

<p>在这本书中，VB的创造者Alan Cooper创造性的把所有程序员黑了一遍——让程序员创造面向用户的软件，等价于让一群疯子开精神病院——因为能成为程序员的人思维本身就不正常：</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/ynm3000.png" alt="要你命3000" /></p>

<p>这是<a href="http://movie.douban.com/subject/1307739/">达文西</a>发明的要你命3000。</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/crazy_app.jpg" alt="要你命3000000000" /></p>

<p>这是程序员发明的要你命3000000000。</p>

<p>当然这本书不只是为了黑程序员，作者花了大量篇幅解释为什么现在的产品随着科技含量的提高反而愈发不好用，并提出了<a href="http://en.wikipedia.org/wiki/Interaction_design#Goal-oriented_design">认知摩擦（Cognitive friction）</a>、<a href="http://www.slideshare.net/PublishingTechnology/dancing-bears-pubtech">跳舞的熊（Dancing bear）</a>以及逻辑人（Homo logicus）等令人耳目一新的概念。总而言之，<a href="http://en.wikipedia.org/wiki/Interaction_design">交互设计（Interaction Design）</a>对于软件开发必不可少。</p>

<p>如果你是一个想做出好产品的程序员（码农），那么这本书值得一读——它会打破你现有的观念，让你意识到优秀的产品需要设计。就像我的朋友讲的那个笑话，它会让你意识到<strong>是你在逆行，而不是你面前的几百辆车在逆行。</strong></p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>
]]></content>
  </entry>
  
</feed>
