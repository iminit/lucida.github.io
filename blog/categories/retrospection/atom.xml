<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Retrospection | Lucida]]></title>
  <link href="http://zh.lucida.me/blog/categories/retrospection/atom.xml" rel="self"/>
  <link href="http://zh.lucida.me/"/>
  <updated>2014-06-24T23:50:09+01:00</updated>
  <id>http://zh.lucida.me/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——1. A Taxonomy of Programming Errors]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-1/"/>
    <updated>2014-06-24T23:32:12+01:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-1</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-1/">A Taxonomy of Programming Errors</a></li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<h2>编程错误的分类</h2>

<p>前文讲到Knuth在开发TEX的过程中遇到了各式各样的差错，为了理解并控制编程错误，Knuth将这些错误整理到<a href="http://texdoc.net/texmf-dist/doc/generic/knuth/errata/errorlog.pdf">记录日志</a>，并将这些差错分为15类。为了引用方便，我将它们翻译成中文。</p>

<p>注意：</p>

<ol>
<li>为了引用方便，Knuth使用英文首字母指代各个编程错误的分类，出于同样的原因，我将这些分类一一翻译为成语。</li>
<li>保留原文，以便读者理解，以免信息丢失。</li>
<li>原文中的"my"和"I"以及译文中的"我"均指Knuth本人。</li>
<li>如果认为翻译不靠谱请在评论中指出 :)</li>
</ol>


<p>下面是Knuth对TEX错误的分类：</p>

<!-- more -->


<hr />

<ul>
<li><strong>A: an algorithm awry.</strong> Here my original method proved to be incorrect or inadequate.</li>
<li><strong>不可胜算</strong>：我最初设想的算法有误或存在不足。</li>
</ul>


<hr />

<ul>
<li><strong>B: a blunder or botch.</strong> Here I knew what I ought to do, but I wrote something else that was syntactically correct&mdash;sort of a mental typo.</li>
<li><strong>鬼使神差</strong>：我知道这段代码该怎么写，但我糊里糊涂写了另外一段出来而且还能通过编译。</li>
</ul>


<hr />

<ul>
<li><strong>C: a cleanup for consistency or clarity.</strong> Here I changed the rules of the language to make things easier to remember and/or more logical.</li>
<li><strong>得心应手</strong>：我对语言（TEX）规则进行整理，使其符合逻辑，更加易用。</li>
</ul>


<hr />

<ul>
<li><strong>D: a data structure debacle.</strong> Here I didn&rsquo;t properly update the representation of information to preserve the appropriate invariants.</li>
<li><strong>差之毫厘</strong>：我对数据结构的操作有误，使其处在不一致的状态（破坏了其本应维持的不变式）。</li>
</ul>


<hr />

<ul>
<li><strong>E: an efficiency enhancement.</strong> Here I changed the program so that it would run faster; the existing code was correct but slow.</li>
<li><strong>多快好省</strong>：尽管原来的代码正确，但速度很慢，于是我修改代码以改善程序的性能。</li>
</ul>


<hr />

<ul>
<li><strong>F: a forgotten function.</strong> Here I didn&rsquo;t remember to do everything I had intended, when I actually got around to writing a particular part of the code.</li>
<li><strong>丢三落四</strong>：我忘记了一些本应完成的事情，比如说我知道这段代码应该写但我忘了写。</li>
</ul>


<hr />

<ul>
<li><strong>G: a generalization or growth of ability.</strong> Here I realized that some extension of the existing specifications was desirable.</li>
<li><strong>虚怀若谷</strong>：我将一些已有的代码进行扩展/抽象使其更加通用。</li>
</ul>


<hr />

<ul>
<li><strong>I: an interactive improvement.</strong> Here I made TEX respond better to the user&rsquo;s needs.</li>
<li><strong>各得其所</strong>：我使TEX对用户更加友好。</li>
</ul>


<hr />

<ul>
<li><strong>L: a language liability.</strong> Here I misused or misunderstood the programming language or system hardware I was working with.</li>
<li><strong>言非所指</strong>：我对编程语言（或是系统硬件）理解有误，从而造成错误。</li>
</ul>


<hr />

<ul>
<li><strong>M: a mismatch between modules.</strong> Here I forgot the conventions I had built into a subroutine when I actually got around to using that subroutine.</li>
<li><strong>事与愿违</strong>：我忘了我自己编写的例程（或函数）的正确用法，以至于调用它们时出现问题。</li>
</ul>


<hr />

<ul>
<li><strong>P: a promotion of portability.</strong> Here I changed the organization or documentation of the program; this affected only a person who would try to read or modify the code, not a person who tried to run it.</li>
<li><strong>焕然一新</strong>：我对程序的结构或是文档进行改善，从而在不改变程序的前提下改善其可读性和可修改性。</li>
</ul>


<hr />

<ul>
<li><strong>Q: a quest for quality.</strong> Here I changed the specifications of what the program should output from given input, when I learned how to improve the typographic appearance of the output.</li>
<li><strong>精益求精</strong>：在对字体版式有了更深入的理解之后，我对程序进行修改，以获得更好的输出效果。</li>
</ul>


<hr />

<ul>
<li><strong>R: a reinforcement of robustness.</strong> Whenever I realized that TEX could loop or crash in the presence of certain erroneous input, I tried to make the code bulletproof.</li>
<li><strong>百毒不侵</strong>：一旦我意识到TEX有可能在极端情况下崩溃，我就会想方设法使程序变的更加健壮。</li>
</ul>


<hr />

<ul>
<li><strong>S: a surprising scenario.</strong> Errors of type S were particularly bad bugs that forced me to change my original ideas, because of unforeseen interactions between various parts of the program.</li>
<li><strong>出乎意料</strong>：由于我最初对问题的定义或是对程序间模块的交互理解不足，导致一些无法预见的错误——这类错误往往很棘手。</li>
</ul>


<hr />

<ul>
<li><strong>T: a trivial typo.</strong> Sometimes I did&rsquo;t type the right thing when I entered the program into the computer, although my original pencil draft was correct.</li>
<li><strong>粗心大意</strong>：我在打字时会犯一些小错，以至我纸上的草稿是对的，但敲进去的是错的。</li>
</ul>


<hr />

<h2>进一步的分类</h2>

<h3>Knuth随后将这15个分类分为两大类：</h3>

<ul>
<li><strong>不可胜算</strong>、<strong>鬼使神差</strong>、<strong>差之毫厘</strong>、<strong>丢三落四</strong>、<strong>言非所指</strong>、<strong>事与愿违</strong>、<strong>百毒不侵</strong>、<strong>出乎意料</strong>和<strong>粗心大意</strong>属于程序的差错（Bugs）。</li>
<li><strong>得心应手</strong>、<strong>多快好省</strong>、<strong>虚怀若谷</strong>、<strong>各得其所</strong>、<strong>焕然一新</strong>和<strong>精益求精</strong>属于对程序的改进（Enhancements）。</li>
</ul>


<h3>然后按复杂程度把差错（Bugs）分为三类：</h3>

<h4>简单的差错</h4>

<ul>
<li><strong>粗心大意</strong>：敲错了代码。</li>
<li><strong>鬼使神差</strong>：敲串了代码。</li>
<li><strong>丢三落四</strong>：忘敲了代码。</li>
<li><strong>言非所指</strong>：踩语言的坑。</li>
<li><strong>事与愿违</strong>：中自己的坑。</li>
</ul>


<h4>复杂的差错</h4>

<ul>
<li><strong>不可胜算</strong>：算法设计不当。</li>
<li><strong>差之毫厘</strong>：数据结构维护不周。</li>
</ul>


<h4>棘手的差错</h4>

<ul>
<li><strong>百毒不侵</strong>：对错误输入处理不当而造成的问题。</li>
<li><strong>出乎意料</strong>：由于对问题的理解不足，从而导致各种诡异的问题。</li>
</ul>


<h2><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>的不足</h2>

<p>Knuth在<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对TEX的错误进行了详细的分析，并对这些错误进行了系统的分类，但我认为这篇文章仍有一些不足：</p>

<ol>
<li>Knuth并未对编程错误给出应对策略。</li>
<li><a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文成于1989年，其中记载的是1978年至1982年Knuth开发TEX时碰到的各种问题——30年前的编程语言和现在严重脱节。</li>
</ol>


<p>所以，我打算（不自量力的）结合自己的经验，在Knuth的分析基础上再进一步——从下篇开始，我会为每一类编程错误给出其案例，诱因和应对策略。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-1/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于编程错误的思考——0. Knuth, Tex, and the Errors of TEX]]></title>
    <link href="http://zh.lucida.me/blog/on-programming-errors-0/"/>
    <updated>2014-06-23T23:14:42+01:00</updated>
    <id>http://zh.lucida.me/blog/on-programming-errors-0</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>

<h2>概要</h2>

<p><strong>关于编程错误的思考</strong>是一个博文系列，我试图通过结合<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>对编程错误的分类以及自己的编程经验，对常见的编程错误、以及如何控制和预防这些错误进行介绍。</p>

<p>原本我计划在一篇文章完成所有内容，然而随着写作的深入，我发现文章的篇幅越来越长——考虑到可读性，我决定将这篇文章拓展为一个系列，计划如下：</p>

<ol>
<li><a href="http://zh.lucida.me/blog/on-programming-errors-0/">Knuth, TEX, and the Errors of TEX</a></li>
<li>A Taxonomy of Programming Errors</li>
<li>Blunders, Typos, Mismatches, and Language Liability</li>
<li>Algorithm + Data Structures &ndash;> Programming</li>
<li>Robustness and Surprise</li>
<li>On Enhancing Existing Systems</li>
<li>Epilogue</li>
</ol>


<!-- more -->


<h2>免责声明（Disclaimer）</h2>

<p>几天前我在知乎上读到一篇关于Swift的<a href="http://www.zhihu.com/question/24002984">讨论</a>：</p>

<p>胡搅蛮缠</p>

<p><img src="http://i.imgur.com/ezV72EP.png" alt="讨论1" /></p>

<p>无知者无畏</p>

<p><img src="http://i.imgur.com/XXo9TlC.png" alt="讨论2" /></p>

<p>为了避免无谓的讨论，如果您认为iPhone系统闹钟可以用200行代码搞定，或者觉着Python适合编写大型项目，那么这个系列不适合您阅读。</p>

<h2>编程错误（Programming Errors）</h2>

<p>作为软件开发者，我自己写过一些微型程序（500行左右）和一些中小型应用（5'000~20'000行），实习时做过一些小项目（2'000行左右），到现在参与大型项目（100'000行以上）。如果让我总结这些项目的共同点，那么就是我在这些项目里都犯了各式各样的错误——小到喜闻乐见的"烫烫烫烫烫烫烫烫"，大到破坏整个应用兼容性导致上千用户流失，有的错误很愚蠢，有的错误则是聪明反被聪明误。</p>

<p>不过我可以安慰自己，因为我并非孤独——计算机程序向来以错误百出而臭名昭著，以至于计算机先驱<a href="http://en.wikipedia.org/wiki/Grace_hopper">Grace Hopper</a>近乎自嘲的为计算机程序错误取了一个别名——Bug。在之后的六十余年，Bug和其衍生词Debug一直是了所有程序员的梦魇。</p>

<p>Grace Hopper发现的“Bug”</p>

<p><img src="http://i.imgur.com/m36RhHW.jpg" alt="第一个Bug" /></p>

<p>随着经验的累积，我隐隐感觉到这些编程错误有一定的规律，因为我开始发现一些错误似乎在哪里见过，于是我开始寻找这方面的书籍和文献，以控制/减少自己的编程错误。</p>

<blockquote><p>Those who cannot remember the past are condemned to repeat it.</p>

<p>George Santayana</p></blockquote>

<p>然后我找到了<a href="http://en.wikipedia.org/wiki/Donald_Knuth">Knuth</a>的<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>。</p>

<h2>the Errors of TEX</h2>

<h3>背景</h3>

<p><img src="http://i.imgur.com/UF1uTSy.jpg" alt="Knuth" /></p>

<p>相信任何学计算机的人都知道Knuth和他神话（或神化）般（的<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>七卷本（未完成），但对Knuth开发的TEX以及Knuth开发TEX的流程可能就不是那么了解了，所以我在这里简单介绍下。</p>

<p><img src="http://i.imgur.com/3HzERY5.jpg" alt="TAOCP" /></p>

<p>撰写并出版<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>前三卷之后，Knuth发现印刷排版烂的一逼，在没有好使的数字排版系统的情况下，Knuth决定自己搞一个出来——于是就有了TEX。</p>

<p><img src="http://i.imgur.com/e6FqiCM.jpg" alt="TEX" /></p>

<p>不过排版系统并非简单的（Trivial）系统，即便如Knuth此般异禀天赋，也无法从容应付——事实上Knuth在开发TEX的过程中遇到了大量的错误，这些错误从TEX初版（1978年）到<a href="http://tug.org/TUGboat/tb35-1/tb109knut.pdf">最近的一次性能调优</a>（2014年），源源不断，挥之不去。</p>

<p>这些错误让Knuth很头痛，为了理解并控制编程错误，Knuth将这些错误整理到记录日志，并对这些编程错误进行分类，这成为了<a href="http://dl.acm.org/citation.cfm?id=66416">the Errors of TEX</a>一文的基础。</p>

<h3>插曲</h3>

<p>Knuth开发TEX的流程在我等屌丝码农看来绝对匪夷所思，在<a href="http://www.codersatwork.com/">Coders at Work</a>一书对Knuth的访谈里，Knuth提到：</p>

<blockquote><p>When I wrote TeX originally in 1977 and ’78, of course I didn’t have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>

<p>Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of ’78 while I had started writing the program in October of ’77. The code for that is in the Stanford archives—it’s all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p></blockquote>

<p>尽管有可能是1978年还没有好用的交互编程环境（Interactive Programming Environment），但Knuth六个月纸上设计纸上写代码的开发方式仍可以说是编程史上的一朵奇葩。如果放到今天，Knuth一定会被各路敏捷极限TDD编程<em>高手</em>喷出翔。</p>

<p>插曲到此为止，下篇进入正题——编程错误的分类（A Taxonomy of Programming Errors）。</p>

<p>——未完待续</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/on-programming-errors-0/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的设计——0. Prologue]]></title>
    <link href="http://zh.lucida.me/blog/design-of-design-0-prologue/"/>
    <updated>2014-06-06T23:06:06+01:00</updated>
    <id>http://zh.lucida.me/blog/design-of-design-0-prologue</id>
    <content type="html"><![CDATA[<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>

<h2>关于</h2>

<p>“设计中的设计”是一个博文系列，我打算在这个系列记录我所见过的优秀设计和优秀设计原则，并推荐一些（我认为）不错的设计书籍。</p>

<p>在“<strong>设计</strong>中的<em>设计</em>”里，第一个<strong>设计</strong>指具有杰出设计的优秀产品，而第二个<em>设计</em>指优秀产品具有的杰出设计。</p>

<p>此外，副标题里使用<strong>Prologue</strong>，主要是因为我接下来提到的产品（设计）大多没有中文名——为了一致，我决定在这一系列所有文章的副标题中统一使用英文。</p>

<p>最后，这一系列博文和原研哉的<a href="http://book.douban.com/subject/1336111/">設計中的設計</a>无关，尽管它们名字相同。</p>

<h2>为什么要写这个系列？</h2>

<p>作为一个码农，按理说我应该和设计绝缘——设计是美工的事情嘛，码农负责写好代码就成。事实上我之前也一直这么认为。</p>

<!-- more -->


<p>但在三年前我这个看法被动摇了——2011年是国内移动互联网井喷的一年，随着iPhone及其模仿者的大行其道，曾经的手机王者Nokia被迅速的淘汰出市场；随着手机应用开发门槛的降低（从Symbian到iOS或Android），各种手机应用喷涌而出。</p>

<p>在这段时间我编写了一些手机应用，并通过QQ群，邮件列表以及论坛等渠道直接与用户交流，在这个过程中，我悲观的发现用户的思维模式和我（开发者）的思维模式完全不同，我认为理所当然的东西他们认为不可理喻，反之亦然。</p>

<p>在那段时间里我一度绝望的认为所有的用户都是神经病、弱智或是某些代谢产物，后来在Microsoft ATC实习时结识了几个设计师朋友（<a href="http://weibo.com/u/3848053360">@Xing</a>和<a href="http://weibo.com/u/2104950751">@Yan</a>），我向他们大吐苦水，他们则非常腹黑的讲了一个笑话：</p>

<blockquote><p>丈夫驾车出门。妻子在家听广播，听到一则报道，妻子连忙拿起电话。</p>

<p>妻子：老公啊，我刚听广播上说，高速公路上有一辆车在逆行，你千万要小心。</p>

<p>老公：哪是一辆啊，我看有好几百辆车都在逆行。</p></blockquote>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/hei.png" alt="黑" /></p>

<p>被善意的黑出翔之后，我认为我不能这样一直逆行下去——于是我开始天天死皮赖脸的向他们请教：从设计的原则，到设计的书籍，再到用户的心理，我强迫自己跳出码农的思维模式，像正常人一样思考。</p>

<p>感谢他们的指导，尽管我无法成为像他们一样专业的优秀设计师，但我形成了一个大体的设计观：比如一个好设计应该是什么样子，而一个烂设计又应该是什么样子。</p>

<p>在这个设计观的指引下，接下来我编写的手机应用都获得了不错的评价（几乎全五星），在做私活时也总能做出令客户满意的产品。</p>

<h2>优秀的产品&amp;杰出的设计</h2>

<p>在朋友的推荐下，最近把《道德经》看了一遍，我认为《道德经》里面的一段文字可以套用在产品和设计上：</p>

<blockquote><p>太上，不知有之；</p>

<p>其次，亲而誉之；</p>

<p>其次，畏之；</p>

<p>其次，侮之；</p>

<p>信不足焉，有不信焉。</p>

<p>—— 《道德经》 十七章</p></blockquote>

<p>把上面的文字应用到产品和设计：</p>

<ul>
<li>优秀的设计使用户专注于产品本身，而忽略设计的存在。（例如Google（搜索引擎）和iPad）</li>
<li>不错的设计使用户感到舒适，用户会称赞它的设计。（例如iPod Classic，<a href="http://www.parrot.com/zik/uk/">Parrot Zik</a>和Amazon Kindle）</li>
<li>马虎的设计使用户感到不适，用户很难掌握产品的功能。（例如早期版本的Microsoft Office，vim编辑器和JavaScript语言）</li>
<li>糟糕的设计会毁掉一个产品，用户会把产品和产品的设计骂出翔。（例如Nokia的Symbian触屏手机和绝大多数Linux桌面系统）</li>
</ul>


<p>需要注意，我在上面列举的产品都具有强大的功能——它们有的成功，有的失败，区别就在于设计。</p>

<h2>The Inmates are Running the Asylum</h2>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/inmates_asylum.jpg" alt="The Inmates are Running the Asylum" /></p>

<p><a href="http://www.amazon.com/The-Inmates-Are-Running-Asylum/dp/0672326140/">The Inmates are Running the Asylum</a>的全名是：The Inmates Are Running the Asylum : Why High Tech Products Drive Us Crazy and How to Restore the Sanity，直译成中文是：疯子开精神病院（为什么高科技产品总让我们抓狂以及如何打破这个窘境），可能是这个书名太惊悚，所以它的中文书名被分别译为<a href="http://book.douban.com/subject/1237849/">软件创新之路</a>（第一版）和<a href="http://book.douban.com/subject/1493316/">交互设计之路</a>（第二版）。</p>

<p>在这本书中，VB的创造者Alan Cooper创造性的把所有程序员黑了一遍——让程序员创造面向用户的软件，等价于让一群疯子开精神病院——因为能成为程序员的人思维本身就不正常：</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/ynm3000.png" alt="要你命3000" /></p>

<p>这是<a href="http://movie.douban.com/subject/1307739/">达文西</a>发明的要你命3000。</p>

<p><img src="http://lucida-imgs.b0.upaiyun.com/blogs/dod_0/crazy_app.jpg" alt="要你命3000000000" /></p>

<p>这是程序员发明的要你命3000000000。</p>

<p>当然这本书不只是为了黑程序员，作者花了大量篇幅解释为什么现在的产品随着科技含量的提高反而愈发不好用，并提出了<a href="http://en.wikipedia.org/wiki/Interaction_design#Goal-oriented_design">认知摩擦（Cognitive friction）</a>、<a href="http://www.slideshare.net/PublishingTechnology/dancing-bears-pubtech">跳舞的熊（Dancing bear）</a>以及逻辑人（Homo logicus）等令人耳目一新的概念。总而言之，<a href="http://en.wikipedia.org/wiki/Interaction_design">交互设计（Interaction Design）</a>对于软件开发必不可少。</p>

<p>如果你是一个想做出好产品的程序员（码农），那么这本书值得一读——它会打破你现有的观念，让你意识到优秀的产品需要设计。就像我的朋友讲的那个笑话，它会让你意识到<strong>是你在逆行，而不是你面前的几百辆车在逆行。</strong></p>

<p>（未完待续）</p>

<p>作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<ul>
<li><a href="http://www.weibo.com/pegong/">微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p><a href="http://zh.lucida.me/blog/design-of-design-0-prologue/">原文链接</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于锤子手机和锤子手机发布会]]></title>
    <link href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/"/>
    <updated>2014-05-24T09:33:38+01:00</updated>
    <id>http://zh.lucida.me/blog/on-the-keynote-of-t-one</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>本文记录了作者对<a href="http://v.youku.com/v_show/id_XNzE0Nzc0OTQ0.html">锤子手机发布会</a>和<a href="http://www.smartisan.com/">锤子手机</a>的一点感受，仅代表个人看法，但欢迎评论。</p>

<p>原文作者：</p>

<ul>
<li><a href="http://zh.lucida.me/">Lucida Blog</a></li>
<li><a href="http://www.weibo.com/pegong/">新浪微博</a></li>
<li><a href="http://www.douban.com/people/figure9/">豆瓣</a></li>
</ul>


<p>原文链接：<a href="http://zh.lucida.me/blog/on-the-keynote-of-t-one/">http://zh.lucida.me/blog/on-the-keynote-of-t-one/</a></p>

<h2>重复</h2>

<p>演讲（或说服）有一个要点是重复，老罗显然深得此道，整场发布会下面的句式均被重复了不止五遍：</p>

<ul>
<li>作为一个大众消费品…………（表明自己站在消费者这边）</li>
<li>作为一个小厂商…………（博取听众（消费者）的同情（sympathy）和容忍（tolerance））</li>
<li>作为一个企业家，我不该…………（在贬低其它企业之后均以此句开脱）</li>
</ul>


<h2>误导</h2>

<p>在提到锤子手机音质时老罗举了这样的例子：</p>

<blockquote><p>我老婆之前认为自己是木耳，听不出音质的区别，但把苹果耳机换成几百森海塞尔后，她明显感到音质有了很大的提升。</p></blockquote>

<p>以证明即便是普通人也可以感受到音质的区别。</p>

<p>但这里有个问题：老罗夫人感受到的音质的提升源自于<strong>耳机</strong>，而非<strong>音源</strong>。在同等耳机的情况下，我怀疑老罗夫人是否还能听出锤子手机和同类手机间音质的区别。</p>

<p>此外，在提到无法更换壁纸的问题时老罗是这么解释的：</p>

<blockquote><p>我无法忍受把一堆图标堆在亲人的脸上。</p></blockquote>

<p>似乎确实很有道理，但再想一想，为什么一定要用亲人头像做壁纸呢？如果我要用风景或是纯色呢？</p>

<!-- more -->


<h2>冷知识</h2>

<p>老罗很擅长用一些冷门知识去吸引人，这样的例子在这次发布会上数不胜数：</p>

<ul>
<li>不断的列出硬件厂商的渊源。</li>
<li>指出锤子手机手机盒子使用了某英国著名公司的纸。</li>
<li>强调光线传感器的设计。</li>
<li>自带螺丝刀和若干螺丝钉。</li>
</ul>


<p>个人认为这些东西是Boilerplate——懂编程的童鞋应该明白我的意思。</p>

<h2>拍照效果</h2>

<p>老罗宣称锤子手机是目前最好的拍照手机之一，并花了大量时间去阐述他在打造拍照效果上所付出的努力，比如：</p>

<ul>
<li>寻找最好的拍照调校团队。</li>
<li>使用最好的摄像镜头。</li>
</ul>


<p>但令我疑惑的是：发布会并没有任何拍照效果的对比，甚至连锤子手机的拍照样张都没有——如果拍照效果真的那么强大，我不认为老罗会放这个贬低其他竞争对手的机会于不顾。</p>

<h2>双音量键</h2>

<p>锤子手机有一个很有趣的设计是双音量键——在单独使用时可以分别作为音量调节和亮度调节使用，而一起使用时则可以进行抢拍或快速启动某个指定应用程序。</p>

<p>这也带来了老罗所宣称的“全世界最快的抢拍手机”这个卖点。</p>

<p>但我还是有几个疑问：</p>

<ol>
<li>双音量键一起使用是一个很不直观的设计。</li>
<li>同时使用双音量键很不自然，不信的话你在你的手机上试试这个姿势。</li>
<li>从设计图上可以看出音量键并没有明显凸起——这意味着操作时需要按<strong>进</strong>音量键，也意味着任何手机壳或是bumper之类阻隔音量键的手机饰品均会妨碍音量键的正常使用。</li>
</ol>


<h2>对苹果的模仿</h2>

<h3>锤子手机在模仿iPhone5</h3>

<p>这里借用某条<a href="http://weibo.com/1847542877/B5fhi9RoE">微博</a>里的图片：</p>

<p><img src="http://i.imgur.com/VOSZ1dX.jpg" alt="无处不在的模仿" /></p>

<h3>锤子手机发布会处处在模仿iPhone1发布会</h3>

<p>iPhone1发布会时Jobs曾给出一个转盘手机的假想图：</p>

<p><img src="http://i.imgur.com/sfOzhfx.png" alt="转盘手机" /></p>

<p>老罗则给出一个锤子手机的假想图：</p>

<p><img src="http://i.imgur.com/fkoM9QQ.png" alt="锤子手机" /></p>

<p>iPhone1发布时Jobs强调三位一体的概念：</p>

<p><img src="http://i.imgur.com/WDmytpx.png" alt="三位一体" /></p>

<p>老罗也是如此：</p>

<p><img src="http://i.imgur.com/FK5fsC2.png" alt="又一个三位一体" /></p>

<p>Jobs经常在发布会最后来一个“One more thing”：</p>

<p><img src="http://i.imgur.com/ebmQPgi.png" alt="One more thing" /></p>

<p>到了老罗这里变成“还有两个好东西”：</p>

<p><img src="http://i.imgur.com/6yXVZ4a.png" alt="还有两个好东西" /></p>

<h2>软件改进</h2>

<p>下面是老罗重点介绍的锤子手机的软件改进：</p>

<ul>
<li>可以更换的主题：这个我真觉的不是啥改进——除非要和Windows Phone比。</li>
<li>手指横扫解决单手操作问题：很有创意的想法，但我注意到即便老罗本人如此操作锤子手机时也有相当的失误率——我怀疑这个功能的实用性。</li>
<li>通过短信内容智能新建日历：无论是Google还是Apple都已经有这个功能。</li>
<li>定时解除静音：很赞，这是我一直希望的功能。</li>
<li>区域截屏：看似很赞，但仔细一想几乎所有的手机聊天应用里面都带有编辑图片的选项，此外我个人对这个功能的稳定性有疑问。</li>
</ul>


<h2>总结</h2>

<p>锤子手机发布会最大的亮点是对OpenSSL的捐款，至于锤子手机本身……抱歉我没看到什么亮点。</p>

<p>但令我诧异的是很多资深人士纷纷表示看好锤子手机（发布会），<a href="http://www.weibo.com/fenng">fenng</a>甚至在微信上宣称这是手机行业迄今为止最好的产品发布会——</p>

<p><img src="http://i.imgur.com/MqEKRBk.jpg" alt="最好的产品发布会？？" /></p>

<p>我不清楚他是否也把iPhone发布会算在内。</p>

<p>总之，在锤子手机发布会上，我看到的是一个人在不断的强调自己有多努力多认真，但我也知道当某人不断的给你强调他有多努力（effort）时，事实往往是他还没有获得任何实质性成果（progress），简而言之，effort不等于progress，就这场发布会所得到的信息，我依然认为锤子手机没有希望。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的算法学习之路]]></title>
    <link href="http://zh.lucida.me/blog/on-learning-algorithms/"/>
    <updated>2014-05-04T21:43:42+01:00</updated>
    <id>http://zh.lucida.me/blog/on-learning-algorithms</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>严格来说，本文题目应该是<strong>我的数据结构和算法学习之路</strong>，但这个写法实在太绕口——况且CS中的算法往往暗指数据结构和算法（例如<strong>算法导论</strong>指的实际上是<strong>数据结构和算法导论</strong>），所以我认为本文题目是合理的。</p>

<p>原文链接：<a href="http://zh.lucida.me/blog/on-learning-algorithms/">http://zh.lucida.me/blog/on-learning-algorithms/</a></p>

<p>原文作者：<a href="http://zh.lucida.me/">Lucida</a></p>

<h3>这篇文章讲了什么？</h3>

<ul>
<li>我这些年学习数据结构和算法的总结。</li>
<li>一些不错的算法书籍和教程。</li>
<li>算法的重要性。</li>
</ul>


<h2>初学</h2>

<p>第一次接触数据结构是在大二下学期的数据结构课程。然而这门课程并没有让我入门——当时自己正忙于倒卖各种MP3和耳机，对于这些课程根本就不屑一顾——反正最后考试划个重点也能过，于是这门整个计算机专业本科最重要的课程就被傻逼的我直接忽略过去了。</p>

<p>直到大三我才反应过来以后还要找工作——而且大二的折腾证明了我并没有什么商业才能，以后还是得靠码代码混饭吃，我当时惊恐的发现自己对编程序几乎一无所知，于是我给自己制订了一个类似于建国初期五年计划的读书成长计划，其中包括C语言基础、数据结构以及计算机网络等方面的书籍。</p>

<p>读书计划的第一步是选择书籍，我曾向当时我觉得很牛的"学长"和"大神"请教应该读哪些算法书籍，"学长"们均推荐算法导论，还有几个"大神"推荐计算机程序设计艺术（现在我疑心他们是否翻过这些书），草草的翻了下这两本书发现实在看不懂，但幸运的是我在无意中发现了<a href="http://www.douban.com/">豆瓣</a>这个神奇的网站，里面有很多质量不错的书评，于是我就把评价很高而且看上去不那么吓人的计算机书籍都买了下来——事实证明豆瓣要比这些"学长"或是"大神"靠谱的多得多。</p>

<!-- more -->


<h3>数据结构与算法分析——C语言描述</h3>

<p><img src="http://img3.douban.com/lpic/s1106991.jpg" alt="数据结构与算法分析——C语言描述" /></p>

<p><a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我学习数据结构的第一本书：当时有很多地方看不懂，于是做记号反复看；代码看不明白，于是抄到本子上反复研读；一些算法想不通，就把它所有的中间状态全画出来然后反复推演。事实证明尽管这种学习方法看起来傻逼而且效率很低，但对于当时同样傻逼的我却效果不错——傻人用傻办法嘛，而且这本书的课后题大多都是经典的面试题目，以至于日后我看到<a href="http://book.douban.com/subject/3004255/">编程之美</a>的第一反应就是这货的题目不全是抄别人的么。</p>

<p>至今记得，这本书为了说明算法是多么重要，在开篇就拿最大子序列和作为例子，一路把复杂度从O(N<sup>3</sup>)杀到O(N<sup>2</sup>)再到O(NlgN)最后到O(N)，当时内心真的是景仰之情=如滔滔江水连绵不绝，尼玛为何可以这么屌，</p>

<p>此外，我当时还把这本书里图算法之前的数据结构全手打了一遍，后来找实习还颇为自得的把这件事放到简历里，现在想想真是傻逼无极限。</p>

<p>凭借这个读书成长计划中学到的知识，我总算比较顺利的找到了一份实习工作，这是后话。</p>

<h2>入门</h2>

<p>我的实习并没有用到什么算法（现在看来就是不停的堆砌已有的API，编写一堆自己都不知道对不对的代码而已），在发现身边的人工作了几年却还在和我做同样的事情之后，我开始越来越不安。尽管当时我对自己没什么规划，但我清楚这绝壁不是我想做的工作。</p>

<h3>微软的梦工厂</h3>

<p><img src="http://img3.douban.com/lpic/s3322643.jpg" alt="微软的梦工厂" /></p>

<p>在这个摇摆不定的时刻，<a href="http://book.douban.com/subject/3238803/">微软的梦工场</a>成了压倒骆驼的最后一支稻草，这本书对微软亚洲研究院的描写让我下定了"找工作就要这样的公司"的决心，然而我又悲观的发现无论是以我当时的能力还是文凭，都无法达到微软亚研院的要求，矛盾之下，我彻底推翻了自己"毕业就工作"的想法，辞掉实习，准备考研。</p>

<p>考研的细节无需赘述，但至今仍清楚的记得自己在复试时惊奇且激动的发现北航宿舍对面就是微软西格玛大厦，那种离理想又进了一步的感觉简直爽到爆。</p>

<h3>算法设计与分析</h3>

<p>我的研究生生涯绝对是一个反面典型——翘课，实习，写水论文，做水研究，但有一点我颇为自得——从头到尾认真听了韩军教授的算法设计与分析课程。</p>

<p>韩军给我印象最深的有两点：课堂休息时跑到外面和几个学生借火抽烟；讲解算法时的犀利和毫不含糊。</p>

<p><img src="http://img3.douban.com/lpic/s2019521.jpg" alt="算法设计与分析基础" /></p>

<p>尽管韩军从来没有主动提及，但我敢肯定<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是他算法课程事实上的（de-facto）教材，因为他的课程结构几乎和这本书的组织结构一模一样。</p>

<p>如果<a href="http://book.douban.com/subject/1139426/">数据结构与算法分析——C语言描述</a>是我的数据结构启蒙，那么韩军的课程和<a href="http://book.douban.com/subject/1968704/">算法设计与分析基础</a>就是我的算法启蒙，结合课程和书籍，我一一理解并掌握了复杂度分析、分治、减治、变治、动态规划和回溯这些简单但强大的算法工具。</p>

<h3>算法引论</h3>

<p><img src="http://img5.douban.com/lpic/s4230097.jpg" alt="算法引论" /></p>

<p><a href="http://book.douban.com/subject/4178907/">算法引论</a>是我这时无意中读到的另一本算法书，和普通的算法书不同，这本书从创造性的角度出发——如果说算法导论讲的是有哪些算法，那么算法引论讲的就是如何创造算法。结合前面的<a href="http://img3.douban.com/lpic/s2019521.jpg">算法设计与分析基础</a>，这本书把我能解决的算法问题数量扩大了一个数量级。</p>

<p>之后，在机缘巧合下，我进入微软亚洲工程院实习，离理想又近了一步，自我感觉无限牛逼。</p>

<h2>巩固</h2>

<p>在微软工程院的实习是我研究生阶段的一个非常非常非常重要的转折点：</p>

<ol>
<li>做出了一个还说的过去的小项目。</li>
<li>期间百度实习面试受挫，痛定思痛之下阅读了大量的程序设计书。</li>
<li>微软的实习经历成为了我之后简历上为数不多的亮点之一（本屌一没成绩，二没论文，三没ACM）。</li>
</ol>


<p>这里就不说1和3了（和本文题目不搭边），重点说说2。</p>

<p>由于当时组内没有特别多的项目，我负责的那一小块又提前搞定了，mentor便很慷慨的扔给我一个Kinect和一部Windows Phone让我研究，研究嘛，自然就没有什么deadline，于是我就很鸡贼的把时间三七开：七分倒腾Windows Phone，三分看书&amp;经典论文。</p>

<p>然而一件事打断了这段安逸的生活——</p>

<h3>百度实习面试</h3>

<p>基友在人人发百度实习内推贴，当时自我感觉牛逼闪闪放光芒，于是就抱着看看国内IT环境+虐虐面试官的变态心理投了简历，结果在第一面就自己的师兄爆出翔：他让我写一个<code>stof</code>（字符串转浮点数），我磨磨唧唧半天也没写出完整实现，之后回到宿舍赶快写了一个版本发到师兄的邮箱，结果对方压根没鸟我。</p>

<p>这件事对我产生了很大的震动——</p>

<ul>
<li>原来自己连百度实习面试都过不去。</li>
<li>原来自己还是一个编程弱逼。</li>
<li>原来自己还是一个算法菜逼。</li>
</ul>


<p>痛定思痛，我开始了第二个"五年计划"，三七开的时间分配变成了七三开：七分看书，三分WP。而这一阶段的重点从原理（Principle）变成了实现（Implementation）——Talk is cheap, show me the code.</p>

<h3>Elements of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s4243636.jpg" alt="Elements of Programming" /></p>

<p>由于一直觉得名字里带"Elements of"的都是酷炫叼炸天的书，所以我几乎是毫不犹豫的买了这本<a href="http://book.douban.com/subject/3802826/">Elements of Programming</a>，事实上这本书里的代码（或者说STL的代码）确实是：快，狠，准，古龙高手三要素全齐。</p>

<h3>C Interfaces and Implementation</h3>

<p><img src="http://img5.douban.com/lpic/s1686769.jpg" alt="C Interfaces and Implementation" /></p>

<p>百度面试被爆出翔的经历让我意识到另一个问题，绝大多数公司面试时都需要在纸上写C代码，而我自己却很少用C（多数情况用C#），考虑到自己还没牛逼到能让公司改变面试流程的地步，我需要提升自己编写C代码的能力（哪怕只是为了面试）。一顿Google之后，我锁定了<a href="http://book.douban.com/subject/1826292/">C Interfaces and Implementation</a>——另一本关于如何写出狂炫酷帅叼炸天的C代码的奇书，这里套用下Amazon的<a href="http://www.amazon.com/review/RMXKDJNH8UOPU/">评论</a>：Probably the best advanced C book in existance。</p>

<p>严格来说上面两本书都不是传统的算法书，因为它们侧重的都不是算法，而是经典算法的具体实现（Implementation），然而这正是我所需要的：因为算法的原理我能说明白，但要给出优雅正确简练的实现我就傻逼了，哪怕是<code>stof</code>这种简单到爆的"算法"。</p>

<p>依然是以前的傻逼学习方法：反复研读+一遍又一遍的把代码抄写到本子上，艰难的完成了这两本书后，又读了相当数量的编程实践（Programming Practice）书籍，自我感觉编程能力又大幅提升，此外获得新技能——<strong>纸上编码</strong>。这也成为了我之后找工作面试的三板斧之一。</p>

<h2>应用</h2>

<p>说老实话，自从本科实习之后，我就一直觉得算法除了面试时能用用，其它基本用不上，甚至还写了一篇当时颇为自得现在读起来极为傻逼的<a href="http://book.douban.com/review/3733680/">文章</a>来黑那些动不动就"基础"或"内功"的所谓"大牛"们，这里摘取一段现在看起来很傻逼但当时却觉得是真理的文字：</p>

<blockquote><p>所以那些动则就扯什么算法啊基础啊内功啊所谓的大牛们，请闭上你的嘴，条条大道通罗马。算法并不是编程的前提条件，数学也不会阻碍一个人成为优秀的程序员。至少在我看来，什么算法基础内功都是唬人的玩意，多编点能用的实用的程序才是王道，当然如果你是一个pure theorist的话就当我什么都没说好了。</p></blockquote>

<p>然而有意思的是，写了这篇<a href="http://book.douban.com/review/3733680/">文章</a>没多久，鼓吹算法无用论的我自己做的几个大大小小的项目全部用到了算法——我疑心是上天在有意抽我的脸。</p>

<h3>LL(k)</h3>

<p>我在微软实习的第一个项目做的是<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A2%BC%E8%A6%86%E8%93%8B">代码覆盖率</a>分析——计算T-SQL存储过程的代码覆盖率。</p>

<p>简单的看了下SQL Server相关的文档，我很快发现SQL Reporting Service可以记录T-SQL的执行语句及行号，于是行覆盖（line coverage）搞定，但老大说行覆盖太naive，我们需要更实际的块覆盖（block coverage）。</p>

<p>阅读了块覆盖的定义后，我发现我需要对T-SQL进行语法分析，在没有找到一个好用的T-SQL Parser的情况下，只能自己动手搞一个：</p>

<p><img src="http://img5.douban.com/lpic/s24921197.jpg" alt="Language Implementation Patterns" /></p>

<p>比较奇诡的是，做这个项目时当时我刚好把<a href="http://www.antlr.org/">ANTLR</a>作者的<a href="http://book.douban.com/subject/4030327/">Language Implementation Patterns</a>看了一半，什么LL(k)啊Packrat啊AST Walker的概念啊正热乎着呢。</p>

<p>于是，自己自己就照着T-SQL的官方EBNF，三下五除二撸了一个T-SQL存储过程的LL(k) Parser，把代码转换成AST，然后用一个External AST Walker生成代码块覆盖的HTML报表，全部过程一周不到。</p>

<p>老大自然是很满意——我疑心他的原计划是花两三个月来完成这个项目，因为这个项目之后的两个月我都没什么活干，天天悠哉游哉。</p>

<h3>拼音索引</h3>

<p>拼音索引是我接的一个手机应用私活里的小模块，用户期待在手机文本框可以根据输入给出智能提示：</p>

<p>比如说输入中国：</p>

<p><img src="http://i.imgur.com/tjKjyzN.png" alt="智能提示" /></p>

<p>同样，输入拼音也应给出提示：</p>

<p><img src="http://i.imgur.com/zTjEBik.png" alt="智能提示" /></p>

<p>中文匹配这个简单，但拼音匹配就得花时间想想了——懒得造轮子的我第一时间找到了微软的拼音库，但接下来我就发现微软这个鸟库在手机上跑不动，研究了下发现WP7对Dictionary的items数量有限制，貌似是7000还是8000个item就会崩盘，而标准汉字则有两万多个，尼玛。</p>

<p>痛骂MS坑爹+汉字坑爹之余，还是得自己撸一个库出来：</p>

<ol>
<li>首先把那两万个汉字搞了出来，排序，然后弄成一个超长的字符串。</li>
<li>接下来用<code>Int16</code>索引了汉字所有的拼音（貌似500多个）。</li>
<li>再接下来用<code>Int64</code>建立汉字和拼音的关联——汉字有多音字，所以需要把多个拼音pack到一个<code>Int64</code>里，这个简单，位操作就搞定。</li>
<li>最后用二分+位移Unpack，直接做到从汉字到拼音的检索。</li>
<li>后来小测了下性能，速度是MS原来那个库的五十倍有余，而代码量只有336行。</li>
</ol>


<p>用户很happy——因为我捎带把他没想到的多音字都搞定了，而且流畅的一逼。</p>

<p>我也很happy，因为没想到自己写的库居然比MS的还要快几十倍，同时小十几倍。</p>

<p>从这个事情之后我变得特别理解那些造轮子的人——你要想想，<strong>如果你需要一个飞机轮子但市场上只有自行车轮子而且老板还催着你交工，你能怎么搞</strong>。</p>

<h3>快速字符串匹配</h3>

<p>前面提到在微软实习时老大扔给我一个Windows Phone让我研究下，我当时玩了玩就觉着不太对劲，找联系人太麻烦。</p>

<p>比如说找"张晓明"，WP只支持定位到Z分类下——这意味着我需要在Z分类下的七十多个联系人（姓张的姓赵的姓钟的等等）里面线性寻找，每次我都需要滑动四五秒才能找到这个张姓少年。</p>

<p><img src="http://i.imgur.com/R3JalOH.jpg" alt="E51" /></p>

<p>这TMD也太傻逼了，本屌三年前的老破NOKIA都支持首字母定位，996->ZXM->张晓明，直接搞定，尼玛一个新时代Windows Phone居然会弱到这个程度。</p>

<p>搜了一下发现没有好用的拨号程序，于是本屌就直接撸了一个支持首字母匹配的拨号程序出来扔到WP论坛里。</p>

<p>结果马上就有各种问题出现——最主要的反映是速度太慢，一些用户甚至反馈按键有时要半秒才有反应。本屌问了下他的通讯录大小：大概3000多人。</p>

<p><img src="http://i.imgur.com/Pfff0e9.jpg" alt="Cry" /></p>

<p>吐槽怎么会有这么奇葩的通讯录之余，我意识到自己的字符串匹配算法存在严重的性能问题：读取所有人的姓名计算出拼音，然后一个个的匹配——结果如果联系人数量太多的话，速度必然拙计。</p>

<p>于是我就开始苦思冥想有没有一个能够同时搜索多个字符串的高端算法，以至于那两天坐地铁都在嘟囔怎么才能把这个应用搞的快一些。</p>

<p><img src="http://img3.douban.com/lpic/s8978030.jpg" alt="Algorithms on Strings, Trees and Sequences" /></p>

<p>最终还是在<a href="http://book.douban.com/subject/1765938/">Algorithms on Strings, Trees and Sequences</a>里找到了答案——确实有能够同时搜索多个字符串的方法：Tries，而且这本书还用足足一章来讲怎么弄Multiple string comparison，看得我当时高潮迭起，直呼过瘾。</p>

<p>具体细节不多说，总之换了算法之后，匹配速度快了大约九十多倍，而且代码还短了几十行。哪怕是有10000个联系人，也能在0.1秒内搞定，速度瓶颈就这样愉快的被算法搞定。</p>

<h3>Writing Efficient Programs</h3>

<p>之后又做了若干个项目，多多少少都用到了"自制"的算法或数据结构，最奇诡的一次是写一个电子书阅读器里的分页，我照着模拟退火（Simulated Annealing）的原理写了一个快速分页算法，事实上这个算法确实很快——但问题是我都不知道为啥它会这么快。</p>

<p>总之，算法是一种<strong>将有限计算资源发挥到极致</strong>的武器，当计算资源很富余时算法确实没大用，但一旦到了效率瓶颈算法绝壁是开山第一刀（因为算法不要钱嘛！要不还得换CPU买SSD升级RAM，肉疼啊！！）。一些人会认为这种说法是有问题，因为编写新算法的人力成本有时比增加硬件的成本还要高——但别忘了增加硬件提升效率也是建立在算法是Scalable的基础上——说白了还是得撸算法。</p>

<p><img src="http://img3.douban.com/lpic/s3780111.jpg" alt="Writing Efficient Programs" /></p>

<p>说到优化这里顺带提一下<a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a>——很难找到一本讲代码优化的书（我疑心是自从Knuth说了<strong>过早优化是万恶之源</strong>之后没人敢写，万恶之源嘛，写它干毛），注意这本书讲的是代码优化——在不改变架构、算法以及硬件的前提之下进行的优化。尽管书中的一些诸如变量复用或是循环展开的trick已经过时，但总体仍不失为一本好书。</p>

<h2>提高</h2>

<p>实习实习着就到了研二暑假，接下来就是求职季。</p>

<p>求职季时我有一种莫名的复仇感——尼玛之前百度实习面试老子被你们黑的漫天飞翔，这回求职老子要把你们一个个黑回来，尼玛。</p>

<p>现在回想当时的心理实属傻逼+幼稚，但这种黑暗心理也起了一定的积极作用：我丝毫不敢有任何怠慢，以至于在5月份底我就开始准备求职笔试面试，比身边的同学早了两个月不止。</p>

<p>我没有像身边的同学那般刷题——而是继续看书抄代码学算法，因为我认为那些难得离谱的题面试官也不会问——事实上也是如此。</p>

<h3>Algorithm Design Manual</h3>

<p><img src="http://img3.douban.com/lpic/s10347625.jpg" alt="Algorithm Design Manual" /></p>

<p>因为很多Coding Interview的论坛都提到这本<a href="http://book.douban.com/subject/3072383/">红皮书</a>，我也跟风搞了一本。事实证明，仅仅是关于Backtrack Template那部分的描述就足以值回书价，更不用说它的Heuristics和课后题。</p>

<h3>编程珠玑&amp;更多的编程珠玑</h3>

<p><img src="http://img3.douban.com/lpic/s2712842.jpg" alt="Programming Pearls" /></p>

<p><img src="http://img3.douban.com/lpic/s7073511.jpg" alt="More Programming Pearls" /></p>

<p>这两本书就不用多介绍，<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>和<a href="http://book.douban.com/subject/1944826/">更多的编程珠玑</a>，没听说过这两本书请自行面壁。前者偏算法理论，后者偏算法轶事，前者提升能力，后者增长谈资，都值得一读。</p>

<h3>The Science of Programming</h3>

<p><img src="http://img5.douban.com/lpic/s2812798.jpg" alt="The Science of Programming" /></p>

<p>读到<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>里面关于Binary Search的正确性证明时我大呼过瘾，原来程序的正确性也是可以推导的，然后我就在那一章的引用里发现David Gries的<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>。看名字就觉得很厉害，直接搞了一本开撸。</p>

<p>不愧为<a href="http://book.douban.com/subject/1484451/">编程珠玑</a>引用的书籍，撸完<a href="http://book.douban.com/subject/2350559/">The Science of Programming</a>之后，本屌获得了<strong>证明简单代码段的正确性</strong>这个技能——求职面试三板斧之二。</p>

<p><strong>证明简单代码段的正确性</strong>是一个很神奇的技能——因为面试时大多数公司都会要求在纸上写一段代码，然后面试官检查这段代码，如果你能够自己证明自己写的代码是正确的，面试官还能挑剔什么呢？</p>

<p>之后就是各种面试，详情见之前的<a href="http://www.cnblogs.com/figure9/archive/2013/01/09/2853649.html">博客</a>，总之就是<strong>项目经历</strong>、<strong>纸上代码</strong>加<strong>正确性证明</strong>这三板斧，摧枯拉朽。</p>

<h2>进化</h2>

<p>求职毕业季之后就是各种Happy，Happy过后本屌发现即将面临另一个问题：算法能力不足。</p>

<p>因为据说以后的同事大多是ACM选手，而本屌从来没搞过算法竞赛，而且知道的算法和数据结构都极为基础：像那些元胞自动机、斐波那契堆或是线段树这些高端数据结构压根只是能把它们的英文名称<strong>拼写</strong>出来，连用都没用过，所以心理忐忑的一逼。</p>

<p>为了不至于到时入职被鄙视的太惨烈，加上自己一贯的算法自卑症，本屌强制自己再次学习算法：</p>

<h3>Algorithms 4th</h3>

<p><img src="http://img5.douban.com/lpic/s8938479.jpg" alt="Algorithms" /></p>

<p><a href="http://book.douban.com/subject/10432347/">Algorithms</a>是我重温算法的第一本书，尽管它实际就是一本<a href="http://book.douban.com/review/5348372/">数据结构的入门书</a>，但它确实适合当时已经快把算法忘光的本屌——不为学习，只为重温。</p>

<p>这本书最大的亮点在于它把Visualization和Formatting做到了极致——也许它不是最好的数据结构入门书，但它绝壁是我读过的排版最好的书，阅读体验爽的一逼；当然这本书的内容也不错，尤其是红黑树那一部分，我想不会有什么书会比此书讲的更明白。</p>

<h3>6.851 Advanced Data Structures</h3>

<p><img src="http://courses.csail.mit.edu/6.851/spring12/illus.png" alt="Advanced Data Structures" /></p>

<p><a href="http://courses.csail.mit.edu/6.851/">Advanced Data Structures</a>是MIT的高级数据结构教程，为什么会找到这个教程呢？因为Google <strong>Advanced Data Structures</strong>第一个出来的就是这货。</p>

<p>这门课包含各种让本屌世界观崩坏的奇诡数据结构和算法，它们包括但不限于：</p>

<ul>
<li>带"记忆"的数据结构（Data Structure with Persistence）。</li>
<li>van Emde Boas（逆天的插入，删除，前驱和后继时间复杂度）。</li>
<li>o(1)时间复杂度的的LCA、RMQ和LA解法。</li>
<li>奇幻的o(n)时间复杂度的Suffix Tree构建方法。</li>
<li>o(lglgn)的BST。</li>
<li>&hellip;</li>
</ul>


<p>总之高潮迭起，分分高能，唯一的不足就是没有把它们实现一圈。以后本屌一定找时间把它们一个个撸一遍。</p>

<h2>总结</h2>

<p>从接触算法到现在，大概七年：初学时推崇算法牛逼论，实习后鼓吹算法无用论，读研后再被现实打回算法牛逼论。</p>

<p>怎么这么像辩证法里的肯定到否定再到否定之否定。</p>

<p>现在来看，相当数量的鼓吹算法牛逼论的人其实不懂算法的重要性——如果你连用算法解决<strong>实际</strong>问题的经历都没有，那你如何可以证明算法很有用？而绝大多数鼓吹算法无用论的人不过是低水平码农的无病呻吟——他们从未碰到过需要用算法解决的难题，自然不知道算法有多重要。</p>

<p><a href="http://norvig.com/">Peter Norvig</a>曾经写过一篇非常精彩的<a href="http://www.amazon.com/review/R403HR4VL71K8/">SICP书评</a>，我认为这里把SICP换成算法依然适用：</p>

<blockquote><p>To use an analogy, if algorithms were about automobiles, it would be for the person who wants to know how cars work, how they are built, and how one might design fuel-efficient, safe, reliable vehicles for the 21st century. The people who hate algorithms are the ones who just want to know how to drive their car on the highway, just like everyone else.</p></blockquote>

<p>MIT教授<a href="http://erikdemaine.org/">Erik Demaine</a>则更为直接：</p>

<blockquote><p>If you want to become a good programmer, you can spend 10 years programming, or spend 2 years programming and learning algorithms.</p></blockquote>

<p>总而言之，如果你想成为一个码农或是熟练工（Code Monkey），你大可以不学算法，因为算法对你确实没有用；但如果你想成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断的掉进一些只能借助算法才能爬出去的坑里。</p>

<p>以上。</p>

<p>By <a href="http://zh.lucida.me">Lucida</a></p>
]]></content>
  </entry>
  
</feed>
