<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Retrospection | Lucida]]></title>
  <link href="http://lucida.github.io/blog/categories/retrospection/atom.xml" rel="self"/>
  <link href="http://lucida.github.io/"/>
  <updated>2014-04-13T02:01:10+01:00</updated>
  <id>http://lucida.github.io/</id>
  <author>
    <name><![CDATA[Lucida]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习&使用技术的四种层次]]></title>
    <link href="http://lucida.github.io/blog/levels-on-learning-and-using-technologies/"/>
    <updated>2014-04-13T01:53:21+01:00</updated>
    <id>http://lucida.github.io/blog/levels-on-learning-and-using-technologies</id>
    <content type="html"><![CDATA[<h1>学习&amp;使用技术的四种层次</h1>

<h2>关键字</h2>

<p>技术，生活，反思。</p>

<p>本文链接：<a href="http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/">http://zh.lucida.me/blog/levels-on-learning-and-using-technologies/</a></p>

<h2>关于</h2>

<p>Bjarne Stroustrup在他的新书《<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A tour of C++</a>》</p>

<p><img src="http://i.imgur.com/VlQ7ROA.jpg" alt="A tour of C++" style="max-height: 370px;"/></p>

<p>里面举了一个旅行的例子来比喻初学编程语言：</p>

<blockquote><p>&hellip;as an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions what to see next&hellip;</p>

<p>&hellip;you do not know the city after such a tour. You do not understand all you have seen and heard. You do not know how to navigate the formal and informal rules that govern life in the city&hellip;</p>

<p>&hellip;to really know a city, you have to live in it, often for years.</p></blockquote>

<p>简而言之，编程语言是City，而开发者则是Traveller——这是一个很有意思的比喻，在这篇文章里，我试图<strong>延续</strong>这个类比（Analogy）——把这个类比放大到初学，掌握，了解以至精通一门技术的层面。</p>

<p>不过需要注意：我自己并没有精通哪一门技术——所以这篇文章的内容是值得怀疑（susceptible）的，但它可以作为一个不错的参考。</p>

<h2>0. Stranger（陌生人）</h2>

<p>使用一项技术最初的层次就是听说过没用过——就像我们之中的大多数人都听过南极，听过北极，知道南极有企鹅，北极有北极熊，但是却从来没有去过南极或北极。</p>

<p>Stranger具有以下的特征：</p>

<ul>
<li>知道这项技术的名字。</li>
<li>知道这项技术的一些术语。</li>
<li>知道这项技术的一些关键人物的名字。</li>
<li>了解少量技术的细节，但没有使用这项技术的实际经验。</li>
</ul>


<p>以我本人和RoR来打个比方：</p>

<ul>
<li>知道RoR是Ruby on Rails。</li>
<li>知道Rails，Gem和Rake的存在。</li>
<li>知道DHH也知道松本行弘。</li>
<li>看过<a href="http://www.amazon.co.uk/Ruby-Programming-Language-David-Flanagan/dp/0596516177/">The Ruby Programming Language</a>，还使用一个基于RoR的博客框架<a href="http://octopress.org/">Octopress</a>写博客。</li>
<li>但从来没有使用RoR去搭建网站。</li>
</ul>


<p>所以我是一个RoR的Stranger。</p>

<p>对于新技术，绝大多数人都是Stranger——但是就我对国内技术社区的观察，相当Stranger意识不到自己还是Stranger——认为知道一点术语一些人名就算了解一门技术，甚至把它写在简历上（Familiar with XXX）或是开始与别人进行讨论（当然都是无意义的讨论）。</p>

<h2>1. Tourist（旅行者）</h2>

<p>当开发者真正开始用一项技术作出了可以用的东西：</p>

<ul>
<li>面向用户的产品（End-User-Oriented Product），比如一个手机应用，或是一个浏览器插件。</li>
<li>或是面向程序员的工具（Programmer-Oriented Tools），比如一个页面抓取框架，或一个简单的Parser Generator。</li>
<li>注意教科书范例（Textbook examples）和Hello world不属于可以用的东西——这些只是Dead Code——被执行一两次，然后被遗忘。</li>
</ul>


<p>这时这个开发者就进入到了Tourist阶段：</p>

<ul>
<li>了解这项技术的基本元素。</li>
<li>使用这项技术做出了实用的产品或工具。</li>
<li>了解对这项技术的部分细节。</li>
</ul>


<p>根据的学习目的的不同，Tourist又可以分为Salesman和Sightseer。</p>

<h3>1.1. Salesman（旅行商）</h3>

<p><img src="http://i.imgur.com/k5oucJ5.jpg" alt="Salesman" style="max-height: 370px;"/></p>

<p>Salesman是具有明确目的的Tourist——他们学习技术的目标是为了完成某一项业务，就像旅行商去某地出差是为了卖商品而非观光一样。</p>

<p>绝大多数职业开发者在开发生涯中都会扮演Salesman这个角色——接到一个任务，涉及到某项不熟悉的技术，需要在限定时间内完成。</p>

<h3>1.2. Sightseer（观光者）</h3>

<p><img src="http://i.imgur.com/RpYoDXc.gif" alt="Sightseer" style="max-height: 370px;"/></p>

<p>和Salesman相反，Sightseer学习技术的目标是为了拓展视野，增加见识，而非完成某项特定业务。</p>

<p>具有主动学习精神的开发者在业余时会时常扮演Sightseer角色——找到自己认为有价值的新技术或是基础知识进行系统学习，从而拓宽视野，提高水平。</p>

<h2>2. Resident（居住者）</h2>

<p>如果一个旅行者在一个地方待了半年以上，那么他/她就会变得原来越像当地人。随着Tourist对某项技术的日益精进，他/她会逐渐演变成这项技术的Resident：</p>

<ul>
<li>熟悉这项技术的基本元素。</li>
<li>熟悉这项技术的生态系统（Ecology）：既包括开发工具（编辑器，命令行工具，集成开发环境等），也包括开发社区（讨论组，邮件列表等）。</li>
<li>了解这项技术能做什么，不能做什么。</li>
<li>了解这项技术有那些坑，如何绕过这些坑，以及识别这些坑带来的问题。</li>
<li>对某些领域有深入的研究——但并不受限于特定领域。</li>
<li>使用这项技术做出了有相当价值的产品或工具。</li>
</ul>


<p>同Tourist一样，根据使用技术的目标不同，Resident可以分为Worker和Craftsman：</p>

<h2>2.1. Worker（工人）</h2>

<p><img src="http://i.imgur.com/jGNNrQp.jpg" alt="Worker" style="max-height: 370px;"/></p>

<p>技术是Worker的谋生手段，一个优秀的Worker应具备以下特征：</p>

<ul>
<li>对于给定问题，知道如何给出经济有效的解决方案。</li>
<li>以团队合作为主，了解团队合作的价值，能够推动团队项目健康前进。</li>
<li>追求按时交付。</li>
</ul>


<h3>2.2. Craftsman（工匠）</h3>

<p><img src="http://i.imgur.com/9RRUjmb.jpg" alt="Craftsman" style="max-height: 370px;"/></p>

<p>同Worker不同，技术并非Craftsman的谋生手段，而是某种“副业”——用来提升声望，修炼开发水平。</p>

<p>一个优秀的Craftman往往具备以下特点：</p>

<ul>
<li>对于给定问题，知道如何给出优雅的解决方案。</li>
<li>以单兵作战为主，主要靠个人推进项目，但也能进行一定程度的团队合作。</li>
<li>追求极致美感。</li>
</ul>


<h2>3. Architect（架构者）</h2>

<p>有想法且有能力的人在一个地方待久了都会有将这个地方变的更好的冲动——一种方式是从源头出发，推翻旧制度建立新社会，也就是革命；另一种方式则是保留现有的制度，对其进行温和但持续的改进，也就是改良。</p>

<p>技术也是如此，任何技术都跟不上开发者成长的脚步，当这种差距到达一定程度时，就会有卓越的开发者站出来，创造出新的技术，他们就是Architect：</p>

<ul>
<li>熟悉多项互相关联的技术，并了解他们的优势和不足。</li>
<li>具备强大的领导能力，深厚的基础和大量实际开发经验。</li>
<li>能够带动整个技术的生态系统发展。</li>
<li>好吧，我编不下去了（尼玛我要都知道我还至于是IT苦屌么 &ndash;_-）</li>
</ul>


<p>如果你看过<a href="http://movie.douban.com/subject/1304141/">Matrix 2: Reloaded</a></p>

<p><img src="http://i.imgur.com/EDyNv4F.jpg" alt="Matrix 2: Reloaded" style="max-height: 370px;"/></p>

<p>就会知道Architect这个词放在这里再好不过。</p>

<p>根据目标不同，Architect分为Reformist和Revolutionist。</p>

<h3>3.1. Reformist（改良者）</h3>

<p><img src="http://i.imgur.com/xp2SzWu.jpg" alt="Reformist" style="max-height: 370px;"/></p>

<p>改良者的目标：<strong>把现有技术变的更好</strong>。（<strong>Makes</strong> existing technology better）</p>

<p>例如：</p>

<ul>
<li>GoF总结<a href="http://en.wikipedia.org/wiki/Design_Patterns">Design Pattern</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/John_Resig">John Resig</a>创造<a href="http://en.wikipedia.org/wiki/Jquery">jQuery</a>。</li>
<li><a href="http://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>为C#引入<a href="http://en.wikipedia.org/wiki/LINQ">LINQ</a>。</li>
</ul>


<h3>3.2. Revolutionist（革命者）</h3>

<p><img src="http://i.imgur.com/cpmjDCC.jpg" alt="Revolutionist" style="max-height: 370px;"/></p>

<p>革命者的目标：<strong>用更好的技术取代现有技术</strong>。（<strong>Replaces</strong> existing technology with better one）</p>

<p>例如：</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Alan_kay">Alan Kay</a>把细胞的概念引入软件开发]进而创造出<a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>的核心概念。</li>
<li><a href="http://en.wikipedia.org/wiki/Donald_Knuth">Don Knuth</a>对计算机算法（<a href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">TAOCP</a>）以及计算机排版（TEX）的贡献。</li>
<li>iPhone于2010年之前的任何手机（iPhone4除外）。</li>
</ul>


<h2>小结</h2>

<p>这篇文章利用<a href="http://www.amazon.co.uk/Tour-C--Depth/dp/0321958314/">A Tour of C++</a>里的隐喻，把学习/使用技术分成了四个层次七个头衔：Stranger，Tourist（Salesman，Sightseer），Resident（Worker，Craftsman），Architect（Reformist，Revolutionist），然后给出了各个头衔所应具备的特征和能力。</p>

<h3>关于同类文章</h3>

<p>之前也有类似的文章，例如<a href="http://blog.itpub.net/6517/viewspace-611506/">程序员的十层境界</a>和<a href="http://blog.csdn.net/happydeer/article/details/8107560">开发者的八种境界</a></p>

<p>这些文章的共同点：</p>

<ol>
<li>看似很牛逼但回想一下啥都没说。</li>
<li>不会给人带来什么价值。</li>
<li>没有一个鉴别的标准。</li>
<li>没有指导性，也没有使用价值。</li>
</ol>


<h3>本文的应用场景</h3>

<h4>考察状态</h4>

<p>以我自己对编程语言的掌握为例：</p>

<ul>
<li>C/C++: Stranger.</li>
<li>Python: Craftsman.</li>
<li>Java: Worker.</li>
<li>C#: Craftsman.</li>
<li>JavaScript: Sightseer.</li>
<li>Scheme: Sightseer</li>
</ul>


<p>将上面的列表转置：</p>

<ul>
<li>Stranger: C/C++</li>
<li>Sightseer: JavaScript, Scheme</li>
<li>Worker: Java</li>
<li>Craftsman: C#, Python</li>
</ul>


<p>结合这些头衔的定义，一目了然。</p>

<h4>制定计划</h4>

<p>运用本文的词汇，可以进行非常精炼的计划制定：</p>

<ul>
<li>例如 Make a thoroughly <strong>sightseeing</strong> of <strong>C++</strong>；</li>
<li>或是 Become a proficient <strong>worker</strong> on <strong>IntelliJ</strong>；</li>
<li>抑或 Take a short <strong>tour</strong> of <strong>Sublime Text</strong>。</li>
</ul>


<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[三月小结（暨TARQIE——一种量化成长的方法（下））]]></title>
    <link href="http://lucida.github.io/blog/summary-of-march-2014/"/>
    <updated>2014-04-06T23:24:33+01:00</updated>
    <id>http://lucida.github.io/blog/summary-of-march-2014</id>
    <content type="html"><![CDATA[<h1>三月小结（暨TARQIE——一种量化成长的方法（下））</h1>

<h2>目标实际完成情况</h2>

<h3>Tarqie-J</h3>

<ol>
<li>目标

<ul>
<li>高效完成Q1 OKR。 &ndash;> 1.0

<ul>
<li>搞定，超出Manager和Mentor的预期。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>成功迁移124个Test。 &ndash;> 1.0

<ul>
<li>搞定，并且构建了持续测试环境。</li>
</ul>
</li>
<li>为这些Test配置一个可稳定运行的环境。 &ndash;> 0.8

<ul>
<li>基本搞定，但仍存在少量（每天1~2次）的不稳定状况。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>恬着脸皮向不同的同事请教。 &ndash;> 1.0

<ul>
<li>达成——基本每个同事都被我骚扰了一遍 &ndash;_&ndash;</li>
</ul>
</li>
<li>理解当前Test的架构和流程。 &ndash;> 1.0

<ul>
<li>重建测试框架的过程中了解</li>
</ul>
</li>
<li>阅读The Art Of Unit Test，Guice Book和GuiceBerry Manual，了解如何用Guice写良好的Test。 &ndash;> 0.7

<ul>
<li>部分完成，阅读Google Guice Book，了解了Guice运作机制。</li>
</ul>
</li>
<li>阅读Java Best Practices和Effective Java。 &ndash;> 0.8

<ul>
<li>部分完成，重新阅读了JBP，但Effective Java只看了一多半。</li>
</ul>
</li>
<li>阅读Java Performance，了解JVM。 &ndash;> 0.7

<ul>
<li>部分完成，阅读了国产的<a href="http://book.douban.com/subject/24722612/">《深入理解Java虚拟机》</a>，了解Java内存管理/回收，字节码生成等内容。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>每周与mentor交流，进行进度控制/难点求助。 &ndash;> 0.6

<ul>
<li>由于mentor结婚度蜜月所以没有达成。</li>
</ul>
</li>
<li>Test的数量不断增加。 &ndash;> 1.0

<ul>
<li>达成——事实上全部搞定。</li>
</ul>
</li>
<li>CL中review的数量持续降低。 &ndash;> 1.0

<ul>
<li>搞定，成功的从每次提交代码20余个review降至小于6个。</li>
</ul>
</li>
<li>逐步理解项目代码背后的机理。 &ndash;> 0.6

<ul>
<li>部分搞定，对项目测试框架已经相当了解了（毕竟自己重新搭建了整个框架），但对整个项目的各个模块，交互流程还是一头雾水。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.85</p>

<h3>Tarqie-L</h3>

<ol>
<li>目标

<ul>
<li>提高精力，理解Python。 &ndash;> 0.8

<ul>
<li>精力小有提高，至于Python——实现机制不太了解，但Python语法和编程风格我现在有足够自信——毕竟写了一个程序解析合法的Python然后生成同等语义的Google风格的Python，再加上身边有一个Python Readability Reviewer，说自己现在达到中级Python开发者的水准应该不为过。</li>
</ul>
</li>
</ul>
</li>
<li>量化

<ul>
<li>精力提高（自然醒，不赖床）。 &ndash;> 0.6

<ul>
<li>自然醒但依然赖床——-_&ndash;</li>
</ul>
</li>
<li>熟悉Python及其实现。 &ndash;> 0.8

<ul>
<li>部分搞定，见上文。</li>
</ul>
</li>
<li>理解4个开源项目的架构。 &ndash;> 1.0

<ul>
<li>搞定，见下文。</li>
</ul>
</li>
</ul>
</li>
<li>改进

<ul>
<li>早睡早起（11:30 PM ~ 8:30 AM）+每天运动20分钟。 &ndash;> 0.7

<ul>
<li>早睡早起没做到，运动的频率两周一次。</li>
</ul>
</li>
<li>阅读相关技术书籍（Python源码剖析，开源项目架构等）。 &ndash;> 0.6

<ul>
<li>部分完成，Python源码剖析只读了第一章，但开源项目架构每周一篇。</li>
</ul>
</li>
<li>增强学习能力（阅读《Study Less, Learn More》） &ndash;> 1.0

<ul>
<li>完成。</li>
</ul>
</li>
<li>控制手淫频率至两周一次。 &ndash;> 1.0 &ndash;_&ndash;

<ul>
<li>完成。</li>
</ul>
</li>
</ul>
</li>
<li>验证

<ul>
<li>早睡早起+运动不间断。 &ndash;> 0.5

<ul>
<li>搞定一半。两天运动一次。</li>
</ul>
</li>
<li>学习能力增强（+系统学习能力）。 &ndash;> 1.0

<ul>
<li>部分做到，但很难验证——不过用十天搞出了另外一个家伙搞了5个月的东西应该能说明部分问题。</li>
</ul>
</li>
<li>逐步理解Python各个部分的实现（对象，语句，元组，列表，字典，控制流，异常，自定义类型，列表理解，生成器，模块，从源码了解其机制）。 &ndash;> 1.0

<ul>
<li>没有阅读代码，但完成了一个Python Formatter——把Python代码转换成AST再转换回等语义的<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>代码。</li>
</ul>
</li>
<li>每周理解1个开源项目的架构。 &ndash;> 1.0

<ul>
<li>完成——阅读了<a href="http://aosabook.org/en/bash.html">Bash</a>, <a href="http://aosabook.org/en/selenium.html">Selenium WebDriver</a>, <a href="http://aosabook.org/en/posa/high-performance-networking-in-chrome.html">Chrome</a>和<a href="http://aosabook.org/en/posa/parsing-xml-at-the-speed-of-light.html">puginxml</a>。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>综上所述，得分 0.8</p>

<h3>成就</h3>

<h4>工作</h4>

<ol>
<li>构建新的测试环境并迁移原有的测试用例。

<ul>
<li>各种神坑，Team/MailList/Group/ReadTheFuckingSource。</li>
<li>manager一度问我是否需要support——想了想还是撑下来了，还好搞定了。</li>
<li>神奇的发现自己第一次实习时做的也是migration，尼玛难道是轮回？</li>
</ul>
</li>
<li>利用业余时间构建了pyfmt——基于AST的代码格式化工具，生成符合<a href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html">Google Python Style</a>的等语义代码。

<ul>
<li>速度是公司工具的6倍到50倍不等（已验证）。</li>
<li>速度是<a href="https://github.com/hhatto/autopep8">autopep8</a>的3倍到30倍（已验证）。</li>
<li>生成的代码质量基本等同（待验证）。</li>
<li>代码量是<a href="https://github.com/hhatto/autopep8">autopep8</a>的二分之一。</li>
<li>不依赖任何第三方库。</li>
<li>不使用任何正则表达式——Never send a regex to do a parser&rsquo;s job.</li>
</ul>
</li>
</ol>


<h4>生活</h4>

<ol>
<li>重新实现了自己两年前写的Lucida。

<ul>
<li>重新设计类型系统，进行尾递归优化。然后完成<a href="http://zh.lucida.me/blog/how-to-implement-an-interpreter-in-csharp/">《90分钟实现一门编程语言——极简解释器教程》</a>，写作之余想通了之前很多迷惑的地方。</li>
<li>功能基本等同，代码量是前一版的八分之一，运行速度是前一版的270倍（倒不是这一版效率有多高，主要是前一版写的太挫了）</li>
</ul>
</li>
<li><a href="http://zh.lucida.me/blog/on-reading-books/">《如何阅读书籍》</a>和<a href="http://zh.lucida.me/blog/on-suppressing-the-internet-addiction/">《网络上瘾及其解决方法》</a>两篇议论型博客。</li>
<li>完整的完成一个引体向上。</li>
</ol>


<h3>阅读列表</h3>

<ul>
<li><a href="http://book.douban.com/subject/3814402/">The Quick Python Book</a></li>
<li><a href="http://book.douban.com/subject/25710862/">Getting Started with Google Guava</a></li>
<li><a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a></li>
<li><a href="http://book.douban.com/subject/24383461/">网络素养</a></li>
<li><a href="http://book.douban.com/subject/25783654/">如何高效学习</a></li>
<li><a href="http://book.douban.com/subject/3009235/">Google Guice</a></li>
<li><a href="http://aosabook.org/en/index.html">The Architecture of Open Source Applications</a></li>
</ul>


<h3>一些体会</h3>

<ol>
<li>慢读慎写——读书不是靠页数，代码不是拼行数。</li>
<li>精益求精——严肃认真对待自己的任何一个项目/作品，每一行代码，每一个细节都应有其意义。</li>
<li>Don&rsquo;t <a href="http://en.wikipedia.org/wiki/Satisfice">satisfice</a>—— 在时间充裕的情况下，尽力寻找最优解，而不是找到一个答案就满足。</li>
<li>Have a mentor/coach——无论学习什么，身边要有一个大师级人物，不要盲目相信自学能力——坑大多都是自己挖出来的。</li>
<li>在合适的抽象层工作（Working at a proper abstraction layer），包括下面几点：

<ul>
<li>找到与目标最契合的层次：

<ul>
<li>如果层级过高就会造成性能损失和功能缺失。</li>
<li>如果层次过低就会变成重造轮子。</li>
</ul>
</li>
<li>总是在同一个层次工作——以避免上下文切换。</li>
<li>将复杂度封装到各自对应的层次——以避免进行交互——<a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li>
</ul>
</li>
</ol>


<h3>发现的问题</h3>

<ol>
<li>3月目标制定的过于宏大——尽管完成度不错，但代价也很大——工作时间从每天8小时增加到10小时，到了后期的阅读时间几乎被缩减到零，接下来会相应的缩小计划目标。</li>
<li>除了工作就是学习，导致略抑郁——尽管做出的东西带来了一点成就感。总之接下来需要更多的娱乐。</li>
<li>猛然反应过来所谓的TARQIE其实就是OKR（<a href="http://en.wikipedia.org/wiki/OKR">Objective-Key-Results</a>）——所以接下来直接使用<a href="http://en.wikipedia.org/wiki/OKR">OKR</a>制定计划，更加简洁。</li>
</ol>


<h3>4月计划</h3>

<h3>OKR-J</h3>

<ul>
<li>目标

<ol>
<li>完整迁移测试到原项目中。</li>
<li>稳定+推广pyfmt。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>成功迁移124个Test到原项目。</li>
<li>将测试的不稳定性控制在每天3次以下。</li>
<li>pyfmt通过Python Readability。</li>
<li>pyfmt有10个以上的用户。</li>
<li>pyfmt从experimental进入devtools（略激进，但值得一试）。</li>
</ol>
</li>
</ul>


<h3>OKR-L</h3>

<ul>
<li>目标

<ol>
<li>正常作息，提高精力。</li>
<li>结合pyfmt，深度理解Python。</li>
<li>加深对Java &amp; JVM的理解。</li>
</ol>
</li>
<li>关键结果

<ol>
<li>理解Python各个部分的实现，从源码了解其机制。</li>
<li>阅读并理解两个以上的开源项目架构。</li>
<li>完成<a href="http://book.douban.com/subject/24722612/">深入理解Java虚拟机：JVM高级特性与最佳实践</a>，阅读<a href="http://www.amazon.co.uk/Java-Performance-Addison-Wesley-Charlie-Hunt/dp/0137142528/">《Java Performance》</a>至50%。</li>
<li>迁移测试的同时完成<a href="http://www.amazon.co.uk/Effective-Unit-Testing-guide-developers/dp/1935182579/">Effective Unit Testing: A guide for Java developers</a>的阅读。</li>
<li>早睡<em>晚</em>起（8:40 ~ 23:50）</li>
<li>控制手淫频率至两周一次。</li>
<li>至少两天一次20分钟的运动。</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读书籍]]></title>
    <link href="http://lucida.github.io/blog/on-reading-books/"/>
    <updated>2014-03-15T20:05:35+00:00</updated>
    <id>http://lucida.github.io/blog/on-reading-books</id>
    <content type="html"><![CDATA[<h1>如何阅读书籍</h1>

<h2>摘要</h2>

<p>这篇文章从如何阅读书籍出发，简单讨论了如何选择书籍、是否阅读原版和阅读数量这几个常见问题，然后自己的阅读问题进行了分析和总结。</p>

<h2>注意</h2>

<ol>
<li>“如何阅读”指“What to read”而非“How to read”，Mortimer J. Adler的<a href="http://book.douban.com/subject/1013208/">怎样阅读一本书</a>对How to read有着精彩的描述。</li>
<li>“书籍”指非小说（Non-fiction）类书籍。</li>
</ol>


<h2>目标</h2>

<p>我是一个功利主义者（<a href="http://en.wikipedia.org/wiki/Utilitarianism">Utilitarianism</a>），因此我认为阅读的目标在于为自己创造实际价值，所以：</p>

<ol>
<li>我不会因为某本书看起来很有趣就去阅读（机会成本）。</li>
<li>也不会因为很多人推荐某本书就去阅读（从众）。</li>
<li>更不会因为某本书难就去阅读（追求智商优越感）</li>
</ol>


<p>一本书值得阅读，当且仅当：</p>

<ol>
<li>它可以直接为我创造价值。</li>
<li>它可以间接为我创造价值。</li>
</ol>


<p>我的阅读目标：</p>

<blockquote><p>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。</p></blockquote>

<h2>如何选择？</h2>

<h3>专业书籍</h3>

<blockquote><p>专业知识尽可能深入。</p></blockquote>

<p>我是一个软件开发者（Software Developer），因此这里的专业书籍均和软件开发有关。</p>

<p>这里介绍我自己用的两种方法：</p>

<h4>根据引用列表</h4>

<p>从一本经典书籍出发，深度优先遍历它的引用列表，通过书评和摘要了解这些引用书籍，再根据自己的实际情况决定自己的阅读次序。</p>

<p>这里以<a href="http://book.douban.com/subject/1477390/">代码大全</a>为例（为了方便和一致性，这里使用英文书名）：</p>

<p>```
Code Complete：软件构建全程最佳实践指南。
|
|&mdash;&mdash;How to Solve it：系统解决问题。
|
|&mdash;&mdash;Conceptual Blockbusting：跳出思维的壁垒。
|
|&mdash;&mdash;Mythical Man Month：软件工程不能做什么。
|
|&mdash;&mdash;Programming Pearls：极简算法手册。</p>

<pre><code> |
 |----The Science of Programming：编写正确的程序。
 |
 |----Writing Efficient Programs：编写高效的程序。
</code></pre>

<p>|
|&mdash;&mdash;Pragmatic Programmer：高效程序员的实践。
|
|&mdash;&mdash;Refactoring：如何改进自己的代码。
|
|&mdash;&mdash;Programming on Purposes：用正确的编程模式处理问题。
|
|&mdash;&mdash;Software Tools：用合适的抽象封装复杂度。</p>

<pre><code> |
 |----The Practice of Programming：极简编程风格指南。
      |
      |---- Writing Solid Code：减少调试的时间。
      |
      |---- Elements of Programming Style：极简编程风格指南。
</code></pre>

<p>```</p>

<p>可以发现，通过<a href="http://book.douban.com/subject/1477390/">代码大全</a>一本书，经过短短两层引用联系，几乎可以找到2004年以前所有软件开发的经典书籍。事实上，我阅读的80%以上的软件开发经典书籍，都源自于<a href="http://book.douban.com/subject/1477390/">代码大全</a>的引用列表。</p>

<p>这种方法的好处：</p>

<ul>
<li>简单直接：相对于从茫茫书海里找出10本经典书籍，找1本经典书籍再从它的引用列表里面找到20本经典书籍要容易的多。</li>
<li>质量保证：靠谱书籍的引用书籍的质量一般都很高。</li>
<li>发现一些被忽视的经典：相当一部分的书籍随着时间的流逝而淡出人们的视野，但这并不代表它们本身没有价值，例如：

<ul>
<li><a href="http://book.douban.com/subject/1989284/">Programming on Purposes</a></li>
<li><a href="http://book.douban.com/subject/1815459/">Software Tools</a></li>
<li><a href="http://book.douban.com/subject/2350559/">The Science of Programming</a></li>
<li><a href="http://book.douban.com/subject/1456967/">Writing Solid Code</a></li>
<li><a href="http://book.douban.com/subject/1768600/">Writing Efficient Programs</a></li>
<li>等等&hellip; 这些书或者绝版，但它们都对我的软件开发理念产生了巨大影响。</li>
</ul>
</li>
<li>形成知识体系：引用书籍彼此具有天然的联系，这使得创建知识体系更加容易。</li>
</ul>


<p>我认为这种方法适用于任何需要严肃阅读的领域：</p>

<ol>
<li>锚点：找到一本经典书籍。</li>
<li>撒网：了解该书引用列表中的书籍。</li>
<li>收网：根据自己实际需要，精读相关书籍。</li>
</ol>


<h4>根据作者</h4>

<p>这里以计算机书籍为例（以下仅代表个人口味）：</p>

<ol>
<li>Richard Stevens：善。</li>
<li>Brian Kernighan：极善。</li>
<li>Deitel Series：翔。</li>
<li>Bruce Eckel：废话连篇。</li>
<li>Jon Bentley：善。</li>
<li>Andrew S Tanenbaum：大善。</li>
<li>Jeffrey D Ullman：善。</li>
<li>P.J. Plauger：大善。</li>
<li>Robert C Martin：善。</li>
<li>Bjarne Stroustrup：善，但略神叨（神侃世界观方法论有点顶不住）。</li>
<li>Martin Fowler：善，但略唠叨。</li>
<li>Ron Jeffries：翔（好吧我是故意来黑的，尼玛连个<a href="http://devgrind.com/2007/04/25/how-to-not-solve-a-sudoku/">Sudoku</a>都解不出来写毛程序）</li>
</ol>


<p>这种方法的问题在于需要一定阅读经验，但是它非常有效——以至于不用看内容就对书的质量有七八成把握。</p>

<h3>非本专业书籍</h3>

<blockquote><p>专业周边知识尽可能精炼。</p></blockquote>

<ol>
<li>对于专业周边知识，了解关键概念及指导思想即可。</li>
<li>不需要，也没有必要对专业周边知识进行深入了解。</li>
<li>&ldquo;Know what&rdquo; is enough, &ldquo;Know how&rdquo; is expensive.</li>
</ol>


<p>以我2年前编写手机应用，学习用户体验为例：</p>

<ol>
<li>分别在现实中（身边有几个很不错的交互设计师）和线上（Quora和知乎）进行提问和搜索，得到一个书单。</li>
<li>按照下面的原则过滤书单：

<ul>
<li>去掉教科书和大部头。</li>
<li>去掉包含大量原理或论证的书籍。</li>
<li>保留结论型书籍。</li>
<li>保留指南型书籍。</li>
</ul>
</li>
<li>总结出书单，迅速的阅读并找到关键点。

<ul>
<li><a href="http://book.douban.com/subject/3323633/">给大家看的设计书</a>：CRAP原则，字体与配色。</li>
<li><a href="http://book.douban.com/subject/4606471/">设计心理学</a>：心智模型，心智摩擦，最小惊讶。</li>
<li><a href="http://book.douban.com/subject/1493316/">交互设计之路</a>：为什么需要交互，交互有哪些坑。</li>
<li><a href="http://book.douban.com/subject/4254166/">Tapworthy</a>：具有实际操作性的移动平台交互设计指南。</li>
</ul>
</li>
</ol>


<p>了解设计的人可能认为上面的书单过于初级——没错，它们都是结论型或指南型书籍，没有原理，也没有论证——但这正是对于我这样的非专业者所需要的书籍：我不需要知道这些知识是怎么来的，知道怎么用足矣。</p>

<p>此外，受价值驱动，而非兴趣——大多数情况下兴趣只是把自己脱离当前困境的接口。</p>

<h3>学习型书籍</h3>

<p>学习型书籍是一种元（Meta）方法书籍：这类书籍用于提升学习能力，换句话说，就是缩短吸收知识所需要的时间。</p>

<p>这类书籍我只读过下面的几本，效果有但不明显：</p>

<ul>
<li><a href="http://book.douban.com/subject/2345548/">学习之道</a>：冥想，体会。</li>
<li><a href="http://book.douban.com/subject/1013208/">如何阅读一本书</a>：检视阅读，主题阅读。</li>
<li><a href="http://www.scotthyoung.com/learnmorestudyless/">Learn more, study less</a>：建立知识体系及联系。</li>
</ul>


<p>需要注意的是，不要陷入到寻求最优学习方法的误区——Best is the worthest enemy of better。</p>

<h2>阅读原版？</h2>

<h3>如何在翻译版和原版做选择？</h3>

<ol>
<li>优先选择翻译版。计算机书籍这种描述精确知识的书籍更是如此。</li>
<li>此外，如果阅读中出现难以理解的问题，不要下意识的把其归咎于翻译问题——多数情况是理解问题。</li>
</ol>


<h3>为什么还有那么多人阅读原版？</h3>

<ol>
<li>因为翻译版还没出版。</li>
<li>知识的价值有其时效性。</li>
<li>逼格。</li>
</ol>


<h2>越多越好？</h2>

<p>我经常逛豆瓣，豆瓣有一个很有意思的现象就是人们喜欢去比较自己每年读书的数量，或者是截图炫耀自己读过几千本书云云。</p>

<p>我在这里酸一下：书的数量并没有什么参考价值，就好比无法用盖一栋大楼的砖数评价这栋大楼的质量；换个说法，Effort不等于Progress。</p>

<blockquote><p>关键在于读过书的质量，吸收的程度，以及创造的价值。</p></blockquote>

<p>此外，盲目追求读书的数量会带来另一个问题——浅尝辄止。本应花在专业书籍上的时间被分配到其它无关紧要的事情上，导致该学好的没学好，没必要的学了一滩但用不上。</p>

<h2>总结</h2>

<ol>
<li>形成T型知识结构：专业知识尽可能深入，专业周边知识尽可能精炼。

<ul>
<li>按照引用列表和作者深入阅读专业书籍。</li>
<li>利用结论型/指南型书籍精炼阅读专业周边书籍。</li>
<li>不断强化自己的按需学习能力。</li>
</ul>
</li>
<li>不一定非要阅读原版。</li>
<li>读书并非多多益善。</li>
<li>读书之前回答下面几个问题：

<ul>
<li>这本书能给自己带来什么改变？</li>
<li>自己是否需要这种改变？</li>
<li>如果均为Yes，继续；如果有一个No，砍掉。</li>
</ul>
</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网络上瘾及其解决方法]]></title>
    <link href="http://lucida.github.io/blog/on-suppressing-the-internet-addiction/"/>
    <updated>2014-03-09T17:14:28+00:00</updated>
    <id>http://lucida.github.io/blog/on-suppressing-the-internet-addiction</id>
    <content type="html"><![CDATA[<h1>网络上瘾及其解决方法</h1>

<h2>症状</h2>

<h3>起床后</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人，大概20分钟。</p>

<h3>工作中</h3>

<p>大概每隔半小时刷一下微博或论坛，点进去看两分钟再切回来。</p>

<h3>睡觉前</h3>

<p>拿起手机，微博->论坛A->论坛B->知乎->人人->草榴（-_-），大概30分钟。</p>

<h2>原因</h2>

<h3>智能手机带来的极其便利的信息可访问性</h3>

<p>平板和智能手机使互联网的可访问性（accessibility）提升了至少两个数量级——三年前我的NOKIA E51只能在WIFI环境下浏览简单的文字信息，而现在我的iPhone5可以无时无刻的阅读/观看互联网上几乎所有的信息，得益于4G，即便是包含大量图片甚至视频的信息也可以轻松阅读。</p>

<h3>碎片化时间不知如何处理</h3>

<p>无论是工作还是学习，都会有疲倦或无聊的时刻，大概10分钟左右。</p>

<p>微博这种碎片化信息的出现正好填补了碎片化时间。但比较恶心的是这种东西会上瘾——慢慢的它会占据越来越多的时间：清晨，睡眠甚至路上和正常阅读的时间。</p>

<h3>长时间从事同一种工作带来的无聊感</h3>

<p>无论多么有激情有兴趣，长时间从事同一种工作总会无聊的，低智力门槛的社交网络就成了一个打发时间的好选择。</p>

<p>然后时间就都耗里面了。-_&ndash;</p>

<h2>现实 V.S. 虚拟</h2>

<p>人是社会性动物，社会性动物通过与其他对象建立联系来确定自己的存在感，也就是交流（Communication），现实和虚拟中都是如此。交流包括一对一交流和一对多交流：现实中，一对一交流通过谈话/电话/信件，一对多交流通过电视/广播；虚拟中，一对一交流通过IM（Instant Messenger），一对多交流通过微博/论坛/博客。</p>

<h3>一对一交流：</h3>

<ol>
<li>现实中，一对一交流通过谈话/电话/信件，一对一交流通过IM（Instant Messenger）。</li>
<li>现实的一对一交流大多无状态——双方的交流同时开始，同时结束。虚拟的一对一交流大多有状态——双方的交流可以从某一方开始，然后若干小时后另一方看到消息回复，然后如此继续。</li>
<li>现实中的一对一交流需要考虑对方的状态——也就是交流需要建立在双方都有时间的基础上；虚拟的一对一交流无需考虑对方的状态，有意交流的一方可以随时给对方发送信息。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>任何人都可以与你交流，无论你愿意与否。</li>
<li>你可以与任何人交流，无论是否值得。</li>
<li>可能会陷入一种等待交流的焦虑中。</li>
</ol>


<h3>一对多交流：</h3>

<ol>
<li>现实的一对多交流需要大量人力物力（广播/电视/报纸），虚拟的一对多交流几乎零成本（微博/博客/社交网络）。</li>
<li>现实的一对多交流需要信息审核/证伪，虚拟的一对多交流几乎没有信息审核。</li>
<li>现实的一对多交流中接收方是完全被动的，虚拟的一对多交流接收方和广播方之间可以有交互。</li>
</ol>


<p>虚拟带来的问题：</p>

<ol>
<li>没有审核带来的大量低质量无意义信息（通常会以一种很有趣或是令人热血沸腾的形式出现）。</li>
<li><a href="http://book.douban.com/subject/1012611/">乌合之众</a>，最热门的信息不是最有价值的，而是吵的最响（或是争议最多）的。</li>
<li>与广播方（例如名人）的交流会带来成就感，也会使自己陷入等待回复的焦虑中。</li>
<li>可能会陷入一种不断查看新信息（尽管这些信息毫无意义）的焦虑中。</li>
</ol>


<h2>解决方法</h2>

<p>为此在豆瓣阅读买了一本<a href="http://book.douban.com/subject/24383461/">网络素养</a>，原版：<a href="http://www.amazon.com/Net-Smart-How-Thrive-Online/dp/0262526131/">Net Smart: How to thrive online</a>。</p>

<p><img src="http://img5.douban.com/lpic/s26842036.jpg" title="网络素养" alt="网络素养" /></p>

<p><img src="http://ecx.images-amazon.com/images/I/41LRFD-SVlL._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_SX385_SY500_CR,0,0,385,500_SH20_OU02_.jpg" title="Net Smart" alt="Net Smart" /></p>

<p>这本书废话极多，关键的两点：控制注意力，鉴别垃圾信息。</p>

<h3>控制注意力</h3>

<ul>
<li>下意识的控制注意力，可以通过关注自己的呼吸来调节。</li>
<li>即便忽略几条微博几条信息，也不会对生活造成多大影响。</li>
<li>此外可以使用冥想提升自己的集中力（Focus）。</li>
<li>番茄工作法（没看明白要点，25分钟休息一次是什么原理，如果这样岂不是更不靠谱）。</li>
</ul>


<h3>鉴别垃圾信息</h3>

<ul>
<li>冷静面对夸张的标题，此类信息一般有意断章取义，或是掩盖上下文。</li>
<li>恰当的使用三点式验证争议信息：使用三个不同可信来源验证信息的有效性。</li>
<li>选取可信/有效/有价值的信息来源，屏蔽哗众取宠/断章取义的信息源。</li>
</ul>


<h3>集中时间处理社交网络</h3>

<ul>
<li>在固定的时间段（例：12:40 &ndash; 13:10, 20:20 &ndash; 21:00）处理社交网络信息，而非随时随地的查看状态。</li>
<li>如有特别需求，可以编写Crawler来发送Reminder邮件，替代人工轮询。</li>
</ul>


<h2>用不上瘾的行为填充碎片化时间</h2>

<p>碎片化时间可以进行其它益智或体育活动，包括但不限于：</p>

<ul>
<li>拆解/还原九连环。</li>
<li>单手还原魔方。</li>
<li>背诵单词。</li>
<li>绘画。</li>
<li>乒乓。</li>
<li>桌球。</li>
</ul>


<h2>尝试其它活动</h2>

<p>为了得到新鲜感，包括但不限于：</p>

<ul>
<li>学习自己感兴趣但不了解的技术（例如ANTLR）或学科（例如经济/心理学）。</li>
<li>尝试集体运动（例如攀岩，射箭）。</li>
<li>尝试旅行（例如在周末去荷兰、芬兰或瑞典进行两日游）。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TARQIE——一种量化成长的方法（上）]]></title>
    <link href="http://lucida.github.io/blog/tarqie-a-quantized-continous-growing-approach/"/>
    <updated>2014-03-02T23:31:27+00:00</updated>
    <id>http://lucida.github.io/blog/tarqie-a-quantized-continous-growing-approach</id>
    <content type="html"><![CDATA[<h1>TARQIE——一种量化成长的方法（上）</h1>

<h2>问题</h2>

<p>工作到现在大概三个多月，但始终感觉有些不对——没有之前高速成长的感觉，换句话说，就是感觉自己相比三个月之前没有多大进步。</p>

<p>这是一个很危险的讯息——如果三个月还没感受到实质性的成长，那么就相当于倒退，尤其还是在Google这种奇人遍地的公司。</p>

<p>反复思考后发现自己现在掉到几个怪圈里——</p>

<h3>选择瘫痪（Analysis Paralysis）</h3>

<ol>
<li>想做事情A，做了一小半。</li>
<li>想做事情B。</li>
<li>发现事情C也有必要搞。</li>
<li>结果A，B，C都没有搞定。</li>
<li>陷入深深的自责。</li>
<li>回到步骤A。</li>
</ol>


<h3>呆滞沉浸（Dumb Dump）</h3>

<ol>
<li>看着电脑屏幕发呆。</li>
<li>或者不停的刷微博。</li>
<li>或者开始看一部早已经看过的美剧。</li>
<li>或者撸来撸去。</li>
<li>总之就是一种知道不该继续但又停不下来的感觉。-_&ndash;</li>
</ol>


<h3>拖延（Procrastination）</h3>

<ol>
<li>无法持续一件事情。（比如看书或是锻炼）</li>
<li>缺乏行动力，做事之前束手束脚。</li>
</ol>


<h2>分析</h2>

<p>回想自己过去并不是这个样子——不断成长（Continuous Growing）是自己过去几年的关键字，某种上来所自己有一种强迫症，极端的说：</p>

<blockquote><p>如果自己大脑里面一半都是半年以前的东西，那么证明自己这半年什么都没做。</p></blockquote>

<p>但自己现在处于一个更好的环境，没有理由比之前做的差。于是我决定从之前的成功经历里找到答案，试着用简短的关键字回顾自己前10年的几个关键点：</p>

<h3>关键点（Milestones）</h3>

<h4>高考</h4>

<ul>
<li>目标

<ol>
<li>考上一个不错的大学。</li>
</ol>
</li>
<li>量化

<ol>
<li>考到年级60名以内。</li>
<li>或者是班级第一。</li>
</ol>
</li>
<li>改进

<ol>
<li>海量习题练习。</li>
<li>规律作息。</li>
<li>每天至少踢腿二十分钟。</li>
</ol>
</li>
<li>验证

<ol>
<li>月考成绩。</li>
<li>模拟成绩。</li>
</ol>
</li>
</ul>


<h4>考研</h4>

<ul>
<li>目标

<ol>
<li>考上北航计算机系。</li>
</ol>
</li>
<li>量化

<ol>
<li>超过提档线50分。</li>
</ol>
</li>
<li>改进

<ol>
<li>海量习题练习。</li>
<li>规律作息。</li>
<li>禁欲（即停止手淫，保存精力）。</li>
</ol>
</li>
<li>验证

<ol>
<li>前期：监测学习进度。</li>
<li>后期：各种模拟试卷，给自己打分。</li>
</ol>
</li>
</ul>


<h4>找工作</h4>

<ul>
<li>目标

<ol>
<li>找到一个不错的外企工作。</li>
</ol>
</li>
<li>量化

<ol>
<li>解答Top Coder D2L1和D1L2区段的题目。</li>
<li>在纸上流畅写出可运行的算法C代码。</li>
</ol>
</li>
<li>改进

<ol>
<li>每天练习Top Coder一道大题，若干道小题。</li>
<li>用EOP的思路编写纸上代码。</li>
</ol>
</li>
<li>验证

<ol>
<li>找到MS正式员工为自己做模拟面试+评估。</li>
<li>独立解答CareerCup上7成以上的编程题目。</li>
<li>不断拿到新的Offer。</li>
</ol>
</li>
</ul>


<h3>总结</h3>

<p>我惊奇的发现自己找到了一个和《机器学习》里几乎雷同的模型：</p>

<ul>
<li>目标（TARget）：一个清晰的目标。</li>
<li>量化（Quantization）：该目标可以被量化成具体数据。</li>
<li>改进（Improvement）：有一种或几种改进途径不断接近目标。</li>
<li>验证（Evaluation）：有一种或几种验证方法确认（Verify）自己正在接近目标。</li>
</ul>


<p>综合到一起——TARQIE，即标题里这个奇怪的词汇（很高兴这个词压根不存在）。</p>

<h2>应用</h2>

<p>根据自己的现状，对自己的工作和生活（或学习），分别创建对应的Tarqie模型，这里我称其为Tarqie-J（ob）和Tarqie-L（ife）。</p>

<h3>Tarqie-J</h3>

<ul>
<li>目标

<ol>
<li>高效完成Q1 OKR。</li>
</ol>
</li>
<li>量化

<ol>
<li>成功迁移124个Test。</li>
<li>为这些Test配置一个可稳定运行的环境。</li>
</ol>
</li>
<li>改进

<ol>
<li>恬着脸皮向不同的同事请教。</li>
<li>理解当前Test的架构和流程。</li>
<li>阅读The Art Of Unit Test，Guice Book和GuiceBerry Manual，了解如何用Guice写良好的Test。</li>
<li>阅读Java Best Practices和Effective Java。</li>
<li>阅读Java Performance，了解JVM。</li>
</ol>
</li>
<li>验证

<ol>
<li>每周与mentor交流，进行进度控制/难点求助。</li>
<li>Test的数量不断增加。</li>
<li>CL中review的数量持续降低。</li>
<li>逐步理解项目代码背后的机理。</li>
</ol>
</li>
</ul>


<h3>Tarqie-L</h3>

<ul>
<li>目标

<ol>
<li>提高精力，理解Python。</li>
</ol>
</li>
<li>量化

<ol>
<li>精力提高（自然醒，不赖床）。</li>
<li>熟悉Python及其实现。</li>
<li>理解4个开源项目的架构。</li>
</ol>
</li>
<li>改进

<ol>
<li>早睡早起（11:30 PM ~ 8:30 AM）+每天运动20分钟。</li>
<li>阅读相关技术书籍（Python源码剖析，开源项目架构等）。</li>
<li>增强学习能力（阅读《Study Less, Learn More》）</li>
<li>控制手淫频率至两周一次。</li>
</ol>
</li>
<li>验证

<ol>
<li>早睡早起+运动不间断。</li>
<li>学习能力增强（+系统学习能力）。</li>
<li>逐步理解Python各个部分的实现（对象，语句，元组，列表，字典，控制流，异常，自定义类型，列表理解，生成器，模块，从源码了解其机制）。</li>
<li>每周理解1个开源项目的架构。</li>
</ol>
</li>
</ul>


<h2>实验</h2>

<h3>内容</h3>

<p>在接下来的一个月（2014年3月），分别应用Tarqie-J和Tarqie-L到自己的工作和学习中。</p>

<h3>假设</h3>

<ol>
<li>效率比之前提升50%。</li>
<li>掌握两样新技能。</li>
</ol>


<h3>实验开始</h3>

<h2>未完待续</h2>
]]></content>
  </entry>
  
</feed>
